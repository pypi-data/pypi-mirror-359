# cwb2G

## 0. Test code

```python
install_path = "/Users/yumengxu/Project/Physics/cwb/cwb_source/tools/install/lib"
import os
os.environ['LD_LIBRARY_PATH'] = install_path
from pycwb import logger_init
logger_init()

# load user parameters
from pycwb.config import Config, CWBConfig
cwb_config = CWBConfig('./config.ini')
cwb_config.export_to_envs()
config = Config('./user_parameters.yaml')

# 1.1 load noise from gwf
from pycwb.modules.read_data import read_from_gwf
noise = [read_from_gwf(i, config, f"frames/L1H1V1-SimStrain-9311/{ifo}-SimStrain-931158100-600.gwf",
                       config.channelNamesRaw[i], None, None) for i, ifo in enumerate(config.ifo)]

# 1.2 generate injection from pycbc
from pycbc.waveform import get_td_waveform
hp, hc = get_td_waveform(approximant="IMRPhenomPv3",
                         mass1=20,
                         mass2=20,
                         spin1z=0.9,
                         spin2z=0.4,
                         inclination=1.23,
                         coa_phase=2.45,
                         delta_t=1.0 / noise[0].sample_rate,
                         f_lower=32)
declination = 0.65
right_ascension = 4.67
polarization = 2.34
gps_end_time = 931158700
from pycwb.modules.read_data import project_to_detector
strain = project_to_detector(hp, hc, right_ascension, declination, polarization, config.ifo, gps_end_time)

# 1.3 inject signal into noise and convert to wavearray
injected = [noise[i].add_into(strain[i]) for i in range(len(config.ifo))]

# 2. data conditioning
from pycwb.utils import convert_pycbc_timeseries_to_wavearray
wavearray = [convert_pycbc_timeseries_to_wavearray(d) for d in injected]

from pycwb.modules.data_conditioning import regression, whitening
data_reg = [regression(config, wavearray[i]) for i in range(len(config.ifo))]
data_w_reg = [whitening(config, data_reg[i]) for i in range(len(config.ifo))]
tf_map = [d['TFmap'] for d in data_w_reg]

# 3. initialize network
from pycwb.modules.coherence import create_network
net, wdm_list = create_network(1, config, data_w_reg)

# 4. calculate coherence

## 4.1 select pixels
from pycwb.modules.coherence import select_pixels
sparse_table_list = select_pixels(config, net, tf_map, wdm_list)

```

## 1. ReadData


### 1.1 Read and check frame

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {   
    fr[i].readFrames(FRF[i],cfg.channelNamesRaw[i],x);
    
    if(TMath::IsNaN(x.mean())) 
    {cout << "cwb2G::ReadData - Error : found NaN in strain data !!!" <<  endl;EXIT(1);}
    
    if(x.rate()!=cfg.inRate)
    {cout << "cwb2G::ReadData - input rate from frame " << x.rate()
          << " do not match the one defined in config : " << cfg.inRate << endl;EXIT(1);}
}    
```
</td>
<td>

```python
def data_check(data: TimeSeries, sample_rate: int):
    # check if data contains NaNs
    if data.value.any() == np.nan:
        raise ValueError('Data contains NaNs')
    # check if the sample rate is consitent with configuation
    if data.sample_rate.value != sample_rate:
        raise ValueError('Sample rate is not consistent with configuation')

    return True
```
</td>
</tr>
</table>

### 1.2 Process raw data 
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) { 
    x.start(x.start()+cfg.dataShift[i]);                // dataShift
    x.start(x.start()-cfg.segLen*(segID[i]-segID[0]));  // SLAG
    if(singleDetector) TB.resampleToPowerOfTwo(x);
    if(cfg.dcCal[i]>0.) x*=cfg.dcCal[i];                // DC correction
    if(cfg.fResample>0) x.Resample(cfg.fResample);   	  // RESAMPLING
    x.Resample(x.rate()/(1<<cfg.levelR));		  // resampling
    x*=sqrt(1<<cfg.levelR);				  // rescaling
    
    // save ifo data to temporary job file
    cdstrain->cd();gwavearray<double> gx(x);gx.Write(ifo[i],TObject::kOverwrite);
}
```
</td>
<td>

```python
def read_from_gwf(ifo_index, config, filename, channel, start=None, end=None):
   # Read data from GWF file
   data = TimeSeries.read(filename, channel, start, end)

   # Check data
   data_check(data, config.inRate)
   data = data.to_pycbc()
   # data shift
   # SLAG
   # DC correction
   # if config.dcCal[ifo_index] > 0:
   #     data.data *= config.dcCal[config.ifo.indexof(ifo_index)]

   # resampling
   if config.fResample > 0:
      data = data.resample(1.0 / config.fResample)

   new_sample_rate = data.sample_rate / (1 << config.levelR)
   data = data.resample(1.0 / new_sample_rate)

   # rescaling
   data.data *= (2 ** config.levelR) ** 0.5

   # return data
   return data
```
</td>
</tr>
</table>

### 1.3 Check synchronization (can be ensured by data processing stage?)
```cpp
for(int i=0; i<nIFO; i++) {  
    if(i==0) {xrate=x.rate();xstart=x.start();xsize=x.size();}
    
    fprintf(stdout,"start=%f duration=%f rate=%f\n", x.start(),x.size()/x.rate(),x.rate());
    if(i>0 && xstart != x.start()) {
      cout << "cwb2G::ReadData - Error : ifo noise data not synchronized" << endl;
      cout << ifo[i] << " " << x.start() << " != " << ifo[0] << " " << xstart << endl;
      EXIT(1);
    }
    if(i>0 && xrate != x.rate()) {
      cout << "cwb2G::ReadData - Error : ifo noise data have different rates" << endl;
      cout << ifo[i] << " " << x.rate() << " != " << ifo[0] << " " << xrate << endl;
      EXIT(1);
    }
}
```

## 2. Data Conditioning


Apply regression to remove lines & whiten data

Loop over detectors

 - read ifo strain from job file
 - read MDC data from temporary job file (config::simulation>0)
 - if(config::simulation==1) MDC are rescaled according to the config::factors
 - Add MDC to noise
 - Apply regression to remove lines
 - Use detector::white to estimate noise (detector::nRMS)
 - Use the estimated noise to whiten data (WSeries<double>::white)
 - Store injected waveforms (SaveWaveforms)
 - Store whitened data (detector::HoT) to job file (jfile)
 - Store estimated noise to job file (detector::nRMS)


### 2.1 Inject MDC
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
    px = (wavearray<double>*)jfile->Get(TString("strain/")+ifo[i]);
    hot[i] = pD[i]->getHoT();
    *hot[i] = *px; delete px;
    xM = *px;				// copy MDC to temporary wavearray
    (*px)*=factor;	
    hot[i]->add(*px);
}
```
</td>
<td>

```python
injected = [noise[i].add_into(strain[i]) for i in range(len(config.ifo))]
```
</td>
</tr>
</table>


### 2.2 2G Data regression
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
      pTF[i] = pD[i]->getTFmap();

      // regression
      pTF[i]->Forward(*hot[i],WDMlpr);
      regression rr(*pTF[i],const_cast<char*>("target"),
                    1.,cfg.fHigh);
      rr.add(*hot[i],const_cast<char*>("target"));
      rr.setFilter(REGRESSION_FILTER_LENGTH);
      rr.setMatrix(NET.Edge,REGRESSION_MATRIX_FRACTION);
      rr.solve(REGRESSION_SOLVE_EIGEN_THR,
               REGRESSION_SOLVE_EIGEN_NUM,
               REGRESSION_SOLVE_REGULATOR);
      rr.apply(REGRESSION_APPLY_THR);
      *hot[i] = rr.getClean();
}
```
</td>
<td>

```python
from pycwb.constants import REGRESSION_FILTER_LENGTH, \
   REGRESSION_MATRIX_FRACTION, \
   REGRESSION_SOLVE_EIGEN_THR, REGRESSION_SOLVE_EIGEN_NUM,\
   REGRESSION_SOLVE_REGULATOR, REGRESSION_APPLY_THR,\
   WDM_BETAORDER, WDM_PRECISION


def regression(config: Config, h: TimeSeries):
   layers = int(config.rateANA / 8)
   wdm = ROOT.WDM(np.double)(layers, layers, WDM_BETAORDER, WDM_PRECISION)
   tf_map = ROOT.WSeries(np.double)(h, wdm)
   tf_map.Forward()

   # TOOD: consideration?
   r = ROOT.regression(tf_map, "target", 1., config.fHigh)
   r.add(h, "target")

   # Calculate prediction
   r.setFilter(REGRESSION_FILTER_LENGTH)  # length of filter
   r.setMatrix(config.segEdge, REGRESSION_MATRIX_FRACTION)
   r.solve(REGRESSION_SOLVE_EIGEN_THR,
           REGRESSION_SOLVE_EIGEN_NUM,
           REGRESSION_SOLVE_REGULATOR)
   r.apply(REGRESSION_APPLY_THR)

   # cleaned data
   hh = r.getClean()

   return hh
```
</td>
</tr>
</table>


### 2.3 2G Data Whitening

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
    // whitening
    pTF[i]->Forward(*hot[i],WDMwhite);
    pTF[i]->setlow(cfg.fLow);
    pTF[i]->sethigh(cfg.fHigh);
    // calculate noise rms 
    pD[i]->white(cfg.whiteWindow,0,cfg.segEdge,
                 cfg.whiteStride);
    // high pass filtering at 16Hz
    pD[i]->nRMS.bandpass(16.,0.,1); 
    // whiten  0 phase WSeries
    pTF[i]->white(pD[i]->nRMS,1);  
    // whiten 90 phase WSeries
    pTF[i]->white(pD[i]->nRMS,-1);  
    
    WSeries<double> wtmp = *pTF[i];
    pTF[i]->Inverse();
    wtmp.Inverse(-2);
    *hot[i] = *pTF[i];
    *hot[i] += wtmp;
    *hot[i] *= 0.5;
    // add infos to history
    sprintf(info,"-IFO:%d-RMS:%g",i,hot[i]->rms());
}
```
</td>
<td>

```python
def whitening(config: Config, h: TimeSeries):
   layers_white = 2 ** config.l_white if config.l_white > 0 else 2 ** config.l_high

   wdm_white = ROOT.WDM(np.double)(layers_white,
                                   layers_white, 6, 10)

   tf_map = ROOT.WSeries(np.double)(h, wdm_white)
   tf_map.Forward()
   tf_map.setlow(config.fLow)
   tf_map.sethigh(config.fHigh)

   # calculate noise rms
   logger.info('calculate noise rms')
   # FIXME: should here be tf_map?
   # FIXME: check the length of data and white parameters to prevent freezing
   nRMS = tf_map.white(config.whiteWindow, 0, config.segEdge,
                       config.whiteStride)

   # high pass filtering at 16Hz
   logger.info('high pass filtering at 16Hz')
   # nRMS.bandpass(16., 0., 1)

   # whiten  0 phase WSeries
   logger.info('whiten  0 phase WSeries')
   tf_map.white(nRMS, 1)
   # whiten 90 phase WSeries
   logger.info('whiten 90 phase WSeries')
   tf_map.white(nRMS, -1)

   wtmp = copy.deepcopy(tf_map)
   tf_map.Inverse()
   wtmp.Inverse(-2)
   tf_map += wtmp
   tf_map *= 0.5

   # hw = ut.convert_wseries_to_wavearray(tf_map)

   return {"TFmap": tf_map, 'nRMS': nRMS}
```
</td>
</tr>
</table>

Key output: detector `pD`, `hot`

## 3. CWB Init and Network

### 3.1 CWB2G Init

 - Initialize the WDM<double> tranforms for each resolution level used in the analysis
 - Load the xTalk Catalog (network::setMRAcatalog) used for the Multi Resolution Analysis

#### loading MRA catalog
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
nRES = cfg.l_high-cfg.l_low+1;     // number of frequency resolution levels
sprintf(MRAcatalog,"%s/%s",cfg.filter_dir,cfg.wdmXTalk);
TB.checkFile(MRAcatalog);
NET.setMRAcatalog(MRAcatalog);

```

</td>
<td>

```python
def load_MRA(config: Config, net: ROOT.network):
   logger.info("Loading MRA")
   net.setMRAcatalog(config.MRAcatalog)
```

</td>
</tr>
</table>

#### Create WDM
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
int BetaOrder = WDM_BETAORDER;	// beta function order for Meyer
int precision = WDM_PRECISION;	// wavelet precision
if(NET.wdmMRA.tag!=0) {		// new catalog format : read BetaOrder,precision from catalog
  BetaOrder=NET.wdmMRA.BetaOrder; 
  precision=NET.wdmMRA.precision;
}

for(int level=cfg.l_high; level>=cfg.l_low; level--) {
  int layers = level>0 ? 1<<level : 0;
  pwdm[cfg.l_high-level] = new WDM<double>(layers,layers,BetaOrder,precision);
  // check if filter lenght is less than cwb scratch length
  double wdmFLen = double(pwdm[cfg.l_high-level]->m_H)/rateANA;    // sec
  if(wdmFLen > cfg.segEdge+0.001) {
     cout << endl;
     cout << "cwb2G::Init : Error - filter length must be <= segEdge !!!" << endl;
     cout << "filter length : " << wdmFLen << " sec" << endl;
     cout << "cwb   scratch : " << cfg.segEdge << " sec" << endl;
     EXIT(1);
  } else {
     cout << "Filter length = " << wdmFLen << " (sec)" << endl;
  }
  // check if the length for time delay amplitudes is less than cwb scratch length
  // the factor 1.5 is used to avoid to use pixels on the border which could be distorted
  double rate  = rateANA>>level;
  if(cfg.segEdge<int(1.5*(cfg.TDSize/rate)+0.5)) {
     cout << endl;
     cout << "cwb2G::Init : Error - segEdge must be > " 
          << "1.5x the length for time delay amplitudes!!!" << endl;
     cout << "TD length : " << cfg.TDSize/rate << " sec" << endl;
     cout << "segEdge   : " << cfg.segEdge << " sec" << endl;
     cout << "Select segEdge > " << int(1.5*(cfg.TDSize/rate)+0.5) << endl << endl;
     EXIT(1);
  } 
  // add WDM to network
  NET.add(pwdm[cfg.l_high-level]); // network vector must be filled starting from max resolution level
}
```
</td>
<td>

```python
def create_wdm(config: Config, net: ROOT.network):
    beta_order = WDM_BETAORDER  # beta function order for Meyer
    precision = WDM_PRECISION  # wavelet precision

    if net.wdmMRA.tag != 0:
        beta_order = net.wdmMRA.BetaOrder
        precision = net.wdmMRA.precision

    wdm_list = []
    for i in range(config.l_low, config.l_high + 1):
        level = config.l_high + config.l_low - i
        layers = 2 ** level if level > 0 else 0
        wdm = ROOT.WDM(np.double)(layers, layers, beta_order, precision)
        wdmFLen = wdm.m_H / config.rateANA

        if wdmFLen > config.segEdge + 0.001:
            logger.error("Filter length must be <= segEdge !!!")
            logger.error("filter length : %s sec", wdmFLen)
            logger.error("cwb   scratch : %s sec", config.segEdge)
            raise ValueError("Filter length must be <= segEdge !!!")
        else:
            logger.info("Filter length = %s (sec)", wdmFLen)

        # check if the length for time delay amplitudes is less than cwb scratch length
        # the factor 1.5 is used to avoid to use pixels on the border which could be distorted
        rate = config.rateANA >> level

        if config.segEdge < int(1.5 * (config.TDSize / rate) + 0.5):
            logger.error("segEdge must be > 1.5x the length for time delay amplitudes!!!")
            logger.error("TD length : %s sec", config.TDSize / rate)
            logger.error("segEdge   : %s sec", config.segEdge)
            logger.error("Select segEdge > %s", int(1.5 * (config.TDSize / rate) + 0.5))
            raise ValueError("segEdge must be > 1.5x the length for time delay amplitudes!!!")

        wdm_list.append(wdm)
        net.add(wdm)

    return wdm_list
```

</td>
</tr>
</table>

#### check if analysis layers are contained in the MRAcatalog

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
  // level : is the decomposition level
  // layes : are the number of layers along the frequency axis rateANA/(rateANA>>level)
  int check_layers=0;
  for(int level=cfg.l_high; level>=cfg.l_low; level--) {
    int layers = level>0 ? 1<<level : 0;
    for(int j=0;j<NET.wdmMRA.nRes;j++) if(layers==NET.wdmMRA.layers[j]) check_layers++;
  }

  if(check_layers!=nRES) {
    cout << "cwb2G::Init - Error : analysis layers do not match the MRA catalog" << endl;
    cout << endl << "analysis layers : " << endl;
    for(int level=cfg.l_high; level>=cfg.l_low; level--) {
      int layers = level>0 ? 1<<level : 0;
      cout << "level : " << level << " layers : " << layers << endl;
    }
    cout << endl << "MRA catalog layers : " << endl;
    for(int i=0;i<NET.wdmMRA.nRes;i++) 
       cout << "layers : " << NET.wdmMRA.layers[i] << endl;
    EXIT(1);
  } 
  else {
    cout << endl;
    for(int level=cfg.l_high; level>=cfg.l_low; level--) {
      int layers = level>0 ? 1<<level : 0;
      int rate  = rateANA>>level;
      cout << "level : " << level << "\t rate(hz) : " << rate << "\t layers : " << layers
           << "\t df(hz) : " << rateANA/2./double(1<<level)
           << "\t dt(ms) : " << 1000./rate << endl;
    }
    cout << endl;
  }
```
</td>
<td>

```python
def check_layers_with_MRAcatalog(config: Config, net: ROOT.network):
    check_layers = 0
    for i in range(config.l_low, config.l_high + 1):
        level = config.l_high + config.l_low - i
        layers = 2 ** level if level > 0 else 0
        for j in range(net.wdmMRA.nRes):
            if layers == net.wdmMRA.layers[j]:
                check_layers += 1

    if check_layers != config.nRES:
        logger.error("analysis layers do not match the MRA catalog")
        logger.error("analysis layers : ")
        for level in range(config.l_high, config.l_low - 1, -1):
            layers = 1 << level if level > 0 else 0
            logger.error("level : %s layers : %s", level, layers)

        logger.error("MRA catalog layers : ")
        for i in range(net.wdmMRA.nRes):
            logger.error("layers : %s", net.wdmMRA.layers[i])
        raise ValueError("analysis layers do not match the MRA catalog")

```

</td>
</tr>
</table>

#### Check if lagStep compatible with WDM parity

> Put in Config

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
  // This condition is necessary to avoid mixing between odd 
  // and even pixels when circular buffer is used for lag shift
  // The MRAcatalog distinguish odd and even pixels
  int rate_min  = rateANA>>cfg.l_high;
  double dt_max = 1./rate_min;
  if(fmod(rate_min,1.)) {
    cout << "cwb2G::Init - Error : rate min=" << rate_min << "(Hz) is not integer" << endl << endl;
    EXIT(1);  
  }
  if(int(cfg.lagStep*rate_min+0.001)&1) {
    cout << "cwb2G::Init - Error : lagStep=" << cfg.lagStep << "(sec)"
         << " is not a multple of 2*max_time_resolution=" << 2*dt_max << "(sec)" << endl << endl;
    EXIT(1);  
  }
  if(int(cfg.segEdge*rate_min+0.001)&1) {
    cout << "cwb2G::Init - Error : segEdge=" << cfg.segEdge << "(sec)"
         << " is not a multple of 2*max_time_resolution=" << 2*dt_max << "(sec)" << endl << endl;
    EXIT(1);  
  }
  if(int(cfg.segMLS*rate_min+0.001)&1) {
    cout << "cwb2G::Init - Error : segMLS=" << cfg.segMLS << "(sec)"
         << " is not a multple of 2*max_time_resolution=" << 2*dt_max << "(sec)" << endl << endl;
    EXIT(1);  
  }

```
</td>
<td>

```python
def check_lagStep(config: Config):
    rate_min = config.rateANA >> config.l_high
    dt_max = 1. / rate_min
    if rate_min % 1:
        logger.error("rate min=%s (Hz) is not integer", rate_min)
        raise ValueError("rate min=%s (Hz) is not integer", rate_min)
    if int(config.lagStep * rate_min + 0.001) & 1:
        logger.error("lagStep=%s (sec) is not a multple of 2*max_time_resolution=%s (sec)", config.lagStep, 2 * dt_max)
        raise ValueError("lagStep=%s (sec) is not a multple of 2*max_time_resolution=%s (sec)", config.lagStep,
                         2 * dt_max)
    if int(config.segEdge * rate_min + 0.001) & 1:
        logger.error("segEdge=%s (sec) is not a multple of 2*max_time_resolution=%s (sec)", config.segEdge, 2 * dt_max)
        raise ValueError("segEdge=%s (sec) is not a multple of 2*max_time_resolution=%s (sec)", config.segEdge,
                         2 * dt_max)
    if int(config.segMLS * rate_min + 0.001) & 1:
        logger.error("segMLS=%s (sec) is not a multple of 2*max_time_resolution=%s (sec)", config.segMLS, 2 * dt_max)
        raise ValueError("segMLS=%s (sec) is not a multple of 2*max_time_resolution=%s (sec)", config.segMLS,
                         2 * dt_max)
```

</td>
</tr>
</table>

#### time-delay filter rate

> Moved to Config

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp

  // time-delay filter rate
  if(cfg.fResample>0) {                                 // RESAMPLING
    TDRate = (cfg.fResample>>cfg.levelR)*cfg.upTDF;	
  } else {
    TDRate = (cfg.inRate>>cfg.levelR)*cfg.upTDF;	
  }

```
</td>
<td>

```python
  if self.fResample > 0:
      self.TDRate = (self.fResample >> self.levelR) * self.upTDF
  else:
      self.TDRate = (self.inRate >> self.levelR) * self.upTDF
```
</td>
</tr>
</table>

### 3.2 Init Network
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
 if(strlen(cfg.ifo[i])>0) pD[i] = new detector(cfg.ifo[i]);        // built in detector
 else                     pD[i] = new detector(cfg.detParms[i]);   // user define detector
}
// set the original sampling rate
for(int i=0; i<nIFO; i++) pD[i]->rate = cfg.fResample>0 ? cfg.fResample : cfg.inRate;
// add detector object to network
for(int i=0; i<nIFO; i++) NET.add(pD[i]);

// set network skymaps 
NET.setSkyMaps(int(cfg.healpix));
NET.setAntenna();

// restore network parameters
NET.constraint(cfg.delta,cfg.gamma);
NET.setDelay(cfg.refIFO);
NET.Edge = cfg.segEdge;
NET.netCC = cfg.netCC;
NET.netRHO = cfg.netRHO;
NET.EFEC = cfg.EFEC;
NET.precision = cfg.precision;
NET.nSky = cfg.nSky;
NET.setRunID(runID);
NET.setAcore(cfg.Acore);
NET.optim=cfg.optim;
NET.pattern=cfg.pattern;

// set sky mask
if(strlen(cfg.skyMaskFile)>0) SetSkyMask(&NET,&cfg,cfg.skyMaskFile,'e'); 
if(strlen(cfg.skyMaskCCFile)>0) SetSkyMask(&NET,&cfg,cfg.skyMaskCCFile,'c'); 
```
</td>
<td>

```python
def init_network(config: Config, net: ROOT.network,
                 strain_list: list,
                 run_id):
   logger.info("Initializing network")

   for i, ifo in enumerate(config.ifo):
      logger.info("Adding ifo %s", ifo)
      det = ROOT.detector(ifo)

      det.rate = config.inRate if not config.fResample else config.fResample
      det.HoT = strain_list[i]['TFmap']
      det.TFmap = strain_list[i]['TFmap']
      det.nRMS = strain_list[i]['nRMS']
      net.add(det)

   # set network skymaps
   logger.info("Setting skymaps")
   net.setSkyMaps(int(config.healpix))
   net.setAntenna()

   # restore network parameters
   logger.info("Restoring network parameters")
   net.constraint(config.delta, config.gamma)
   net.setDelay(config.refIFO)
   net.Edge = config.segEdge
   net.netCC = config.netCC
   net.netRHO = config.netRHO
   net.EFEC = config.EFEC
   net.precision = config.precision
   net.nSky = config.nSky
   net.setRunID(run_id)
   net.setAcore(config.Acore)
   net.optim = config.optim
   net.pattern = config.pattern

   # set sky mask
   logger.info("Setting sky mask")
   tmp_cfg = ROOT.CWB.config()
   tmp_cfg.healpix = config.healpix
   tmp_cfg.Theta1 = config.Theta1
   tmp_cfg.Theta2 = config.Theta2
   tmp_cfg.Phi1 = config.Phi1
   tmp_cfg.Phi2 = config.Phi2

   if len(config.skyMaskFile) > 0:
      ROOT.SetSkyMask(net, tmp_cfg, config.skyMaskFile, 'e')

   if len(config.skyMaskCCFile) > 0:
      ROOT.SetSkyMask(net, tmp_cfg, config.skyMaskCCFile, 'c')

   return net
```
</td>
</tr>
</table>

```python
def set_liv_time(config: Config, net: ROOT.network, lagBuffer: str, lagMode: str):
    if lagBuffer:
        lags = net.setTimeShifts(config.lagSize, config.lagStep, config.lagOff, config.lagMax,
                                 lagBuffer,
                                 lagMode,
                                 config.lagSite)
    else:
        lags = net.setTimeShifts(config.lagSize, config.lagStep, config.lagOff, config.lagMax)
    logger.info("lag step: %s", config.lagStep)
    logger.info("number of time lags: %s", lags)

    return net


def get_lag_buffer(config: Config):
    if config.lagMode == "r":
        with open(config.lagFile, "r") as f:
            lagBuffer = f.read()
        lagMode = 's'
    else:
        lagBuffer = config.lagFile
        lagMode = 'w'

    return lagBuffer, lagMode
```

## 4. Coherence


Select the significant pixels

Loop over resolution levels (nRES)

 - Loop over detectors (cwb::nIFO)
   - Compute the maximum energy of TF pixels (WSeries<double>::maxEnergy)
 - Set pixel energy selection threshold (network::THRESHOLD)
 - Loop over time lags (network::nLag)
   - Select the significant pixels (network::getNetworkPixels)
   - Single resolution clustering (network::cluster)
   - Store selected pixels to job file (netcluster::write)


### 4.1 produce TF maps with max over the sky energy

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

> Remove single detector mode?

```cpp
for(int i=0; i<nRES; i++) {
  double alp=0;
  for(int n=0; n<nIFO; n++) {
    alp+=NET.getifo(n)->getTFmap()->maxEnergy(
                            *hot[n],*pwdm[i],mTau,upN,NET.pattern);
    // restore the frequency boundaries changed by the maxEnergy call
    NET.getifo(n)->getTFmap()->setlow(cfg.fLow);
    NET.getifo(n)->getTFmap()->sethigh(cfg.fHigh);
  }
}
```
</td>
<td>

```python
def max_energy(config: Config, net: ROOT.network, h: ROOT.wavearray(np.double),
               wdm_list: list):
   # maximum time delay
   m_tau = net.getDelay('MAX')

   # calculate upsample factor
   up_n = config.rateANA // 1024
   if up_n < 1:
      up_n = 1

   alp_list = []
   for i in range(config.nRES):
      alp = 0
      for n in range(len(config.ifo)):
         alp += net.getifo(n).getTFmap().maxEnergy(h, wdm_list[i],
                                                   m_tau, up_n,
                                                   net.pattern)
         net.getifo(n).getTFmap().setlow(config.fLow)
         net.getifo(n).getTFmap().sethigh(config.fHigh)
      alp_list.append(alp)

   return alp_list
```
</td>
</tr>
</table>

### 4.2 threshold on pixel energy

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
      alp /= nIFO;
      if(NET.pattern!=0) { 
        Eo = NET.THRESHOLD(cfg.bpp,alp);          
      } else {
        Eo = NET.THRESHOLD(cfg.bpp); 
      }
      cout.precision(5);
      cout<<"thresholds in units of noise variance: Eo="<<Eo<<" Emax="<<Eo*2<<endl;
      // add infos to history
      sprintf(info,"-RES:%d-THR:%g",i,Eo);
      PrintAnalysisInfo(CWB_STAGE_COHERENCE,"cwb2G::Coherence",info,false);
  
      double TL = NET.setVeto(cfg.iwindow);
      cout<<"live time in zero lag: "<<TL<<endl;        // set veto array
      if(TL <= 0.) {froot->Close();EXIT(1);}  	        // exit if live time is zero 
}
```
</td>
<td>

```python
def threshold(config: Config, net: ROOT.network, alp_list: np.array):
    threshold_list = []
    for i, alp in enumerate(alp_list / len(config.ifo)):
        if net.pattern != 0:
            Eo = net.THRESHOLD(config.bpp, alp)
        else:
            Eo = net.THRESHOLD(config.bpp)
        logger.info("thresholds in units of noise variance: Eo=%g Emax=%g", Eo, Eo * 2)
        logger.info(f"cwb2G::Coherence -RES:{i}-THR:{Eo}")
        # set veto array
        # TODO: test if we need to re-export net again from here, or set veto in init
        TL = net.setVeto(config.iwindow)
        logger.info("live time in zero lag: %g", TL)
        if TL <= 0.:
            raise ValueError("live time is zero")
        threshold_list.append(Eo)

    return np.array(threshold_list)

```
</td>
</tr>
</table>


### 4.3 init sparse table (used in supercluster stage : set the TD filter size)
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
      pwdm[i]->setTDFilter(cfg.TDSize, 1); 
      for(int n=0; n<nIFO; n++) {
         WS[n].Forward(*hot[n],*pwdm[i]);
         vSS[n].SetMap(&WS[n]);
         vSS[n].SetHalo(mTau);
         if(singleDetector) {
           WS[1]=WS[0];
           vSS[1].SetMap(&WS[1]);
           vSS[1].SetHalo(mTau);
           break;
         }
      }
}
```
</td>
<td>

```python
sparse_table = []
wdm_list[i].setTDFilter(config.TDSize, 1)
for n in range(config.nIFO):
   ws = ROOT.WSeries(np.double)(strain_list[n], wdm_list[i])
   ws.Forward()
   ss = ROOT.SSeries(np.double)()
   ss.SetMap(ws)
   ss.SetHalo(m_tau)
   sparse_table.append(ss)
```
</td>
</tr>
</table>

### 4.4 select pixels

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
      if(cfg.simulation) {cout<<"ifactor|clusters|pixels ";cout.flush();}
      else               {cout<<"lag|clusters|pixels ";    cout.flush();}
      int csize_tot=0;int psize_tot=0; 
      for(int j=0; j<(int)NET.nLag; j++) {
         // select pixels above Eo
         NET.getNetworkPixels(j,Eo); 
         // get pixel list
         pwc = NET.getwc(j);
         if(NET.pattern!=0) {
            // cluster pixels
            NET.cluster(2,3);
            wc.cpf(*(pwc),false);
            // remove pixels below subrho
            wc.select(const_cast<char*>("subrho"),cfg.select_subrho);
            // remove pixels below subnet
            wc.select(const_cast<char*>("subnet"),cfg.select_subnet);
            // copy selected pixels back to pwc
            pwc->cpf(wc,false);
         } else NET.cluster(1,1);
         // store cluster into temporary job file
         int cycle = cfg.simulation ? ifactor : Long_t(pwc->shift);
         pwc->write(jfile,"coherence","clusters",0,cycle);
         pwc->write(jfile,"coherence","clusters",-1,cycle,-(rateANA>>(cfg.l_high-i)));
         cout<<cycle<<"|"<<pwc->csize()<<"|"<<pwc->size()<<" ";cout.flush();
         csize_tot+=pwc->csize(); psize_tot+=pwc->size(); 

         // add core pixels to sparse table
         for(int n=0; n<nIFO; n++) vSS[n].AddCore(n,pwc);

         pwc->clear();
      }
}
```
</td>
<td>

```python
def select_pixels(config: Config, net: ROOT.network,
                  strain_list: list[ROOT.wavearray(np.double)],
                  wdm_list: list[ROOT.WDM(np.double)],
                  threshold_list: np.array):
    # init sparse table (used in supercluster stage : set the TD filter size)
    sparse_table_list = []
    m_tau = net.getDelay('MAX')
    wc = ROOT.netcluster()

    for i in range(config.nRES):
       sparse_table = []
       wdm_list[i].setTDFilter(config.TDSize, 1)
       for n in range(config.nIFO):
          ws = ROOT.WSeries(np.double)(strain_list[n], wdm_list[i])
          ws.Forward()
          ss = ROOT.SSeries(np.double)()
          ss.SetMap(ws)
          ss.SetHalo(m_tau)
          sparse_table.append(ss)

       logger.info("lag|clusters|pixels ")

       csize_tot = 0
       psize_tot = 0

       for j in range(int(net.nLag)):
          print("lag: ", j)
          net.getNetworkPixels(j, threshold_list[i])
          print("pixels selected")
          pwc = net.getwc(j)
          print("wc got")
          print("net pattern: ", net.pattern)
          if net.pattern != 0:
             net.cluster(2, 3)
             wc.cpf(pwc, False)
             wc.select("subrho", config.select_subrho)
             wc.select("subnet", config.select_subnet)
             pwc.cpf(wc, False)
          else:
             net.cluster(1, 1)
          # store cluster into temporary job file
          csize_tot += pwc.csize()
          psize_tot += pwc.size()
          logger.info("%3d|%9d|%7d ", j, csize_tot, psize_tot)

          # add core pixels to sparse table
          for n in range(config.nIFO):
             sparse_table[n].AddCore(n, pwc)

          pwc.clear()

    return sparse_table_list
```
</td>
</tr>
</table>

Key output: cluster `pwc`, spare table `vSS`

## 5. Supercluster


Multi resolution clustering & Rejection of the sub-threshold clusters

Loop over time lags

 - Read clusters from job file (netcluster::read)
 - Multi resolution clustering (netcluster::supercluster)
 - Compute for each pixel the time delay amplitudes (netcluster::loadTDampSSE)
 - Rejection of the sub-threshold clusters (network::subNetCut)
 - Defragment clusters (netcluster::defragment)
 - Store superclusters to job file (netcluster::write)

### 5.1 Build & Write to job file the sparse TF maps (WriteSparseTFmap)

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
// decrease skymap resolution to improve subNetCut performances
double skyres=0;
skyres = cfg.healpix>MIN_SKYRES_HEALPIX ? MIN_SKYRES_HEALPIX : 0;
if(skyres) {
NET.setSkyMaps(int(skyres));
NET.setAntenna();
NET.setDelay(cfg.refIFO);
// the down resampling of the skymask works only for the built-in skymask
if(strlen(cfg.skyMaskFile)>0)   SetSkyMask((network*)(&NET),&cfg,cfg.skyMaskFile,'e',skyres);
if(strlen(cfg.skyMaskCCFile)>0) SetSkyMask((network*)(&NET),&cfg,cfg.skyMaskCCFile,'c',skyres);
}

for(int i=0; i<nIFO; i++) pTF[i] = pD[i]->getTFmap();
// set low-rate TD filters 
for(int k=0;k<nRES;k++) pwdm[k]->setTDFilter(cfg.TDSize, 1); 
```
</td>
<td>

```python

```
</td>
</tr>
</table>

### 5.2 read sparse map from job file

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp  
for(int n=0; n<nIFO; n++) {
    pD[n]->sclear();   // clear vector with sparse maps
    for(int i=0; i<nRES; i++) {
      char swname[32];
      if(cfg.simulation) sprintf(swname,"csparse/%s-level:%d:%d",ifo[n],ifactor,i+cfg.l_low);
      else               sprintf(swname,"csparse/%s-level:%d",ifo[n],i+cfg.l_low);
      SSeries<double>* psw;
      if(ifile!=NULL) psw = (SSeries<double>*)ifile->Get(swname);	
      else            psw = (SSeries<double>*)jfile->Get(swname);	
      if(psw==NULL) {
        cout << "cwb2G::SuperCluster : sparse map " << swname
             << " not exist in job file" << endl;EXIT(1);
      }
      SSeries<double> SS = *psw;
      pD[n]->vSS.push_back(SS);
      delete psw;
    }
    cout<<endl;
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>


### 5.3 read data

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int j=0; j<(int)lags; j++) {

  int cycle = cfg.simulation ? ifactor : Long_t(NET.wc_List[j].shift);

  // read cluster metadata
  if(ifile!=NULL) wc.read(ifile,"coherence","clusters",0,cycle);	
  else            wc.read(jfile,"coherence","clusters",0,cycle);	
  // read clusters from temporary job file, loop over TF resolutions
  if(ifile!=NULL) {
    for(int i=nRES-1; i>=0; i--)     // reverse loop is faster loading cluster (?)
      wc.read(ifile,"coherence","clusters",-2,cycle,-(rateANA>>(i+cfg.l_low))); 
  } else {           
    for(int i=nRES-1; i>=0; i--)     // reverse loop is faster loading cluster (?)
      wc.read(jfile,"coherence","clusters",-2,cycle,-(rateANA>>(i+cfg.l_low))); 
  }
  cout<<"-----------------------------------------------------"<<endl; 
  char cycle_name[32];
  if(cfg.simulation) sprintf(cycle_name," factor[%d]=%g",ifactor,cfg.factors[ifactor]);
  else               sprintf(cycle_name," lag=%d",cycle); 
  cout<<"-> Processing "   <<cycle_name<<" ..."<<endl;
  cout<<"   --------------------------------------------------"<<endl; 
  cout<<"   coher  clusters|pixels      : "
      <<setfill(' ')<<setw(6)<<wc.csize()<<"|"<<wc.size()<<endl;
```

</td>
<td>

```python

```
</td>
</tr>
</table>

### 5.4 supercluster analysis

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int j=0; j<(int)lags; j++) {
  if(cfg.l_high==cfg.l_low) wc.pair=false;		// if only one resolution is used pair is false 
  if(NET.pattern!=0) wc.pair=false;                 // if other than pattern=0 - allow one resolution cluster
  wc.supercluster('L',NET.e2or,cfg.TFgap,false);  	// likehood2G
  cout<<"   super  clusters|pixels      : "
      <<setfill(' ')<<setw(6)<<wc.esize(0)<<"|"<<wc.psize(0)<<endl;
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>


<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int j=0; j<(int)lags; j++) {
  // defragmentation for pattern != 0
  if(NET.pattern!=0) {
     wc.defragment(cfg.Tgap,cfg.Fgap);                                
     cout<<"   defrag clusters|pixels      : "
         <<setfill(' ')<<setw(6)<<wc.esize(0)<<"|"<<wc.psize(0)<<"\n";
  }

  // copy selected clusters to network
  pwc = NET.getwc(j);
  pwc->cpf(wc, false);

  // apply subNetCut() only for pattern=0 || cfg.subnet>0 || cfg.subcut>0 || cfg.subnorm>0 || cfg.subrho>=0
  if(NET.pattern==0 || cfg.subnet>0 || cfg.subcut>0 || cfg.subnorm>0 || cfg.subrho>=0) {
     if(cfg.subacor>0) NET.acor=cfg.subacor;	// set Acore for subNetCuts
     if(cfg.subrho>0)  NET.netRHO=cfg.subrho;	// set netRHO for subNetCuts
     NET.setDelayIndex(hot[0]->rate());
     pwc->setcore(false);   
     int psel = 0;
     while(1) {
       count = pwc->loadTDampSSE(NET, 'a', cfg.BATCH, cfg.LOUD);
       psel += NET.subNetCut((int)j,cfg.subnet,cfg.subcut,cfg.subnorm,NULL);
       int ptot = pwc->psize(1)+pwc->psize(-1);
       double pfrac = ptot>0 ? double(psel)/double(ptot) : 0.;
       //cout<<"selected pixels: "<<psel<<"|"<<ptot<<", fraction: "<<pfrac<<" "<<cfg.subnet<<" "<<cfg.subcut<<endl;
       if(count<10000) break;
     }
     cout<<"   subnet clusters|pixels      : "
         <<setfill(' ')<<setw(6)<<NET.events()<<"|"<<pwc->psize(-1)<<"\n";
     if(cfg.subacor>0) NET.acor=cfg.Acore;		// restore Acore
     if(cfg.subrho>0)  NET.netRHO=cfg.netRHO;	// restore netRHO
  }
  if(NET.pattern==0) {
     // defragmentation
     pwc->defragment(cfg.Tgap,cfg.Fgap);    
     cout<<"   defrag clusters|pixels      : "
         <<setfill(' ')<<setw(6)<<NET.events()<<"|"<<pwc->psize(-1)<<"\n";
  }

  nevt += NET.events();
  nnn  += pwc->psize(-1);
  mmm  += pwc->psize(1)+pwc->psize(-1);

  // store cluster into temporary job file [NEWSS]
  pwc->write(jfile,"supercluster","clusters",0,cycle);
  pwc->write(jfile,"supercluster","clusters",-1,cycle);
  //cout<<cycle<<"|"<<pwc->csize()<<"|"<<pwc->size()<<" ";cout.flush();

  pwc->clear();
  cout<<endl;cout.flush();
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>

Key output: cluster `pwc`

## 6. Likelihood

Event reconstruction & parameters estimation

Read sparse map from job file

Loop over time lags

 - Read cluster list from job file (netcluster::read)
 - Loop over cluster list
   - Read pixels (netcluster::read)
   - Compute for each pixel the time delay amplitudes (netcluster::loadTDampSSE)
   - Event reconstruction+parameter estimation (network::likelihood2G)
   - Store event parameters to job file (netevent::output)
   - If(config::cedDump>0) Generate Coherent Event Display (CWB::ced)


### 6.1 loop over the cluster list

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
NET.network::setDelayIndex(TDRate);

for(int k=0; k<nRES; k++) pwdm[k]->setTDFilter(cfg.TDSize, cfg.upTDF);
NET.network::setDelayIndex(TDRate);

...

for(int k=0;k<(int)clist.size();k++) {	// loop over the cluster list 
      pwc->read(jfile,"supercluster","clusters",nmax,cycle,0,clist[k]);
    
      wavearray<double> cid = pwc->get((char*)"ID",  0,'S',0); // get cluster ID
      if(!cid.size()) continue;
      
      int id = size_t(cid.data[cid.size()-1]+0.1);
      pwc->setcore(false,id);
      pwc->loadTDampSSE((network&)NET, 'a', cfg.BATCH, cfg.BATCH);  // attach TD amp to pixels
    
      int lag = j;
    
      int ID = cfg.cedDump ? -id : 0;
      int selected_core_pixels = 0;
      if(NET.pattern>0) { 
        selected_core_pixels = NET.likelihoodWP(cfg.search, lag, ID, NULL, cfg.Search);
      } else { 
        selected_core_pixels = NET.network::likelihood2G(cfg.search, lag, ID, NULL);
      }
      if(!cfg.outPlugin) { 	// if true then output to root file is provided by the user plugin
        double ofactor=0;
        if(cfg.simulation==4)      ofactor=-factor;
        else if(cfg.simulation==3) ofactor=-ifactor;
        else                       ofactor=factor;
        if(cfg.dump) netburst->dopen(outDump,const_cast<char*>("a"),false);
        netburst->output(net_tree,&NET,id,lag,ofactor);
        if(cfg.dump) netburst->dclose();
      } 
      int rejected_weak_pixels = 0;
      int rejected_loud_pixels = 0;
    
      bool detected = (bool)(NET.network::getwc(j)->sCuts[k] == -1);
    
      // print reconstructed event  
      cout<<"   cluster-id|pixels: "<<setfill(' ')<<setw(5)<<clist[k]<<"|"<<pwc->size()-npixels;  
      if(detected) cout << "\t -> SELECTED !!!" << endl;
      else 	   cout << "\t <- rejected    " << endl;
      cout.flush();
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>

### 6.2 Store data

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int k=0;k<(int)clist.size();k++) {	// loop over the cluster list 
      if(((k==0)||detected)&&(jobfOptions&CWB_JOBF_SAVE_LIKELIHOOD)) {
        TFile* ifile = jfile;
        if(xname!=jname) {
          ifile = new TFile(jname,"UPDATE");
          if(ifile==NULL||!ifile->IsOpen()) {
            cout << "cwb2G::Likelihood - Error : file " << jname << " not found" <<  endl; EXIT(1); }
        }
        pwc->write(ifile,"likelihood","clusters",0,cycle);
        pwc->write(ifile,"likelihood","clusters",-1,cycle,0,k+1);
        if(detected) cout<<"saved"<<endl;cout.flush();
        ifile->Write();
        if(xname!=jname) ifile->Close();
      }

      if(detected) nevents++;
      npixels=pwc->size();
}
```
</td>
<td>

```python

```
   
</td>
</tr>
</table>

