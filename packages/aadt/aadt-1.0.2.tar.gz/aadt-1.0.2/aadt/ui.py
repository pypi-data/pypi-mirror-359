# Anki Add-on Builder
#
# Copyright (C)  2016-2021 Aristotelis P. <https://glutanimate.com/>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version, with the additions
# listed at the end of the license file that accompanied this program.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# NOTE: This program is subject to certain additional terms pursuant to
# Section 7 of the GNU Affero General Public License.  You should have
# received a copy of these additional terms immediately following the
# terms and conditions of the GNU Affero General Public License that
# accompanied this program.
#
# If not, please request a copy through one of the means of contact
# listed here: <https://glutanimate.com/contact/>.
#
# Any modifications to this file must keep this entire header intact.

"""
Qt6 UI Compilation

Compiles Qt Designer .ui files to Python classes using pyuic6.
This module focuses exclusively on Qt6 support for modern Anki add-ons.
"""

import logging
import re
import shutil
import subprocess
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

from whichcraft import which

from . import __title__, __version__
from .config import Config

# Default path names (kept for backward compatibility)
DEFAULT_UI_FOLDER_NAME = "ui"
DEFAULT_DESIGNER_FOLDER_NAME = "designer"
DEFAULT_RESOURCES_FOLDER_NAME = "resources"
DEFAULT_FORMS_PACKAGE_NAME = "forms"


class UICompilationError(Exception):
    """Exception raised when UI compilation fails"""

    def __init__(
        self, message: str, ui_file: Path | None = None, stderr: str | None = None
    ):
        self.ui_file = ui_file
        self.stderr = stderr
        super().__init__(message)


_template_header = '''\
# -*- coding: utf-8 -*-
#
# {display_name} Add-on for Anki
# Copyright (C)  {years} {author}{contact}
#
# This file was automatically generated by {__title__} v{__version__}
# It is subject to the same licensing terms as the rest of the program
# (see the LICENSE file which accompanies this program).
#
# WARNING! All changes made in this file will be lost!

"""
Initializes generated Qt forms/resources
"""\
'''

_template_all = """\
__all__ = [
{}
]\
"""

_template_qt_shim = '''\
# -*- coding: utf-8 -*-
#
# {display_name} Add-on for Anki
# Copyright (C)  {years} {author}{contact}
#
# This file was automatically generated by {__title__} v{__version__}
# It is subject to the same licensing terms as the rest of the program
# (see the LICENSE file which accompanies this program).
#
# WARNING! All changes made in this file will be lost!

"""
Imports Qt6 forms directly for modern Anki add-ons
"""

from .qt6 import *  # noqa: F401
'''


class QtVersion(Enum):
    """Qt version enum - Qt6 only for modern add-ons"""

    qt6 = 6


class UIBuilder:
    """
    Modern Qt6-only UI builder for Anki add-ons.

    Compiles .ui files from Qt Designer into Python classes using pyuic6.
    No longer supports Qt5 or QRC resource files - uses modern Qt6 approach.
    """

    _re_munge = re.compile(r"^import .+?_rc(\n)?$", re.MULTILINE)
    _ui_file_glob = "*.ui"
    _ui_file_tool = "pyuic"

    def __init__(self, dist: Path, config: Config) -> None:
        self._dist = dist
        self._config = config
        self._addon_config = config.as_dataclass()

        # Get UI configuration
        ui_config = self._addon_config.build_config.ui_config

        self._gui_path: Path = (
            self._dist / "src" / self._addon_config.module_name / "gui"
        )
        self._ui_source_path: Path = self._dist / ui_config.ui_dir
        self._forms_source_path: Path = self._ui_source_path / ui_config.designer_dir
        self._resources_source_path: Path = (
            self._ui_source_path / ui_config.resources_dir
        )
        self._forms_out_path: Path = self._gui_path / ui_config.forms_package

        self._format_dict: dict[str, Any] = self._get_format_dict()

    def _compile_ui_file(self, ui_file: Path, output_file: Path, tool: str) -> None:
        """Compile a single UI file with improved error handling"""
        try:
            # Use subprocess.run for better error control
            result = subprocess.run(
                [tool, str(ui_file), "-o", str(output_file)],
                capture_output=True,
                text=True,
                check=True,
                timeout=30,  # 30 second timeout
            )

            if result.stderr:
                logging.debug(f"pyuic6 stderr for {ui_file.name}: {result.stderr}")

        except subprocess.CalledProcessError as e:
            error_msg = f"Failed to compile {ui_file.name}"
            if e.stderr:
                error_msg += f": {e.stderr.strip()}"
            raise UICompilationError(error_msg, ui_file=ui_file, stderr=e.stderr) from e
        except subprocess.TimeoutExpired as e:
            raise UICompilationError(
                f"UI compilation timed out for {ui_file.name}", ui_file=ui_file
            ) from e
        except FileNotFoundError as e:
            raise UICompilationError(
                f"Tool {tool} not found. Please ensure PyQt6 is installed.",
                ui_file=ui_file,
            ) from e

    def build(self) -> bool:
        qt_version = QtVersion.qt6
        qt_version_key = qt_version.name

        logging.info("Starting UI build tasks for target %r...", qt_version_key)

        path_in = self._forms_source_path
        path_out = self._forms_out_path / qt_version_key

        # Qt6 doesn't need QRC resource migration
        resource_prefixes_to_replace: list[str] = []

        if not path_in.exists():
            logging.warning(
                f"No Qt forms folder found under {self._forms_source_path}. Skipping"
                " build."
            )
            return False

        ret = self._build(
            path_in=path_in,
            path_out=path_out,
            qt_version_number=qt_version.value,
            resource_prefixes_to_replace=resource_prefixes_to_replace,
        )

        # Copy UI resources to the module
        if self._resources_source_path.exists():
            self._copy_ui_resources()

        logging.info("Done with all UI build tasks.")

        return ret

    def create_qt_shim(self) -> bool:
        if not self._forms_out_path.is_dir():
            return False
        out_path = self._forms_out_path / "__init__.py"
        if out_path.exists():
            out_path.unlink()
        format_dict = self._format_dict
        content = _template_qt_shim.format(**format_dict)
        with out_path.open("w", encoding="utf-8") as f:
            f.write(content)
        return True

    def _build(
        self,
        path_in: Path,
        path_out: Path,
        qt_version_number: int,
        resource_prefixes_to_replace: list[str],
    ) -> bool:
        # Basic checks
        ui_files = list(path_in.glob(self._ui_file_glob))
        if not ui_files:
            logging.warning("No forms found in %s. Skipping UI build.", path_in)
            return False

        # Find a valid UIC tool, preferring pyside6-uic
        tool_names = [f"pyside{qt_version_number}-uic", f"pyuic{qt_version_number}"]
        tool_path = None
        for name in tool_names:
            path = which(name)
            if path:
                tool_path = path
                break

        if not tool_path:
            logging.error(
                f"Could not find any of the required tools: {', '.join(tool_names)}. "
                f"Please ensure PyQt{qt_version_number} or PySide{qt_version_number} is installed."
            )
            return False

        logging.info("Using UI compiler: %s", tool_path)
        path_out.mkdir(parents=True, exist_ok=True)

        compiled_modules: list[str] = []

        for file in ui_files:
            out_name = f"form_{file.stem.lower().replace('-', '_')}.py"
            out_file = path_out / out_name
            try:
                self._compile_ui_file(file, out_file, str(tool_path))
                self._munge_form(out_file, resource_prefixes_to_replace)
                compiled_modules.append(out_name.replace(".py", ""))
            except UICompilationError as e:
                logging.error(
                    f"Error compiling {self._relative_to_cwd(e.ui_file)}: {e}",
                )
                if e.stderr:
                    logging.error("Compiler output:\n%s", e.stderr)
                # Continue to next file
            except Exception as e:
                logging.error(
                    "An unexpected error occurred during UI compilation: %s", e
                )

        if compiled_modules:
            self._write_init_file(compiled_modules, path_out)
            return True

        return False

    def _write_init_file(self, modules: list[str], path_out: Path) -> None:
        logging.debug("Generating init file for %s", self._relative_to_cwd(path_out))

        header = _template_header.format(**self._format_dict)
        all_str = self._generate_all_str(modules)
        import_str = self._generate_import_str(modules)

        init = "\n\n".join((header, all_str, import_str)) + "\n"

        with (path_out / "__init__.py").open("w", encoding="utf-8") as f:
            f.write(init)

    def _generate_all_str(self, modules: list[str]) -> str:
        module_string = ",\n".join(f'    "{m}"' for m in modules)
        out = _template_all.format(module_string)
        return out

    def _generate_import_str(self, modules: list[str]) -> str:
        out = "\n".join(f"from . import {m}" for m in modules)
        return out

    def _munge_form(self, path: Path, resource_prefixes_to_replace: list[str]) -> None:
        """
        Post-process generated Qt form files to clean up resource references.

        This method performs two main operations:
        1. Removes `import *_rc` statements generated by pyuic6 for QRC resources
        2. Converts Qt resource syntax (:/prefix/path) to direct file paths
           (prefix:path)

        Why this is needed in Qt6 workflow:
        - Even in Qt6, pyuic6 may generate QRC import statements if the .ui file
          contains resource references
        - We use direct file paths instead of compiled QRC resources for simplicity
        - This allows resources to be accessed as regular files in the add-on package

        Args:
            path: Path to the generated Python form file
            resource_prefixes_to_replace: List of resource prefixes to convert
                from Qt syntax (:/prefix/) to direct syntax (prefix:)
        """
        logging.debug("Munging %s...", self._relative_to_cwd(path))
        with path.open("r+", encoding="utf-8") as f:
            form = f.read()
            munged = self._re_munge.sub("", form)
            for prefix in resource_prefixes_to_replace:
                munged = munged.replace(f'":/{prefix}/', f'"{prefix}:')
            f.seek(0)
            f.write(munged)
            f.truncate()

    def _get_format_dict(self) -> dict[str, Any]:
        config = self._addon_config
        start_year = config.copyright_start
        now = datetime.now().year
        if start_year and start_year != now:
            years = f"{start_year}-{now}"
        else:
            years = f"{now}"

        contact = config.contact

        format_dict = {
            "display_name": config.display_name,
            "author": config.author,
            "contact": "" if not contact else f" <{contact}>",
            "__title__": __title__,
            "__version__": __version__,
            "years": years,
        }

        return format_dict

    def _copy_ui_resources(self) -> None:
        """
        Copy UI resources from ui/resources/ to src/module/resources/ with filtering
        """
        from .utils import copy_recursively

        target_resources_path = self._gui_path.parent / "resources"
        ui_config = self._addon_config.build_config.ui_config

        logging.info("Copying UI resources...")
        logging.debug("From: %s", self._relative_to_cwd(self._resources_source_path))
        logging.debug("To: %s", self._relative_to_cwd(target_resources_path))

        # Create target directory if it doesn't exist
        target_resources_path.mkdir(parents=True, exist_ok=True)

        # Copy all resources with optional filtering
        for item in self._resources_source_path.iterdir():
            # Check if we should exclude optional resources
            if (
                ui_config.exclude_optional_resources
                and item.is_dir()
                and item.name == "optional"
            ):
                logging.debug("Skipping optional resources directory: %s", item.name)
                continue

            if item.is_file():
                # Copy files directly
                target_file = target_resources_path / item.name
                target_file.write_bytes(item.read_bytes())
                logging.debug("Copied file: %s", item.name)
            elif item.is_dir():
                # Handle optional subdirectories within other directories
                if (
                    ui_config.exclude_optional_resources
                    and self._contains_optional_directory(item)
                ):
                    self._copy_directory_excluding_optional(
                        item, target_resources_path / item.name
                    )
                else:
                    # Copy directories recursively
                    target_dir = target_resources_path / item.name
                    copy_recursively(str(item), str(target_dir))
                logging.debug("Copied directory: %s", item.name)

    def _contains_optional_directory(self, directory: Path) -> bool:
        """Check if directory contains an 'optional' subdirectory"""
        return any(f.name == "optional" and f.is_dir() for f in directory.rglob("*"))

    def _copy_directory_excluding_optional(self, src_dir: Path, dst_dir: Path) -> None:
        """
        Recursively copies a directory, excluding any sub-directory named 'optional'.
        """
        dst_dir.mkdir(parents=True, exist_ok=True)
        for item in src_dir.iterdir():
            if item.name == "optional" and item.is_dir():
                continue

            src_path = src_dir / item.name
            dst_path = dst_dir / item.name

            if item.is_dir():
                self._copy_directory_excluding_optional(src_path, dst_path)
            else:
                shutil.copy2(src_path, dst_path)

    def _relative_to_cwd(self, path: Path) -> Path:
        try:
            return path.relative_to(Path.cwd())
        except ValueError:
            return path  # Not a subpath of CWD, return original
