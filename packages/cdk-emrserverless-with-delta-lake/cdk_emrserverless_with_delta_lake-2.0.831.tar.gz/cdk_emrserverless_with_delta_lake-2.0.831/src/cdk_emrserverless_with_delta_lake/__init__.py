r'''
# cdk-emrserverless-with-delta-lake

[![License](https://img.shields.io/badge/License-Apache%202.0-green)](https://opensource.org/licenses/Apache-2.0) [![Release](https://github.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/actions/workflows/release.yml/badge.svg)](https://github.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/actions/workflows/release.yml/badge.svg) [![npm downloads](https://img.shields.io/npm/dt/cdk-emrserverless-with-delta-lake?label=npm%20downloads&style=plastic)](https://img.shields.io/npm/dt/cdk-emrserverless-with-delta-lake?label=npm%20downloads&style=plastic) [![pypi downloads](https://img.shields.io/pypi/dw/cdk-emrserverless-with-delta-lake?label=pypi%20downloads&style=plastic)](https://img.shields.io/pypi/dw/cdk-emrserverless-with-delta-lake?label=pypi%20downloads&style=plastic) [![NuGet downlods](https://img.shields.io/nuget/dt/Emrserverless.With.Delta.Lake?label=NuGet%20downloads&style=plastic)](https://img.shields.io/nuget/dt/Emrserverless.With.Delta.Lake?label=NuGet%20downloads&style=plastic) [![repo languages](https://img.shields.io/github/languages/count/HsiehShuJeng/cdk-emrserverless-with-delta-lake?style=plastic)](https://img.shields.io/github/languages/count/HsiehShuJeng/cdk-emrserverless-with-delta-lake?style=plastic)

| npm (JS/TS) | PyPI (Python) | Maven (Java) | Go | NuGet |
| --- | --- | --- | --- | --- |
| [Link](https://www.npmjs.com/package/cdk-emrserverless-with-delta-lake) | [Link](https://pypi.org/project/cdk-emrserverless-with-delta-lake/) | [Link](https://search.maven.org/artifact/io.github.hsiehshujeng/cdk-emrserverless-quickdemo-with-delta-lake) | [Link](https://github.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake-go) | [Link](https://www.nuget.org/packages/Emrserverless.With.Delta.Lake/) |

![high level architecture](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/high%20level%20architecture.png)

This constrcut builds an EMR studio, a cluster template for the EMR Studio, and an EMR Serverless application. 2 S3 buckets will be created, one is for the EMR Studio workspace and the other one is for EMR Serverless applications. Besides, the VPC and the subnets for the EMR Studio will be tagged `{"Key": "for-use-with-amazon-emr-managed-policies", "Value": "true"}` via a custom resource. This is necessary for the [service role](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-service-role.html#emr-studio-service-role-instructions) of EMR Studio.
This construct is for analysts, data engineers, and anyone who wants to know how to process **Delta Lake data** with EMR serverless.
![cfn designer](https://github.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/blob/main/images/cfn-designer.png?raw=true)
They build the construct via [cdkv2](https://docs.aws.amazon.com/cdk/v2/guide/home.html) and build a serverless job within the EMR application generated by the construct via AWS CLI within few minutes. After the EMR serverless job is finished, they can then check the processed result done by the EMR serverless job on an EMR notebook through the cluster template.
![app history](https://github.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/blob/main/images/spark%20jobs.png?raw=true)

# TOC

* [Requirements](#requirements)
* [Before deployment](#before-deployment)
* [Minimal content for deployment](#minimal-content-for-deployment)
* [After deployment](#after-deployment)
* [Create an EMR Serverless application](#create-an-emr-serverless-app)
* [Check the executing job](#check-the-executing-job)
* [Check results from an EMR notebook via cluster template](#check-results-from-an-emr-notebook-via-cluster-template)
* [Fun facts](#fun-facts)
* [Future work](#future-work)

# Requirements

1. Your current identity has the `AdministratorAccess` power.
2. [An IAM user](https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html) named `Administrator` with the `AdministratorAccess` power.

   * This is related to the Portfolio of AWS Service Catalog created by the construct, which is required for [EMR cluster tempaltes](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-cluster-templates.html).
   * You can choose whatsoever identity you wish to associate with the Product in the Porfolio for creating an EMR cluster via cluster tempalte. Check `serviceCatalogProps` in the `EmrServerless` construct for detail, otherwise, the IAM user mentioned above will be chosen to set up with the Product.

# Before deployment

You might want to execute the following command.

```sh
PROFILE_NAME="scott.hsieh"
# If you only have one credentials on your local machine, just ignore `--profile`, buddy.
cdk bootstrap aws://${AWS_ACCOUNT_ID}/${AWS_REGION} --profile ${PROFILE_NAME}
```

# Minimal content for deployment

```python
#!/usr/bin/env node
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { EmrServerless } from 'cdk-emrserverless-with-delta-lake';

class TypescriptStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);
    new EmrServerless(this, 'EmrServerless');
  }
}

const app = new cdk.App();
new TypescriptStack(app, 'TypescriptStack', {
  stackName: 'emr-studio',
  env: {
    region: process.env.CDK_DEFAULT_REGION,
    account: process.env.CDK_DEFAULT_ACCOUNT,
  },
});
```

# After deployment

Promise me, darling, make advantage on the CloudFormation outputs.  All you need is **copy-paste**, **copy-paste**, **copy-paste**, life should be always that easy.
![cfn outputs](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/cfn-outputs.png)

1. **Define the following environment variables on your current session.**

   ```
   export PROFILE_NAME="${YOUR_PROFILE_NAME}"
   export JOB_ROLE_ARN="${copy-paste-thank-you}"
   export APPLICATION_ID="${copy-paste-thank-you}"
   export SERVERLESS_BUCKET_NAME="${copy-paste-thank-you}"
   export DELTA_LAKE_SCRIPT_NAME="delta-lake-demo"
   ```
2. **Copy partial NYC-taxi data into the EMR Serverless bucket.**

   ```sh
   aws s3 cp s3://nyc-tlc/trip\ data/ s3://${SERVERLESS_BUCKET_NAME}/nyc-taxi/ --exclude "*" --include "yellow_tripdata_2021-*.parquet" --recursive --profile ${PROFILE_NAME}
   ```
3. **Create a Python script for processing Delta Lake**

   ```sh
   touch ${DELTA_LAKE_SCRIPT_NAME}.py
   cat << EOF > ${DELTA_LAKE_SCRIPT_NAME}.py
   from pyspark.sql import SparkSession
   import uuid

   if __name__ == "__main__":
       """
           Delta Lake with EMR Serverless, take NYC taxi as example.
       """
       spark = SparkSession \\
           .builder \\
           .config("spark.sql.extensions", "io.delta.sql.DeltaSparkSessionExtension") \\
           .config("spark.sql.catalog.spark_catalog", "org.apache.spark.sql.delta.catalog.DeltaCatalog") \\
           .enableHiveSupport() \\
           .appName("Delta-Lake-OSS") \\
           .getOrCreate()

       url = "s3://${SERVERLESS_BUCKET_NAME}/emr-serverless-spark/delta-lake/output/1.2.1/%s/" % str(
           uuid.uuid4())

       # creates a Delta table and outputs to target S3 bucket
       spark.range(5).write.format("delta").save(url)

       # reads a Delta table and outputs to target S3 bucket
       spark.read.format("delta").load(url).show()

       # The source for the second Delta table.
       base = spark.read.parquet(
           "s3://${SERVERLESS_BUCKET_NAME}/nyc-taxi/*.parquet")

       # The sceond Delta table, oh ya.
       base.write.format("delta") \\
           .mode("overwrite") \\
           .save("s3://${SERVERLESS_BUCKET_NAME}/emr-serverless-spark/delta-lake/nyx-tlc-2021")
       spark.stop()
   EOF
   ```
4. **Upload the script and required jars into the serverless bucket**

   ```sh
   # upload script
   aws s3 cp delta-lake-demo.py s3://${SERVERLESS_BUCKET_NAME}/scripts/${DELTA_LAKE_SCRIPT_NAME}.py --profile ${PROFILE_NAME}
   # download jars and upload them
   DELTA_VERSION="3.0.0"
   DELTA_LAKE_CORE="delta-spark_2.13-${DELTA_VERSION}.jar"
   DELTA_LAKE_STORAGE="delta-storage-${DELTA_VERSION}.jar"
   curl https://repo1.maven.org/maven2/io/delta/delta-spark_2.13/${DELTA_VERSION}/${DELTA_LAKE_CORE} --output ${DELTA_LAKE_CORE}
   curl https://repo1.maven.org/maven2/io/delta/delta-storage/${DELTA_VERSION}/${DELTA_LAKE_STORAGE} --output ${DELTA_LAKE_STORAGE}
   aws s3 mv ${DELTA_LAKE_CORE} s3://${SERVERLESS_BUCKET_NAME}/jars/${DELTA_LAKE_CORE} --profile ${PROFILE_NAME}
   aws s3 mv ${DELTA_LAKE_STORAGE} s3://${SERVERLESS_BUCKET_NAME}/jars/${DELTA_LAKE_STORAGE} --profile ${PROFILE_NAME}
   ```

# Create an EMR Serverless app

Rememeber, you got so much information to copy and paste from the CloudFormation outputs.
![cfn outputs](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/cfn-outputs.png)

```sh
aws emr-serverless start-job-run \
  --application-id ${APPLICATION_ID} \
  --execution-role-arn ${JOB_ROLE_ARN} \
  --name 'shy-shy-first-time' \
  --job-driver '{
        "sparkSubmit": {
            "entryPoint": "s3://'${SERVERLESS_BUCKET_NAME}'/scripts/'${DELTA_LAKE_SCRIPT_NAME}'.py",
            "sparkSubmitParameters": "--conf spark.executor.cores=1 --conf spark.executor.memory=4g --conf spark.driver.cores=1 --conf spark.driver.memory=4g --conf spark.executor.instances=1 --conf spark.jars=s3://'${SERVERLESS_BUCKET_NAME}'/jars/'${DELTA_LAKE_CORE}',s3://'${SERVERLESS_BUCKET_NAME}'/jars/'${DELTA_LAKE_STORAGE}'"
        }
    }' \
  --configuration-overrides '{
        "monitoringConfiguration": {
            "s3MonitoringConfiguration": {
                "logUri": "s3://'${SERVERLESS_BUCKET_NAME}'/serverless-log/"
	        }
	    }
	}' \
	--profile ${PROFILE_NAME}
```

If you execute with success, you should see similar reponse as the following:

```sh
{
    "applicationId": "00f1gvklchoqru25",
    "jobRunId": "00f1h0ipd2maem01",
    "arn": "arn:aws:emr-serverless:ap-northeast-1:630778274080:/applications/00f1gvklchoqru25/jobruns/00f1h0ipd2maem01"
}
```

and got a Delta Lake data under `s3://${SERVERLESS_BUCKET_NAME}/emr-serverless-spark/delta-lake/nyx-tlc-2021/`.
![Delta Lake data](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/delta%20lake%20data.png)

# Check the executing job

Access the EMR Studio via the URL from the CloudFormation outputs. It should look very similar to the following url: `https://es-pilibalapilibala.emrstudio-prod.ap-northeast-1.amazonaws.com`, i.e., weird string and region won't be the same as mine.

1. **Enter into the application**
   ![enter into the app](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/enter-serverless-app.png)
2. **Enter into the executing job**

# Check results from an EMR notebook via cluster template

1. Create a workspace and an EMR cluster via the cluster template on the AWS Console
   ![create workspace](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/create%20workspace.png)
2. Check the results delivered by the EMR serverless application via an EMR notebook.

# Fun facts

1. You can assign multiple jars as a comma-separated list to the `spark.jars` as [the Spark page](https://spark.apache.org/docs/latest/configuration.html#runtime-environment) says for your EMR Serverless job. The UI will complain, you still can start the job. Don't be afraid, just click it like when you were child, facing authority fearlessly.
   ![ui bug](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/ui-bug.png)
2. To fully delet a stack with the construct, you need to make sure there is no more workspace within the EMR Studio. Aside from that, you also need to remove the associated identity from the Service Catalog (this is a necessary resource for the cluster template).
3. Version inconsistency on Spark history. Possibly it can be ignored yet still made me wonder why the versions are different.
   ![naughty inconsistency](https://raw.githubusercontent.com/HsiehShuJeng/cdk-emrserverless-with-delta-lake/main/images/Spark%20history.png)
4. So far, I still haven't figured out how to make the s3a URI work. The s3 URI is fine while the serverless app will complain that it couldn't find proper credentials provider to read the s3a URI.

# Future work

1. Custom resuorce for EMR Serverless
2. Make the construct more flexible for users
3. Compare Databricks Runtime and EMR Serverless.
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
import aws_cdk.aws_emr as _aws_cdk_aws_emr_ceddda9d
import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
import aws_cdk.aws_lambda as _aws_cdk_aws_lambda_ceddda9d
import aws_cdk.aws_s3 as _aws_cdk_aws_s3_ceddda9d
import aws_cdk.aws_servicecatalog as _aws_cdk_aws_servicecatalog_ceddda9d
import constructs as _constructs_77d1e7e8


class EmrClusterTemplateStack(
    _aws_cdk_aws_servicecatalog_ceddda9d.ProductStack,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrClusterTemplateStack",
):
    '''Creates a CloudFormation template which will be a Product under a Portfolio of AWS Service Catalog.

    This is for creating an EMR cluster via cluster template in the EMR Studio, created by the ``EmrServerless`` construct, on the AWS Console.

    And you don't have control via the ``EmrServerless`` construct by now. The documentation is for you to grasp the architecture of the ``EmrServerless`` more easily.

    For detail, please refer to `Create AWS CloudFormation templates for Amazon EMR Studio <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-cluster-templates.html>`_::

       const product = new servicecatalog.CloudFormationProduct(this, 'MyFirstProduct', {
          productName: 'EMR_6.6.0',
          owner: 'scott.hsieh',
          description: 'EMR cluster with 6.6.0 version',
          productVersions: [
            {
              productVersionName: 'v1',
              validateTemplate: true,
              cloudFormationTemplate: servicecatalog.CloudFormationTemplate.fromProductStack(new EmrClusterTemplateStack(this, 'EmrStudio')),
            },
       ],
       });
    '''

    def __init__(self, scope: _constructs_77d1e7e8.Construct, id: builtins.str) -> None:
        '''
        :param scope: -
        :param id: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b40d8d3575864a15feaf0e04d730dd2c31d40763b0fcc93a79b2a11853a34169)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        jsii.create(self.__class__, self, [scope, id])


class EmrServerless(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrServerless",
):
    '''Creates an EMR Studio, an EMR cluster template for the studio, and an EMR Serverless application.

    Example::

       // the quickiest deployment
       new EmrServerless(this, 'EmrServerless');

       // custom deployment references
       new EmrServerless(this, 'EmrServerless', {
          vpcId: 'vpc-idididid',
       });

       new EmrServerless(this, 'EmrServerless', {
          vpcId: 'vpc-idididid',
          subnetIds: ['subnet-eeeee', 'subnet-fffff']
       });

       const myRole = new iam.Role.fromRoleName('MyRole');
       new EmrServerless(this, 'EmrServerless', {
          serviceCatalogProps: {
              role: myRole
          }
       });

       const myUser = new iam.Role.fromUserName('MyUser');
       new EmrServerless(this, 'EmrServerless', {
          vpcId: 'vpc-idididid',
          subnetIds: ['subnet-eeeee', 'subnet-fffff'],
          serviceCatalogProps: {
              user: myUser
          }
       });

       const myGroup = new iam.Group.fromGroupName('MyGroup');
       new EmrServerless(this, 'EmrServerless', {
          serviceCatalogProps: {
              group: myGroup
          }
       });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        service_catalog_props: typing.Optional[typing.Union["EmrStudioDeveloperStackProps", typing.Dict[builtins.str, typing.Any]]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param service_catalog_props: Options for which kind of identity will be associated with the Product of the Porfolio in AWS Service Catalog for EMR cluster templates. You can choose either an IAM group, IAM role, or IAM user. If you leave it empty, an IAM user named ``Administrator`` with the ``AdministratorAccess`` power needs to be created first.
        :param subnet_ids: The subnet IDs for the EMR studio. You can select the subnets from the default VPC in your AWS account.
        :param vpc_id: Used by the EMR Studio. Default: - 'The default VPC will be used.'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90f6dce837ed6875380209d49b66583583fb9de6773398eb7ef9da8c4dd2080b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrServerlessProps(
            service_catalog_props=service_catalog_props,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )

        jsii.create(self.__class__, self, [scope, name, props])


class EmrServerlessBucket(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrServerlessBucket",
):
    '''Creates a bucket for EMR Serverless applications.

    Example::

       const emrServerlessBucket = new EmrServerlessBucket(this, 'EmrServerless');
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        bucket_name: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param bucket_name: The bucket name for EMR Serverless applications. Default: - 'emr-serverless-AWS::AccountId'
        :param removal_policy: Policy to apply when the bucket is removed from this stack. Default: - The bucket will be deleted.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be9cf64c6fec85d3275f91bf9201f245024e9fedcf42c5ad93293b6a2f7d17d7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrServerlessBucketProps(
            bucket_name=bucket_name, removal_policy=removal_policy
        )

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="bucketEntity")
    def bucket_entity(self) -> _aws_cdk_aws_s3_ceddda9d.Bucket:
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.Bucket, jsii.get(self, "bucketEntity"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrServerlessBucketProps",
    jsii_struct_bases=[],
    name_mapping={"bucket_name": "bucketName", "removal_policy": "removalPolicy"},
)
class EmrServerlessBucketProps:
    def __init__(
        self,
        *,
        bucket_name: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    ) -> None:
        '''Properties for the EMR Serverless bucket.

        :param bucket_name: The bucket name for EMR Serverless applications. Default: - 'emr-serverless-AWS::AccountId'
        :param removal_policy: Policy to apply when the bucket is removed from this stack. Default: - The bucket will be deleted.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__527518165642dd620d0cdb844cbf5b6f00640db3b7e36db22d6b3b4509609445)
            check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bucket_name is not None:
            self._values["bucket_name"] = bucket_name
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy

    @builtins.property
    def bucket_name(self) -> typing.Optional[builtins.str]:
        '''The bucket name for EMR Serverless applications.

        :default: - 'emr-serverless-AWS::AccountId'
        '''
        result = self._values.get("bucket_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy]:
        '''Policy to apply when the bucket is removed from this stack.

        :default: - The bucket will be deleted.
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrServerlessBucketProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrServerlessProps",
    jsii_struct_bases=[],
    name_mapping={
        "service_catalog_props": "serviceCatalogProps",
        "subnet_ids": "subnetIds",
        "vpc_id": "vpcId",
    },
)
class EmrServerlessProps:
    def __init__(
        self,
        *,
        service_catalog_props: typing.Optional[typing.Union["EmrStudioDeveloperStackProps", typing.Dict[builtins.str, typing.Any]]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param service_catalog_props: Options for which kind of identity will be associated with the Product of the Porfolio in AWS Service Catalog for EMR cluster templates. You can choose either an IAM group, IAM role, or IAM user. If you leave it empty, an IAM user named ``Administrator`` with the ``AdministratorAccess`` power needs to be created first.
        :param subnet_ids: The subnet IDs for the EMR studio. You can select the subnets from the default VPC in your AWS account.
        :param vpc_id: Used by the EMR Studio. Default: - 'The default VPC will be used.'
        '''
        if isinstance(service_catalog_props, dict):
            service_catalog_props = EmrStudioDeveloperStackProps(**service_catalog_props)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d8dd0945f913a2b553b1a9bd9d986479072d68d10576fd1e4e2d59ffc2930ec)
            check_type(argname="argument service_catalog_props", value=service_catalog_props, expected_type=type_hints["service_catalog_props"])
            check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_catalog_props is not None:
            self._values["service_catalog_props"] = service_catalog_props
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def service_catalog_props(self) -> typing.Optional["EmrStudioDeveloperStackProps"]:
        '''Options for which kind of identity will be associated with the Product of the Porfolio in AWS Service Catalog for EMR cluster templates.

        You can choose either an IAM group, IAM role, or IAM user. If you leave it empty, an IAM user named ``Administrator`` with the ``AdministratorAccess`` power needs to be created first.
        '''
        result = self._values.get("service_catalog_props")
        return typing.cast(typing.Optional["EmrStudioDeveloperStackProps"], result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The subnet IDs for the EMR studio.

        You can select the subnets from the default VPC in your AWS account.
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''Used by the EMR Studio.

        :default: - 'The default VPC will be used.'
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrServerlessProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrStudio(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudio",
):
    '''Creates an EMR Studio for EMR Serverless applications.

    The Studio is not only for EMR Serverless applications but also for launching an EMR cluster via a cluster template created in this constrcut to check out results transformed by EMR serverless applications.

    For what Studio can do further, please refer to `Amazon EMR Studio <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio.html>`_::

       const workspaceBucket = new WorkSpaceBucket(this, 'EmrStudio');
       const emrStudio = new EmrStudio(this, '', {
          workSpaceBucket: workspaceBucket,
          subnetIds: ['subnet1', 'subnet2', 'subnet3']
       });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        work_space_bucket: "WorkSpaceBucket",
        auth_mode: typing.Optional["StudioAuthMode"] = None,
        description: typing.Optional[builtins.str] = None,
        engine_security_group_id: typing.Optional[builtins.str] = None,
        service_catalog_props: typing.Optional[typing.Union["EmrStudioDeveloperStackProps", typing.Dict[builtins.str, typing.Any]]] = None,
        service_role_arn: typing.Optional[builtins.str] = None,
        service_role_name: typing.Optional[builtins.str] = None,
        studio_name: typing.Optional[builtins.str] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_role_arn: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        work_space_security_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param work_space_bucket: The custom construct as the workspace S3 bucket.
        :param auth_mode: Specifies whether the Studio authenticates users using AWS SSO or IAM. Default: - StudioAuthMode.AWS_IAM.
        :param description: A detailed description of the Amazon EMR Studio. Default: - 'EMR Studio Quick Launch - by scott.hsieh'
        :param engine_security_group_id: The ID of the Amazon EMR Studio Engine security group. The Engine security group allows inbound network traffic from the Workspace security group, and it must be in the same VPC specified by VpcId. Default: - a security group created by ``EmrStudioEngineSecurityGroup``.
        :param service_catalog_props: Options for which kind of identity will be associated with the Product of the Porfolio in AWS Service Catalog for EMR cluster templates. You can choose either an IAM group, IAM role, or IAM user. If you leave it empty, an IAM user named ``Administrator`` with the ``AdministratorAccess`` power needs to be created first.
        :param service_role_arn: 
        :param service_role_name: A name for the service role of an EMR Studio. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - 'emr-studio-service-role'
        :param studio_name: A descriptive name for the Amazon EMR Studio. Default: - 'emr-sutdio-quicklaunch'
        :param subnet_ids: The subnet IDs for the EMR studio. You can select the subnets from the default VPC in your AWS account.
        :param user_role_arn: The custom user role for the EMR Studio when authentication is AWS SSO. Currently, if you choose to establish an EMR serverless application where the authentication mechanism used by the EMR Studio is AWS SSO, you need to create a user role by yourself and assign the role arn to this argument if AWS SSO is chosen as authentication for the EMR Studio;
        :param vpc_id: Used by the EMR Studio. Default: - 'The default VPC will be used.'
        :param work_space_security_group_id: The ID of the security group used by the workspace. Default: - a security group created by ``EmrStudioWorkspaceSecurityGroup``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf467b28d0b83b0ef8c3bbd6137b0929253236b4088d2b67500feac8061ecbf1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrStudioProps(
            work_space_bucket=work_space_bucket,
            auth_mode=auth_mode,
            description=description,
            engine_security_group_id=engine_security_group_id,
            service_catalog_props=service_catalog_props,
            service_role_arn=service_role_arn,
            service_role_name=service_role_name,
            studio_name=studio_name,
            subnet_ids=subnet_ids,
            user_role_arn=user_role_arn,
            vpc_id=vpc_id,
            work_space_security_group_id=work_space_security_group_id,
        )

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="entity")
    def entity(self) -> _aws_cdk_aws_emr_ceddda9d.CfnStudio:
        return typing.cast(_aws_cdk_aws_emr_ceddda9d.CfnStudio, jsii.get(self, "entity"))


class EmrStudioDeveloperStack(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioDeveloperStack",
):
    '''Creates a Service Catalog for EMR cluster templates.

    For detail, please refer to `Create AWS CloudFormation templates for Amazon EMR Studio <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-cluster-templates.html>`_::

       const emrClusterTemplatePortfolio = new EmrStudioDeveloperStack(this, 'ClusterTempalte');
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        group: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IGroup] = None,
        provider_name: typing.Optional[builtins.str] = None,
        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        user: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IUser] = None,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param group: an IAM group you wish to associate with the Portfolio for EMR cluster template.
        :param provider_name: The provider name in a Service Catalog for EMR cluster templates. Default: - 'scott.hsieh'
        :param role: an IAM role you wish to associate with the Portfolio for EMR cluster template.
        :param user: an IAM user you wish to associate with the Portfolio for EMR cluster template.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18d8abb489569c20860e9601cc71ca861c32e1136c1e2fa21dd6db0cfe1f4948)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrStudioDeveloperStackProps(
            group=group, provider_name=provider_name, role=role, user=user
        )

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="portfolio")
    def portfolio(self) -> _aws_cdk_aws_servicecatalog_ceddda9d.Portfolio:
        '''The representative of the service catalog for EMR cluster tempaltes.'''
        return typing.cast(_aws_cdk_aws_servicecatalog_ceddda9d.Portfolio, jsii.get(self, "portfolio"))

    @builtins.property
    @jsii.member(jsii_name="product")
    def product(self) -> _aws_cdk_aws_servicecatalog_ceddda9d.Product:
        '''The representative of the product for demo purpose.'''
        return typing.cast(_aws_cdk_aws_servicecatalog_ceddda9d.Product, jsii.get(self, "product"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioDeveloperStackProps",
    jsii_struct_bases=[],
    name_mapping={
        "group": "group",
        "provider_name": "providerName",
        "role": "role",
        "user": "user",
    },
)
class EmrStudioDeveloperStackProps:
    def __init__(
        self,
        *,
        group: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IGroup] = None,
        provider_name: typing.Optional[builtins.str] = None,
        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        user: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IUser] = None,
    ) -> None:
        '''Interface for Service Catalog of EMR cluster templates.

        :param group: an IAM group you wish to associate with the Portfolio for EMR cluster template.
        :param provider_name: The provider name in a Service Catalog for EMR cluster templates. Default: - 'scott.hsieh'
        :param role: an IAM role you wish to associate with the Portfolio for EMR cluster template.
        :param user: an IAM user you wish to associate with the Portfolio for EMR cluster template.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8befc3c14062038bb7e027d763ab0589b2b3ab4f5724371cf8de08abb7b3d9fc)
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument provider_name", value=provider_name, expected_type=type_hints["provider_name"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if group is not None:
            self._values["group"] = group
        if provider_name is not None:
            self._values["provider_name"] = provider_name
        if role is not None:
            self._values["role"] = role
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def group(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IGroup]:
        '''an IAM group you wish to associate with the Portfolio for EMR cluster template.'''
        result = self._values.get("group")
        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IGroup], result)

    @builtins.property
    def provider_name(self) -> typing.Optional[builtins.str]:
        '''The provider name in a Service Catalog for EMR cluster templates.

        :default: - 'scott.hsieh'
        '''
        result = self._values.get("provider_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
        '''an IAM role you wish to associate with the Portfolio for EMR cluster template.'''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)

    @builtins.property
    def user(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IUser]:
        '''an IAM user you wish to associate with the Portfolio for EMR cluster template.'''
        result = self._values.get("user")
        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IUser], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrStudioDeveloperStackProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrStudioEngineSecurityGroup(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioEngineSecurityGroup",
):
    '''Created an engine security group for EMR notebooks.

    For detail, plrease refer to `Engine security group <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-security-groups.html#emr-studio-security-group-instructions>`_::

       const workSpaceSecurityGroup = new EmrStudioWorkspaceSecurityGroup(this, 'Workspace', { vpc: baseVpc });
       const engineSecurityGroup = new EmrStudioEngineSecurityGroup(this, 'Engine', { vpc: baseVpc });
       workSpaceSecurityGroup.entity.connections.allowTo(engineSecurityGroup.entity, ec2.Port.tcp(18888), 'Allow traffic to any resources in the Engine security group for EMR Studio.');
       workSpaceSecurityGroup.entity.addEgressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), 'Allow traffic to the internet to link publicly hosted Git repositories to Workspaces.');
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param vpc: The VPC in which to create the engine security group for EMR Studio. Default: - default VPC in an AWS account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cba1dcbacc62cb64b43f6ad633c938ee772c9e83d748eea57962286776a8925e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrStudioEngineSecurityGroupProps(vpc=vpc)

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="entity")
    def entity(self) -> _aws_cdk_aws_ec2_ceddda9d.SecurityGroup:
        '''The representative of the security group as the EMR Studio engine security group.'''
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SecurityGroup, jsii.get(self, "entity"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioEngineSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={"vpc": "vpc"},
)
class EmrStudioEngineSecurityGroupProps:
    def __init__(self, *, vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc) -> None:
        '''Interface for engine security group of EMR Studio.

        :param vpc: The VPC in which to create the engine security group for EMR Studio. Default: - default VPC in an AWS account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb566bde060b5245e75b74d32abf8fa15cccfdbf988b90b36228dba8a3251a07)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
        }

    @builtins.property
    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
        '''The VPC in which to create the engine security group for EMR Studio.

        :default: - default VPC in an AWS account.
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrStudioEngineSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioProps",
    jsii_struct_bases=[],
    name_mapping={
        "work_space_bucket": "workSpaceBucket",
        "auth_mode": "authMode",
        "description": "description",
        "engine_security_group_id": "engineSecurityGroupId",
        "service_catalog_props": "serviceCatalogProps",
        "service_role_arn": "serviceRoleArn",
        "service_role_name": "serviceRoleName",
        "studio_name": "studioName",
        "subnet_ids": "subnetIds",
        "user_role_arn": "userRoleArn",
        "vpc_id": "vpcId",
        "work_space_security_group_id": "workSpaceSecurityGroupId",
    },
)
class EmrStudioProps:
    def __init__(
        self,
        *,
        work_space_bucket: "WorkSpaceBucket",
        auth_mode: typing.Optional["StudioAuthMode"] = None,
        description: typing.Optional[builtins.str] = None,
        engine_security_group_id: typing.Optional[builtins.str] = None,
        service_catalog_props: typing.Optional[typing.Union[EmrStudioDeveloperStackProps, typing.Dict[builtins.str, typing.Any]]] = None,
        service_role_arn: typing.Optional[builtins.str] = None,
        service_role_name: typing.Optional[builtins.str] = None,
        studio_name: typing.Optional[builtins.str] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_role_arn: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        work_space_security_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options for the EMR Studio, mainly for EMR Serverless applications.

        :param work_space_bucket: The custom construct as the workspace S3 bucket.
        :param auth_mode: Specifies whether the Studio authenticates users using AWS SSO or IAM. Default: - StudioAuthMode.AWS_IAM.
        :param description: A detailed description of the Amazon EMR Studio. Default: - 'EMR Studio Quick Launch - by scott.hsieh'
        :param engine_security_group_id: The ID of the Amazon EMR Studio Engine security group. The Engine security group allows inbound network traffic from the Workspace security group, and it must be in the same VPC specified by VpcId. Default: - a security group created by ``EmrStudioEngineSecurityGroup``.
        :param service_catalog_props: Options for which kind of identity will be associated with the Product of the Porfolio in AWS Service Catalog for EMR cluster templates. You can choose either an IAM group, IAM role, or IAM user. If you leave it empty, an IAM user named ``Administrator`` with the ``AdministratorAccess`` power needs to be created first.
        :param service_role_arn: 
        :param service_role_name: A name for the service role of an EMR Studio. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - 'emr-studio-service-role'
        :param studio_name: A descriptive name for the Amazon EMR Studio. Default: - 'emr-sutdio-quicklaunch'
        :param subnet_ids: The subnet IDs for the EMR studio. You can select the subnets from the default VPC in your AWS account.
        :param user_role_arn: The custom user role for the EMR Studio when authentication is AWS SSO. Currently, if you choose to establish an EMR serverless application where the authentication mechanism used by the EMR Studio is AWS SSO, you need to create a user role by yourself and assign the role arn to this argument if AWS SSO is chosen as authentication for the EMR Studio;
        :param vpc_id: Used by the EMR Studio. Default: - 'The default VPC will be used.'
        :param work_space_security_group_id: The ID of the security group used by the workspace. Default: - a security group created by ``EmrStudioWorkspaceSecurityGroup``.
        '''
        if isinstance(service_catalog_props, dict):
            service_catalog_props = EmrStudioDeveloperStackProps(**service_catalog_props)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8ece76aa21839d16748f809f90cab63e03a42228d610516462560602d4b3c33)
            check_type(argname="argument work_space_bucket", value=work_space_bucket, expected_type=type_hints["work_space_bucket"])
            check_type(argname="argument auth_mode", value=auth_mode, expected_type=type_hints["auth_mode"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument engine_security_group_id", value=engine_security_group_id, expected_type=type_hints["engine_security_group_id"])
            check_type(argname="argument service_catalog_props", value=service_catalog_props, expected_type=type_hints["service_catalog_props"])
            check_type(argname="argument service_role_arn", value=service_role_arn, expected_type=type_hints["service_role_arn"])
            check_type(argname="argument service_role_name", value=service_role_name, expected_type=type_hints["service_role_name"])
            check_type(argname="argument studio_name", value=studio_name, expected_type=type_hints["studio_name"])
            check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            check_type(argname="argument user_role_arn", value=user_role_arn, expected_type=type_hints["user_role_arn"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument work_space_security_group_id", value=work_space_security_group_id, expected_type=type_hints["work_space_security_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "work_space_bucket": work_space_bucket,
        }
        if auth_mode is not None:
            self._values["auth_mode"] = auth_mode
        if description is not None:
            self._values["description"] = description
        if engine_security_group_id is not None:
            self._values["engine_security_group_id"] = engine_security_group_id
        if service_catalog_props is not None:
            self._values["service_catalog_props"] = service_catalog_props
        if service_role_arn is not None:
            self._values["service_role_arn"] = service_role_arn
        if service_role_name is not None:
            self._values["service_role_name"] = service_role_name
        if studio_name is not None:
            self._values["studio_name"] = studio_name
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if user_role_arn is not None:
            self._values["user_role_arn"] = user_role_arn
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if work_space_security_group_id is not None:
            self._values["work_space_security_group_id"] = work_space_security_group_id

    @builtins.property
    def work_space_bucket(self) -> "WorkSpaceBucket":
        '''The custom construct as the workspace S3 bucket.'''
        result = self._values.get("work_space_bucket")
        assert result is not None, "Required property 'work_space_bucket' is missing"
        return typing.cast("WorkSpaceBucket", result)

    @builtins.property
    def auth_mode(self) -> typing.Optional["StudioAuthMode"]:
        '''Specifies whether the Studio authenticates users using AWS SSO or IAM.

        :default: - StudioAuthMode.AWS_IAM.
        '''
        result = self._values.get("auth_mode")
        return typing.cast(typing.Optional["StudioAuthMode"], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A detailed description of the Amazon EMR Studio.

        :default: - 'EMR Studio Quick Launch - by scott.hsieh'
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Amazon EMR Studio Engine security group.

        The Engine security group allows inbound network traffic from the Workspace security group, and it must be in the same VPC specified by VpcId.

        :default: - a security group created by ``EmrStudioEngineSecurityGroup``.
        '''
        result = self._values.get("engine_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_catalog_props(self) -> typing.Optional[EmrStudioDeveloperStackProps]:
        '''Options for which kind of identity will be associated with the Product of the Porfolio in AWS Service Catalog for EMR cluster templates.

        You can choose either an IAM group, IAM role, or IAM user. If you leave it empty, an IAM user named ``Administrator`` with the ``AdministratorAccess`` power needs to be created first.
        '''
        result = self._values.get("service_catalog_props")
        return typing.cast(typing.Optional[EmrStudioDeveloperStackProps], result)

    @builtins.property
    def service_role_arn(self) -> typing.Optional[builtins.str]:
        result = self._values.get("service_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_role_name(self) -> typing.Optional[builtins.str]:
        '''A name for the service role of an EMR Studio.

        For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference.

        IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.

        If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates.

        :default: - 'emr-studio-service-role'
        '''
        result = self._values.get("service_role_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def studio_name(self) -> typing.Optional[builtins.str]:
        '''A descriptive name for the Amazon EMR Studio.

        :default: - 'emr-sutdio-quicklaunch'
        '''
        result = self._values.get("studio_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The subnet IDs for the EMR studio.

        You can select the subnets from the default VPC in your AWS account.
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def user_role_arn(self) -> typing.Optional[builtins.str]:
        '''The custom user role for the EMR Studio when authentication is AWS SSO.

        Currently, if you choose to establish an EMR serverless application where the authentication mechanism used by the EMR Studio is AWS SSO, you need to create a user role by yourself and assign the role arn to this argument if AWS SSO is chosen as authentication for the EMR Studio;

        :link: https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-user-permissions.html
        '''
        result = self._values.get("user_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''Used by the EMR Studio.

        :default: - 'The default VPC will be used.'
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def work_space_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group used by the workspace.

        :default: - a security group created by ``EmrStudioWorkspaceSecurityGroup``.
        '''
        result = self._values.get("work_space_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrStudioProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrStudioServiceRole(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioServiceRole",
):
    '''Creates a default service role for an EMR Studio.

    For detail, please refer to `Create an EMR Studio service role <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-service-role.html>`_::

       const workSpaceBucket = new WorkSpaceBucket(this, 'WorkSpace');
       const emrStudioServiceRole = new EmrStudioServiceRole(this, 'Service', {
            workSpaceBucket: workSpaceBucket
       });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        work_space_bucket: "WorkSpaceBucket",
        role_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param work_space_bucket: The custom construct as the workspace S3 bucket.
        :param role_name: A name for the service role of an EMR Studio. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - 'emr-studio-service-role'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fe737c319b0cc5d63a781dad02941734c5bb864b1c3945d442fd84304460375)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrStudioServiceRoleProps(
            work_space_bucket=work_space_bucket, role_name=role_name
        )

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="roleEntity")
    def role_entity(self) -> _aws_cdk_aws_iam_ceddda9d.Role:
        '''The representative of the default service role for EMR Studio.'''
        return typing.cast(_aws_cdk_aws_iam_ceddda9d.Role, jsii.get(self, "roleEntity"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioServiceRoleProps",
    jsii_struct_bases=[],
    name_mapping={"work_space_bucket": "workSpaceBucket", "role_name": "roleName"},
)
class EmrStudioServiceRoleProps:
    def __init__(
        self,
        *,
        work_space_bucket: "WorkSpaceBucket",
        role_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining the `service role <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-service-role.html>`_ of an EMR Studio.

        :param work_space_bucket: The custom construct as the workspace S3 bucket.
        :param role_name: A name for the service role of an EMR Studio. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - 'emr-studio-service-role'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5b13bb7c5bf8d9d00f324aeeff6c02c78ab6ae3d6d3b2d6d29da649f1e034ff)
            check_type(argname="argument work_space_bucket", value=work_space_bucket, expected_type=type_hints["work_space_bucket"])
            check_type(argname="argument role_name", value=role_name, expected_type=type_hints["role_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "work_space_bucket": work_space_bucket,
        }
        if role_name is not None:
            self._values["role_name"] = role_name

    @builtins.property
    def work_space_bucket(self) -> "WorkSpaceBucket":
        '''The custom construct as the workspace S3 bucket.'''
        result = self._values.get("work_space_bucket")
        assert result is not None, "Required property 'work_space_bucket' is missing"
        return typing.cast("WorkSpaceBucket", result)

    @builtins.property
    def role_name(self) -> typing.Optional[builtins.str]:
        '''A name for the service role of an EMR Studio.

        For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference.

        IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.

        If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates.

        :default: - 'emr-studio-service-role'
        '''
        result = self._values.get("role_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrStudioServiceRoleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrStudioTaggingExpert(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioTaggingExpert",
):
    '''Creates a Lambda function for the custom resource which can add necessary tag onto the VPC and subnets for the EMR Studio during deployment.

    For detail on the tag, please refer to `How to create a service role for EMR Studio <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-service-role.html#emr-studio-service-role-instructions>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be4d8890c648405923432108734725ae787a93d2173731e1df5562a6d1f01ae9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        jsii.create(self.__class__, self, [scope, name])

    @builtins.property
    @jsii.member(jsii_name="functionEntity")
    def function_entity(self) -> _aws_cdk_aws_lambda_ceddda9d.Function:
        '''The repesentative of the Lambda function for the custom resource which can add necessary tag onto the VPC and subnets for the EMR Studio during deployment.'''
        return typing.cast(_aws_cdk_aws_lambda_ceddda9d.Function, jsii.get(self, "functionEntity"))


class EmrStudioWorkspaceSecurityGroup(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioWorkspaceSecurityGroup",
):
    '''Created a workspace security group for EMR Studio.

    For detail, plrease refer to `Workspace security group <https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-studio-security-groups.html#emr-studio-security-group-instructions>`_::

       const workSpaceSecurityGroup = new EmrStudioWorkspaceSecurityGroup(this, 'Workspace', { vpc: baseVpc });
       const engineSecurityGroup = new EmrStudioEngineSecurityGroup(this, 'Engine', { vpc: baseVpc });
       workSpaceSecurityGroup.entity.connections.allowTo(engineSecurityGroup.entity, ec2.Port.tcp(18888), 'Allow traffic to any resources in the Engine security group for EMR Studio.');
       workSpaceSecurityGroup.entity.addEgressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), 'Allow traffic to the internet to link publicly hosted Git repositories to Workspaces.');
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param vpc: The VPC in which to create workspace security group for EMR Studio. Default: - default VPC in an AWS account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea0ce2ebd9ab5f0c7482e304f847584719e5c90f541705a5043c7d4f19cdbf22)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = EmrStudioWorkspaceSecurityGroupProps(vpc=vpc)

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="entity")
    def entity(self) -> _aws_cdk_aws_ec2_ceddda9d.SecurityGroup:
        '''The representative of the security group as the EMR Studio workspace security group.'''
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SecurityGroup, jsii.get(self, "entity"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.EmrStudioWorkspaceSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={"vpc": "vpc"},
)
class EmrStudioWorkspaceSecurityGroupProps:
    def __init__(self, *, vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc) -> None:
        '''Interface for workspace security group of EMR Studio.

        :param vpc: The VPC in which to create workspace security group for EMR Studio. Default: - default VPC in an AWS account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61af5b98618f8d5355200cca09b6cac20052d7eeecb1647a3c9dafd9a9c37451)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
        }

    @builtins.property
    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
        '''The VPC in which to create workspace security group for EMR Studio.

        :default: - default VPC in an AWS account.
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrStudioWorkspaceSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ServerlessJobRole(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.ServerlessJobRole",
):
    '''Creates an execution job role for EMR Serverless.

    For detail, please refer to `Create a job runtime role <https://docs.aws.amazon.com/emr/latest/EMR-Serverless-UserGuide/getting-started.html#gs-runtime-role>`_::

       const emrServerlessBucket = new EmrServerlessBucket(this, 'EmrServerlessStorage');
       const emrServerlessJobRole = new ServerlessJobRole(this, 'EmrServerlessJob', {emrServerlessBucket: emrServerlessBucket});
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        emr_serverless_bucket: _aws_cdk_aws_s3_ceddda9d.Bucket,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param emr_serverless_bucket: The EMR Serverless bucket.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__171aad10e11aea30b81f8c4fe61f6dec3c6bbae1f9d8211807308186aab60164)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = ServerlessJobRoleProps(emr_serverless_bucket=emr_serverless_bucket)

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="entity")
    def entity(self) -> _aws_cdk_aws_iam_ceddda9d.Role:
        '''The representative of the execution role for EMR Serverless.'''
        return typing.cast(_aws_cdk_aws_iam_ceddda9d.Role, jsii.get(self, "entity"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.ServerlessJobRoleProps",
    jsii_struct_bases=[],
    name_mapping={"emr_serverless_bucket": "emrServerlessBucket"},
)
class ServerlessJobRoleProps:
    def __init__(
        self,
        *,
        emr_serverless_bucket: _aws_cdk_aws_s3_ceddda9d.Bucket,
    ) -> None:
        '''Options for the execution job role of EMR Serverless.

        :param emr_serverless_bucket: The EMR Serverless bucket.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2874177a118954f64dfec706ef123bd66106a9b6b077e1d9439f1d1c3ad18de)
            check_type(argname="argument emr_serverless_bucket", value=emr_serverless_bucket, expected_type=type_hints["emr_serverless_bucket"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "emr_serverless_bucket": emr_serverless_bucket,
        }

    @builtins.property
    def emr_serverless_bucket(self) -> _aws_cdk_aws_s3_ceddda9d.Bucket:
        '''The EMR Serverless bucket.'''
        result = self._values.get("emr_serverless_bucket")
        assert result is not None, "Required property 'emr_serverless_bucket' is missing"
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.Bucket, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServerlessJobRoleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-emrserverless-with-delta-lake.StudioAuthMode")
class StudioAuthMode(enum.Enum):
    '''What kind of authentication the Studio uses.'''

    AWS_SSO = "AWS_SSO"
    '''the Studio authenticates users using AWS SSO.'''
    AWS_IAM = "AWS_IAM"
    '''the Studio authenticates users using AWS IAM.'''


class WorkSpaceBucket(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-emrserverless-with-delta-lake.WorkSpaceBucket",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        name: builtins.str,
        *,
        bucket_name: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    ) -> None:
        '''
        :param scope: -
        :param name: -
        :param bucket_name: The bucket name for the workspace of an EMR Studio. Default: - 'emr-studio-workspace-bucket-AWS::AccountId'
        :param removal_policy: Policy to apply when the bucket is removed from this stack. Default: - The bucket will be deleted.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__680872503299c43f4335fca584c301a84339f25b7d195fa2f08c334a2b93319c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = WorkSpaceBucketProps(
            bucket_name=bucket_name, removal_policy=removal_policy
        )

        jsii.create(self.__class__, self, [scope, name, props])

    @builtins.property
    @jsii.member(jsii_name="bucketEntity")
    def bucket_entity(self) -> _aws_cdk_aws_s3_ceddda9d.Bucket:
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.Bucket, jsii.get(self, "bucketEntity"))


@jsii.data_type(
    jsii_type="cdk-emrserverless-with-delta-lake.WorkSpaceBucketProps",
    jsii_struct_bases=[],
    name_mapping={"bucket_name": "bucketName", "removal_policy": "removalPolicy"},
)
class WorkSpaceBucketProps:
    def __init__(
        self,
        *,
        bucket_name: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    ) -> None:
        '''
        :param bucket_name: The bucket name for the workspace of an EMR Studio. Default: - 'emr-studio-workspace-bucket-AWS::AccountId'
        :param removal_policy: Policy to apply when the bucket is removed from this stack. Default: - The bucket will be deleted.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4e229da447e775790ad164fc11afc0f5baaca96dcc93c14f18243a589861b89)
            check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bucket_name is not None:
            self._values["bucket_name"] = bucket_name
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy

    @builtins.property
    def bucket_name(self) -> typing.Optional[builtins.str]:
        '''The bucket name for the workspace of an EMR Studio.

        :default: - 'emr-studio-workspace-bucket-AWS::AccountId'
        '''
        result = self._values.get("bucket_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy]:
        '''Policy to apply when the bucket is removed from this stack.

        :default: - The bucket will be deleted.
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WorkSpaceBucketProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "EmrClusterTemplateStack",
    "EmrServerless",
    "EmrServerlessBucket",
    "EmrServerlessBucketProps",
    "EmrServerlessProps",
    "EmrStudio",
    "EmrStudioDeveloperStack",
    "EmrStudioDeveloperStackProps",
    "EmrStudioEngineSecurityGroup",
    "EmrStudioEngineSecurityGroupProps",
    "EmrStudioProps",
    "EmrStudioServiceRole",
    "EmrStudioServiceRoleProps",
    "EmrStudioTaggingExpert",
    "EmrStudioWorkspaceSecurityGroup",
    "EmrStudioWorkspaceSecurityGroupProps",
    "ServerlessJobRole",
    "ServerlessJobRoleProps",
    "StudioAuthMode",
    "WorkSpaceBucket",
    "WorkSpaceBucketProps",
]

publication.publish()

def _typecheckingstub__b40d8d3575864a15feaf0e04d730dd2c31d40763b0fcc93a79b2a11853a34169(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90f6dce837ed6875380209d49b66583583fb9de6773398eb7ef9da8c4dd2080b(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    service_catalog_props: typing.Optional[typing.Union[EmrStudioDeveloperStackProps, typing.Dict[builtins.str, typing.Any]]] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be9cf64c6fec85d3275f91bf9201f245024e9fedcf42c5ad93293b6a2f7d17d7(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    bucket_name: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__527518165642dd620d0cdb844cbf5b6f00640db3b7e36db22d6b3b4509609445(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d8dd0945f913a2b553b1a9bd9d986479072d68d10576fd1e4e2d59ffc2930ec(
    *,
    service_catalog_props: typing.Optional[typing.Union[EmrStudioDeveloperStackProps, typing.Dict[builtins.str, typing.Any]]] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf467b28d0b83b0ef8c3bbd6137b0929253236b4088d2b67500feac8061ecbf1(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    work_space_bucket: WorkSpaceBucket,
    auth_mode: typing.Optional[StudioAuthMode] = None,
    description: typing.Optional[builtins.str] = None,
    engine_security_group_id: typing.Optional[builtins.str] = None,
    service_catalog_props: typing.Optional[typing.Union[EmrStudioDeveloperStackProps, typing.Dict[builtins.str, typing.Any]]] = None,
    service_role_arn: typing.Optional[builtins.str] = None,
    service_role_name: typing.Optional[builtins.str] = None,
    studio_name: typing.Optional[builtins.str] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    user_role_arn: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
    work_space_security_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18d8abb489569c20860e9601cc71ca861c32e1136c1e2fa21dd6db0cfe1f4948(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    group: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IGroup] = None,
    provider_name: typing.Optional[builtins.str] = None,
    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    user: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IUser] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8befc3c14062038bb7e027d763ab0589b2b3ab4f5724371cf8de08abb7b3d9fc(
    *,
    group: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IGroup] = None,
    provider_name: typing.Optional[builtins.str] = None,
    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    user: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IUser] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cba1dcbacc62cb64b43f6ad633c938ee772c9e83d748eea57962286776a8925e(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb566bde060b5245e75b74d32abf8fa15cccfdbf988b90b36228dba8a3251a07(
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8ece76aa21839d16748f809f90cab63e03a42228d610516462560602d4b3c33(
    *,
    work_space_bucket: WorkSpaceBucket,
    auth_mode: typing.Optional[StudioAuthMode] = None,
    description: typing.Optional[builtins.str] = None,
    engine_security_group_id: typing.Optional[builtins.str] = None,
    service_catalog_props: typing.Optional[typing.Union[EmrStudioDeveloperStackProps, typing.Dict[builtins.str, typing.Any]]] = None,
    service_role_arn: typing.Optional[builtins.str] = None,
    service_role_name: typing.Optional[builtins.str] = None,
    studio_name: typing.Optional[builtins.str] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    user_role_arn: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
    work_space_security_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fe737c319b0cc5d63a781dad02941734c5bb864b1c3945d442fd84304460375(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    work_space_bucket: WorkSpaceBucket,
    role_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5b13bb7c5bf8d9d00f324aeeff6c02c78ab6ae3d6d3b2d6d29da649f1e034ff(
    *,
    work_space_bucket: WorkSpaceBucket,
    role_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be4d8890c648405923432108734725ae787a93d2173731e1df5562a6d1f01ae9(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea0ce2ebd9ab5f0c7482e304f847584719e5c90f541705a5043c7d4f19cdbf22(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61af5b98618f8d5355200cca09b6cac20052d7eeecb1647a3c9dafd9a9c37451(
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__171aad10e11aea30b81f8c4fe61f6dec3c6bbae1f9d8211807308186aab60164(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    emr_serverless_bucket: _aws_cdk_aws_s3_ceddda9d.Bucket,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2874177a118954f64dfec706ef123bd66106a9b6b077e1d9439f1d1c3ad18de(
    *,
    emr_serverless_bucket: _aws_cdk_aws_s3_ceddda9d.Bucket,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__680872503299c43f4335fca584c301a84339f25b7d195fa2f08c334a2b93319c(
    scope: _constructs_77d1e7e8.Construct,
    name: builtins.str,
    *,
    bucket_name: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4e229da447e775790ad164fc11afc0f5baaca96dcc93c14f18243a589861b89(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
) -> None:
    """Type checking stubs"""
    pass
