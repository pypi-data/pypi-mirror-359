from __future__ import annotations

import json
import logging
from abc import abstractmethod
from typing import Any

from flask import Response, jsonify
from flask.views import MethodView

import ckan.plugins as p
import ckan.plugins.toolkit as tk
from ckan.logic import parse_params

import ckanext.ap_main.types as types
from ckanext.ap_main.interfaces import IAdminPanel
from ckanext.ap_main.table import TableDefinition
from ckanext.ap_main.utils import get_config_schema

log = logging.getLogger(__name__)


class ApConfigurationPageView(MethodView):
    def __init__(
        self,
        schema_id: str,
        render_template: str = "admin_panel/config/autogenerated_config.html",
        breadcrumb_label: str = "Configuration",
        page_title: str = "Configuration page",
        success_update_message: str = "Config options have been updated",
        fields: list[dict[str, Any]] | None = None,
    ):
        """A generic view to render configurations for an extension based on
        an arbitrary schema and config_declaration.yaml

        Args:
            schema_id : an arbitrary schema ID
            render_template (optional): a path to a render template
            breadcrumb_label (optional): page breadcrumb label
            page_title (optional): page title
            success_update_message (optional): message text after a success update
            fields (optional): provide a schema fields list directly
        """
        self.schema_id = schema_id
        self.render_template = render_template
        self.breadcrumb_label = breadcrumb_label
        self.page_title = page_title
        self.success_update_message = success_update_message
        self.fields = fields

    def get(self):
        self.schema = self.get_config_schema()
        self.data = self.get_config_form_data()
        self.disable_non_editable_fields()

        return tk.render(
            self.render_template,
            self.prepare_extra_vars(self.schema, self.data, {}),
        )

    def get_config_schema(self) -> dict[str, Any]:
        """Fetch a full schema or use the fields user provides and put them inside
        a dict to imitate a schema"""
        schema = (
            get_config_schema(self.schema_id)
            if not self.fields
            else {"schema_id": self.schema_id, "fields": self.fields}
        )

        if not schema:
            raise ValueError(f"Config schema '{self.schema_id}' not found")

        return schema

    def get_config_form_data(self) -> dict[str, Any]:
        """Fetch/humanize configuration values from a CKANConfig"""
        from ckanext.editable_config.shared import value_as_string

        data = {}

        for field in self.schema["fields"]:
            if field["field_name"] not in tk.config:
                continue

            data[field["field_name"]] = value_as_string(
                field["field_name"], tk.config[field["field_name"]]
            )

        return data

    def disable_non_editable_fields(self) -> None:
        """Update a schema fields and disable those, that are not marked as editable
        in a config_declaration.yml"""
        from ckanext.editable_config.shared import is_editable

        for field in self.schema["fields"]:
            if is_editable(field["field_name"]):
                continue

            field.setdefault("form_attrs", {})
            field["form_attrs"]["disabled"] = 1

    def prepare_extra_vars(
        self, schema: dict[str, Any], data: dict[str, Any], errors: dict[str, Any]
    ) -> dict[str, Any]:
        return {
            "data": data,
            "errors": errors,
            "schema": schema,
            "breadcrumb_label": self.breadcrumb_label,
            "page_title": self.page_title,
        }

    def post(self):
        self.schema = self.get_config_schema()
        self.data = parse_params(tk.request.form)
        self.disable_non_editable_fields()
        self.throw_away_undeclared_fields()

        conf_before_update = {key: tk.config[key] for key in self.data.keys()}

        for plugin in reversed(list(p.PluginImplementations(IAdminPanel))):
            plugin.before_config_update(self.schema_id, self.data)

        try:
            if tk.request.form.get("reset"):
                tk.get_action("editable_config_reset")(
                    {},
                    {"keys": list(self.data)},
                )
            else:
                tk.get_action("editable_config_change")(
                    {},
                    {"options": self.data},
                )
        except tk.ObjectNotFound as e:
            tk.h.flash_error(
                tk._("No default value found for option {}".format(e.message))
            )
            return tk.render(
                self.render_template,
                self.prepare_extra_vars(
                    self.schema, self.data, {"test": "No default value"}
                ),
            )
        except tk.ValidationError as e:
            return tk.render(
                self.render_template,
                self.prepare_extra_vars(self.schema, self.data, e.error_dict),
            )

        for plugin in reversed(list(p.PluginImplementations(IAdminPanel))):
            plugin.after_config_update(
                self.schema_id,
                conf_before_update,
                self.data,
            )

        tk.h.flash_success(self.success_update_message)

        return tk.redirect_to(tk.request.endpoint)

    def throw_away_undeclared_fields(self) -> None:
        self.data = {k: v for k, v in self.data.items() if k in tk.config}


class ApTableView(MethodView):
    def __init__(
        self,
        table: type[TableDefinition],
        breadcrumb_label: str = "Table",
        page_title: str = "Table",
    ):
        """A generic view to render tables

        Args:
            table: a table definition
            render_template (optional): a path to a render template
        """
        self.table = table
        self.breadcrumb_label = breadcrumb_label
        self.page_title = page_title

    def get(self) -> str | Response:
        """Render a table

        If the data argument is provided, returns the table data
        """
        table = self.table()  # type: ignore

        if tk.request.args.get("data"):
            return jsonify(table.get_data())

        return table.render_table(
            breadcrumb_label=self.breadcrumb_label, page_title=self.page_title
        )

    def post(self) -> Response:
        """Handle global actions on a table"""
        global_action = tk.request.form.get("global_action")
        rows = tk.request.form.get("rows")

        action_func = self.get_global_action(global_action) if global_action else None

        if not action_func or not rows:
            return jsonify(
                {
                    "success": False,
                    "errors": [tk._("The global action is not implemented")],
                }
            )

        errors = []

        for row in json.loads(rows):
            success, error = action_func(row)

            if not success:
                log.debug("Error during global action %s: %s", global_action, error)
                errors.append(error)

        return jsonify({"success": not errors, "errors": errors})

    @abstractmethod
    def get_global_action(self, value: str) -> types.GlobalActionHandler | None:
        pass
