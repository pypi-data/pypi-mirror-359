# generated by datamodel-codegen:
#   filename:  media_insights_response.json

from __future__ import annotations

from typing import Any, Mapping, Optional, Sequence, Union

from typing_extensions import Literal, NotRequired, TypedDict


class PublishDataRoom(TypedDict):
    dataRoomId: str


class MediaInsightsResponse1(TypedDict):
    publishDataRoom: PublishDataRoom


class MediaInsightsResponse3(TypedDict):
    publishAdvertiserDataset: Mapping[str, Any]


class MediaInsightsResponse4(TypedDict):
    publishPublisherUsersDataset: Mapping[str, Any]


class MediaInsightsResponse5(TypedDict):
    unpublishPublisherUsersDataset: Mapping[str, Any]


class MediaInsightsResponse6(TypedDict):
    publishDemographicsDataset: Mapping[str, Any]


class MediaInsightsResponse7(TypedDict):
    unpublishDemographicsDataset: Mapping[str, Any]


class MediaInsightsResponse8(TypedDict):
    publishSegmentsDataset: Mapping[str, Any]


class MediaInsightsResponse9(TypedDict):
    unpublishSegmentsDataset: Mapping[str, Any]


class MediaInsightsResponse10(TypedDict):
    publishEmbeddingsDataset: Mapping[str, Any]


class MediaInsightsResponse11(TypedDict):
    unpublishEmbeddingsDataset: Mapping[str, Any]


class MediaInsightsResponse12(TypedDict):
    unpublishAdvertiserDataset: Mapping[str, Any]


class RetrievePublishedDatasets(TypedDict):
    advertiserDatasetHashHex: NotRequired[Optional[str]]
    demographicsDatasetHashHex: NotRequired[Optional[str]]
    embeddingsDatasetHashHex: NotRequired[Optional[str]]
    publisherDatasetHashHex: NotRequired[Optional[str]]
    segmentsDatasetHashHex: NotRequired[Optional[str]]


class MediaInsightsResponse13(TypedDict):
    retrievePublishedDatasets: RetrievePublishedDatasets


class ComputeAvailableAudiences(TypedDict):
    computeNodeName: str
    jobIdHex: str


class MediaInsightsResponse14(TypedDict):
    computeAvailableAudiences: ComputeAvailableAudiences


class ComputeOverlapStatistics(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse15(TypedDict):
    computeOverlapStatistics: ComputeOverlapStatistics


class ComputeInsights(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse16(TypedDict):
    computeInsights: ComputeInsights


class MediaInsightsResponse17(TypedDict):
    publishActivatedAudiencesConfig: Mapping[str, Any]


class MediaInsightsResponse18(TypedDict):
    unpublishActivatedAudiencesConfig: Mapping[str, Any]


class GetAudienceUserList(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse19(TypedDict):
    getAudienceUserList: GetAudienceUserList


class GetAudienceUserListForAdvertiser(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse20(TypedDict):
    getAudienceUserListForAdvertiser: GetAudienceUserListForAdvertiser


class GetAudiencesForPublisher(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse21(TypedDict):
    getAudiencesForPublisher: GetAudiencesForPublisher


class GetAudiencesForAdvertiser(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse22(TypedDict):
    getAudiencesForAdvertiser: GetAudiencesForAdvertiser


class IngestAudiencesReport(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse23(TypedDict):
    ingestAudiencesReport: IngestAudiencesReport


class RetrieveModelQualityReport(ComputeAvailableAudiences):
    pass


class MediaInsightsResponse24(TypedDict):
    retrieveModelQualityReport: RetrieveModelQualityReport


class EnclaveSpecificationV0(TypedDict):
    attestationProtoBase64: str
    id: str
    workerProtocol: int


FormatType = Literal[
    'STRING',
    'INTEGER',
    'FLOAT',
    'EMAIL',
    'DATE_ISO8601',
    'PHONE_NUMBER_E164',
    'HASH_SHA256_HEX',
]


HashingAlgorithm = Literal['SHA256_HEX']


ModelEvaluationType = Literal['ROC_CURVE', 'DISTANCE_TO_EMBEDDING', 'JACCARD']


class RequirementFlagValue31(TypedDict):
    type: Literal['SUPPORTED']


class RequirementFlagValue32(TypedDict):
    type: Literal['DATASET']


class RequirementFlagValue33(TypedDict):
    type: Literal['PROPERTY']
    value: str


RequirementFlagValue = Union[
    RequirementFlagValue31, RequirementFlagValue32, RequirementFlagValue33
]


KnownOrUnknownRequirementFlagValue = Optional[RequirementFlagValue]


class ModelEvaluationConfig(TypedDict):
    postScopeMerge: Sequence[ModelEvaluationType]
    preScopeMerge: Sequence[ModelEvaluationType]


class RequirementFlag(TypedDict):
    details: KnownOrUnknownRequirementFlagValue
    name: str


class RequirementOp28(TypedDict):
    has: RequirementFlag


class MediaInsightsComputeV0(TypedDict):
    advertiserEmails: Sequence[str]
    agencyEmails: Sequence[str]
    authenticationRootCertificatePem: str
    driverEnclaveSpecification: EnclaveSpecificationV0
    hashMatchingIdWith: NotRequired[Optional[HashingAlgorithm]]
    id: str
    mainAdvertiserEmail: str
    mainPublisherEmail: str
    matchingIdFormat: FormatType
    modelEvaluation: NotRequired[Optional[ModelEvaluationConfig]]
    name: str
    observerEmails: Sequence[str]
    publisherEmails: Sequence[str]
    pythonEnclaveSpecification: EnclaveSpecificationV0
    rateLimitPublishDataNumPerWindow: NotRequired[int]
    rateLimitPublishDataWindowSeconds: NotRequired[int]


class MediaInsightsComputeV1(MediaInsightsComputeV0):
    pass


class MediaInsightsComputeV2(TypedDict):
    advertiserEmails: Sequence[str]
    agencyEmails: Sequence[str]
    authenticationRootCertificatePem: str
    dataPartnerEmails: NotRequired[Sequence[str]]
    driverEnclaveSpecification: EnclaveSpecificationV0
    hashMatchingIdWith: NotRequired[Optional[HashingAlgorithm]]
    id: str
    mainAdvertiserEmail: str
    mainPublisherEmail: str
    matchingIdFormat: FormatType
    modelEvaluation: NotRequired[Optional[ModelEvaluationConfig]]
    name: str
    observerEmails: Sequence[str]
    publisherEmails: Sequence[str]
    pythonEnclaveSpecification: EnclaveSpecificationV0
    rateLimitPublishDataNumPerWindow: NotRequired[int]
    rateLimitPublishDataWindowSeconds: NotRequired[int]


class MediaInsightsComputeV3(MediaInsightsComputeV2):
    pass


class MediaInsightsComputeV4(MediaInsightsComputeV2):
    pass


class MediaInsightsComputeV5(MediaInsightsComputeV2):
    pass


class MediaInsightsCompute(TypedDict):
    v0: MediaInsightsComputeV0


class MediaInsightsCompute21(TypedDict):
    v1: MediaInsightsComputeV1


class MediaInsightsCompute22(TypedDict):
    v2: MediaInsightsComputeV2


class MediaInsightsCompute23(TypedDict):
    v3: MediaInsightsComputeV3


class MediaInsightsCompute24(TypedDict):
    v4: MediaInsightsComputeV4


class MediaInsightsCompute25(TypedDict):
    v5: MediaInsightsComputeV5


MediaInsightsCompute19 = Union[
    MediaInsightsCompute,
    MediaInsightsCompute21,
    MediaInsightsCompute22,
    MediaInsightsCompute23,
    MediaInsightsCompute24,
    MediaInsightsCompute25,
]


MediaInsightsComputeOrUnknown = Optional[MediaInsightsCompute19]


class RetrieveDataRoom(TypedDict):
    dataRoom: MediaInsightsDcr


class MediaInsightsResponse2(TypedDict):
    retrieveDataRoom: RetrieveDataRoom


MediaInsightsResponse = Union[
    MediaInsightsResponse1,
    MediaInsightsResponse2,
    MediaInsightsResponse3,
    MediaInsightsResponse4,
    MediaInsightsResponse5,
    MediaInsightsResponse6,
    MediaInsightsResponse7,
    MediaInsightsResponse8,
    MediaInsightsResponse9,
    MediaInsightsResponse10,
    MediaInsightsResponse11,
    MediaInsightsResponse12,
    MediaInsightsResponse13,
    MediaInsightsResponse14,
    MediaInsightsResponse15,
    MediaInsightsResponse16,
    MediaInsightsResponse17,
    MediaInsightsResponse18,
    MediaInsightsResponse19,
    MediaInsightsResponse20,
    MediaInsightsResponse21,
    MediaInsightsResponse22,
    MediaInsightsResponse23,
    MediaInsightsResponse24,
]


class ConsumerRequirements(TypedDict):
    optional: Sequence[RequirementFlag]
    required: NotRequired[Optional[RequirementOp]]


class MediaInsightsDcr4(TypedDict):
    v0: MediaInsightsDcrInner


MediaInsightsDcr = MediaInsightsDcr4


class MediaInsightsDcrInner(TypedDict):
    compute: MediaInsightsComputeOrUnknown
    consumes: ConsumerRequirements
    features: Sequence[str]


RequirementOp25 = TypedDict(
    'RequirementOp25',
    {
        'or': Sequence[RequirementOp],
    },
)


RequirementOp26 = TypedDict(
    'RequirementOp26',
    {
        'and': Sequence[RequirementOp],
    },
)


class RequirementOp27(TypedDict):
    exclusiveOr: Sequence[RequirementOp]


RequirementOp = Union[
    RequirementOp25, RequirementOp26, RequirementOp27, RequirementOp28
]
