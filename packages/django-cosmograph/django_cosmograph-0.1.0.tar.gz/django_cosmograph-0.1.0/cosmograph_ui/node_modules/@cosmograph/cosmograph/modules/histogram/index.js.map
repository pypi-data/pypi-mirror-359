{"version":3,"file":"index.js","sources":["../../../src/modules/histogram/index.ts"],"sourcesContent":["import { CosmosInputLink, CosmosInputNode } from '@cosmograph/cosmos'\nimport { Histogram, HistogramConfigInterface, HistogramEvents, merge } from '@cosmograph/ui'\nimport { Cosmograph, Filter } from '../cosmograph'\nimport { FilterType } from '../cosmograph/types'\nimport { CosmographHistogramInputConfig, CosmographHistogramConfigInterface, defaultCosmographHistogramConfig } from './config'\n\nexport class CosmographHistogram<OutDatum, InDatum = OutDatum> {\n  private _cosmograph: Cosmograph<CosmosInputNode, CosmosInputLink>\n  private _histogram: Histogram\n  private _config: CosmographHistogramConfigInterface<OutDatum, InDatum>\n  private _filter: Filter<CosmosInputNode | CosmosInputLink>\n\n  public constructor (cosmograph: Cosmograph<CosmosInputNode, CosmosInputLink>, targetElement: HTMLElement, config?: CosmographHistogramInputConfig<OutDatum, InDatum>) {\n    this._cosmograph = cosmograph\n    this._config = merge(defaultCosmographHistogramConfig, config ?? {})\n    this._histogram = new Histogram(targetElement, this._createHistogramConfig(config))\n    this._filter = this._config.filterType === FilterType.Nodes ? this._cosmograph.addNodesFilter() : this._cosmograph.addLinksFilter()\n    this._filter.onDataAdded = () => {\n      this._updateData()\n    }\n    this._filter.onFiltered = () => {\n      if (this._config.highlightCrossfiltered) this._updateDynamicData()\n    }\n    this._updateDimension()\n    this._updateData()\n  }\n\n  /**\n   * Sets the config for the histogram.\n   * @param config Configuration to be applied to the histogram.\n   */\n  public setConfig (config?: CosmographHistogramInputConfig<OutDatum, InDatum>): void {\n    const nextConfig = merge(defaultCosmographHistogramConfig, config ?? {})\n    this._histogram.setConfig(this._createHistogramConfig(config))\n    if (\n      nextConfig.accessor !== this._config.accessor ||\n      nextConfig.data !== this._config.data ||\n      nextConfig.filterFunction !== this._config.filterFunction\n    ) {\n      this._updateDimension()\n      this._updateData()\n      // Re-set selection\n      this.setSelection()\n    }\n    this._config = nextConfig\n  }\n\n  /**  `getCurrentSelection`: Returns current brush selection. */\n  public getCurrentSelection (): number[] | undefined {\n    return this._histogram.getCurrentSelection\n  }\n\n  /**  `getCurrentSelectionInPixels`: Returns current brush selection in pixels. */\n  public getCurrentSelectionInPixels (): number[] {\n    return this._histogram.getCurrentSelectionInPixels\n  }\n\n  /**  `getBarWidth`: Returns computed bar width in pixels */\n  public getBarWidth (): number {\n    return this._histogram.getBarWidth()\n  }\n\n  /**  `setSelection`: Set the selected range on a `Histogram`. Takes a numeric selection range in the X axis units as a parameter. */\n  public setSelection (selection?: [number, number]): void {\n    this._histogram.setSelection(selection)\n  }\n\n  /**\n   * Returns current histogram configuration.\n   */\n  public getConfig (): CosmographHistogramConfigInterface<OutDatum, InDatum> {\n    return this._config\n  }\n\n  /**\n   * Destroy the histogram instance.\n   */\n  public remove (): void {\n    this._histogram.destroy()\n  }\n\n  private _createHistogramConfig (config?: CosmographHistogramInputConfig<OutDatum, InDatum>): HistogramConfigInterface {\n    return {\n      ...config,\n      events: {\n        onBrush: this._onBrush.bind(this),\n        onBarHover: this._onBarHover.bind(this),\n      },\n    }\n  }\n\n  private _updateDimension (): void {\n    const { _config: { accessor, filterFunction, data, filterType }, _filter } = this\n    if (!accessor) return\n    const isUserDefinedFiltering = filterFunction && data\n    if (isUserDefinedFiltering) {\n      if (filterType === FilterType.Nodes) {\n        _filter.setAccessor(d => (d as CosmosInputNode).id)\n      } else {\n        _filter.setAccessor(d => ([(d as CosmosInputLink).source, (d as CosmosInputLink).target]))\n      }\n    } else {\n      _filter.setAccessor(accessor as (d: CosmosInputNode | CosmosInputLink) => number)\n    }\n  }\n\n  private _applyFilter (selection?: [number, number]): void {\n    const { _filter, _config: { filterFunction, data, filterType } } = this\n    if (selection) {\n      const isUserDefinedFiltering = filterFunction && data\n      if (isUserDefinedFiltering) {\n        const crossSelectedRecords = _filter.getFilteredRecords() as OutDatum[]\n        if (filterType === FilterType.Nodes) {\n          const filteredNodes = filterFunction(selection, data, crossSelectedRecords) as CosmosInputNode[]\n          const filteredNodeIds = new Set(filteredNodes.map(d => d.id))\n          _filter.applyFilter(d => filteredNodeIds.has(d as string))\n        } else {\n          const filteredLinks = filterFunction(selection, data, crossSelectedRecords) as CosmosInputLink[]\n          const filteredLinkIds = new Set(filteredLinks.map(d => [d.source, d.target]).flat())\n          _filter.applyFilter(d => {\n            const source = (d as [string, string])?.[0]\n            const target = (d as [string, string])?.[1]\n            return filteredLinkIds.has(source) && filteredLinkIds.has(target)\n          })\n        }\n      } else {\n        _filter.applyFilter(d => (d as number) >= selection[0] && (d as number) <= selection[1])\n      }\n    } else _filter.clear()\n  }\n\n  private _updateData (): void {\n    const { _config: { data, filterFunction, accessor } } = this\n    const isUserDefinedFiltering = filterFunction && data\n    const histogramData = (isUserDefinedFiltering && accessor) ? data.map(accessor) : this._filter.getAllValues()\n    if (histogramData) this._histogram.setHistogramData(histogramData as number[], this._config.customExtent)\n  }\n\n  private _updateDynamicData (): void {\n    const dynamicData = this._filter.getFilteredValues() as number[]\n    this._histogram.setHighlightedData(dynamicData)\n  }\n\n  private _onBrush: Exclude<HistogramEvents['onBrush'], undefined> = (selection, isManuallySelected) => {\n    this._applyFilter(selection)\n    this._config.onSelection?.(selection, isManuallySelected)\n  }\n\n  private _onBarHover: Exclude<HistogramEvents['onBarHover'], undefined> = (...args) => {\n    this._config.onBarHover?.(...args)\n  }\n}\n\nexport type { CosmographHistogramConfigInterface, CosmographHistogramInputConfig }\n"],"names":["CosmographHistogram","constructor","cosmograph","targetElement","config","this","_onBrush","selection","isManuallySelected","_applyFilter","_b","_a","_config","onSelection","call","_onBarHover","args","onBarHover","_cosmograph","merge","defaultCosmographHistogramConfig","_histogram","Histogram","_createHistogramConfig","_filter","filterType","FilterType","Nodes","addNodesFilter","addLinksFilter","onDataAdded","_updateData","onFiltered","highlightCrossfiltered","_updateDynamicData","_updateDimension","setConfig","nextConfig","accessor","data","filterFunction","setSelection","getCurrentSelection","getCurrentSelectionInPixels","getBarWidth","getConfig","remove","destroy","events","onBrush","bind","setAccessor","d","id","source","target","crossSelectedRecords","getFilteredRecords","filteredNodes","filteredNodeIds","Set","map","applyFilter","has","filteredLinks","filteredLinkIds","flat","clear","histogramData","getAllValues","setHistogramData","customExtent","dynamicData","getFilteredValues","setHighlightedData"],"mappings":"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"}