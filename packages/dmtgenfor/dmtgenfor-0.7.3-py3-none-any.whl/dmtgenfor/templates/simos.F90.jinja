! This an autogenerated file
! Please do not edit.
! user defined code can be added at the marked locations.
!------------------------------------------------------------------------------
!******************************************************************************
module {{type.module}}
    !---------------------------------------------------------------------------
    !use statements
    !using general modules
    !******************************************************************************
    !using general modules
    use, intrinsic :: iso_fortran_env, only: real64, int64
    use iso_fortran_env, only: sp => real32, dp => real64
    use fcore__typeio, only: typeio_t, serializer_t, deserializer_t
    use fcore__error, only: error_t
    use class_string, only: String, assignment(=), operator(+), operator(//), operator(==)
    use string_util
    use exceptions, only: throw, exception_occurred
    use class_illegal_state_exception, only: illegal_state_exception
    !******************************************************************************
    !using custom modules. Classes are aliased to avoid name clashing
{%- for module, dependency in type.dependencies.items() | sort(attribute='0') %}
    use {{module}}, only:        &
    {%- for imp in dependency.imports | sort(attribute='name') %}
        {%if imp.rename %}{{imp.rename}} => {%endif%}{{imp.name}}{%- if not loop.last %},        &{%-endif%}
    {%- endfor %}
{%- endfor %}
#   include "exceptions.h"
    !---------------------------------------------------------------------------
{%- if config.user_defined_code %}
!@@@@@ USER DEFINED USE START @@@@@
{{type.user_defined.get("use", "")}}
!@@@@@ USER DEFINED USE END @@@@@
{%- endif %}
    !---------------------------------------------------------------------------
    implicit none
    private
    !---------------------------------------------------------------------------
    public :: {{type.type}}
    !> {{type.description}}
    type, extends(typeio_t) :: {{type.type}}{%-if type.is_shared%} ! #shared{%endif%}{%-if type.is_writable%} ! #writeable-all{%endif%}
        private
{%- for attr in type.attributes %}
        ! {{attr.description}}
        {{attr.type_init}}{%- if attr.is_allocatable %}, allocatable{% endif %}, public :: {{attr.fieldname}}{%-if attr.is_shared%} ! #shared{%endif%}
        {%-if attr.is_optional and config.use_is_set %}
        logical, public :: is_set_{{attr.name}} = .false.
        {%-endif%}

{%- endfor %}
!---------------------------------------------------------------------------
{%- if config.user_defined_code %}
!@@@@@ USER DEFINED PROPERTIES START @@@@@
{{type.user_defined.get("properties", "")}}
!@@@@@ USER DEFINED PROPERTIES END @@@@@
{%- endif %}
        contains
        private
        procedure, public :: serialize
        procedure, public :: deserialize
        procedure, nopass, public :: typename

        {%- if config.generate_default_init%}
        generic, public :: default_init => default_initFromSingle, default_initFromSingleWiNameFromChar, default_initFromSingleWiNameFromString
        {%- endif %}
        {%- if config.generate_allocate%}
        procedure, public :: allocate
        {%- endif %}
        {%- if config.generate_destroy%}
        procedure, public :: destroy
        {%- endif %}
        {%- if config.generate_resize %}
        !--- resize functions for single atomic arrays ----
        {%- for attr in type.attributes if attr.is_variable_array %}
        procedure, public :: resize_{{attr.name}}
        {%- endfor %}
        {%- endif %}
        ! Private procedures
        {%- if config.generate_default_init %}
        procedure :: default_initFromSingle
        procedure :: default_initFromSingleWiNameFromChar
        procedure :: default_initFromSingleWiNameFromString
        {%- endif %}
        {%- if config.generate_destroy %}
        {%- for attr in type.attributes if attr.is_destroyable %}
        procedure :: destroy_{{attr.name}}
        {%- endfor %}
        {%- endif %}
    !---------------------------------------------------------------------------
{%- if config.user_defined_code %}
!@@@@@ USER DEFINED PROCEDURE DECLARATIONS START @@@@@
{{type.user_defined.get("procedure", "")}}
!@@@@@ USER DEFINED PROCEDURE DECLARATIONS End   @@@@@
{%- endif %}
    end type {{type.type}}

contains
{%- if config.user_defined_code %}
!@@@@@ USER DEFINED DECLARATIONS START @@@@@
{{type.user_defined.get("declarations", "")}}
!@@@@@ USER DEFINED DECLARATIONS END @@@@@
{%- endif %}


    pure function typename()
        character(len=:), allocatable :: typename

        typename = '{{type.path}}'
    end function


    subroutine serialize(this, se, error)
        class({{type.type}}), target, intent(in) :: this
        class(serializer_t), intent(inout) :: se
        class(error_t), allocatable, intent(out) :: error
{% for attr in type.attributes if not attr.is_transient %}
  {%- set indent = 0 %}
  {%- if attr.is_optional and config.use_is_set %}
        if (this%is_set_{{attr.name}}) then
    {%- set indent = indent + 1 %}
  {%- endif %}
    {%- if attr.is_primitive %}
      {%- if attr.is_allocatable %}
        {{indent * '    '}}call se%write_allocatable('{{attr.name}}', this%{{attr.name}}, error)
      {%- else %}
        {{indent * '    '}}call se%write('{{attr.name}}', this%{{attr.name}}, error)
      {%- endif %}
  {%- else %}
    {%- if attr.is_allocatable %}
      {%- if attr.is_array %}
        {{indent * '    '}}call se%write_allocatable_type_rank1('{{attr.name}}', {{attr.name}}_getter, error)
      {%- else %}
        {{indent * '    '}}call se%write_allocatable_type('{{attr.name}}', this%{{attr.name}}, error)
      {%- endif %}
    {%- else %}
        {{indent * '    '}}call se%write('{{attr.name}}', this%{{attr.name}}, error)
    {%- endif %}
  {%- endif %}
        {{indent * '    '}}if (allocated(error)) return
  {%- if attr.is_optional and config.use_is_set %}
        end if
  {%- endif %}
{%- endfor %}
    contains
{%- for attr in type.attributes if attr.is_allocatable and not attr.is_primitive and not attr.is_transient %}

    {%- if not attr.is_array %}
        subroutine {{attr.name}}_getter(ptr)
            class(typeio_t), pointer, intent(out) :: ptr

            nullify(ptr)
            if (allocated(this%{{attr.name}})) ptr => this%{{attr.name}}
        end subroutine
    {%- else %}
        subroutine {{attr.name}}_getter(ptr)
            class(typeio_t), pointer, intent(out) :: ptr(:)

            nullify(ptr)
            if (allocated(this%{{attr.name}})) ptr => this%{{attr.name}}
        end subroutine
    {%- endif %}
{%- endfor %}
    end subroutine


    subroutine deserialize(this, de, error)
        class({{type.type}}), target, intent(out) :: this
        class(deserializer_t), intent(inout) :: de
        class(error_t), allocatable, intent(out) :: error
{% for attr in type.attributes if not attr.is_transient %}
  {%- set indent = 0 %}
  {%- if attr.is_optional and config.use_is_set %}
        if (de%has('{{attr.name}}')) then
    {%- set indent = indent + 1 %}
  {%- endif %}
  {%- if attr.is_primitive %}
    {%- if attr.is_allocatable %}
        {{indent * '    '}}call de%read_allocatable('{{attr.name}}', this%{{attr.name}}, error)
    {%- else %}
        {{indent * '    '}}call de%read('{{attr.name}}', this%{{attr.name}}, error)
    {%- endif %}
  {%- else %}
    {%- if attr.is_allocatable %}
      {%- if attr.is_array %}
        {{indent * '    '}}call de%read_allocatable_type_rank1('{{attr.name}}', {{attr.name}}_allocator, error)
      {%- else %}
        {{indent * '    '}}call de%read_allocatable_type('{{attr.name}}', {{attr.name}}_allocator, error)
      {%- endif %}
    {%- else %}
        {{indent * '    '}}call de%read('{{attr.name}}', this%{{attr.name}}, error)
    {%- endif %}
  {%- endif %}
        {{indent * '    '}}if (allocated(error)) return
  {%- if attr.is_optional and config.use_is_set %}
        {{indent * '    '}}this%is_set_{{attr.name}} = .true.
        end if
  {%- endif %}
{%- endfor %}
    contains
{%- for attr in type.attributes if attr.is_allocatable and not attr.is_primitive and not attr.is_transient %}

    {%- if not attr.is_array %}
        subroutine {{attr.name}}_allocator(ptr)
            class(typeio_t), pointer, intent(out) :: ptr

            allocate(this%{{attr.name}})
            ptr => this%{{attr.name}}
        end subroutine
    {%- else %}
        subroutine {{attr.name}}_allocator(n1, ptr)
            integer(int64), intent(in) :: n1
            class(typeio_t), pointer, intent(out) :: ptr(:)

            allocate(this%{{attr.name}}(n1))
            ptr => this%{{attr.name}}
        end subroutine
    {%- endif %}
{%- endfor %}
    end subroutine
    {% if config.generate_destroy %}
    pure subroutine destroy(this)
        class({{type.type}}), intent(inout) :: this
        {%- for attr in type.attributes if attr.is_destroyable%}
        call this%destroy_{{attr.name}}()
        {%- endfor %}
    end subroutine destroy

    {%for attr in type.attributes if attr.is_destroyable %}
    pure subroutine destroy_{{attr.name}}(this)
        class({{type.type}}), intent(inout) :: this
        {{attr.destroy}}
    end subroutine destroy_{{attr.name}}
    !---------------------------------------------------------------------------
    {%-endfor %}
    {%- endif %}
    {%- if config.generate_allocate %}
    subroutine allocate(this){%-if type.is_shared%} ! #shared{%endif%}
        class({{type.type}}), intent(out) :: this

        {%- if config.generate_default_init %}
        call this%default_initFromSingle()
        {%- endif %}
    end subroutine allocate
    {%- endif %}

    {%- if config.generate_default_init %}
    !-------------------------------Default initialization----------------------
    pure subroutine default_initFromSingleWiNameFromChar(this, insName)
        class({{type.type}}), intent(inout) :: this
        character(*), intent(in) :: insName

        call this%default_initFromSingle()
        {%if type.has_name-%}
        ! Set the default name of the object
        this%name = string(insName)
	    {%-endif%}
    end subroutine default_initFromSingleWiNameFromChar

    pure subroutine default_initFromSingleWiNameFromString(this, insName)
        class({{type.type}}), intent(inout) :: this
        type(String), intent(in) :: insName

        call this%default_initFromSingle()
        {%if type.has_name-%}
        ! Set the default name of the object
        this%name = insName
	    {%-endif%}
    end subroutine default_initFromSingleWiNameFromString

    pure subroutine default_initFromSingle(this)
        class({{type.type}}), intent(inout) :: this

        {%if type.has_name-%}
		! Set the default name of the object
		this%name = string('{{type.type}}')
	    {%-endif%}
        {%-for attr in type.attributes if attr.has_default_init %}
        call this%{{attr.fieldname}}%default_init('{{attr.name}}')
        {%-endfor%}
    end subroutine default_initFromSingle
    {%- endif %}

    {%- if config.generate_resize %}
    !-------------------------------Resize functions----------------------------
    {%-for attr in type.resize.attributes%}
    !---------------------------------------------------------------------------
    subroutine resize_{{attr.name}}(this, {{attr.dimension_names}})
        class({{type.name}}) :: this
        integer,intent(in) :: {{attr.dimension_names}}
        !internal variables
        integer :: error, sv
        type(string) :: error_message
        {%-if attr.has_name%}
        type(String) :: name
        integer :: idx1
        {%-endif%}
        call this%destroy_{{attr.name}}()
        if (allocated(this%{{attr.name}})) deallocate(this%{{attr.name}})
        allocate(this%{{attr.name}}({{attr.dimension_names}}),stat=sv)
        if (sv.ne.0) then
            error=-1
            error_message = 'Error during resizing in {{type.name}}, error when trying to alloc&
                &ate memory for {{attr.name}}'
            call throw(illegal_state_exception(error_message%toChars()))
            return
        end if
        {%-if attr.has_name%}
        do idx1 = 1,size(this%{{attr.name}}, 1)
            name = '{{attr.name}}' + String("_") + to_string(idx1)
            call this%{{attr.name}}(idx1)%default_init(name%toChars())
        end do
        {%-endif%}
    end subroutine resize_{{attr.name}}
    {%-endfor%}
    {%- endif %}

{%- if config.user_defined_code %}
!@@@@@ USER DEFINED PROCEDURES START @@@@@
{{type.user_defined.get("procedures", "")}}
!@@@@@ USER DEFINED PROCEDURES END @@@@@
{%- endif %}

end module {{type.module}}