!------------------------------------------------------------------------------
! THIS AN AUTOGENERATED FILE. PLEASE DO NOT EDIT!
!------------------------------------------------------------------------------
module {{module.name}}
    use, intrinsic :: iso_fortran_env, only: real64, int64
    use fcore__typeio, only: typeio_t, serializer_t, deserializer_t
    use fcore__error, only: error_t
    use fcore__string, only: string_t
{%- for use_module, dependency in module.dependencies.items() | sort(attribute='0') %}
    use {{use_module}}, only: &
    {%- for imp in dependency.imports | sort(attribute='name') %}
        {%if imp.rename %}{{imp.rename}} => {%endif%}{{imp.name}}{%- if not loop.last %}, &{%-endif%}
    {%- endfor %}
{%- endfor %}
    implicit none

    private
    public {{module.type.name}}

    type, extends(typeio_t) :: {{module.type.name}}{% if module.type.shared %} ! #shared{% endif %}{%if module.type.writable%} ! #writeable-all {%endif%}
    {%- if module.type.description %}
        {%- for str in module.type.description %}
        !! {{str}}
        {%- endfor %}

    {%- endif %}
{%- for attr in module.type.attributes %}
        {{attr.type_decl}}{% if attr.allocatable %}, allocatable{% endif %} :: {{attr.name}}{% if attr.shape %}({{','.join(attr.shape)}}){% endif %}{% if attr.shared %} ! #shared{% endif %}
        {%- for str in attr.description %}
            !! {{str}}
        {%- endfor %}
{%- endfor %}
    contains
        procedure :: serialize
        procedure :: deserialize
        procedure, nopass :: typename
    end type

contains


    pure function typename()
        character(len=:), allocatable :: typename

        typename = '{{module.type.qualified_name}}'
    end function


    subroutine serialize(this, se, error)
        class({{module.type.name}}), target, intent(in) :: this
        class(serializer_t), intent(inout) :: se
        class(error_t), allocatable, intent(out) :: error
{% for attr in module.type.attributes %}
    {%- if not attr.primitive and attr.allocatable %}
      {%- if attr.rank > 0 %}
        call se%write_allocatable_type_rank{{attr.rank}}('{{attr.name}}', {{attr.name}}_getter, error)
      {%- else %}
        call se%write_allocatable_type('{{attr.name}}', {{attr.name}}_getter, error)
      {%- endif %}
    {%- elif attr.allocatable %}
        call se%write_allocatable('{{attr.name}}', this%{{attr.name}}, error)
    {%- else %}
        call se%write('{{attr.name}}', this%{{attr.name}}, error)
    {%- endif %}
        if (allocated(error)) return
{%- endfor %}
    {%- set attrs = [] %}
{%- for attr in module.type.attributes if attr.allocatable and not attr.primitive %}
    {%- if attrs.append(attr) %}{% endif %}
{%- endfor %}
{%- if attrs|length > 0 %}
    contains
{%- endif %}
{%- for attr in attrs %}
    {%- if attr.rank == 0 %}
        subroutine {{attr.name}}_getter(ptr)
            class(typeio_t), pointer, intent(out) :: ptr

            nullify(ptr)
            if (allocated(this%{{attr.name}})) ptr => this%{{attr.name}}
        end subroutine
    {%- elif attr.rank == 1 %}
        subroutine {{attr.name}}_getter(ptr)
            class(typeio_t), pointer, intent(out) :: ptr(:)

            nullify(ptr)
            if (allocated(this%{{attr.name}})) ptr => this%{{attr.name}}
        end subroutine
    {%- endif %}
{%- endfor %}
    end subroutine


    subroutine deserialize(this, de, error)
        class({{module.type.name}}), target, intent(out) :: this
        class(deserializer_t), intent(inout) :: de
        class(error_t), allocatable, intent(out) :: error
{% for attr in module.type.attributes %}
    {%- if not attr.primitive and attr.allocatable %}
      {%- if attr.rank > 0 %}
        call de%read_allocatable_type_rank{{attr.rank}}('{{attr.name}}', {{attr.name}}_allocator, error)
      {%- else %}
        call de%read_allocatable_type('{{attr.name}}', {{attr.name}}_allocator, error)
      {%- endif %}
    {%- elif attr.allocatable %}
        call de%read_allocatable('{{attr.name}}', this%{{attr.name}}, error)
    {%- else %}
        call de%read('{{attr.name}}', this%{{attr.name}}, error)
    {%- endif %}
        if (allocated(error)) return
{%- endfor %}
    {%- set attrs = [] %}
{%- for attr in module.type.attributes if attr.allocatable and not attr.primitive %}
    {%- if attrs.append(attr) %}{% endif %}
{%- endfor %}
{%- if attrs|length > 0 %}
    contains
{%- endif %}
{%- for attr in attrs %}
    {%- if attr.rank == 0 %}
        subroutine {{attr.name}}_allocator(ptr)
            class(typeio_t), pointer, intent(out) :: ptr

            allocate(this%{{attr.name}})
            ptr => this%{{attr.name}}
        end subroutine
    {%- elif attr.rank == 1 %}
        subroutine {{attr.name}}_allocator(n1, ptr)
            integer(int64), intent(in) :: n1
            class(typeio_t), pointer, intent(out) :: ptr(:)

            allocate(this%{{attr.name}}(n1))
            ptr => this%{{attr.name}}
        end subroutine
    {%- endif %}
{%- endfor %}
    end subroutine

end module