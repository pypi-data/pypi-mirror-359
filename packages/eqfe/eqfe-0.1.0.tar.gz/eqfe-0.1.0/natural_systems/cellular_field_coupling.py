"""
Cellular Field Coupling Module

This module models how cellular structures generate and interact with
electromagnetic fields, potentially creating conditions for quantum
correlation amplification.

Based on the Environmental Quantum Field Effects amplification law:
A(φ,t) = exp[α⟨φ²⟩t - β∫₀ᵗ C(τ) dτ]

We explore how biological structures might naturally create field conditions
that enhance rather than destroy quantum correlations.
"""

import numpy as np
from typing import Dict
from dataclasses import dataclass

# Import our core framework
import sys
import os

sys.path.append(os.path.join(os.path.dirname(__file__), "..", "simulations"))

from simulations.core.field_simulator import EnvironmentalFieldSimulator


@dataclass
class CellularStructure:
    """Parameters for different cellular structures that couple to fields."""

    name: str
    characteristic_length: float  # meters
    membrane_potential: float  # volts
    ion_concentration: float  # mol/L
    oscillation_frequency: float  # Hz
    coherence_time: float  # seconds
    temperature: float = 310.0  # Kelvin (body temperature)


class CellularFieldCoupling:
    """
    Model electromagnetic field generation and coupling in cellular systems.

    This class explores how cellular structures might naturally create
    field conditions favorable for quantum correlation enhancement.
    """

    def __init__(self):
        """Initialize cellular field coupling simulator."""
        self.base_simulator = EnvironmentalFieldSimulator(
            field_mass=1e-12,  # Ultra-light field for biological systems
            coupling_strength=1e-5,  # Weak but non-negligible bio coupling
            temperature=310.0,  # Body temperature
        )

        # Define key cellular structures
        self.structures = {
            "microtubule": CellularStructure(
                name="microtubule",
                characteristic_length=25e-9,  # 25 nm diameter
                membrane_potential=-0.07,  # -70 mV resting potential
                ion_concentration=0.15,  # 150 mM typical
                oscillation_frequency=40,  # Gamma wave frequency
                coherence_time=1e-12,  # Picosecond coherence
            ),
            "membrane_interface": CellularStructure(
                name="membrane_interface",
                characteristic_length=5e-9,  # 5 nm membrane thickness
                membrane_potential=-0.07,
                ion_concentration=0.15,
                oscillation_frequency=10,  # Alpha wave frequency
                coherence_time=1e-15,  # Femtosecond coherence
            ),
            "mitochondria": CellularStructure(
                name="mitochondria",
                characteristic_length=1e-6,  # 1 micrometer
                membrane_potential=-0.18,  # -180 mV mitochondrial
                ion_concentration=0.1,
                oscillation_frequency=100,  # High frequency oscillations
                coherence_time=1e-13,  # Sub-picosecond coherence
            ),
        }

    def cellular_field_strength(
        self, structure: CellularStructure, distance: float
    ) -> np.ndarray:
        """
        Calculate electromagnetic field strength generated by
        cellular structure.

        Parameters:
        -----------
        structure : CellularStructure
            The cellular structure generating the field
        distance : float
            Distance from structure center (meters)

        Returns:
        --------
        np.ndarray : Field strength values
        """
        # Dipole field approximation for cellular structures
        # Field strength ∝ (membrane_potential * ion_concentration) / distance³

        dipole_moment = (
            structure.membrane_potential
            * structure.ion_concentration
            * structure.characteristic_length**3
        )

        # Add oscillatory component
        time_points = np.linspace(0, 1 / structure.oscillation_frequency, 1000)
        oscillation = np.sin(
            2 * np.pi * structure.oscillation_frequency * time_points
        )

        # Calculate field strength with 1/r³ dependence
        field_strength = (abs(dipole_moment) / distance**3) * oscillation

        # Add thermal fluctuations
        thermal_noise = self.base_simulator.thermal_field_fluctuations(
            len(time_points)
        )

        return field_strength + 0.1 * thermal_noise

    def quantum_amplification_potential(
        self, structure: CellularStructure
    ) -> Dict:
        """
        Assess potential for quantum correlation amplification in structure.

        Parameters:
        -----------
        structure : CellularStructure
            The cellular structure to analyze

        Returns:
        --------
        Dict : Analysis results including amplification factors and conditions
        """
        # Generate field at characteristic distance
        distance = structure.characteristic_length
        field_data = self.cellular_field_strength(structure, distance)

        # Calculate amplification using our core framework
        amplification = self.base_simulator.amplification_factor(
            field_data, structure.coherence_time
        )

        # Analyze enhancement vs decoherence competition
        field_variance = np.var(field_data)
        alpha = self.base_simulator.alpha
        beta = self.base_simulator.beta

        enhancement_term = alpha * field_variance * structure.coherence_time
        decoherence_term = beta * field_variance * structure.coherence_time

        net_effect = enhancement_term - decoherence_term

        # Determine if structure favors quantum correlation enhancement
        amplification_favorable = net_effect > 0

        return {
            "structure_name": structure.name,
            "mean_amplification": np.mean(amplification),
            "max_amplification": np.max(amplification),
            "field_variance": field_variance,
            "enhancement_term": enhancement_term,
            "decoherence_term": decoherence_term,
            "net_effect": net_effect,
            "amplification_favorable": amplification_favorable,
            "optimal_frequency": structure.oscillation_frequency,
            "coherence_time": structure.coherence_time,
        }

    def evolutionary_optimization_analysis(self) -> Dict:
        """
        Analyze which cellular structures are optimized for
        quantum amplification.

        This explores whether evolution might have selected for structures
        that enhance quantum correlations through field coupling.

        Returns:
        --------
        Dict : Comparative analysis of cellular structures
        """
        results = {}

        for structure_name, structure in self.structures.items():
            analysis = self.quantum_amplification_potential(structure)
            results[structure_name] = analysis

        # Find the most promising structure for quantum amplification
        best_structure = max(
            results.keys(), key=lambda x: results[x]["net_effect"]
        )

        # Calculate relative enhancement potentials
        net_effects = [results[name]["net_effect"] for name in results.keys()]
        mean_net_effect = np.mean(net_effects)

        evolutionary_insights = {
            "best_amplifier": best_structure,
            "best_net_effect": results[best_structure]["net_effect"],
            "structure_rankings": sorted(
                results.keys(),
                key=lambda x: results[x]["net_effect"],
                reverse=True,
            ),
            "mean_net_effect": mean_net_effect,
            "amplification_structures": [
                name
                for name, data in results.items()
                if data["amplification_favorable"]
            ],
            "evolutionary_pressure": mean_net_effect
            > 0,  # Selection for amplification
        }

        return {
            "individual_analyses": results,
            "evolutionary_insights": evolutionary_insights,
        }

    def biological_field_engineering(
        self, target_amplification: float
    ) -> Dict:
        """
        Determine what biological parameters would achieve target amplification.

        This explores how biological systems might 'engineer' their field
        environment to achieve specific quantum correlation enhancement.

        Parameters:
        -----------
        target_amplification : float
            Desired amplification factor

        Returns:
        --------
        Dict : Optimal biological parameters for target amplification
        """
        optimal_params = {}

        # Search parameter space for optimal biological configuration
        frequencies = np.logspace(0, 3, 50)  # 1 Hz to 1 kHz
        coherence_times = np.logspace(-15, -9, 50)  # fs to ns

        best_params = None
        best_match = float("inf")

        for freq in frequencies:
            for coh_time in coherence_times:
                # Create test structure
                test_structure = CellularStructure(
                    name="optimized",
                    characteristic_length=25e-9,
                    membrane_potential=-0.07,
                    ion_concentration=0.15,
                    oscillation_frequency=freq,
                    coherence_time=coh_time,
                )

                analysis = self.quantum_amplification_potential(test_structure)

                # Check how close we get to target
                match_quality = abs(
                    analysis["mean_amplification"] - target_amplification
                )

                if match_quality < best_match:
                    best_match = match_quality
                    best_params = {
                        "frequency": freq,
                        "coherence_time": coh_time,
                        "achieved_amplification": analysis[
                            "mean_amplification"
                        ],
                        "net_effect": analysis["net_effect"],
                    }

        return {
            "target_amplification": target_amplification,
            "optimal_parameters": best_params,
            "match_quality": best_match,
            "engineering_feasible": best_match < 0.1 * target_amplification,
        }


def analyze_cellular_quantum_amplification():
    """
    Analyze quantum amplification potential in cellular systems.

    This function demonstrates how to use the cellular field coupling framework
    to explore natural quantum amplification.
    """
    print("Cellular Quantum Amplification Analysis")
    print("=" * 50)

    coupling = CellularFieldCoupling()

    # Analyze evolutionary optimization
    evolution_analysis = coupling.evolutionary_optimization_analysis()

    print("\nEvolutionary Optimization Results:")
    evo_insights = evolution_analysis['evolutionary_insights']
    print(
        f"Best quantum amplifier: "
        f"{evo_insights['best_amplifier']}"
    )
    amplification_structures = evo_insights['amplification_structures']
    print(
        f"Structures favoring amplification: "
        f"{amplification_structures}"
    )
    evolutionary_pressure = evo_insights['evolutionary_pressure']
    print(
        f"Evidence for evolutionary pressure: "
        f"{evolutionary_pressure}"
    )

    # Detailed analysis of each structure
    print("\nDetailed Structure Analysis:")
    for name, analysis in evolution_analysis["individual_analyses"].items():
        print(f"\n{name.upper()}:")
        print(f"  Mean amplification: {analysis['mean_amplification']:.4f}")
        print(f"  Net effect: {analysis['net_effect']:.6e}")
        print(
            f"  Amplification favorable: {analysis['amplification_favorable']}"
        )

    # Biological field engineering
    print("\nBiological Field Engineering Analysis:")
    target_amps = [1.01, 1.05, 1.1, 1.2]

    for target in target_amps:
        engineering = coupling.biological_field_engineering(target)
        print(f"\nTarget amplification {target}:")
        if engineering["engineering_feasible"]:
            params = engineering["optimal_parameters"]
            print(f"  Optimal frequency: {params['frequency']:.2f} Hz")
            print(
                f"  Optimal coherence time: {params['coherence_time']:.2e} s"
            )
            achieved_amp = params['achieved_amplification']
            print(f"  Achieved amplification: {achieved_amp:.4f}")
        else:
            print("  Target not feasible with biological parameters")


if __name__ == "__main__":
    analyze_cellular_quantum_amplification()
