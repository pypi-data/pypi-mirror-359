# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gstlearn
else:
    import _gstlearn

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_SwigPyIterator

    def value(self):
        return _gstlearn.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gstlearn.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gstlearn.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gstlearn.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gstlearn.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gstlearn.SwigPyIterator_copy(self)

    def next(self):
        return _gstlearn.SwigPyIterator_next(self)

    def __next__(self):
        return _gstlearn.SwigPyIterator___next__(self)

    def previous(self):
        return _gstlearn.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gstlearn.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gstlearn.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gstlearn.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gstlearn.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gstlearn.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gstlearn.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gstlearn.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _gstlearn:
_gstlearn.SwigPyIterator_swigregister(SwigPyIterator)
class DoNotUseVectorIntStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorIntStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorIntStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorIntStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorIntStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorIntStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorIntStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorIntStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorIntStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorIntStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorIntStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorIntStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorIntStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorIntStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorIntStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorIntStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorIntStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorIntStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorIntStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorIntStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorIntStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorIntStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorIntStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorIntStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorIntStd_swiginit(self, _gstlearn.new_DoNotUseVectorIntStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorIntStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorIntStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorIntStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorIntStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorIntStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorIntStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorIntStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorIntStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorIntStd

# Register DoNotUseVectorIntStd in _gstlearn:
_gstlearn.DoNotUseVectorIntStd_swigregister(DoNotUseVectorIntStd)
class DoNotUseVectorSizeT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorSizeT_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorSizeT___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorSizeT___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorSizeT___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorSizeT___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorSizeT___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorSizeT___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorSizeT___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorSizeT___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorSizeT___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorSizeT_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorSizeT_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorSizeT_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorSizeT_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorSizeT_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorSizeT_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorSizeT_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorSizeT_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorSizeT_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorSizeT_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorSizeT_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorSizeT_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorSizeT_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorSizeT_swiginit(self, _gstlearn.new_DoNotUseVectorSizeT(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorSizeT_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorSizeT_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorSizeT_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorSizeT_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorSizeT_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorSizeT_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorSizeT_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorSizeT_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorSizeT

# Register DoNotUseVectorSizeT in _gstlearn:
_gstlearn.DoNotUseVectorSizeT_swigregister(DoNotUseVectorSizeT)
class DoNotUseVectorDoubleStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorDoubleStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorDoubleStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorDoubleStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorDoubleStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorDoubleStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorDoubleStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorDoubleStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorDoubleStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorDoubleStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorDoubleStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorDoubleStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorDoubleStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorDoubleStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorDoubleStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorDoubleStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorDoubleStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorDoubleStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorDoubleStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorDoubleStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorDoubleStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorDoubleStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorDoubleStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorDoubleStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorDoubleStd_swiginit(self, _gstlearn.new_DoNotUseVectorDoubleStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorDoubleStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorDoubleStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorDoubleStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorDoubleStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorDoubleStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorDoubleStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorDoubleStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorDoubleStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorDoubleStd

# Register DoNotUseVectorDoubleStd in _gstlearn:
_gstlearn.DoNotUseVectorDoubleStd_swigregister(DoNotUseVectorDoubleStd)
class DoNotUseVectorStringStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorStringStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorStringStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorStringStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorStringStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorStringStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorStringStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorStringStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorStringStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorStringStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorStringStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorStringStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorStringStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorStringStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorStringStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorStringStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorStringStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorStringStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorStringStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorStringStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorStringStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorStringStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorStringStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorStringStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorStringStd_swiginit(self, _gstlearn.new_DoNotUseVectorStringStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorStringStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorStringStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorStringStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorStringStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorStringStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorStringStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorStringStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorStringStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorStringStd

# Register DoNotUseVectorStringStd in _gstlearn:
_gstlearn.DoNotUseVectorStringStd_swigregister(DoNotUseVectorStringStd)
class DoNotUseVectorFloatStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorFloatStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorFloatStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorFloatStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorFloatStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorFloatStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorFloatStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorFloatStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorFloatStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorFloatStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorFloatStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorFloatStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorFloatStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorFloatStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorFloatStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorFloatStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorFloatStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorFloatStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorFloatStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorFloatStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorFloatStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorFloatStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorFloatStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorFloatStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorFloatStd_swiginit(self, _gstlearn.new_DoNotUseVectorFloatStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorFloatStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorFloatStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorFloatStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorFloatStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorFloatStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorFloatStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorFloatStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorFloatStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorFloatStd

# Register DoNotUseVectorFloatStd in _gstlearn:
_gstlearn.DoNotUseVectorFloatStd_swigregister(DoNotUseVectorFloatStd)
class DoNotUseVectorUCharStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorUCharStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorUCharStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorUCharStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorUCharStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorUCharStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorUCharStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorUCharStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorUCharStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorUCharStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorUCharStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorUCharStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorUCharStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorUCharStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorUCharStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorUCharStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorUCharStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorUCharStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorUCharStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorUCharStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorUCharStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorUCharStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorUCharStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorUCharStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorUCharStd_swiginit(self, _gstlearn.new_DoNotUseVectorUCharStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorUCharStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorUCharStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorUCharStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorUCharStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorUCharStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorUCharStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorUCharStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorUCharStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorUCharStd

# Register DoNotUseVectorUCharStd in _gstlearn:
_gstlearn.DoNotUseVectorUCharStd_swigregister(DoNotUseVectorUCharStd)
class DoNotUseVectorBoolStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVectorBoolStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVectorBoolStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVectorBoolStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVectorBoolStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVectorBoolStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVectorBoolStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVectorBoolStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVectorBoolStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVectorBoolStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVectorBoolStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVectorBoolStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVectorBoolStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVectorBoolStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVectorBoolStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVectorBoolStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVectorBoolStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVectorBoolStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVectorBoolStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVectorBoolStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVectorBoolStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVectorBoolStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVectorBoolStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVectorBoolStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVectorBoolStd_swiginit(self, _gstlearn.new_DoNotUseVectorBoolStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVectorBoolStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVectorBoolStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVectorBoolStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVectorBoolStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVectorBoolStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVectorBoolStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVectorBoolStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVectorBoolStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVectorBoolStd

# Register DoNotUseVectorBoolStd in _gstlearn:
_gstlearn.DoNotUseVectorBoolStd_swigregister(DoNotUseVectorBoolStd)
class DoNotUseVVectorIntStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVVectorIntStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVVectorIntStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVVectorIntStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVVectorIntStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVVectorIntStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVVectorIntStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVVectorIntStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVVectorIntStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVVectorIntStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVVectorIntStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVVectorIntStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVVectorIntStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVVectorIntStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVVectorIntStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVVectorIntStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVVectorIntStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVVectorIntStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVVectorIntStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVVectorIntStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVVectorIntStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVVectorIntStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVVectorIntStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVVectorIntStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVVectorIntStd_swiginit(self, _gstlearn.new_DoNotUseVVectorIntStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVVectorIntStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVVectorIntStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVVectorIntStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVVectorIntStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVVectorIntStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVVectorIntStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVVectorIntStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVVectorIntStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVVectorIntStd

# Register DoNotUseVVectorIntStd in _gstlearn:
_gstlearn.DoNotUseVVectorIntStd_swigregister(DoNotUseVVectorIntStd)
class DoNotUseVVectorDoubleStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVVectorDoubleStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVVectorDoubleStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVVectorDoubleStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVVectorDoubleStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVVectorDoubleStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVVectorDoubleStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVVectorDoubleStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVVectorDoubleStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVVectorDoubleStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVVectorDoubleStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVVectorDoubleStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVVectorDoubleStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVVectorDoubleStd_swiginit(self, _gstlearn.new_DoNotUseVVectorDoubleStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVVectorDoubleStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVVectorDoubleStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVVectorDoubleStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVVectorDoubleStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVVectorDoubleStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVVectorDoubleStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVVectorDoubleStd

# Register DoNotUseVVectorDoubleStd in _gstlearn:
_gstlearn.DoNotUseVVectorDoubleStd_swigregister(DoNotUseVVectorDoubleStd)
class DoNotUseVVectorFloatStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.DoNotUseVVectorFloatStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.DoNotUseVVectorFloatStd___nonzero__(self)

    def __bool__(self):
        return _gstlearn.DoNotUseVVectorFloatStd___bool__(self)

    def __len__(self):
        return _gstlearn.DoNotUseVVectorFloatStd___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.DoNotUseVVectorFloatStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.DoNotUseVVectorFloatStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.DoNotUseVVectorFloatStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.DoNotUseVVectorFloatStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.DoNotUseVVectorFloatStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.DoNotUseVVectorFloatStd___setitem__(self, *args)

    def pop(self):
        return _gstlearn.DoNotUseVVectorFloatStd_pop(self)

    def append(self, x):
        return _gstlearn.DoNotUseVVectorFloatStd_append(self, x)

    def empty(self):
        return _gstlearn.DoNotUseVVectorFloatStd_empty(self)

    def size(self):
        return _gstlearn.DoNotUseVVectorFloatStd_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.DoNotUseVVectorFloatStd_swap(self, v)

    def begin(self):
        return _gstlearn.DoNotUseVVectorFloatStd_begin(self)

    def end(self):
        return _gstlearn.DoNotUseVVectorFloatStd_end(self)

    def rbegin(self):
        return _gstlearn.DoNotUseVVectorFloatStd_rbegin(self)

    def rend(self):
        return _gstlearn.DoNotUseVVectorFloatStd_rend(self)

    def clear(self):
        return _gstlearn.DoNotUseVVectorFloatStd_clear(self)

    def get_allocator(self):
        return _gstlearn.DoNotUseVVectorFloatStd_get_allocator(self)

    def pop_back(self):
        return _gstlearn.DoNotUseVVectorFloatStd_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.DoNotUseVVectorFloatStd_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.DoNotUseVVectorFloatStd_swiginit(self, _gstlearn.new_DoNotUseVVectorFloatStd(*args))

    def push_back(self, x):
        return _gstlearn.DoNotUseVVectorFloatStd_push_back(self, x)

    def front(self):
        return _gstlearn.DoNotUseVVectorFloatStd_front(self)

    def back(self):
        return _gstlearn.DoNotUseVVectorFloatStd_back(self)

    def assign(self, n, x):
        return _gstlearn.DoNotUseVVectorFloatStd_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.DoNotUseVVectorFloatStd_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.DoNotUseVVectorFloatStd_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.DoNotUseVVectorFloatStd_reserve(self, n)

    def capacity(self):
        return _gstlearn.DoNotUseVVectorFloatStd_capacity(self)
    __swig_destroy__ = _gstlearn.delete_DoNotUseVVectorFloatStd

# Register DoNotUseVVectorFloatStd in _gstlearn:
_gstlearn.DoNotUseVVectorFloatStd_swigregister(DoNotUseVVectorFloatStd)
class VectorECov(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorECov_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorECov___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorECov___bool__(self)

    def __len__(self):
        return _gstlearn.VectorECov___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorECov___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorECov___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorECov___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorECov___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorECov___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorECov___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorECov_pop(self)

    def append(self, x):
        return _gstlearn.VectorECov_append(self, x)

    def empty(self):
        return _gstlearn.VectorECov_empty(self)

    def size(self):
        return _gstlearn.VectorECov_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorECov_swap(self, v)

    def begin(self):
        return _gstlearn.VectorECov_begin(self)

    def end(self):
        return _gstlearn.VectorECov_end(self)

    def rbegin(self):
        return _gstlearn.VectorECov_rbegin(self)

    def rend(self):
        return _gstlearn.VectorECov_rend(self)

    def clear(self):
        return _gstlearn.VectorECov_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorECov_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorECov_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorECov_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorECov_swiginit(self, _gstlearn.new_VectorECov(*args))

    def push_back(self, x):
        return _gstlearn.VectorECov_push_back(self, x)

    def front(self):
        return _gstlearn.VectorECov_front(self)

    def back(self):
        return _gstlearn.VectorECov_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorECov_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorECov_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorECov_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorECov_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorECov_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorECov

# Register VectorECov in _gstlearn:
_gstlearn.VectorECov_swigregister(VectorECov)
class VectorEStatOption(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorEStatOption_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorEStatOption___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorEStatOption___bool__(self)

    def __len__(self):
        return _gstlearn.VectorEStatOption___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorEStatOption___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorEStatOption___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorEStatOption___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorEStatOption___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorEStatOption___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorEStatOption___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorEStatOption_pop(self)

    def append(self, x):
        return _gstlearn.VectorEStatOption_append(self, x)

    def empty(self):
        return _gstlearn.VectorEStatOption_empty(self)

    def size(self):
        return _gstlearn.VectorEStatOption_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorEStatOption_swap(self, v)

    def begin(self):
        return _gstlearn.VectorEStatOption_begin(self)

    def end(self):
        return _gstlearn.VectorEStatOption_end(self)

    def rbegin(self):
        return _gstlearn.VectorEStatOption_rbegin(self)

    def rend(self):
        return _gstlearn.VectorEStatOption_rend(self)

    def clear(self):
        return _gstlearn.VectorEStatOption_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorEStatOption_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorEStatOption_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorEStatOption_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorEStatOption_swiginit(self, _gstlearn.new_VectorEStatOption(*args))

    def push_back(self, x):
        return _gstlearn.VectorEStatOption_push_back(self, x)

    def front(self):
        return _gstlearn.VectorEStatOption_front(self)

    def back(self):
        return _gstlearn.VectorEStatOption_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorEStatOption_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorEStatOption_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorEStatOption_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorEStatOption_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorEStatOption_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorEStatOption

# Register VectorEStatOption in _gstlearn:
_gstlearn.VectorEStatOption_swigregister(VectorEStatOption)
class VectorESelectivity(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorESelectivity_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorESelectivity___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorESelectivity___bool__(self)

    def __len__(self):
        return _gstlearn.VectorESelectivity___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorESelectivity___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorESelectivity___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorESelectivity___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorESelectivity___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorESelectivity___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorESelectivity___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorESelectivity_pop(self)

    def append(self, x):
        return _gstlearn.VectorESelectivity_append(self, x)

    def empty(self):
        return _gstlearn.VectorESelectivity_empty(self)

    def size(self):
        return _gstlearn.VectorESelectivity_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorESelectivity_swap(self, v)

    def begin(self):
        return _gstlearn.VectorESelectivity_begin(self)

    def end(self):
        return _gstlearn.VectorESelectivity_end(self)

    def rbegin(self):
        return _gstlearn.VectorESelectivity_rbegin(self)

    def rend(self):
        return _gstlearn.VectorESelectivity_rend(self)

    def clear(self):
        return _gstlearn.VectorESelectivity_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorESelectivity_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorESelectivity_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorESelectivity_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorESelectivity_swiginit(self, _gstlearn.new_VectorESelectivity(*args))

    def push_back(self, x):
        return _gstlearn.VectorESelectivity_push_back(self, x)

    def front(self):
        return _gstlearn.VectorESelectivity_front(self)

    def back(self):
        return _gstlearn.VectorESelectivity_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorESelectivity_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorESelectivity_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorESelectivity_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorESelectivity_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorESelectivity_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorESelectivity

# Register VectorESelectivity in _gstlearn:
_gstlearn.VectorESelectivity_swigregister(VectorESelectivity)
class VectorDirParam(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorDirParam_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorDirParam___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorDirParam___bool__(self)

    def __len__(self):
        return _gstlearn.VectorDirParam___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorDirParam___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorDirParam___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorDirParam___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorDirParam___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorDirParam___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorDirParam___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorDirParam_pop(self)

    def append(self, x):
        return _gstlearn.VectorDirParam_append(self, x)

    def empty(self):
        return _gstlearn.VectorDirParam_empty(self)

    def size(self):
        return _gstlearn.VectorDirParam_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorDirParam_swap(self, v)

    def begin(self):
        return _gstlearn.VectorDirParam_begin(self)

    def end(self):
        return _gstlearn.VectorDirParam_end(self)

    def rbegin(self):
        return _gstlearn.VectorDirParam_rbegin(self)

    def rend(self):
        return _gstlearn.VectorDirParam_rend(self)

    def clear(self):
        return _gstlearn.VectorDirParam_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorDirParam_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorDirParam_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorDirParam_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorDirParam_swiginit(self, _gstlearn.new_VectorDirParam(*args))

    def push_back(self, x):
        return _gstlearn.VectorDirParam_push_back(self, x)

    def front(self):
        return _gstlearn.VectorDirParam_front(self)

    def back(self):
        return _gstlearn.VectorDirParam_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorDirParam_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorDirParam_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorDirParam_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorDirParam_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorDirParam_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorDirParam

# Register VectorDirParam in _gstlearn:
_gstlearn.VectorDirParam_swigregister(VectorDirParam)
class VectorPolyElem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorPolyElem_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorPolyElem___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorPolyElem___bool__(self)

    def __len__(self):
        return _gstlearn.VectorPolyElem___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorPolyElem___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorPolyElem___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorPolyElem___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorPolyElem___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorPolyElem___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorPolyElem___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorPolyElem_pop(self)

    def append(self, x):
        return _gstlearn.VectorPolyElem_append(self, x)

    def empty(self):
        return _gstlearn.VectorPolyElem_empty(self)

    def size(self):
        return _gstlearn.VectorPolyElem_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorPolyElem_swap(self, v)

    def begin(self):
        return _gstlearn.VectorPolyElem_begin(self)

    def end(self):
        return _gstlearn.VectorPolyElem_end(self)

    def rbegin(self):
        return _gstlearn.VectorPolyElem_rbegin(self)

    def rend(self):
        return _gstlearn.VectorPolyElem_rend(self)

    def clear(self):
        return _gstlearn.VectorPolyElem_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorPolyElem_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorPolyElem_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorPolyElem_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorPolyElem_swiginit(self, _gstlearn.new_VectorPolyElem(*args))

    def push_back(self, x):
        return _gstlearn.VectorPolyElem_push_back(self, x)

    def front(self):
        return _gstlearn.VectorPolyElem_front(self)

    def back(self):
        return _gstlearn.VectorPolyElem_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorPolyElem_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorPolyElem_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorPolyElem_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorPolyElem_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorPolyElem_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorPolyElem

# Register VectorPolyElem in _gstlearn:
_gstlearn.VectorPolyElem_swigregister(VectorPolyElem)
class VectorInterval(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorInterval_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorInterval___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorInterval___bool__(self)

    def __len__(self):
        return _gstlearn.VectorInterval___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorInterval___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorInterval___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorInterval___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorInterval___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorInterval___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorInterval___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorInterval_pop(self)

    def append(self, x):
        return _gstlearn.VectorInterval_append(self, x)

    def empty(self):
        return _gstlearn.VectorInterval_empty(self)

    def size(self):
        return _gstlearn.VectorInterval_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorInterval_swap(self, v)

    def begin(self):
        return _gstlearn.VectorInterval_begin(self)

    def end(self):
        return _gstlearn.VectorInterval_end(self)

    def rbegin(self):
        return _gstlearn.VectorInterval_rbegin(self)

    def rend(self):
        return _gstlearn.VectorInterval_rend(self)

    def clear(self):
        return _gstlearn.VectorInterval_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorInterval_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorInterval_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorInterval_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorInterval_swiginit(self, _gstlearn.new_VectorInterval(*args))

    def push_back(self, x):
        return _gstlearn.VectorInterval_push_back(self, x)

    def front(self):
        return _gstlearn.VectorInterval_front(self)

    def back(self):
        return _gstlearn.VectorInterval_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorInterval_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorInterval_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorInterval_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorInterval_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorInterval_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorInterval

# Register VectorInterval in _gstlearn:
_gstlearn.VectorInterval_swigregister(VectorInterval)
class VectorEPostStat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorEPostStat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorEPostStat___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorEPostStat___bool__(self)

    def __len__(self):
        return _gstlearn.VectorEPostStat___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorEPostStat___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorEPostStat___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorEPostStat___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorEPostStat___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorEPostStat___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorEPostStat___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorEPostStat_pop(self)

    def append(self, x):
        return _gstlearn.VectorEPostStat_append(self, x)

    def empty(self):
        return _gstlearn.VectorEPostStat_empty(self)

    def size(self):
        return _gstlearn.VectorEPostStat_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorEPostStat_swap(self, v)

    def begin(self):
        return _gstlearn.VectorEPostStat_begin(self)

    def end(self):
        return _gstlearn.VectorEPostStat_end(self)

    def rbegin(self):
        return _gstlearn.VectorEPostStat_rbegin(self)

    def rend(self):
        return _gstlearn.VectorEPostStat_rend(self)

    def clear(self):
        return _gstlearn.VectorEPostStat_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorEPostStat_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorEPostStat_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorEPostStat_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorEPostStat_swiginit(self, _gstlearn.new_VectorEPostStat(*args))

    def push_back(self, x):
        return _gstlearn.VectorEPostStat_push_back(self, x)

    def front(self):
        return _gstlearn.VectorEPostStat_front(self)

    def back(self):
        return _gstlearn.VectorEPostStat_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorEPostStat_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorEPostStat_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorEPostStat_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorEPostStat_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorEPostStat_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorEPostStat

# Register VectorEPostStat in _gstlearn:
_gstlearn.VectorEPostStat_swigregister(VectorEPostStat)
class VectorSpacePoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorSpacePoint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorSpacePoint___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorSpacePoint___bool__(self)

    def __len__(self):
        return _gstlearn.VectorSpacePoint___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorSpacePoint___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorSpacePoint___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorSpacePoint___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorSpacePoint___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorSpacePoint___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorSpacePoint___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorSpacePoint_pop(self)

    def append(self, x):
        return _gstlearn.VectorSpacePoint_append(self, x)

    def empty(self):
        return _gstlearn.VectorSpacePoint_empty(self)

    def size(self):
        return _gstlearn.VectorSpacePoint_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorSpacePoint_swap(self, v)

    def begin(self):
        return _gstlearn.VectorSpacePoint_begin(self)

    def end(self):
        return _gstlearn.VectorSpacePoint_end(self)

    def rbegin(self):
        return _gstlearn.VectorSpacePoint_rbegin(self)

    def rend(self):
        return _gstlearn.VectorSpacePoint_rend(self)

    def clear(self):
        return _gstlearn.VectorSpacePoint_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorSpacePoint_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorSpacePoint_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorSpacePoint_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorSpacePoint_swiginit(self, _gstlearn.new_VectorSpacePoint(*args))

    def push_back(self, x):
        return _gstlearn.VectorSpacePoint_push_back(self, x)

    def front(self):
        return _gstlearn.VectorSpacePoint_front(self)

    def back(self):
        return _gstlearn.VectorSpacePoint_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorSpacePoint_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorSpacePoint_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorSpacePoint_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorSpacePoint_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorSpacePoint_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorSpacePoint

# Register VectorSpacePoint in _gstlearn:
_gstlearn.VectorSpacePoint_swigregister(VectorSpacePoint)
class VectorABiTargetCheck(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorABiTargetCheck_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorABiTargetCheck___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorABiTargetCheck___bool__(self)

    def __len__(self):
        return _gstlearn.VectorABiTargetCheck___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorABiTargetCheck___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorABiTargetCheck___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorABiTargetCheck___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorABiTargetCheck___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorABiTargetCheck___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorABiTargetCheck___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorABiTargetCheck_pop(self)

    def append(self, x):
        return _gstlearn.VectorABiTargetCheck_append(self, x)

    def empty(self):
        return _gstlearn.VectorABiTargetCheck_empty(self)

    def size(self):
        return _gstlearn.VectorABiTargetCheck_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorABiTargetCheck_swap(self, v)

    def begin(self):
        return _gstlearn.VectorABiTargetCheck_begin(self)

    def end(self):
        return _gstlearn.VectorABiTargetCheck_end(self)

    def rbegin(self):
        return _gstlearn.VectorABiTargetCheck_rbegin(self)

    def rend(self):
        return _gstlearn.VectorABiTargetCheck_rend(self)

    def clear(self):
        return _gstlearn.VectorABiTargetCheck_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorABiTargetCheck_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorABiTargetCheck_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorABiTargetCheck_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorABiTargetCheck_swiginit(self, _gstlearn.new_VectorABiTargetCheck(*args))

    def push_back(self, x):
        return _gstlearn.VectorABiTargetCheck_push_back(self, x)

    def front(self):
        return _gstlearn.VectorABiTargetCheck_front(self)

    def back(self):
        return _gstlearn.VectorABiTargetCheck_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorABiTargetCheck_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorABiTargetCheck_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorABiTargetCheck_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorABiTargetCheck_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorABiTargetCheck_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorABiTargetCheck

# Register VectorABiTargetCheck in _gstlearn:
_gstlearn.VectorABiTargetCheck_swigregister(VectorABiTargetCheck)
class VectorProjMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorProjMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorProjMatrix___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorProjMatrix___bool__(self)

    def __len__(self):
        return _gstlearn.VectorProjMatrix___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorProjMatrix___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorProjMatrix___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorProjMatrix___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorProjMatrix___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorProjMatrix___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorProjMatrix___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorProjMatrix_pop(self)

    def append(self, x):
        return _gstlearn.VectorProjMatrix_append(self, x)

    def empty(self):
        return _gstlearn.VectorProjMatrix_empty(self)

    def size(self):
        return _gstlearn.VectorProjMatrix_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorProjMatrix_swap(self, v)

    def begin(self):
        return _gstlearn.VectorProjMatrix_begin(self)

    def end(self):
        return _gstlearn.VectorProjMatrix_end(self)

    def rbegin(self):
        return _gstlearn.VectorProjMatrix_rbegin(self)

    def rend(self):
        return _gstlearn.VectorProjMatrix_rend(self)

    def clear(self):
        return _gstlearn.VectorProjMatrix_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorProjMatrix_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorProjMatrix_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorProjMatrix_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorProjMatrix_swiginit(self, _gstlearn.new_VectorProjMatrix(*args))

    def push_back(self, x):
        return _gstlearn.VectorProjMatrix_push_back(self, x)

    def front(self):
        return _gstlearn.VectorProjMatrix_front(self)

    def back(self):
        return _gstlearn.VectorProjMatrix_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorProjMatrix_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorProjMatrix_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorProjMatrix_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorProjMatrix_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorProjMatrix_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorProjMatrix

# Register VectorProjMatrix in _gstlearn:
_gstlearn.VectorProjMatrix_swigregister(VectorProjMatrix)
class VectorConstProjMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorConstProjMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorConstProjMatrix___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorConstProjMatrix___bool__(self)

    def __len__(self):
        return _gstlearn.VectorConstProjMatrix___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorConstProjMatrix___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorConstProjMatrix___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorConstProjMatrix___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorConstProjMatrix___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorConstProjMatrix___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorConstProjMatrix___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorConstProjMatrix_pop(self)

    def append(self, x):
        return _gstlearn.VectorConstProjMatrix_append(self, x)

    def empty(self):
        return _gstlearn.VectorConstProjMatrix_empty(self)

    def size(self):
        return _gstlearn.VectorConstProjMatrix_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorConstProjMatrix_swap(self, v)

    def begin(self):
        return _gstlearn.VectorConstProjMatrix_begin(self)

    def end(self):
        return _gstlearn.VectorConstProjMatrix_end(self)

    def rbegin(self):
        return _gstlearn.VectorConstProjMatrix_rbegin(self)

    def rend(self):
        return _gstlearn.VectorConstProjMatrix_rend(self)

    def clear(self):
        return _gstlearn.VectorConstProjMatrix_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorConstProjMatrix_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorConstProjMatrix_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorConstProjMatrix_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorConstProjMatrix_swiginit(self, _gstlearn.new_VectorConstProjMatrix(*args))

    def push_back(self, x):
        return _gstlearn.VectorConstProjMatrix_push_back(self, x)

    def front(self):
        return _gstlearn.VectorConstProjMatrix_front(self)

    def back(self):
        return _gstlearn.VectorConstProjMatrix_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorConstProjMatrix_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorConstProjMatrix_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorConstProjMatrix_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorConstProjMatrix_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorConstProjMatrix_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorConstProjMatrix

# Register VectorConstProjMatrix in _gstlearn:
_gstlearn.VectorConstProjMatrix_swigregister(VectorConstProjMatrix)
class VectorConstIProj(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorConstIProj_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorConstIProj___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorConstIProj___bool__(self)

    def __len__(self):
        return _gstlearn.VectorConstIProj___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorConstIProj___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorConstIProj___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorConstIProj___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorConstIProj___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorConstIProj___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorConstIProj___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorConstIProj_pop(self)

    def append(self, x):
        return _gstlearn.VectorConstIProj_append(self, x)

    def empty(self):
        return _gstlearn.VectorConstIProj_empty(self)

    def size(self):
        return _gstlearn.VectorConstIProj_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorConstIProj_swap(self, v)

    def begin(self):
        return _gstlearn.VectorConstIProj_begin(self)

    def end(self):
        return _gstlearn.VectorConstIProj_end(self)

    def rbegin(self):
        return _gstlearn.VectorConstIProj_rbegin(self)

    def rend(self):
        return _gstlearn.VectorConstIProj_rend(self)

    def clear(self):
        return _gstlearn.VectorConstIProj_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorConstIProj_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorConstIProj_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorConstIProj_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorConstIProj_swiginit(self, _gstlearn.new_VectorConstIProj(*args))

    def push_back(self, x):
        return _gstlearn.VectorConstIProj_push_back(self, x)

    def front(self):
        return _gstlearn.VectorConstIProj_front(self)

    def back(self):
        return _gstlearn.VectorConstIProj_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorConstIProj_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorConstIProj_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorConstIProj_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorConstIProj_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorConstIProj_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorConstIProj

# Register VectorConstIProj in _gstlearn:
_gstlearn.VectorConstIProj_swigregister(VectorConstIProj)
class VVectorConstProjMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VVectorConstProjMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VVectorConstProjMatrix___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VVectorConstProjMatrix___bool__(self)

    def __len__(self):
        return _gstlearn.VVectorConstProjMatrix___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VVectorConstProjMatrix___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VVectorConstProjMatrix___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VVectorConstProjMatrix___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VVectorConstProjMatrix___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VVectorConstProjMatrix___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VVectorConstProjMatrix___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VVectorConstProjMatrix_pop(self)

    def append(self, x):
        return _gstlearn.VVectorConstProjMatrix_append(self, x)

    def empty(self):
        return _gstlearn.VVectorConstProjMatrix_empty(self)

    def size(self):
        return _gstlearn.VVectorConstProjMatrix_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VVectorConstProjMatrix_swap(self, v)

    def begin(self):
        return _gstlearn.VVectorConstProjMatrix_begin(self)

    def end(self):
        return _gstlearn.VVectorConstProjMatrix_end(self)

    def rbegin(self):
        return _gstlearn.VVectorConstProjMatrix_rbegin(self)

    def rend(self):
        return _gstlearn.VVectorConstProjMatrix_rend(self)

    def clear(self):
        return _gstlearn.VVectorConstProjMatrix_clear(self)

    def get_allocator(self):
        return _gstlearn.VVectorConstProjMatrix_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VVectorConstProjMatrix_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VVectorConstProjMatrix_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VVectorConstProjMatrix_swiginit(self, _gstlearn.new_VVectorConstProjMatrix(*args))

    def push_back(self, x):
        return _gstlearn.VVectorConstProjMatrix_push_back(self, x)

    def front(self):
        return _gstlearn.VVectorConstProjMatrix_front(self)

    def back(self):
        return _gstlearn.VVectorConstProjMatrix_back(self)

    def assign(self, n, x):
        return _gstlearn.VVectorConstProjMatrix_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VVectorConstProjMatrix_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VVectorConstProjMatrix_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VVectorConstProjMatrix_reserve(self, n)

    def capacity(self):
        return _gstlearn.VVectorConstProjMatrix_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VVectorConstProjMatrix

# Register VVectorConstProjMatrix in _gstlearn:
_gstlearn.VVectorConstProjMatrix_swigregister(VVectorConstProjMatrix)
class VVectorConstIProj(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VVectorConstIProj_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VVectorConstIProj___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VVectorConstIProj___bool__(self)

    def __len__(self):
        return _gstlearn.VVectorConstIProj___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VVectorConstIProj___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VVectorConstIProj___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VVectorConstIProj___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VVectorConstIProj___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VVectorConstIProj___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VVectorConstIProj___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VVectorConstIProj_pop(self)

    def append(self, x):
        return _gstlearn.VVectorConstIProj_append(self, x)

    def empty(self):
        return _gstlearn.VVectorConstIProj_empty(self)

    def size(self):
        return _gstlearn.VVectorConstIProj_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VVectorConstIProj_swap(self, v)

    def begin(self):
        return _gstlearn.VVectorConstIProj_begin(self)

    def end(self):
        return _gstlearn.VVectorConstIProj_end(self)

    def rbegin(self):
        return _gstlearn.VVectorConstIProj_rbegin(self)

    def rend(self):
        return _gstlearn.VVectorConstIProj_rend(self)

    def clear(self):
        return _gstlearn.VVectorConstIProj_clear(self)

    def get_allocator(self):
        return _gstlearn.VVectorConstIProj_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VVectorConstIProj_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VVectorConstIProj_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VVectorConstIProj_swiginit(self, _gstlearn.new_VVectorConstIProj(*args))

    def push_back(self, x):
        return _gstlearn.VVectorConstIProj_push_back(self, x)

    def front(self):
        return _gstlearn.VVectorConstIProj_front(self)

    def back(self):
        return _gstlearn.VVectorConstIProj_back(self)

    def assign(self, n, x):
        return _gstlearn.VVectorConstIProj_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VVectorConstIProj_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VVectorConstIProj_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VVectorConstIProj_reserve(self, n)

    def capacity(self):
        return _gstlearn.VVectorConstIProj_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VVectorConstIProj

# Register VVectorConstIProj in _gstlearn:
_gstlearn.VVectorConstIProj_swigregister(VVectorConstIProj)
class VectorMeshes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorMeshes_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorMeshes___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorMeshes___bool__(self)

    def __len__(self):
        return _gstlearn.VectorMeshes___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorMeshes___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorMeshes___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorMeshes___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorMeshes___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorMeshes___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorMeshes___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorMeshes_pop(self)

    def append(self, x):
        return _gstlearn.VectorMeshes_append(self, x)

    def empty(self):
        return _gstlearn.VectorMeshes_empty(self)

    def size(self):
        return _gstlearn.VectorMeshes_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorMeshes_swap(self, v)

    def begin(self):
        return _gstlearn.VectorMeshes_begin(self)

    def end(self):
        return _gstlearn.VectorMeshes_end(self)

    def rbegin(self):
        return _gstlearn.VectorMeshes_rbegin(self)

    def rend(self):
        return _gstlearn.VectorMeshes_rend(self)

    def clear(self):
        return _gstlearn.VectorMeshes_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorMeshes_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorMeshes_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorMeshes_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorMeshes_swiginit(self, _gstlearn.new_VectorMeshes(*args))

    def push_back(self, x):
        return _gstlearn.VectorMeshes_push_back(self, x)

    def front(self):
        return _gstlearn.VectorMeshes_front(self)

    def back(self):
        return _gstlearn.VectorMeshes_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorMeshes_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorMeshes_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorMeshes_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorMeshes_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorMeshes_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorMeshes

# Register VectorMeshes in _gstlearn:
_gstlearn.VectorMeshes_swigregister(VectorMeshes)
class VectorMatrixSquare(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.VectorMatrixSquare_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.VectorMatrixSquare___nonzero__(self)

    def __bool__(self):
        return _gstlearn.VectorMatrixSquare___bool__(self)

    def __len__(self):
        return _gstlearn.VectorMatrixSquare___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.VectorMatrixSquare___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.VectorMatrixSquare___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.VectorMatrixSquare___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.VectorMatrixSquare___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.VectorMatrixSquare___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.VectorMatrixSquare___setitem__(self, *args)

    def pop(self):
        return _gstlearn.VectorMatrixSquare_pop(self)

    def append(self, x):
        return _gstlearn.VectorMatrixSquare_append(self, x)

    def empty(self):
        return _gstlearn.VectorMatrixSquare_empty(self)

    def size(self):
        return _gstlearn.VectorMatrixSquare_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.VectorMatrixSquare_swap(self, v)

    def begin(self):
        return _gstlearn.VectorMatrixSquare_begin(self)

    def end(self):
        return _gstlearn.VectorMatrixSquare_end(self)

    def rbegin(self):
        return _gstlearn.VectorMatrixSquare_rbegin(self)

    def rend(self):
        return _gstlearn.VectorMatrixSquare_rend(self)

    def clear(self):
        return _gstlearn.VectorMatrixSquare_clear(self)

    def get_allocator(self):
        return _gstlearn.VectorMatrixSquare_get_allocator(self)

    def pop_back(self):
        return _gstlearn.VectorMatrixSquare_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.VectorMatrixSquare_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.VectorMatrixSquare_swiginit(self, _gstlearn.new_VectorMatrixSquare(*args))

    def push_back(self, x):
        return _gstlearn.VectorMatrixSquare_push_back(self, x)

    def front(self):
        return _gstlearn.VectorMatrixSquare_front(self)

    def back(self):
        return _gstlearn.VectorMatrixSquare_back(self)

    def assign(self, n, x):
        return _gstlearn.VectorMatrixSquare_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.VectorMatrixSquare_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.VectorMatrixSquare_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.VectorMatrixSquare_reserve(self, n)

    def capacity(self):
        return _gstlearn.VectorMatrixSquare_capacity(self)
    __swig_destroy__ = _gstlearn.delete_VectorMatrixSquare

# Register VectorMatrixSquare in _gstlearn:
_gstlearn.VectorMatrixSquare_swigregister(VectorMatrixSquare)
SHARED_PTR_DISOWN = _gstlearn.SHARED_PTR_DISOWN
class ASpaceSharedPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _gstlearn.ASpaceSharedPtr_swiginit(self, _gstlearn.new_ASpaceSharedPtr())
    __swig_destroy__ = _gstlearn.delete_ASpaceSharedPtr

# Register ASpaceSharedPtr in _gstlearn:
_gstlearn.ASpaceSharedPtr_swigregister(ASpaceSharedPtr)
class ASpaceSharedPtrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gstlearn.ASpaceSharedPtrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gstlearn.ASpaceSharedPtrVector___nonzero__(self)

    def __bool__(self):
        return _gstlearn.ASpaceSharedPtrVector___bool__(self)

    def __len__(self):
        return _gstlearn.ASpaceSharedPtrVector___len__(self)

    def __getslice__(self, i, j):
        return _gstlearn.ASpaceSharedPtrVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gstlearn.ASpaceSharedPtrVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gstlearn.ASpaceSharedPtrVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gstlearn.ASpaceSharedPtrVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gstlearn.ASpaceSharedPtrVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gstlearn.ASpaceSharedPtrVector___setitem__(self, *args)

    def pop(self):
        return _gstlearn.ASpaceSharedPtrVector_pop(self)

    def append(self, x):
        return _gstlearn.ASpaceSharedPtrVector_append(self, x)

    def empty(self):
        return _gstlearn.ASpaceSharedPtrVector_empty(self)

    def size(self):
        return _gstlearn.ASpaceSharedPtrVector_size(self)

    def swap(self, v):
        r"""


        """
        return _gstlearn.ASpaceSharedPtrVector_swap(self, v)

    def begin(self):
        return _gstlearn.ASpaceSharedPtrVector_begin(self)

    def end(self):
        return _gstlearn.ASpaceSharedPtrVector_end(self)

    def rbegin(self):
        return _gstlearn.ASpaceSharedPtrVector_rbegin(self)

    def rend(self):
        return _gstlearn.ASpaceSharedPtrVector_rend(self)

    def clear(self):
        return _gstlearn.ASpaceSharedPtrVector_clear(self)

    def get_allocator(self):
        return _gstlearn.ASpaceSharedPtrVector_get_allocator(self)

    def pop_back(self):
        return _gstlearn.ASpaceSharedPtrVector_pop_back(self)

    def erase(self, *args):
        r"""


        """
        return _gstlearn.ASpaceSharedPtrVector_erase(self, *args)

    def __init__(self, *args):
        _gstlearn.ASpaceSharedPtrVector_swiginit(self, _gstlearn.new_ASpaceSharedPtrVector(*args))

    def push_back(self, x):
        return _gstlearn.ASpaceSharedPtrVector_push_back(self, x)

    def front(self):
        return _gstlearn.ASpaceSharedPtrVector_front(self)

    def back(self):
        return _gstlearn.ASpaceSharedPtrVector_back(self)

    def assign(self, n, x):
        return _gstlearn.ASpaceSharedPtrVector_assign(self, n, x)

    def resize(self, *args):
        return _gstlearn.ASpaceSharedPtrVector_resize(self, *args)

    def insert(self, *args):
        return _gstlearn.ASpaceSharedPtrVector_insert(self, *args)

    def reserve(self, n):
        return _gstlearn.ASpaceSharedPtrVector_reserve(self, n)

    def capacity(self):
        return _gstlearn.ASpaceSharedPtrVector_capacity(self)
    __swig_destroy__ = _gstlearn.delete_ASpaceSharedPtrVector

# Register ASpaceSharedPtrVector in _gstlearn:
_gstlearn.ASpaceSharedPtrVector_swigregister(ASpaceSharedPtrVector)
class VectorTInt(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorTInt_swiginit(self, _gstlearn.new_VectorTInt(*args))
    __swig_destroy__ = _gstlearn.delete_VectorTInt

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorTInt_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorTInt_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorTInt___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorTInt___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorTInt___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorTInt___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorTInt___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorTInt___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorTInt_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorTInt_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorTInt_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorTInt_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorTInt_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorTInt_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorTInt_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorTInt_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorTInt_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorTInt_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorTInt_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorTInt_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorTInt_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorTInt_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorTInt_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorTInt_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorTInt_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorTInt_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorTInt_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorTInt_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorTInt_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorTInt_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorTInt_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorTInt_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorTInt_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorTInt_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorTInt_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorTInt_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorTInt_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorTInt_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorTInt_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorTInt_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorTInt_toTL(self)

# Register VectorTInt in _gstlearn:
_gstlearn.VectorTInt_swigregister(VectorTInt)
class VectorTDouble(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorTDouble_swiginit(self, _gstlearn.new_VectorTDouble(*args))
    __swig_destroy__ = _gstlearn.delete_VectorTDouble

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorTDouble_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorTDouble_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorTDouble___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorTDouble___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorTDouble___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorTDouble___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorTDouble___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorTDouble___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorTDouble_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorTDouble_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorTDouble_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorTDouble_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorTDouble_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorTDouble_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorTDouble_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorTDouble_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorTDouble_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorTDouble_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorTDouble_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorTDouble_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorTDouble_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorTDouble_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorTDouble_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorTDouble_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorTDouble_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorTDouble_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorTDouble_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorTDouble_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorTDouble_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorTDouble_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorTDouble_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorTDouble_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorTDouble_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorTDouble_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorTDouble_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorTDouble_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorTDouble_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorTDouble_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorTDouble_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorTDouble_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorTDouble_toTL(self)

# Register VectorTDouble in _gstlearn:
_gstlearn.VectorTDouble_swigregister(VectorTDouble)
class VectorTFloat(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorTFloat_swiginit(self, _gstlearn.new_VectorTFloat(*args))
    __swig_destroy__ = _gstlearn.delete_VectorTFloat

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorTFloat_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorTFloat_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorTFloat___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorTFloat___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorTFloat___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorTFloat___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorTFloat___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorTFloat___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorTFloat_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorTFloat_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorTFloat_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorTFloat_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorTFloat_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorTFloat_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorTFloat_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorTFloat_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorTFloat_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorTFloat_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorTFloat_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorTFloat_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorTFloat_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorTFloat_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorTFloat_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorTFloat_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorTFloat_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorTFloat_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorTFloat_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorTFloat_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorTFloat_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorTFloat_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorTFloat_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorTFloat_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorTFloat_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorTFloat_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorTFloat_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorTFloat_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorTFloat_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorTFloat_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorTFloat_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorTFloat_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorTFloat_toTL(self)

# Register VectorTFloat in _gstlearn:
_gstlearn.VectorTFloat_swigregister(VectorTFloat)
class VectorBool(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorBool_swiginit(self, _gstlearn.new_VectorBool(*args))
    __swig_destroy__ = _gstlearn.delete_VectorBool

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorBool_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorBool_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorBool___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorBool___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorBool___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorBool___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorBool___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorBool___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorBool_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorBool_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorBool_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorBool_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorBool_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorBool_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorBool_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorBool_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorBool_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorBool_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorBool_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorBool_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorBool_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorBool_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorBool_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorBool_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorBool_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorBool_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorBool_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorBool_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorBool_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorBool_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorBool_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorBool_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorBool_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorBool_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorBool_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorBool_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorBool_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorBool_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorBool_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorBool_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorBool_toTL(self)

# Register VectorBool in _gstlearn:
_gstlearn.VectorBool_swigregister(VectorBool)
class VectorString(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorString_swiginit(self, _gstlearn.new_VectorString(*args))
    __swig_destroy__ = _gstlearn.delete_VectorString

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorString_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorString_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorString___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorString___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorString___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorString___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorString___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorString___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorString_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorString_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorString_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorString_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorString_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorString_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorString_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorString_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorString_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorString_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorString_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorString_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorString_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorString_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorString_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorString_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorString_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorString_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorString_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorString_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorString_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorString_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorString_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorString_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorString_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorString_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorString_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorString_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorString_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorString_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorString_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorString_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorString_toTL(self)

    def __repr__(self):
        return _gstlearn.VectorString___repr__(self)

# Register VectorString in _gstlearn:
_gstlearn.VectorString_swigregister(VectorString)
class VectorInt(VectorTInt):
    r"""


    C++ includes: VectorNumT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorNumT::VectorNumT
        """
        _gstlearn.VectorInt_swiginit(self, _gstlearn.new_VectorInt(*args))
    __swig_destroy__ = _gstlearn.delete_VectorInt

    def isSame(self, other, eps=1.e-10):
        r"""

        VectorNumT::isSame
        """
        return _gstlearn.VectorInt_isSame(self, other, eps)

    def sum(self):
        r"""

        VectorNumT::sum
        """
        return _gstlearn.VectorInt_sum(self)

    def minimum(self):
        r"""

        VectorNumT::minimum
        """
        return _gstlearn.VectorInt_minimum(self)

    def maximum(self):
        r"""

        VectorNumT::maximum
        """
        return _gstlearn.VectorInt_maximum(self)

    def mean(self):
        r"""

        VectorNumT::mean
        """
        return _gstlearn.VectorInt_mean(self)

    def norm(self):
        r"""

        VectorNumT::norm
        """
        return _gstlearn.VectorInt_norm(self)

    def innerProduct(self, v):
        r"""

        VectorNumT::innerProduct
        """
        return _gstlearn.VectorInt_innerProduct(self, v)

    def add(self, *args):
        r"""

        VectorNumT::add
        """
        return _gstlearn.VectorInt_add(self, *args)

    def subtract(self, *args):
        r"""

        VectorNumT::subtract
        """
        return _gstlearn.VectorInt_subtract(self, *args)

    def multiply(self, *args):
        r"""

        VectorNumT::multiply
        """
        return _gstlearn.VectorInt_multiply(self, *args)

    def divide(self, *args):
        r"""

        VectorNumT::divide
        """
        return _gstlearn.VectorInt_divide(self, *args)

    def __repr__(self):
        return _gstlearn.VectorInt___repr__(self)

# Register VectorInt in _gstlearn:
_gstlearn.VectorInt_swigregister(VectorInt)
class VectorDouble(VectorTDouble):
    r"""


    C++ includes: VectorNumT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorNumT::VectorNumT
        """
        _gstlearn.VectorDouble_swiginit(self, _gstlearn.new_VectorDouble(*args))
    __swig_destroy__ = _gstlearn.delete_VectorDouble

    def isSame(self, other, eps=1.e-10):
        r"""

        VectorNumT::isSame
        """
        return _gstlearn.VectorDouble_isSame(self, other, eps)

    def sum(self):
        r"""

        VectorNumT::sum
        """
        return _gstlearn.VectorDouble_sum(self)

    def minimum(self):
        r"""

        VectorNumT::minimum
        """
        return _gstlearn.VectorDouble_minimum(self)

    def maximum(self):
        r"""

        VectorNumT::maximum
        """
        return _gstlearn.VectorDouble_maximum(self)

    def mean(self):
        r"""

        VectorNumT::mean
        """
        return _gstlearn.VectorDouble_mean(self)

    def norm(self):
        r"""

        VectorNumT::norm
        """
        return _gstlearn.VectorDouble_norm(self)

    def innerProduct(self, v):
        r"""

        VectorNumT::innerProduct
        """
        return _gstlearn.VectorDouble_innerProduct(self, v)

    def add(self, *args):
        r"""

        VectorNumT::add
        """
        return _gstlearn.VectorDouble_add(self, *args)

    def subtract(self, *args):
        r"""

        VectorNumT::subtract
        """
        return _gstlearn.VectorDouble_subtract(self, *args)

    def multiply(self, *args):
        r"""

        VectorNumT::multiply
        """
        return _gstlearn.VectorDouble_multiply(self, *args)

    def divide(self, *args):
        r"""

        VectorNumT::divide
        """
        return _gstlearn.VectorDouble_divide(self, *args)

    def __repr__(self):
        return _gstlearn.VectorDouble___repr__(self)

# Register VectorDouble in _gstlearn:
_gstlearn.VectorDouble_swigregister(VectorDouble)
class VectorFloat(VectorTFloat):
    r"""


    C++ includes: VectorNumT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorNumT::VectorNumT
        """
        _gstlearn.VectorFloat_swiginit(self, _gstlearn.new_VectorFloat(*args))
    __swig_destroy__ = _gstlearn.delete_VectorFloat

    def isSame(self, other, eps=1.e-10):
        r"""

        VectorNumT::isSame
        """
        return _gstlearn.VectorFloat_isSame(self, other, eps)

    def sum(self):
        r"""

        VectorNumT::sum
        """
        return _gstlearn.VectorFloat_sum(self)

    def minimum(self):
        r"""

        VectorNumT::minimum
        """
        return _gstlearn.VectorFloat_minimum(self)

    def maximum(self):
        r"""

        VectorNumT::maximum
        """
        return _gstlearn.VectorFloat_maximum(self)

    def mean(self):
        r"""

        VectorNumT::mean
        """
        return _gstlearn.VectorFloat_mean(self)

    def norm(self):
        r"""

        VectorNumT::norm
        """
        return _gstlearn.VectorFloat_norm(self)

    def innerProduct(self, v):
        r"""

        VectorNumT::innerProduct
        """
        return _gstlearn.VectorFloat_innerProduct(self, v)

    def add(self, *args):
        r"""

        VectorNumT::add
        """
        return _gstlearn.VectorFloat_add(self, *args)

    def subtract(self, *args):
        r"""

        VectorNumT::subtract
        """
        return _gstlearn.VectorFloat_subtract(self, *args)

    def multiply(self, *args):
        r"""

        VectorNumT::multiply
        """
        return _gstlearn.VectorFloat_multiply(self, *args)

    def divide(self, *args):
        r"""

        VectorNumT::divide
        """
        return _gstlearn.VectorFloat_divide(self, *args)

    def __repr__(self):
        return _gstlearn.VectorFloat___repr__(self)

# Register VectorFloat in _gstlearn:
_gstlearn.VectorFloat_swigregister(VectorFloat)
class VectorUChar(VectorBool):
    r"""


    C++ includes: VectorNumT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorNumT::VectorNumT
        """
        _gstlearn.VectorUChar_swiginit(self, _gstlearn.new_VectorUChar(*args))
    __swig_destroy__ = _gstlearn.delete_VectorUChar

    def isSame(self, other, eps=1.e-10):
        r"""

        VectorNumT::isSame
        """
        return _gstlearn.VectorUChar_isSame(self, other, eps)

    def sum(self):
        r"""

        VectorNumT::sum
        """
        return _gstlearn.VectorUChar_sum(self)

    def minimum(self):
        r"""

        VectorNumT::minimum
        """
        return _gstlearn.VectorUChar_minimum(self)

    def maximum(self):
        r"""

        VectorNumT::maximum
        """
        return _gstlearn.VectorUChar_maximum(self)

    def mean(self):
        r"""

        VectorNumT::mean
        """
        return _gstlearn.VectorUChar_mean(self)

    def norm(self):
        r"""

        VectorNumT::norm
        """
        return _gstlearn.VectorUChar_norm(self)

    def innerProduct(self, v):
        r"""

        VectorNumT::innerProduct
        """
        return _gstlearn.VectorUChar_innerProduct(self, v)

    def add(self, *args):
        r"""

        VectorNumT::add
        """
        return _gstlearn.VectorUChar_add(self, *args)

    def subtract(self, *args):
        r"""

        VectorNumT::subtract
        """
        return _gstlearn.VectorUChar_subtract(self, *args)

    def multiply(self, *args):
        r"""

        VectorNumT::multiply
        """
        return _gstlearn.VectorUChar_multiply(self, *args)

    def divide(self, *args):
        r"""

        VectorNumT::divide
        """
        return _gstlearn.VectorUChar_divide(self, *args)

    def __repr__(self):
        return _gstlearn.VectorUChar___repr__(self)

# Register VectorUChar in _gstlearn:
_gstlearn.VectorUChar_swigregister(VectorUChar)
class VectorVectorInt(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorVectorInt_swiginit(self, _gstlearn.new_VectorVectorInt(*args))
    __swig_destroy__ = _gstlearn.delete_VectorVectorInt

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorVectorInt_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorVectorInt_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorVectorInt___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorVectorInt___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorVectorInt___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorVectorInt___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorVectorInt___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorVectorInt___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorVectorInt_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorVectorInt_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorVectorInt_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorVectorInt_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorVectorInt_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorVectorInt_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorVectorInt_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorVectorInt_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorVectorInt_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorVectorInt_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorVectorInt_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorVectorInt_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorVectorInt_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorVectorInt_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorVectorInt_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorVectorInt_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorVectorInt_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorVectorInt_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorVectorInt_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorVectorInt_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorVectorInt_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorVectorInt_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorVectorInt_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorVectorInt_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorVectorInt_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorVectorInt_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorVectorInt_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorVectorInt_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorVectorInt_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorVectorInt_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorVectorInt_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorVectorInt_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorVectorInt_toTL(self)

    def __repr__(self):
        return _gstlearn.VectorVectorInt___repr__(self)

# Register VectorVectorInt in _gstlearn:
_gstlearn.VectorVectorInt_swigregister(VectorVectorInt)
class VectorVectorDouble(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorVectorDouble_swiginit(self, _gstlearn.new_VectorVectorDouble(*args))
    __swig_destroy__ = _gstlearn.delete_VectorVectorDouble

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorVectorDouble_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorVectorDouble_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorVectorDouble___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorVectorDouble___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorVectorDouble___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorVectorDouble___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorVectorDouble___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorVectorDouble___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorVectorDouble_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorVectorDouble_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorVectorDouble_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorVectorDouble_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorVectorDouble_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorVectorDouble_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorVectorDouble_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorVectorDouble_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorVectorDouble_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorVectorDouble_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorVectorDouble_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorVectorDouble_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorVectorDouble_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorVectorDouble_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorVectorDouble_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorVectorDouble_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorVectorDouble_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorVectorDouble_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorVectorDouble_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorVectorDouble_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorVectorDouble_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorVectorDouble_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorVectorDouble_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorVectorDouble_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorVectorDouble_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorVectorDouble_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorVectorDouble_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorVectorDouble_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorVectorDouble_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorVectorDouble_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorVectorDouble_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorVectorDouble_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorVectorDouble_toTL(self)

    def __repr__(self):
        return _gstlearn.VectorVectorDouble___repr__(self)

# Register VectorVectorDouble in _gstlearn:
_gstlearn.VectorVectorDouble_swigregister(VectorVectorDouble)
class VectorVectorFloat(object):
    r"""


    C++ includes: VectorT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        VectorT::VectorT
        """
        _gstlearn.VectorVectorFloat_swiginit(self, _gstlearn.new_VectorVectorFloat(*args))
    __swig_destroy__ = _gstlearn.delete_VectorVectorFloat

    def getVector(self, *args):
        r"""

        VectorT::getVector
        """
        return _gstlearn.VectorVectorFloat_getVector(self, *args)

    def getVectorPtr(self):
        r"""

        VectorT::getVectorPtr
        """
        return _gstlearn.VectorVectorFloat_getVectorPtr(self)

    def __eq__(self, other):
        return _gstlearn.VectorVectorFloat___eq__(self, other)

    def __ne__(self, other):
        return _gstlearn.VectorVectorFloat___ne__(self, other)

    def __lt__(self, other):
        return _gstlearn.VectorVectorFloat___lt__(self, other)

    def __le__(self, other):
        return _gstlearn.VectorVectorFloat___le__(self, other)

    def __gt__(self, other):
        return _gstlearn.VectorVectorFloat___gt__(self, other)

    def __ge__(self, other):
        return _gstlearn.VectorVectorFloat___ge__(self, other)

    def getAt(self, pos):
        r"""

        VectorT::getAt
        """
        return _gstlearn.VectorVectorFloat_getAt(self, pos)

    def setAt(self, pos, v):
        r"""

        VectorT::setAt
        """
        return _gstlearn.VectorVectorFloat_setAt(self, pos, v)

    def length(self):
        r"""

        VectorT::length
        """
        return _gstlearn.VectorVectorFloat_length(self)

    def front(self, *args):
        r"""

        VectorT::front
        """
        return _gstlearn.VectorVectorFloat_front(self, *args)

    def back(self, *args):
        r"""

        VectorT::back
        """
        return _gstlearn.VectorVectorFloat_back(self, *args)

    def data(self, *args):
        r"""

        VectorT::data
        """
        return _gstlearn.VectorVectorFloat_data(self, *args)

    def constData(self):
        r"""

        VectorT::constData
        """
        return _gstlearn.VectorVectorFloat_constData(self)

    def subdata(self, *args):
        r"""

        VectorT::subdata
        """
        return _gstlearn.VectorVectorFloat_subdata(self, *args)

    def empty(self):
        r"""

        VectorT::empty
        """
        return _gstlearn.VectorVectorFloat_empty(self)

    def size(self):
        r"""

        VectorT::size
        """
        return _gstlearn.VectorVectorFloat_size(self)

    def reserve(self, new_cap):
        r"""

        VectorT::reserve
        """
        return _gstlearn.VectorVectorFloat_reserve(self, new_cap)

    def capacity(self):
        r"""

        VectorT::capacity
        """
        return _gstlearn.VectorVectorFloat_capacity(self)

    def clear(self):
        r"""

        VectorT::clear
        """
        return _gstlearn.VectorVectorFloat_clear(self)

    def insert(self, *args):
        r"""

        VectorT::insert
        """
        return _gstlearn.VectorVectorFloat_insert(self, *args)

    def remove(self, *args):
        r"""

        VectorT::remove
        """
        return _gstlearn.VectorVectorFloat_remove(self, *args)

    def erase(self, *args):
        r"""

        VectorT::erase
        """
        return _gstlearn.VectorVectorFloat_erase(self, *args)

    def push_back(self, value):
        r"""

        VectorT::push_back
        """
        return _gstlearn.VectorVectorFloat_push_back(self, value)

    def push_front(self, value):
        r"""

        VectorT::push_front
        """
        return _gstlearn.VectorVectorFloat_push_front(self, value)

    def resize(self, *args):
        r"""

        VectorT::resize
        """
        return _gstlearn.VectorVectorFloat_resize(self, *args)

    def begin(self, *args):
        r"""

        VectorT::begin
        """
        return _gstlearn.VectorVectorFloat_begin(self, *args)

    def cbegin(self):
        r"""

        VectorT::cbegin
        """
        return _gstlearn.VectorVectorFloat_cbegin(self)

    def end(self, *args):
        r"""

        VectorT::end
        """
        return _gstlearn.VectorVectorFloat_end(self, *args)

    def cend(self):
        r"""

        VectorT::cend
        """
        return _gstlearn.VectorVectorFloat_cend(self)

    def rbegin(self):
        r"""

        VectorT::rbegin
        """
        return _gstlearn.VectorVectorFloat_rbegin(self)

    def crbegin(self):
        r"""

        VectorT::crbegin
        """
        return _gstlearn.VectorVectorFloat_crbegin(self)

    def rend(self):
        r"""

        VectorT::rend
        """
        return _gstlearn.VectorVectorFloat_rend(self)

    def crend(self):
        r"""

        VectorT::crend
        """
        return _gstlearn.VectorVectorFloat_crend(self)

    def swap(self, other):
        r"""

        VectorT::swap
        """
        return _gstlearn.VectorVectorFloat_swap(self, other)

    def contains(self, value):
        r"""

        VectorT::contains
        """
        return _gstlearn.VectorVectorFloat_contains(self, value)

    def fill(self, value, size=0):
        r"""

        VectorT::fill
        """
        return _gstlearn.VectorVectorFloat_fill(self, value, size)

    def toString(self, strfmt=None):
        r"""

        VectorT::toString
        """
        return _gstlearn.VectorVectorFloat_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        VectorT::display
        """
        return _gstlearn.VectorVectorFloat_display(self, strfmt)

    def toTL(self):
        r"""

        VectorT::toTL
        Has a specific implementation in the Target language.  

        """
        return _gstlearn.VectorVectorFloat_toTL(self)

# Register VectorVectorFloat in _gstlearn:
_gstlearn.VectorVectorFloat_swigregister(VectorVectorFloat)
class ICloneable(object):
    r"""


    Inherits from this interface to make your class cloneable. You must use
    IMPLEMENT_CLONING macro in concrete classes only.  

    C++ includes: ICloneable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ICloneable

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ICloneable_clone(self)

# Register ICloneable in _gstlearn:
_gstlearn.ICloneable_swigregister(ICloneable)
EPSILON1 = _gstlearn.EPSILON1
EPSILON2 = _gstlearn.EPSILON2
EPSILON3 = _gstlearn.EPSILON3
EPSILON4 = _gstlearn.EPSILON4
EPSILON5 = _gstlearn.EPSILON5
EPSILON6 = _gstlearn.EPSILON6
EPSILON7 = _gstlearn.EPSILON7
EPSILON8 = _gstlearn.EPSILON8
EPSILON9 = _gstlearn.EPSILON9
EPSILON10 = _gstlearn.EPSILON10
EPSILON12 = _gstlearn.EPSILON12
EPSILON13 = _gstlearn.EPSILON13
EPSILON20 = _gstlearn.EPSILON20
EPSGRAD = _gstlearn.EPSGRAD
MINIMUM_BIG = _gstlearn.MINIMUM_BIG
MAXIMUM_BIG = _gstlearn.MAXIMUM_BIG
TEST = _gstlearn.TEST
TEST_COMP = _gstlearn.TEST_COMP
ITEST = _gstlearn.ITEST
ASCII_TEST = _gstlearn.ASCII_TEST
BUFFER_LENGTH = _gstlearn.BUFFER_LENGTH
STRING_LENGTH = _gstlearn.STRING_LENGTH
LOCAL_SIZE = _gstlearn.LOCAL_SIZE
LONG_SIZE = _gstlearn.LONG_SIZE
GV_PI = _gstlearn.GV_PI
GV_EE = _gstlearn.GV_EE
MAX_INT = _gstlearn.MAX_INT
MAX_PARAM = _gstlearn.MAX_PARAM
MAX_EXP = _gstlearn.MAX_EXP
THRESH_INF = _gstlearn.THRESH_INF
THRESH_SUP = _gstlearn.THRESH_SUP
EARTH_RADIUS = _gstlearn.EARTH_RADIUS
class Koption(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    calcul = property(_gstlearn.Koption_calcul_get, _gstlearn.Koption_calcul_set)
    ndim = property(_gstlearn.Koption_ndim_get, _gstlearn.Koption_ndim_set)
    ntot = property(_gstlearn.Koption_ntot_get, _gstlearn.Koption_ntot_set)
    ndisc = property(_gstlearn.Koption_ndisc_get, _gstlearn.Koption_ndisc_set)
    disc1 = property(_gstlearn.Koption_disc1_get, _gstlearn.Koption_disc1_set)
    disc2 = property(_gstlearn.Koption_disc2_get, _gstlearn.Koption_disc2_set)
    flag_data_disc = property(_gstlearn.Koption_flag_data_disc_get, _gstlearn.Koption_flag_data_disc_set)
    dsize = property(_gstlearn.Koption_dsize_get, _gstlearn.Koption_dsize_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.Koption_swiginit(self, _gstlearn.new_Koption())
    __swig_destroy__ = _gstlearn.delete_Koption

# Register Koption in _gstlearn:
_gstlearn.Koption_swigregister(Koption)
class StrMod(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    norder = property(_gstlearn.StrMod_norder_get, _gstlearn.StrMod_norder_set)
    nmodel = property(_gstlearn.StrMod_nmodel_get, _gstlearn.StrMod_nmodel_set)
    npar_init = property(_gstlearn.StrMod_npar_init_get, _gstlearn.StrMod_npar_init_set)
    models = property(_gstlearn.StrMod_models_get, _gstlearn.StrMod_models_set)
    optvar = property(_gstlearn.StrMod_optvar_get, _gstlearn.StrMod_optvar_set)
    user_data = property(_gstlearn.StrMod_user_data_get, _gstlearn.StrMod_user_data_set)
    parid = property(_gstlearn.StrMod_parid_get, _gstlearn.StrMod_parid_set)
    covtab = property(_gstlearn.StrMod_covtab_get, _gstlearn.StrMod_covtab_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.StrMod_swiginit(self, _gstlearn.new_StrMod())
    __swig_destroy__ = _gstlearn.delete_StrMod

# Register StrMod in _gstlearn:
_gstlearn.StrMod_swigregister(StrMod)
class Props(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    case_facies = property(_gstlearn.Props_case_facies_get, _gstlearn.Props_case_facies_set)
    case_stat = property(_gstlearn.Props_case_stat_get, _gstlearn.Props_case_stat_set)
    case_prop_interp = property(_gstlearn.Props_case_prop_interp_get, _gstlearn.Props_case_prop_interp_set)
    ngrf = property(_gstlearn.Props_ngrf_get, _gstlearn.Props_ngrf_set)
    nfac = property(_gstlearn.Props_nfac_get, _gstlearn.Props_nfac_set)
    nfaccur = property(_gstlearn.Props_nfaccur_get, _gstlearn.Props_nfaccur_set)
    nfacprod = property(_gstlearn.Props_nfacprod_get, _gstlearn.Props_nfacprod_set)
    nfacmax = property(_gstlearn.Props_nfacmax_get, _gstlearn.Props_nfacmax_set)
    mode = property(_gstlearn.Props_mode_get, _gstlearn.Props_mode_set)
    propfix = property(_gstlearn.Props_propfix_get, _gstlearn.Props_propfix_set)
    propmem = property(_gstlearn.Props_propmem_get, _gstlearn.Props_propmem_set)
    propwrk = property(_gstlearn.Props_propwrk_get, _gstlearn.Props_propwrk_set)
    proploc = property(_gstlearn.Props_proploc_get, _gstlearn.Props_proploc_set)
    coor = property(_gstlearn.Props_coor_get, _gstlearn.Props_coor_set)
    dbprop = property(_gstlearn.Props_dbprop_get, _gstlearn.Props_dbprop_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.Props_swiginit(self, _gstlearn.new_Props())
    __swig_destroy__ = _gstlearn.delete_Props

# Register Props in _gstlearn:
_gstlearn.Props_swigregister(Props)
class Modif_Categorical(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ipgs = property(_gstlearn.Modif_Categorical_ipgs_get, _gstlearn.Modif_Categorical_ipgs_set)
    flag_used = property(_gstlearn.Modif_Categorical_flag_used_get, _gstlearn.Modif_Categorical_flag_used_set)
    rule = property(_gstlearn.Modif_Categorical_rule_get, _gstlearn.Modif_Categorical_rule_set)
    propdef = property(_gstlearn.Modif_Categorical_propdef_get, _gstlearn.Modif_Categorical_propdef_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.Modif_Categorical_swiginit(self, _gstlearn.new_Modif_Categorical())
    __swig_destroy__ = _gstlearn.delete_Modif_Categorical

# Register Modif_Categorical in _gstlearn:
_gstlearn.Modif_Categorical_swigregister(Modif_Categorical)
class SubPlan(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    coor = property(_gstlearn.SubPlan_coor_get, _gstlearn.SubPlan_coor_set)
    intercept = property(_gstlearn.SubPlan_intercept_get, _gstlearn.SubPlan_intercept_set)
    value = property(_gstlearn.SubPlan_value_get, _gstlearn.SubPlan_value_set)
    rndval = property(_gstlearn.SubPlan_rndval_get, _gstlearn.SubPlan_rndval_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.SubPlan_swiginit(self, _gstlearn.new_SubPlan())
    __swig_destroy__ = _gstlearn.delete_SubPlan

# Register SubPlan in _gstlearn:
_gstlearn.SubPlan_swigregister(SubPlan)
class SubPlanes(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nplan = property(_gstlearn.SubPlanes_nplan_get, _gstlearn.SubPlanes_nplan_set)
    plans = property(_gstlearn.SubPlanes_plans_get, _gstlearn.SubPlanes_plans_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.SubPlanes_swiginit(self, _gstlearn.new_SubPlanes())
    __swig_destroy__ = _gstlearn.delete_SubPlanes

# Register SubPlanes in _gstlearn:
_gstlearn.SubPlanes_swigregister(SubPlanes)
class QSimu(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    QCtt = property(_gstlearn.QSimu_QCtt_get, _gstlearn.QSimu_QCtt_set)
    QCtd = property(_gstlearn.QSimu_QCtd_get, _gstlearn.QSimu_QCtd_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.QSimu_swiginit(self, _gstlearn.new_QSimu())
    __swig_destroy__ = _gstlearn.delete_QSimu

# Register QSimu in _gstlearn:
_gstlearn.QSimu_swigregister(QSimu)
class Cheb_Elem(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ncoeffs = property(_gstlearn.Cheb_Elem_ncoeffs_get, _gstlearn.Cheb_Elem_ncoeffs_set)
    ncmax = property(_gstlearn.Cheb_Elem_ncmax_get, _gstlearn.Cheb_Elem_ncmax_set)
    ndisc = property(_gstlearn.Cheb_Elem_ndisc_get, _gstlearn.Cheb_Elem_ndisc_set)
    power = property(_gstlearn.Cheb_Elem_power_get, _gstlearn.Cheb_Elem_power_set)
    a = property(_gstlearn.Cheb_Elem_a_get, _gstlearn.Cheb_Elem_a_set)
    b = property(_gstlearn.Cheb_Elem_b_get, _gstlearn.Cheb_Elem_b_set)
    v1 = property(_gstlearn.Cheb_Elem_v1_get, _gstlearn.Cheb_Elem_v1_set)
    v2 = property(_gstlearn.Cheb_Elem_v2_get, _gstlearn.Cheb_Elem_v2_set)
    tol = property(_gstlearn.Cheb_Elem_tol_get, _gstlearn.Cheb_Elem_tol_set)
    coeffs = property(_gstlearn.Cheb_Elem_coeffs_get, _gstlearn.Cheb_Elem_coeffs_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.Cheb_Elem_swiginit(self, _gstlearn.new_Cheb_Elem())
    __swig_destroy__ = _gstlearn.delete_Cheb_Elem

# Register Cheb_Elem in _gstlearn:
_gstlearn.Cheb_Elem_swigregister(Cheb_Elem)
class SPDE_SS_Option(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mesh_dbin = property(_gstlearn.SPDE_SS_Option_mesh_dbin_get, _gstlearn.SPDE_SS_Option_mesh_dbin_set)
    mesh_dbout = property(_gstlearn.SPDE_SS_Option_mesh_dbout_get, _gstlearn.SPDE_SS_Option_mesh_dbout_set)
    triswitch = property(_gstlearn.SPDE_SS_Option_triswitch_get, _gstlearn.SPDE_SS_Option_triswitch_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.SPDE_SS_Option_swiginit(self, _gstlearn.new_SPDE_SS_Option())
    __swig_destroy__ = _gstlearn.delete_SPDE_SS_Option

# Register SPDE_SS_Option in _gstlearn:
_gstlearn.SPDE_SS_Option_swigregister(SPDE_SS_Option)
class SPDE_Option(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    options = property(_gstlearn.SPDE_Option_options_get, _gstlearn.SPDE_Option_options_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.SPDE_Option_swiginit(self, _gstlearn.new_SPDE_Option())
    __swig_destroy__ = _gstlearn.delete_SPDE_Option

# Register SPDE_Option in _gstlearn:
_gstlearn.SPDE_Option_swigregister(SPDE_Option)
class CTable(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    res = property(_gstlearn.CTable_res_get, _gstlearn.CTable_res_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.CTable_swiginit(self, _gstlearn.new_CTable())
    __swig_destroy__ = _gstlearn.delete_CTable

# Register CTable in _gstlearn:
_gstlearn.CTable_swigregister(CTable)
class CTables(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nconf = property(_gstlearn.CTables_nconf_get, _gstlearn.CTables_nconf_set)
    ndisc = property(_gstlearn.CTables_ndisc_get, _gstlearn.CTables_ndisc_set)
    flag_cumul = property(_gstlearn.CTables_flag_cumul_get, _gstlearn.CTables_flag_cumul_set)
    cmin = property(_gstlearn.CTables_cmin_get, _gstlearn.CTables_cmin_set)
    cmax = property(_gstlearn.CTables_cmax_get, _gstlearn.CTables_cmax_set)
    dc = property(_gstlearn.CTables_dc_get, _gstlearn.CTables_dc_set)
    dp = property(_gstlearn.CTables_dp_get, _gstlearn.CTables_dp_set)
    v = property(_gstlearn.CTables_v_get, _gstlearn.CTables_v_set)
    CT = property(_gstlearn.CTables_CT_get, _gstlearn.CTables_CT_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.CTables_swiginit(self, _gstlearn.new_CTables())
    __swig_destroy__ = _gstlearn.delete_CTables

# Register CTables in _gstlearn:
_gstlearn.CTables_swigregister(CTables)
class Local_Split(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    oper = property(_gstlearn.Local_Split_oper_get, _gstlearn.Local_Split_oper_set)
    nrule = property(_gstlearn.Local_Split_nrule_get, _gstlearn.Local_Split_nrule_set)
    nbyrule = property(_gstlearn.Local_Split_nbyrule_get, _gstlearn.Local_Split_nbyrule_set)
    Srules = property(_gstlearn.Local_Split_Srules_get, _gstlearn.Local_Split_Srules_set)
    Sfipos = property(_gstlearn.Local_Split_Sfipos_get, _gstlearn.Local_Split_Sfipos_set)
    old_relem = property(_gstlearn.Local_Split_old_relem_get, _gstlearn.Local_Split_old_relem_set)
    relems = property(_gstlearn.Local_Split_relems_get, _gstlearn.Local_Split_relems_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.Local_Split_swiginit(self, _gstlearn.new_Local_Split())
    __swig_destroy__ = _gstlearn.delete_Local_Split

# Register Local_Split in _gstlearn:
_gstlearn.Local_Split_swigregister(Local_Split)
class Local_Relem(object):
    r"""


    C++ includes: geoslib_d.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    facies = property(_gstlearn.Local_Relem_facies_get, _gstlearn.Local_Relem_facies_set)
    nrule = property(_gstlearn.Local_Relem_nrule_get, _gstlearn.Local_Relem_nrule_set)
    nbyrule = property(_gstlearn.Local_Relem_nbyrule_get, _gstlearn.Local_Relem_nbyrule_set)
    nsplit = property(_gstlearn.Local_Relem_nsplit_get, _gstlearn.Local_Relem_nsplit_set)
    Rrules = property(_gstlearn.Local_Relem_Rrules_get, _gstlearn.Local_Relem_Rrules_set)
    Rfipos = property(_gstlearn.Local_Relem_Rfipos_get, _gstlearn.Local_Relem_Rfipos_set)
    old_split = property(_gstlearn.Local_Relem_old_split_get, _gstlearn.Local_Relem_old_split_set)
    splits = property(_gstlearn.Local_Relem_splits_get, _gstlearn.Local_Relem_splits_set)

    def __init__(self):
        r"""


        C++ includes: geoslib_d.h

        """
        _gstlearn.Local_Relem_swiginit(self, _gstlearn.new_Local_Relem())
    __swig_destroy__ = _gstlearn.delete_Local_Relem

# Register Local_Relem in _gstlearn:
_gstlearn.Local_Relem_swigregister(Local_Relem)

def variogram_pgs(db, varioparam, ruleprop, flag_rho=0, opt_correl=2):
    r"""


    Calculate the Gaussian variograms  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `varioparam` :  
        VarioParam structure for the GRFs  
    * `ruleprop` :  
        RuleProp structure  
    * `flag_rho` :  
        1 if the correlation coefficient must be regressed  
    * `opt_correl` :  
        0 full model; 1 symmetrical; 2 residuals  

    remark: This is simply a routine dispatching between the stationary function  

    remark: and the non-stationary one  

    """
    return _gstlearn.variogram_pgs(db, varioparam, ruleprop, flag_rho, opt_correl)

def model_auto_fit(*args, **kwargs):
    r"""


    Automatic model fitting  

    Returns
    -------
    Error returned code  

    Parameters
    ----------
    * `vario` :  
        Vario structure containing the exp. variogram  
    * `model` :  
        Model structure containing the basic structures  
    * `verbose` :  
        Verbose flag  
    * `mauto_arg` :  
        Option_AutoFit structure  
    * `cons_arg` :  
        Constraints structure  
    * `optvar_arg` :  
        Opt_Vario structure  

    """
    return _gstlearn.model_auto_fit(*args, **kwargs)

def vmap_auto_fit(*args, **kwargs):
    r"""


    Automatic model fitting  

    Returns
    -------
    Error returned code  

    Parameters
    ----------
    * `dbmap` :  
        Db Grid structure containing the Vmap  
    * `model` :  
        Model structure containing the basic structures  
    * `verbose` :  
        Verbose flag  
    * `mauto_arg` :  
        Option_AutoFit structure  
    * `cons_arg` :  
        Constraints structure  
    * `optvar_arg` :  
        Opt_Vario structure  

    """
    return _gstlearn.vmap_auto_fit(*args, **kwargs)

def set_test_discrete(flag_discret):
    r"""


    """
    return _gstlearn.set_test_discrete(flag_discret)

def model_pgs(db, varioparam, ruleprop, model1, model2=None):
    r"""


    Evaluate the experimental variogram of indicators in PluriGaussian case  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db descriptor  
    * `varioparam` :  
        VarioParam structure  
    * `ruleprop` :  
        RuleProp structure  
    * `model1` :  
        First Model structure  
    * `model2` :  
        Second Model structure (optional)  

    """
    return _gstlearn.model_pgs(db, varioparam, ruleprop, model1, model2)

def krigsum(*args, **kwargs):
    r"""


    Punctual Multivariate Kriging under a constraint  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        input Db structure  
    * `dbout` :  
        output Db structure  
    * `model` :  
        Model structure (univariate)  
    * `neigh` :  
        ANeigh structure  
    * `flag_positive` :  
        1 for a positive constraints  
    * `namconv` :  
        Naming convention  

    remark: All the variables are estimated using the same model  

    remark: In this procedure, we assume that:  

    remark: - the problem is multivariate ("z" variables)  

    remark: - the constraints is stored in "sum" (only used in dbout)  

    """
    return _gstlearn.krigsum(*args, **kwargs)

def declustering(*args, **kwargs):
    r"""


    Perform the Declustering task  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        input Db structure  
    * `model` :  
        Model structure  
    * `method` :  
        Method for declustering  
    * `neigh` :  
        ANeigh structure  
    * `dbgrid` :  
        Grid auxiliary Db structure  
    * `radius` :  
        Array of neighborhood radius  
    * `ndiscs` :  
        Array of discretization  
    * `flag_sel` :  
        1 to mask off samples with zero weight  
    * `verbose` :  
        Verbose option  

    """
    return _gstlearn.declustering(*args, **kwargs)

def simpgs(*args, **kwargs):
    r"""


    Perform the conditional or non-conditional Pluri-gaussian simulations  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `ruleprop` :  
        RuleProp structure  
    * `model1` :  
        First Model structure  
    * `model2` :  
        Second Model structure (optional)  
    * `neigh` :  
        ANeigh structure  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Seed for random number generator  
    * `flag_gaus` :  
        1 if results must be gaussian; otherwise facies  
    * `flag_prop` :  
        1 for facies proportion  
    * `flag_check` :  
        1 if the facies at data must be checked against the closest simulated grid
        node  
    * `flag_show` :  
        1 if the grid node which coincides with the data should be represented with
        the data facies (only if flag_cond && !flag_gaus)  
    * `nbtuba` :  
        Number of turning bands  
    * `gibbs_nburn` :  
        Number of bootstrap iterations  
    * `gibbs_niter` :  
        Maximum number of iterations  
    * `percent` :  
        Amount of nugget effect added to too much continous model (expressed in
        percentage of the total variance)  
    * `namconv` :  
        Naming convention  

    remark: The argument 'dbin' is optional: it must be defined only for  

    remark: conditional simulations.  

    remark: When conditional, the unique variable in the input Db structure  

    remark: should correspond to the facies index (starting from 1)  

    """
    return _gstlearn.simpgs(*args, **kwargs)

def simbipgs(*args, **kwargs):
    r"""


    Perform the conditional or non-conditional Bi Pluri-gaussian simulations  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `ruleprop` :  
        Ruleprop definition  
    * `model11` :  
        First Model structure for First Lithotype Rule  
    * `model12` :  
        Second Model structure for First Lithotype Rule  
    * `model21` :  
        First Model structure for Second Lithotype Rule  
    * `model22` :  
        Second Model structure for Second Lithotype Rule  
    * `neigh` :  
        ANeigh structure  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Seed for random number generator  
    * `flag_gaus` :  
        1 gaussian results; otherwise facies  
    * `flag_prop` :  
        1 for facies proportion  
    * `flag_check` :  
        1 if the facies at data must be checked against the closest simulated grid
        node  
    * `flag_show` :  
        1 if the grid node which coincides with the data should be represented with
        the data facies (only if flag_cond && !flag_gaus)  
    * `nbtuba` :  
        Number of turning bands  
    * `gibbs_nburn` :  
        Number of bootstrap iterations  
    * `gibbs_niter` :  
        Maximum number of iterations  
    * `percent` :  
        Amount of nugget effect added to too continuous model (expressed in
        percentage of the total variance)  
    * `namconv` :  
        Naming convention  

    remark: When conditional, the two first variables in the input Db  

    remark: should correspond to the two facies indices (starting from 1)  

    remark: The argument 'dbin' is optional: it must be defined only for  

    remark: conditional simulations  

    remark: The proportions (nfac1 * nfac2) must be ordered as follows:  

    remark: f1af2a, f1bf2a, f1cf2a, ..., f1bf2a, f1bf2b, ..., f1nf2m  

    """
    return _gstlearn.simbipgs(*args, **kwargs)

def simsph_mesh(mesh, model, sphepar, seed=54523, verbose=0):
    r"""


    Simulates the random function on the sphere  

    Returns
    -------
    The Vector simulated values  

    Parameters
    ----------
    * `mesh` :  
        MeshSpherical object  
    * `model` :  
        Model (defined in Euclidean space) to be used  
    * `sphepar` :  
        SimuSphericalParam structure  
    * `seed` :  
        Seed for random number generation  
    * `verbose` :  
        Verbose flag  

    """
    return _gstlearn.simsph_mesh(mesh, model, sphepar, seed, verbose)

def fluid_extract(dbgrid, name_facies, name_fluid, name_poro, name_date, nfacies, nfluids, facies0, fluid0, ntime, time0, dtime, verbose=False):
    r"""


    Extract time charts from the fluid propagation block  

    Returns
    -------
    The returned matrix  

    Parameters
    ----------
    * `dbgrid` :  
        Db grid structure  
    * `name_facies` :  
        Name of variable containing Facies  
    * `name_fluid` :  
        Name of variable containing Fluid  
    * `name_poro` :  
        Name of variable containing Porosity (optional)  
    * `name_date` :  
        Name of variable containing Date  
    * `nfacies` :  
        number of facies (facies 0 excluded)  
    * `nfluids` :  
        number of fluids  
    * `facies0` :  
        Value of the target facies  
    * `fluid0` :  
        Value of the target fluid  
    * `ntime` :  
        Number of Time intervals  
    * `time0` :  
        Starting time  
    * `dtime` :  
        Time interval  
    * `verbose` :  
        1 for a verbose option  

    """
    return _gstlearn.fluid_extract(dbgrid, name_facies, name_fluid, name_poro, name_date, nfacies, nfluids, facies0, fluid0, ntime, time0, dtime, verbose)

def simpgs_spde(dbin, dbout, ruleprop, model1, model2, triswitch, gext, flag_gaus, flag_prop, flag_check, flag_show, nfacies, seed, nbsimu, gibbs_nburn, gibbs_niter, ngibbs_int, verbose, percent):
    r"""


    Perform the conditional Pluri-gaussian simulations using spde  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `ruleprop` :  
        RuleProp definition  
    * `model1` :  
        First Model structure  
    * `model2` :  
        Second Model structure (optional)  
    * `triswitch` :  
        Meshing option  
    * `gext` :  
        Array of domain dilation  
    * `flag_gaus` :  
        1 if results must be gaussian; otherwise facies  
    * `flag_prop` :  
        1 for facies proportion  
    * `flag_check` :  
        1 if the facies at data must be checked against the closest simulated grid
        node  
    * `flag_show` :  
        1 if the grid node which coincides with the data should be represented with
        the data facies  
    * `nfacies` :  
        Number of facies  
    * `seed` :  
        Seed for random number generator  
    * `nbsimu` :  
        Number of simulations  
    * `gibbs_nburn` :  
        Number of iterations (Burning step)  
    * `gibbs_niter` :  
        Maximum number of iterations  
    * `ngibbs_int` :  
        Number of iterations internal to Gibbs (SPDE)  
    * `verbose` :  
        Verbose flag  
    * `percent` :  
        Amount of nugget effect added to too continous model (expressed in
        percentage of the total variance)  

    remark: When conditional, the unique variable in the input Db structure  

    remark: should correspond to the facies index (starting from 1)  

    """
    return _gstlearn.simpgs_spde(dbin, dbout, ruleprop, model1, model2, triswitch, gext, flag_gaus, flag_prop, flag_check, flag_show, nfacies, seed, nbsimu, gibbs_nburn, gibbs_niter, ngibbs_int, verbose, percent)

def db_proportion_estimate(*args, **kwargs):
    r"""


    Standard Kriging  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        Model structure  
    * `niter` :  
        Number of iterations  
    * `verbose` :  
        Verbose flag  
    * `namconv` :  
        Naming convention  

    remark: The procedure uses the FIRST covariance of the Model  

    remark: to describe the spatial structure  

    """
    return _gstlearn.db_proportion_estimate(*args, **kwargs)

def gibbs_sampler(*args, **kwargs):
    r"""


    Perform the Gibbs sampler  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Db structure  
    * `model` :  
        Model structure  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Seed for random number generator  
    * `gibbs_nburn` :  
        Initial number of iterations for bootstrapping  
    * `gibbs_niter` :  
        Maximum number of iterations  
    * `flag_moving` :  
        1 for Moving  
    * `flag_norm` :  
        1 if the Model must be normalized  
    * `flag_multi_mono` :  
        1 for the Multi_mono algorithm  
    * `flag_propagation` :  
        1 for the propagation algorithm  
    * `flag_sym_neigh` :  
        Deprecated argument  
    * `gibbs_optstats` :  
        0: No stats - 1: Print - 2: Save Neutral file  
    * `percent` :  
        Amount of nugget effect added to too continuous model (expressed in
        percentage of total variance)  
    * `flag_ce` :  
        1 if the conditional expectation should be returned instead of simulations  
    * `flag_cstd` :  
        1 if the conditional standard deviation should be returned instead of
        simulations  
    * `verbose` :  
        Verbose flag  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.gibbs_sampler(*args, **kwargs)
class AEnum(object):
    r"""


    C++ includes: AEnum.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getKey(self):
        r"""

        AEnum::getKey
        Return the enum key as a string (max 10 characters)  

        """
        return _gstlearn.AEnum_getKey(self)

    def getValue(self):
        r"""

        AEnum::getValue
        Return enum value as an integer value (max 32 enum)  

        """
        return _gstlearn.AEnum_getValue(self)

    def getDescr(self):
        r"""

        AEnum::getDescr
        Return the enum description as a string.  

        """
        return _gstlearn.AEnum_getDescr(self)

    def __lt__(self, e):
        return _gstlearn.AEnum___lt__(self, e)

    def __le__(self, e):
        return _gstlearn.AEnum___le__(self, e)

    def __gt__(self, e):
        return _gstlearn.AEnum___gt__(self, e)

    def __ge__(self, e):
        return _gstlearn.AEnum___ge__(self, e)

    def __eq__(self, e):
        return _gstlearn.AEnum___eq__(self, e)

    def __ne__(self, e):
        return _gstlearn.AEnum___ne__(self, e)

    def isSmaller(self, e):
        r"""

        AEnum::isSmaller
        """
        return _gstlearn.AEnum_isSmaller(self, e)

    def isSmallerOrEqual(self, e):
        r"""

        AEnum::isSmallerOrEqual
        """
        return _gstlearn.AEnum_isSmallerOrEqual(self, e)

    def isGreater(self, e):
        r"""

        AEnum::isGreater
        """
        return _gstlearn.AEnum_isGreater(self, e)

    def isGreaterOrEqual(self, e):
        r"""

        AEnum::isGreaterOrEqual
        """
        return _gstlearn.AEnum_isGreaterOrEqual(self, e)

    def isEqual(self, e):
        r"""

        AEnum::isEqual
        """
        return _gstlearn.AEnum_isEqual(self, e)

    def isDifferent(self, e):
        r"""

        AEnum::isDifferent
        """
        return _gstlearn.AEnum_isDifferent(self, e)

    def printEnum(self):
        r"""

        AEnum::printEnum
        """
        return _gstlearn.AEnum_printEnum(self)

# Register AEnum in _gstlearn:
_gstlearn.AEnum_swigregister(AEnum)
class EKrigOptIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EKrigOptIterator

    def __init__(self, arg2):
        _gstlearn.EKrigOptIterator_swiginit(self, _gstlearn.new_EKrigOptIterator(arg2))

    def __ref__(self):
        return _gstlearn.EKrigOptIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EKrigOptIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EKrigOptIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EKrigOptIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EKrigOptIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EKrigOptIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EKrigOptIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EKrigOptIterator_getDescr(self)

# Register EKrigOptIterator in _gstlearn:
_gstlearn.EKrigOptIterator_swigregister(EKrigOptIterator)
class EKrigOpt(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EKrigOpt

    def __init__(self, *args):
        _gstlearn.EKrigOpt_swiginit(self, _gstlearn.new_EKrigOpt(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EKrigOpt_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EKrigOpt_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EKrigOpt_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EKrigOpt_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EKrigOpt_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EKrigOpt_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EKrigOpt_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EKrigOpt_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EKrigOpt_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EKrigOpt_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EKrigOpt_fromValues(values)
    E_POINT = _gstlearn.EKrigOpt_E_POINT
    E_BLOCK = _gstlearn.EKrigOpt_E_BLOCK
    E_DRIFT = _gstlearn.EKrigOpt_E_DRIFT
    E_DGM = _gstlearn.EKrigOpt_E_DGM

    def toEnum(self):
        return _gstlearn.EKrigOpt_toEnum(self)

# Register EKrigOpt in _gstlearn:
_gstlearn.EKrigOpt_swigregister(EKrigOpt)
cvar = _gstlearn.cvar
EKrigOpt.POINT = _gstlearn.cvar.EKrigOpt_POINT
EKrigOpt.BLOCK = _gstlearn.cvar.EKrigOpt_BLOCK
EKrigOpt.DRIFT = _gstlearn.cvar.EKrigOpt_DRIFT
EKrigOpt.DGM = _gstlearn.cvar.EKrigOpt_DGM

class ESPDECalcModeIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ESPDECalcModeIterator

    def __init__(self, arg2):
        _gstlearn.ESPDECalcModeIterator_swiginit(self, _gstlearn.new_ESPDECalcModeIterator(arg2))

    def __ref__(self):
        return _gstlearn.ESPDECalcModeIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ESPDECalcModeIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ESPDECalcModeIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ESPDECalcModeIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ESPDECalcModeIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ESPDECalcModeIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ESPDECalcModeIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ESPDECalcModeIterator_getDescr(self)

# Register ESPDECalcModeIterator in _gstlearn:
_gstlearn.ESPDECalcModeIterator_swigregister(ESPDECalcModeIterator)
class ESPDECalcMode(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ESPDECalcMode

    def __init__(self, *args):
        _gstlearn.ESPDECalcMode_swiginit(self, _gstlearn.new_ESPDECalcMode(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ESPDECalcMode_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ESPDECalcMode_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ESPDECalcMode_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ESPDECalcMode_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ESPDECalcMode_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ESPDECalcMode_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ESPDECalcMode_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ESPDECalcMode_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ESPDECalcMode_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ESPDECalcMode_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ESPDECalcMode_fromValues(values)
    E_KRIGING = _gstlearn.ESPDECalcMode_E_KRIGING
    E_KRIGVAR = _gstlearn.ESPDECalcMode_E_KRIGVAR
    E_SIMUCOND = _gstlearn.ESPDECalcMode_E_SIMUCOND
    E_SIMUNONCOND = _gstlearn.ESPDECalcMode_E_SIMUNONCOND

    def toEnum(self):
        return _gstlearn.ESPDECalcMode_toEnum(self)

# Register ESPDECalcMode in _gstlearn:
_gstlearn.ESPDECalcMode_swigregister(ESPDECalcMode)
ESPDECalcMode.KRIGING = _gstlearn.cvar.ESPDECalcMode_KRIGING
ESPDECalcMode.KRIGVAR = _gstlearn.cvar.ESPDECalcMode_KRIGVAR
ESPDECalcMode.SIMUCOND = _gstlearn.cvar.ESPDECalcMode_SIMUCOND
ESPDECalcMode.SIMUNONCOND = _gstlearn.cvar.ESPDECalcMode_SIMUNONCOND

class EAnamIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EAnamIterator

    def __init__(self, arg2):
        _gstlearn.EAnamIterator_swiginit(self, _gstlearn.new_EAnamIterator(arg2))

    def __ref__(self):
        return _gstlearn.EAnamIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EAnamIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EAnamIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EAnamIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EAnamIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EAnamIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EAnamIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EAnamIterator_getDescr(self)

# Register EAnamIterator in _gstlearn:
_gstlearn.EAnamIterator_swigregister(EAnamIterator)
class EAnam(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EAnam

    def __init__(self, *args):
        _gstlearn.EAnam_swiginit(self, _gstlearn.new_EAnam(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EAnam_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EAnam_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EAnam_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EAnam_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EAnam_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EAnam_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EAnam_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EAnam_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EAnam_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EAnam_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EAnam_fromValues(values)
    E_UNKNOWN = _gstlearn.EAnam_E_UNKNOWN
    E_EXTERNAL = _gstlearn.EAnam_E_EXTERNAL
    E_HERMITIAN = _gstlearn.EAnam_E_HERMITIAN
    E_EMPIRICAL = _gstlearn.EAnam_E_EMPIRICAL
    E_DISCRETE_DD = _gstlearn.EAnam_E_DISCRETE_DD
    E_DISCRETE_IR = _gstlearn.EAnam_E_DISCRETE_IR

    def toEnum(self):
        return _gstlearn.EAnam_toEnum(self)

# Register EAnam in _gstlearn:
_gstlearn.EAnam_swigregister(EAnam)
EAnam.UNKNOWN = _gstlearn.cvar.EAnam_UNKNOWN
EAnam.EXTERNAL = _gstlearn.cvar.EAnam_EXTERNAL
EAnam.HERMITIAN = _gstlearn.cvar.EAnam_HERMITIAN
EAnam.EMPIRICAL = _gstlearn.cvar.EAnam_EMPIRICAL
EAnam.DISCRETE_DD = _gstlearn.cvar.EAnam_DISCRETE_DD
EAnam.DISCRETE_IR = _gstlearn.cvar.EAnam_DISCRETE_IR

class ECstIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECstIterator

    def __init__(self, arg2):
        _gstlearn.ECstIterator_swiginit(self, _gstlearn.new_ECstIterator(arg2))

    def __ref__(self):
        return _gstlearn.ECstIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ECstIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ECstIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ECstIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ECstIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ECstIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ECstIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ECstIterator_getDescr(self)

# Register ECstIterator in _gstlearn:
_gstlearn.ECstIterator_swigregister(ECstIterator)
class ECst(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECst

    def __init__(self, *args):
        _gstlearn.ECst_swiginit(self, _gstlearn.new_ECst(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ECst_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ECst_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ECst_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ECst_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ECst_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ECst_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ECst_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ECst_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ECst_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ECst_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ECst_fromValues(values)
    E_NTCAR = _gstlearn.ECst_E_NTCAR
    E_NTDEC = _gstlearn.ECst_E_NTDEC
    E_NTROW = _gstlearn.ECst_E_NTROW
    E_NTCOL = _gstlearn.ECst_E_NTCOL
    E_NTBATCH = _gstlearn.ECst_E_NTBATCH
    E_NTNAME = _gstlearn.ECst_E_NTNAME
    E_NTRANK = _gstlearn.ECst_E_NTRANK
    E_NPROC = _gstlearn.ECst_E_NPROC
    E_LOCMOD = _gstlearn.ECst_E_LOCMOD

    def toEnum(self):
        return _gstlearn.ECst_toEnum(self)

# Register ECst in _gstlearn:
_gstlearn.ECst_swigregister(ECst)
ECst.NTCAR = _gstlearn.cvar.ECst_NTCAR
ECst.NTDEC = _gstlearn.cvar.ECst_NTDEC
ECst.NTROW = _gstlearn.cvar.ECst_NTROW
ECst.NTCOL = _gstlearn.cvar.ECst_NTCOL
ECst.NTBATCH = _gstlearn.cvar.ECst_NTBATCH
ECst.NTNAME = _gstlearn.cvar.ECst_NTNAME
ECst.NTRANK = _gstlearn.cvar.ECst_NTRANK
ECst.NPROC = _gstlearn.cvar.ECst_NPROC
ECst.LOCMOD = _gstlearn.cvar.ECst_LOCMOD

class EDbgIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EDbgIterator

    def __init__(self, arg2):
        _gstlearn.EDbgIterator_swiginit(self, _gstlearn.new_EDbgIterator(arg2))

    def __ref__(self):
        return _gstlearn.EDbgIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EDbgIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EDbgIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EDbgIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EDbgIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EDbgIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EDbgIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EDbgIterator_getDescr(self)

# Register EDbgIterator in _gstlearn:
_gstlearn.EDbgIterator_swigregister(EDbgIterator)
class EDbg(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EDbg

    def __init__(self, *args):
        _gstlearn.EDbg_swiginit(self, _gstlearn.new_EDbg(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EDbg_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EDbg_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EDbg_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EDbg_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EDbg_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EDbg_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EDbg_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EDbg_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EDbg_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EDbg_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EDbg_fromValues(values)
    E_INTERFACE = _gstlearn.EDbg_E_INTERFACE
    E_DB = _gstlearn.EDbg_E_DB
    E_NBGH = _gstlearn.EDbg_E_NBGH
    E_MODEL = _gstlearn.EDbg_E_MODEL
    E_KRIGING = _gstlearn.EDbg_E_KRIGING
    E_SIMULATE = _gstlearn.EDbg_E_SIMULATE
    E_RESULTS = _gstlearn.EDbg_E_RESULTS
    E_VARIOGRAM = _gstlearn.EDbg_E_VARIOGRAM
    E_CONVERGE = _gstlearn.EDbg_E_CONVERGE
    E_CONDEXP = _gstlearn.EDbg_E_CONDEXP
    E_BAYES = _gstlearn.EDbg_E_BAYES
    E_MORPHO = _gstlearn.EDbg_E_MORPHO
    E_PROPS = _gstlearn.EDbg_E_PROPS
    E_UPSCALE = _gstlearn.EDbg_E_UPSCALE
    E_SPDE = _gstlearn.EDbg_E_SPDE

    def toEnum(self):
        return _gstlearn.EDbg_toEnum(self)

# Register EDbg in _gstlearn:
_gstlearn.EDbg_swigregister(EDbg)
EDbg.INTERFACE = _gstlearn.cvar.EDbg_INTERFACE
EDbg.DB = _gstlearn.cvar.EDbg_DB
EDbg.NBGH = _gstlearn.cvar.EDbg_NBGH
EDbg.MODEL = _gstlearn.cvar.EDbg_MODEL
EDbg.KRIGING = _gstlearn.cvar.EDbg_KRIGING
EDbg.SIMULATE = _gstlearn.cvar.EDbg_SIMULATE
EDbg.RESULTS = _gstlearn.cvar.EDbg_RESULTS
EDbg.VARIOGRAM = _gstlearn.cvar.EDbg_VARIOGRAM
EDbg.CONVERGE = _gstlearn.cvar.EDbg_CONVERGE
EDbg.CONDEXP = _gstlearn.cvar.EDbg_CONDEXP
EDbg.BAYES = _gstlearn.cvar.EDbg_BAYES
EDbg.MORPHO = _gstlearn.cvar.EDbg_MORPHO
EDbg.PROPS = _gstlearn.cvar.EDbg_PROPS
EDbg.UPSCALE = _gstlearn.cvar.EDbg_UPSCALE
EDbg.SPDE = _gstlearn.cvar.EDbg_SPDE

class ELawIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ELawIterator

    def __init__(self, arg2):
        _gstlearn.ELawIterator_swiginit(self, _gstlearn.new_ELawIterator(arg2))

    def __ref__(self):
        return _gstlearn.ELawIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ELawIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ELawIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ELawIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ELawIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ELawIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ELawIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ELawIterator_getDescr(self)

# Register ELawIterator in _gstlearn:
_gstlearn.ELawIterator_swigregister(ELawIterator)
class ELaw(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ELaw

    def __init__(self, *args):
        _gstlearn.ELaw_swiginit(self, _gstlearn.new_ELaw(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ELaw_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ELaw_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ELaw_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ELaw_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ELaw_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ELaw_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ELaw_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ELaw_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ELaw_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ELaw_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ELaw_fromValues(values)
    E_CONSTANT = _gstlearn.ELaw_E_CONSTANT
    E_UNIFORM = _gstlearn.ELaw_E_UNIFORM
    E_GAUSSIAN = _gstlearn.ELaw_E_GAUSSIAN
    E_EXPONENTIAL = _gstlearn.ELaw_E_EXPONENTIAL
    E_GAMMA = _gstlearn.ELaw_E_GAMMA
    E_STABLE = _gstlearn.ELaw_E_STABLE
    E_BETA1 = _gstlearn.ELaw_E_BETA1
    E_BETA2 = _gstlearn.ELaw_E_BETA2

    def toEnum(self):
        return _gstlearn.ELaw_toEnum(self)

# Register ELaw in _gstlearn:
_gstlearn.ELaw_swigregister(ELaw)
ELaw.CONSTANT = _gstlearn.cvar.ELaw_CONSTANT
ELaw.UNIFORM = _gstlearn.cvar.ELaw_UNIFORM
ELaw.GAUSSIAN = _gstlearn.cvar.ELaw_GAUSSIAN
ELaw.EXPONENTIAL = _gstlearn.cvar.ELaw_EXPONENTIAL
ELaw.GAMMA = _gstlearn.cvar.ELaw_GAMMA
ELaw.STABLE = _gstlearn.cvar.ELaw_STABLE
ELaw.BETA1 = _gstlearn.cvar.ELaw_BETA1
ELaw.BETA2 = _gstlearn.cvar.ELaw_BETA2

class EShapeIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EShapeIterator

    def __init__(self, arg2):
        _gstlearn.EShapeIterator_swiginit(self, _gstlearn.new_EShapeIterator(arg2))

    def __ref__(self):
        return _gstlearn.EShapeIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EShapeIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EShapeIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EShapeIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EShapeIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EShapeIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EShapeIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EShapeIterator_getDescr(self)

# Register EShapeIterator in _gstlearn:
_gstlearn.EShapeIterator_swigregister(EShapeIterator)
class EShape(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EShape

    def __init__(self, *args):
        _gstlearn.EShape_swiginit(self, _gstlearn.new_EShape(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EShape_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EShape_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EShape_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EShape_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EShape_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EShape_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EShape_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EShape_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EShape_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EShape_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EShape_fromValues(values)
    E_PARALLELEPIPED = _gstlearn.EShape_E_PARALLELEPIPED
    E_ELLIPSOID = _gstlearn.EShape_E_ELLIPSOID
    E_PARABOLOID = _gstlearn.EShape_E_PARABOLOID
    E_HALFELLIPSOID = _gstlearn.EShape_E_HALFELLIPSOID
    E_HALFPARABOLOID = _gstlearn.EShape_E_HALFPARABOLOID
    E_HALFSINUSOID = _gstlearn.EShape_E_HALFSINUSOID

    def toEnum(self):
        return _gstlearn.EShape_toEnum(self)

# Register EShape in _gstlearn:
_gstlearn.EShape_swigregister(EShape)
EShape.PARALLELEPIPED = _gstlearn.cvar.EShape_PARALLELEPIPED
EShape.ELLIPSOID = _gstlearn.cvar.EShape_ELLIPSOID
EShape.PARABOLOID = _gstlearn.cvar.EShape_PARABOLOID
EShape.HALFELLIPSOID = _gstlearn.cvar.EShape_HALFELLIPSOID
EShape.HALFPARABOLOID = _gstlearn.cvar.EShape_HALFPARABOLOID
EShape.HALFSINUSOID = _gstlearn.cvar.EShape_HALFSINUSOID

class EConvDirIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConvDirIterator

    def __init__(self, arg2):
        _gstlearn.EConvDirIterator_swiginit(self, _gstlearn.new_EConvDirIterator(arg2))

    def __ref__(self):
        return _gstlearn.EConvDirIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EConvDirIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EConvDirIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EConvDirIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EConvDirIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EConvDirIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EConvDirIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EConvDirIterator_getDescr(self)

# Register EConvDirIterator in _gstlearn:
_gstlearn.EConvDirIterator_swigregister(EConvDirIterator)
class EConvDir(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConvDir

    def __init__(self, *args):
        _gstlearn.EConvDir_swiginit(self, _gstlearn.new_EConvDir(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EConvDir_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EConvDir_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EConvDir_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EConvDir_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EConvDir_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EConvDir_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EConvDir_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EConvDir_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EConvDir_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EConvDir_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EConvDir_fromValues(values)
    E_X = _gstlearn.EConvDir_E_X
    E_Y = _gstlearn.EConvDir_E_Y
    E_Z = _gstlearn.EConvDir_E_Z
    E_XY = _gstlearn.EConvDir_E_XY
    E_XYZ = _gstlearn.EConvDir_E_XYZ

    def toEnum(self):
        return _gstlearn.EConvDir_toEnum(self)

# Register EConvDir in _gstlearn:
_gstlearn.EConvDir_swigregister(EConvDir)
EConvDir.X = _gstlearn.cvar.EConvDir_X
EConvDir.Y = _gstlearn.cvar.EConvDir_Y
EConvDir.Z = _gstlearn.cvar.EConvDir_Z
EConvDir.XY = _gstlearn.cvar.EConvDir_XY
EConvDir.XYZ = _gstlearn.cvar.EConvDir_XYZ

class ECalcVarioIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECalcVarioIterator

    def __init__(self, arg2):
        _gstlearn.ECalcVarioIterator_swiginit(self, _gstlearn.new_ECalcVarioIterator(arg2))

    def __ref__(self):
        return _gstlearn.ECalcVarioIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ECalcVarioIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ECalcVarioIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ECalcVarioIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ECalcVarioIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ECalcVarioIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ECalcVarioIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ECalcVarioIterator_getDescr(self)

# Register ECalcVarioIterator in _gstlearn:
_gstlearn.ECalcVarioIterator_swigregister(ECalcVarioIterator)
class ECalcVario(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECalcVario

    def __init__(self, *args):
        _gstlearn.ECalcVario_swiginit(self, _gstlearn.new_ECalcVario(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ECalcVario_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ECalcVario_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ECalcVario_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ECalcVario_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ECalcVario_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ECalcVario_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ECalcVario_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ECalcVario_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ECalcVario_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ECalcVario_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ECalcVario_fromValues(values)
    E_UNDEFINED = _gstlearn.ECalcVario_E_UNDEFINED
    E_VARIOGRAM = _gstlearn.ECalcVario_E_VARIOGRAM
    E_COVARIANCE = _gstlearn.ECalcVario_E_COVARIANCE
    E_COVARIOGRAM = _gstlearn.ECalcVario_E_COVARIOGRAM
    E_MADOGRAM = _gstlearn.ECalcVario_E_MADOGRAM
    E_RODOGRAM = _gstlearn.ECalcVario_E_RODOGRAM
    E_POISSON = _gstlearn.ECalcVario_E_POISSON
    E_GENERAL1 = _gstlearn.ECalcVario_E_GENERAL1
    E_GENERAL2 = _gstlearn.ECalcVario_E_GENERAL2
    E_GENERAL3 = _gstlearn.ECalcVario_E_GENERAL3
    E_COVARIANCE_NC = _gstlearn.ECalcVario_E_COVARIANCE_NC
    E_ORDER4 = _gstlearn.ECalcVario_E_ORDER4
    E_TRANS1 = _gstlearn.ECalcVario_E_TRANS1
    E_TRANS2 = _gstlearn.ECalcVario_E_TRANS2
    E_BINORMAL = _gstlearn.ECalcVario_E_BINORMAL

    def toEnum(self):
        return _gstlearn.ECalcVario_toEnum(self)

# Register ECalcVario in _gstlearn:
_gstlearn.ECalcVario_swigregister(ECalcVario)
ECalcVario.UNDEFINED = _gstlearn.cvar.ECalcVario_UNDEFINED
ECalcVario.VARIOGRAM = _gstlearn.cvar.ECalcVario_VARIOGRAM
ECalcVario.COVARIANCE = _gstlearn.cvar.ECalcVario_COVARIANCE
ECalcVario.COVARIOGRAM = _gstlearn.cvar.ECalcVario_COVARIOGRAM
ECalcVario.MADOGRAM = _gstlearn.cvar.ECalcVario_MADOGRAM
ECalcVario.RODOGRAM = _gstlearn.cvar.ECalcVario_RODOGRAM
ECalcVario.POISSON = _gstlearn.cvar.ECalcVario_POISSON
ECalcVario.GENERAL1 = _gstlearn.cvar.ECalcVario_GENERAL1
ECalcVario.GENERAL2 = _gstlearn.cvar.ECalcVario_GENERAL2
ECalcVario.GENERAL3 = _gstlearn.cvar.ECalcVario_GENERAL3
ECalcVario.COVARIANCE_NC = _gstlearn.cvar.ECalcVario_COVARIANCE_NC
ECalcVario.ORDER4 = _gstlearn.cvar.ECalcVario_ORDER4
ECalcVario.TRANS1 = _gstlearn.cvar.ECalcVario_TRANS1
ECalcVario.TRANS2 = _gstlearn.cvar.ECalcVario_TRANS2
ECalcVario.BINORMAL = _gstlearn.cvar.ECalcVario_BINORMAL

class EConvTypeIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConvTypeIterator

    def __init__(self, arg2):
        _gstlearn.EConvTypeIterator_swiginit(self, _gstlearn.new_EConvTypeIterator(arg2))

    def __ref__(self):
        return _gstlearn.EConvTypeIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EConvTypeIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EConvTypeIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EConvTypeIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EConvTypeIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EConvTypeIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EConvTypeIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EConvTypeIterator_getDescr(self)

# Register EConvTypeIterator in _gstlearn:
_gstlearn.EConvTypeIterator_swigregister(EConvTypeIterator)
class EConvType(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConvType

    def __init__(self, *args):
        _gstlearn.EConvType_swiginit(self, _gstlearn.new_EConvType(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EConvType_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EConvType_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EConvType_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EConvType_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EConvType_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EConvType_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EConvType_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EConvType_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EConvType_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EConvType_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EConvType_fromValues(values)
    E_UNKNOWN = _gstlearn.EConvType_E_UNKNOWN
    E_UNIFORM = _gstlearn.EConvType_E_UNIFORM
    E_EXPONENTIAL = _gstlearn.EConvType_E_EXPONENTIAL
    E_GAUSSIAN = _gstlearn.EConvType_E_GAUSSIAN
    E_SINCARD = _gstlearn.EConvType_E_SINCARD

    def toEnum(self):
        return _gstlearn.EConvType_toEnum(self)

# Register EConvType in _gstlearn:
_gstlearn.EConvType_swigregister(EConvType)
EConvType.UNKNOWN = _gstlearn.cvar.EConvType_UNKNOWN
EConvType.UNIFORM = _gstlearn.cvar.EConvType_UNIFORM
EConvType.EXPONENTIAL = _gstlearn.cvar.EConvType_EXPONENTIAL
EConvType.GAUSSIAN = _gstlearn.cvar.EConvType_GAUSSIAN
EConvType.SINCARD = _gstlearn.cvar.EConvType_SINCARD

class ECovIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECovIterator

    def __init__(self, arg2):
        _gstlearn.ECovIterator_swiginit(self, _gstlearn.new_ECovIterator(arg2))

    def __ref__(self):
        return _gstlearn.ECovIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ECovIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ECovIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ECovIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ECovIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ECovIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ECovIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ECovIterator_getDescr(self)

# Register ECovIterator in _gstlearn:
_gstlearn.ECovIterator_swigregister(ECovIterator)
class ECov(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECov

    def __init__(self, *args):
        _gstlearn.ECov_swiginit(self, _gstlearn.new_ECov(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ECov_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ECov_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ECov_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ECov_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ECov_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ECov_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ECov_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ECov_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ECov_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ECov_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ECov_fromValues(values)
    E_UNKNOWN = _gstlearn.ECov_E_UNKNOWN
    E_FUNCTION = _gstlearn.ECov_E_FUNCTION
    E_NUGGET = _gstlearn.ECov_E_NUGGET
    E_EXPONENTIAL = _gstlearn.ECov_E_EXPONENTIAL
    E_SPHERICAL = _gstlearn.ECov_E_SPHERICAL
    E_GAUSSIAN = _gstlearn.ECov_E_GAUSSIAN
    E_CUBIC = _gstlearn.ECov_E_CUBIC
    E_SINCARD = _gstlearn.ECov_E_SINCARD
    E_BESSELJ = _gstlearn.ECov_E_BESSELJ
    E_MATERN = _gstlearn.ECov_E_MATERN
    E_GAMMA = _gstlearn.ECov_E_GAMMA
    E_CAUCHY = _gstlearn.ECov_E_CAUCHY
    E_STABLE = _gstlearn.ECov_E_STABLE
    E_LINEAR = _gstlearn.ECov_E_LINEAR
    E_POWER = _gstlearn.ECov_E_POWER
    E_ORDER1_GC = _gstlearn.ECov_E_ORDER1_GC
    E_SPLINE_GC = _gstlearn.ECov_E_SPLINE_GC
    E_ORDER3_GC = _gstlearn.ECov_E_ORDER3_GC
    E_ORDER5_GC = _gstlearn.ECov_E_ORDER5_GC
    E_COSINUS = _gstlearn.ECov_E_COSINUS
    E_TRIANGLE = _gstlearn.ECov_E_TRIANGLE
    E_COSEXP = _gstlearn.ECov_E_COSEXP
    E_REG1D = _gstlearn.ECov_E_REG1D
    E_PENTA = _gstlearn.ECov_E_PENTA
    E_SPLINE2_GC = _gstlearn.ECov_E_SPLINE2_GC
    E_STORKEY = _gstlearn.ECov_E_STORKEY
    E_WENDLAND0 = _gstlearn.ECov_E_WENDLAND0
    E_WENDLAND1 = _gstlearn.ECov_E_WENDLAND1
    E_WENDLAND2 = _gstlearn.ECov_E_WENDLAND2
    E_MARKOV = _gstlearn.ECov_E_MARKOV
    E_GEOMETRIC = _gstlearn.ECov_E_GEOMETRIC
    E_POISSON = _gstlearn.ECov_E_POISSON
    E_LINEARSPH = _gstlearn.ECov_E_LINEARSPH

    def toEnum(self):
        return _gstlearn.ECov_toEnum(self)

# Register ECov in _gstlearn:
_gstlearn.ECov_swigregister(ECov)
ECov.UNKNOWN = _gstlearn.cvar.ECov_UNKNOWN
ECov.FUNCTION = _gstlearn.cvar.ECov_FUNCTION
ECov.NUGGET = _gstlearn.cvar.ECov_NUGGET
ECov.EXPONENTIAL = _gstlearn.cvar.ECov_EXPONENTIAL
ECov.SPHERICAL = _gstlearn.cvar.ECov_SPHERICAL
ECov.GAUSSIAN = _gstlearn.cvar.ECov_GAUSSIAN
ECov.CUBIC = _gstlearn.cvar.ECov_CUBIC
ECov.SINCARD = _gstlearn.cvar.ECov_SINCARD
ECov.BESSELJ = _gstlearn.cvar.ECov_BESSELJ
ECov.MATERN = _gstlearn.cvar.ECov_MATERN
ECov.GAMMA = _gstlearn.cvar.ECov_GAMMA
ECov.CAUCHY = _gstlearn.cvar.ECov_CAUCHY
ECov.STABLE = _gstlearn.cvar.ECov_STABLE
ECov.LINEAR = _gstlearn.cvar.ECov_LINEAR
ECov.POWER = _gstlearn.cvar.ECov_POWER
ECov.ORDER1_GC = _gstlearn.cvar.ECov_ORDER1_GC
ECov.SPLINE_GC = _gstlearn.cvar.ECov_SPLINE_GC
ECov.ORDER3_GC = _gstlearn.cvar.ECov_ORDER3_GC
ECov.ORDER5_GC = _gstlearn.cvar.ECov_ORDER5_GC
ECov.COSINUS = _gstlearn.cvar.ECov_COSINUS
ECov.TRIANGLE = _gstlearn.cvar.ECov_TRIANGLE
ECov.COSEXP = _gstlearn.cvar.ECov_COSEXP
ECov.REG1D = _gstlearn.cvar.ECov_REG1D
ECov.PENTA = _gstlearn.cvar.ECov_PENTA
ECov.SPLINE2_GC = _gstlearn.cvar.ECov_SPLINE2_GC
ECov.STORKEY = _gstlearn.cvar.ECov_STORKEY
ECov.WENDLAND0 = _gstlearn.cvar.ECov_WENDLAND0
ECov.WENDLAND1 = _gstlearn.cvar.ECov_WENDLAND1
ECov.WENDLAND2 = _gstlearn.cvar.ECov_WENDLAND2
ECov.MARKOV = _gstlearn.cvar.ECov_MARKOV
ECov.GEOMETRIC = _gstlearn.cvar.ECov_GEOMETRIC
ECov.POISSON = _gstlearn.cvar.ECov_POISSON
ECov.LINEARSPH = _gstlearn.cvar.ECov_LINEARSPH

class ETapeIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ETapeIterator

    def __init__(self, arg2):
        _gstlearn.ETapeIterator_swiginit(self, _gstlearn.new_ETapeIterator(arg2))

    def __ref__(self):
        return _gstlearn.ETapeIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ETapeIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ETapeIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ETapeIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ETapeIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ETapeIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ETapeIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ETapeIterator_getDescr(self)

# Register ETapeIterator in _gstlearn:
_gstlearn.ETapeIterator_swigregister(ETapeIterator)
class ETape(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ETape

    def __init__(self, *args):
        _gstlearn.ETape_swiginit(self, _gstlearn.new_ETape(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ETape_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ETape_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ETape_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ETape_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ETape_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ETape_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ETape_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ETape_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ETape_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ETape_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ETape_fromValues(values)
    E_SPHERICAL = _gstlearn.ETape_E_SPHERICAL
    E_CUBIC = _gstlearn.ETape_E_CUBIC
    E_TRIANGLE = _gstlearn.ETape_E_TRIANGLE
    E_PENTAMODEL = _gstlearn.ETape_E_PENTAMODEL
    E_STORKEY = _gstlearn.ETape_E_STORKEY
    E_WENDLAND1 = _gstlearn.ETape_E_WENDLAND1
    E_WENDLAND2 = _gstlearn.ETape_E_WENDLAND2

    def toEnum(self):
        return _gstlearn.ETape_toEnum(self)

# Register ETape in _gstlearn:
_gstlearn.ETape_swigregister(ETape)
ETape.SPHERICAL = _gstlearn.cvar.ETape_SPHERICAL
ETape.CUBIC = _gstlearn.cvar.ETape_CUBIC
ETape.TRIANGLE = _gstlearn.cvar.ETape_TRIANGLE
ETape.PENTAMODEL = _gstlearn.cvar.ETape_PENTAMODEL
ETape.STORKEY = _gstlearn.cvar.ETape_STORKEY
ETape.WENDLAND1 = _gstlearn.cvar.ETape_WENDLAND1
ETape.WENDLAND2 = _gstlearn.cvar.ETape_WENDLAND2

class ELoadByIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ELoadByIterator

    def __init__(self, arg2):
        _gstlearn.ELoadByIterator_swiginit(self, _gstlearn.new_ELoadByIterator(arg2))

    def __ref__(self):
        return _gstlearn.ELoadByIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ELoadByIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ELoadByIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ELoadByIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ELoadByIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ELoadByIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ELoadByIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ELoadByIterator_getDescr(self)

# Register ELoadByIterator in _gstlearn:
_gstlearn.ELoadByIterator_swigregister(ELoadByIterator)
class ELoadBy(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ELoadBy

    def __init__(self, *args):
        _gstlearn.ELoadBy_swiginit(self, _gstlearn.new_ELoadBy(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ELoadBy_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ELoadBy_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ELoadBy_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ELoadBy_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ELoadBy_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ELoadBy_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ELoadBy_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ELoadBy_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ELoadBy_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ELoadBy_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ELoadBy_fromValues(values)
    E_COLUMN = _gstlearn.ELoadBy_E_COLUMN
    E_SAMPLE = _gstlearn.ELoadBy_E_SAMPLE

    def toEnum(self):
        return _gstlearn.ELoadBy_toEnum(self)

# Register ELoadBy in _gstlearn:
_gstlearn.ELoadBy_swigregister(ELoadBy)
ELoadBy.COLUMN = _gstlearn.cvar.ELoadBy_COLUMN
ELoadBy.SAMPLE = _gstlearn.cvar.ELoadBy_SAMPLE

class ELocIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ELocIterator

    def __init__(self, arg2):
        _gstlearn.ELocIterator_swiginit(self, _gstlearn.new_ELocIterator(arg2))

    def __ref__(self):
        return _gstlearn.ELocIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ELocIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ELocIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ELocIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ELocIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ELocIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ELocIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ELocIterator_getDescr(self)

# Register ELocIterator in _gstlearn:
_gstlearn.ELocIterator_swigregister(ELocIterator)
class ELoc(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ELoc

    def __init__(self, *args):
        _gstlearn.ELoc_swiginit(self, _gstlearn.new_ELoc(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ELoc_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ELoc_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ELoc_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ELoc_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ELoc_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ELoc_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ELoc_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ELoc_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ELoc_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ELoc_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ELoc_fromValues(values)
    E_UNKNOWN = _gstlearn.ELoc_E_UNKNOWN
    E_X = _gstlearn.ELoc_E_X
    E_Z = _gstlearn.ELoc_E_Z
    E_V = _gstlearn.ELoc_E_V
    E_F = _gstlearn.ELoc_E_F
    E_G = _gstlearn.ELoc_E_G
    E_L = _gstlearn.ELoc_E_L
    E_U = _gstlearn.ELoc_E_U
    E_P = _gstlearn.ELoc_E_P
    E_W = _gstlearn.ELoc_E_W
    E_C = _gstlearn.ELoc_E_C
    E_SEL = _gstlearn.ELoc_E_SEL
    E_DOM = _gstlearn.ELoc_E_DOM
    E_BLEX = _gstlearn.ELoc_E_BLEX
    E_ADIR = _gstlearn.ELoc_E_ADIR
    E_ADIP = _gstlearn.ELoc_E_ADIP
    E_SIZE = _gstlearn.ELoc_E_SIZE
    E_BU = _gstlearn.ELoc_E_BU
    E_BD = _gstlearn.ELoc_E_BD
    E_TIME = _gstlearn.ELoc_E_TIME
    E_LAYER = _gstlearn.ELoc_E_LAYER
    E_NOSTAT = _gstlearn.ELoc_E_NOSTAT
    E_TGTE = _gstlearn.ELoc_E_TGTE
    E_SIMU = _gstlearn.ELoc_E_SIMU
    E_FACIES = _gstlearn.ELoc_E_FACIES
    E_GAUSFAC = _gstlearn.ELoc_E_GAUSFAC
    E_DATE = _gstlearn.ELoc_E_DATE
    E_RKLOW = _gstlearn.ELoc_E_RKLOW
    E_RKUP = _gstlearn.ELoc_E_RKUP
    E_SUM = _gstlearn.ELoc_E_SUM

    def toEnum(self):
        return _gstlearn.ELoc_toEnum(self)

# Register ELoc in _gstlearn:
_gstlearn.ELoc_swigregister(ELoc)
ELoc.UNKNOWN = _gstlearn.cvar.ELoc_UNKNOWN
ELoc.X = _gstlearn.cvar.ELoc_X
ELoc.Z = _gstlearn.cvar.ELoc_Z
ELoc.V = _gstlearn.cvar.ELoc_V
ELoc.F = _gstlearn.cvar.ELoc_F
ELoc.G = _gstlearn.cvar.ELoc_G
ELoc.L = _gstlearn.cvar.ELoc_L
ELoc.U = _gstlearn.cvar.ELoc_U
ELoc.P = _gstlearn.cvar.ELoc_P
ELoc.W = _gstlearn.cvar.ELoc_W
ELoc.C = _gstlearn.cvar.ELoc_C
ELoc.SEL = _gstlearn.cvar.ELoc_SEL
ELoc.DOM = _gstlearn.cvar.ELoc_DOM
ELoc.BLEX = _gstlearn.cvar.ELoc_BLEX
ELoc.ADIR = _gstlearn.cvar.ELoc_ADIR
ELoc.ADIP = _gstlearn.cvar.ELoc_ADIP
ELoc.SIZE = _gstlearn.cvar.ELoc_SIZE
ELoc.BU = _gstlearn.cvar.ELoc_BU
ELoc.BD = _gstlearn.cvar.ELoc_BD
ELoc.TIME = _gstlearn.cvar.ELoc_TIME
ELoc.LAYER = _gstlearn.cvar.ELoc_LAYER
ELoc.NOSTAT = _gstlearn.cvar.ELoc_NOSTAT
ELoc.TGTE = _gstlearn.cvar.ELoc_TGTE
ELoc.SIMU = _gstlearn.cvar.ELoc_SIMU
ELoc.FACIES = _gstlearn.cvar.ELoc_FACIES
ELoc.GAUSFAC = _gstlearn.cvar.ELoc_GAUSFAC
ELoc.DATE = _gstlearn.cvar.ELoc_DATE
ELoc.RKLOW = _gstlearn.cvar.ELoc_RKLOW
ELoc.RKUP = _gstlearn.cvar.ELoc_RKUP
ELoc.SUM = _gstlearn.cvar.ELoc_SUM

class EOperatorIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EOperatorIterator

    def __init__(self, arg2):
        _gstlearn.EOperatorIterator_swiginit(self, _gstlearn.new_EOperatorIterator(arg2))

    def __ref__(self):
        return _gstlearn.EOperatorIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EOperatorIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EOperatorIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EOperatorIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EOperatorIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EOperatorIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EOperatorIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EOperatorIterator_getDescr(self)

# Register EOperatorIterator in _gstlearn:
_gstlearn.EOperatorIterator_swigregister(EOperatorIterator)
class EOperator(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EOperator

    def __init__(self, *args):
        _gstlearn.EOperator_swiginit(self, _gstlearn.new_EOperator(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EOperator_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EOperator_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EOperator_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EOperator_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EOperator_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EOperator_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EOperator_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EOperator_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EOperator_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EOperator_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EOperator_fromValues(values)
    E_IDLE = _gstlearn.EOperator_E_IDLE
    E_ADD = _gstlearn.EOperator_E_ADD
    E_PRODUCT = _gstlearn.EOperator_E_PRODUCT
    E_SUBTRACT = _gstlearn.EOperator_E_SUBTRACT
    E_SUBOPP = _gstlearn.EOperator_E_SUBOPP
    E_DIVIDE = _gstlearn.EOperator_E_DIVIDE
    E_DIVOPP = _gstlearn.EOperator_E_DIVOPP
    E_DEFINE = _gstlearn.EOperator_E_DEFINE
    E_MIN = _gstlearn.EOperator_E_MIN
    E_MAX = _gstlearn.EOperator_E_MAX

    def toEnum(self):
        return _gstlearn.EOperator_toEnum(self)

# Register EOperator in _gstlearn:
_gstlearn.EOperator_swigregister(EOperator)
EOperator.IDLE = _gstlearn.cvar.EOperator_IDLE
EOperator.ADD = _gstlearn.cvar.EOperator_ADD
EOperator.PRODUCT = _gstlearn.cvar.EOperator_PRODUCT
EOperator.SUBTRACT = _gstlearn.cvar.EOperator_SUBTRACT
EOperator.SUBOPP = _gstlearn.cvar.EOperator_SUBOPP
EOperator.DIVIDE = _gstlearn.cvar.EOperator_DIVIDE
EOperator.DIVOPP = _gstlearn.cvar.EOperator_DIVOPP
EOperator.DEFINE = _gstlearn.cvar.EOperator_DEFINE
EOperator.MIN = _gstlearn.cvar.EOperator_MIN
EOperator.MAX = _gstlearn.cvar.EOperator_MAX

class EPowerPTIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EPowerPTIterator

    def __init__(self, arg2):
        _gstlearn.EPowerPTIterator_swiginit(self, _gstlearn.new_EPowerPTIterator(arg2))

    def __ref__(self):
        return _gstlearn.EPowerPTIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EPowerPTIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EPowerPTIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EPowerPTIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EPowerPTIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EPowerPTIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EPowerPTIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EPowerPTIterator_getDescr(self)

# Register EPowerPTIterator in _gstlearn:
_gstlearn.EPowerPTIterator_swigregister(EPowerPTIterator)
class EPowerPT(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EPowerPT

    def __init__(self, *args):
        _gstlearn.EPowerPT_swiginit(self, _gstlearn.new_EPowerPT(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EPowerPT_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EPowerPT_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EPowerPT_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EPowerPT_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EPowerPT_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EPowerPT_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EPowerPT_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EPowerPT_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EPowerPT_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EPowerPT_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EPowerPT_fromValues(values)
    E_UNDEFINED = _gstlearn.EPowerPT_E_UNDEFINED
    E_ONE = _gstlearn.EPowerPT_E_ONE
    E_MINUSONE = _gstlearn.EPowerPT_E_MINUSONE
    E_MINUSHALF = _gstlearn.EPowerPT_E_MINUSHALF
    E_HALF = _gstlearn.EPowerPT_E_HALF
    E_LOG = _gstlearn.EPowerPT_E_LOG

    def toEnum(self):
        return _gstlearn.EPowerPT_toEnum(self)

# Register EPowerPT in _gstlearn:
_gstlearn.EPowerPT_swigregister(EPowerPT)
EPowerPT.UNDEFINED = _gstlearn.cvar.EPowerPT_UNDEFINED
EPowerPT.ONE = _gstlearn.cvar.EPowerPT_ONE
EPowerPT.MINUSONE = _gstlearn.cvar.EPowerPT_MINUSONE
EPowerPT.MINUSHALF = _gstlearn.cvar.EPowerPT_MINUSHALF
EPowerPT.HALF = _gstlearn.cvar.EPowerPT_HALF
EPowerPT.LOG = _gstlearn.cvar.EPowerPT_LOG

class ERuleIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ERuleIterator

    def __init__(self, arg2):
        _gstlearn.ERuleIterator_swiginit(self, _gstlearn.new_ERuleIterator(arg2))

    def __ref__(self):
        return _gstlearn.ERuleIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ERuleIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ERuleIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ERuleIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ERuleIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ERuleIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ERuleIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ERuleIterator_getDescr(self)

# Register ERuleIterator in _gstlearn:
_gstlearn.ERuleIterator_swigregister(ERuleIterator)
class ERule(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ERule

    def __init__(self, *args):
        _gstlearn.ERule_swiginit(self, _gstlearn.new_ERule(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ERule_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ERule_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ERule_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ERule_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ERule_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ERule_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ERule_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ERule_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ERule_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ERule_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ERule_fromValues(values)
    E_STD = _gstlearn.ERule_E_STD
    E_SHIFT = _gstlearn.ERule_E_SHIFT
    E_SHADOW = _gstlearn.ERule_E_SHADOW

    def toEnum(self):
        return _gstlearn.ERule_toEnum(self)

# Register ERule in _gstlearn:
_gstlearn.ERule_swigregister(ERule)
ERule.STD = _gstlearn.cvar.ERule_STD
ERule.SHIFT = _gstlearn.cvar.ERule_SHIFT
ERule.SHADOW = _gstlearn.cvar.ERule_SHADOW

class EConsElemIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConsElemIterator

    def __init__(self, arg2):
        _gstlearn.EConsElemIterator_swiginit(self, _gstlearn.new_EConsElemIterator(arg2))

    def __ref__(self):
        return _gstlearn.EConsElemIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EConsElemIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EConsElemIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EConsElemIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EConsElemIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EConsElemIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EConsElemIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EConsElemIterator_getDescr(self)

# Register EConsElemIterator in _gstlearn:
_gstlearn.EConsElemIterator_swigregister(EConsElemIterator)
class EConsElem(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConsElem

    def __init__(self, *args):
        _gstlearn.EConsElem_swiginit(self, _gstlearn.new_EConsElem(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EConsElem_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EConsElem_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EConsElem_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EConsElem_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EConsElem_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EConsElem_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EConsElem_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EConsElem_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EConsElem_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EConsElem_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EConsElem_fromValues(values)
    E_UNKNOWN = _gstlearn.EConsElem_E_UNKNOWN
    E_RANGE = _gstlearn.EConsElem_E_RANGE
    E_ANGLE = _gstlearn.EConsElem_E_ANGLE
    E_PARAM = _gstlearn.EConsElem_E_PARAM
    E_SILL = _gstlearn.EConsElem_E_SILL
    E_SCALE = _gstlearn.EConsElem_E_SCALE
    E_T_RANGE = _gstlearn.EConsElem_E_T_RANGE
    E_VELOCITY = _gstlearn.EConsElem_E_VELOCITY
    E_SPHEROT = _gstlearn.EConsElem_E_SPHEROT
    E_TENSOR = _gstlearn.EConsElem_E_TENSOR

    def toEnum(self):
        return _gstlearn.EConsElem_toEnum(self)

# Register EConsElem in _gstlearn:
_gstlearn.EConsElem_swigregister(EConsElem)
EConsElem.UNKNOWN = _gstlearn.cvar.EConsElem_UNKNOWN
EConsElem.RANGE = _gstlearn.cvar.EConsElem_RANGE
EConsElem.ANGLE = _gstlearn.cvar.EConsElem_ANGLE
EConsElem.PARAM = _gstlearn.cvar.EConsElem_PARAM
EConsElem.SILL = _gstlearn.cvar.EConsElem_SILL
EConsElem.SCALE = _gstlearn.cvar.EConsElem_SCALE
EConsElem.T_RANGE = _gstlearn.cvar.EConsElem_T_RANGE
EConsElem.VELOCITY = _gstlearn.cvar.EConsElem_VELOCITY
EConsElem.SPHEROT = _gstlearn.cvar.EConsElem_SPHEROT
EConsElem.TENSOR = _gstlearn.cvar.EConsElem_TENSOR

class EConsTypeIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConsTypeIterator

    def __init__(self, arg2):
        _gstlearn.EConsTypeIterator_swiginit(self, _gstlearn.new_EConsTypeIterator(arg2))

    def __ref__(self):
        return _gstlearn.EConsTypeIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EConsTypeIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EConsTypeIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EConsTypeIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EConsTypeIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EConsTypeIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EConsTypeIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EConsTypeIterator_getDescr(self)

# Register EConsTypeIterator in _gstlearn:
_gstlearn.EConsTypeIterator_swigregister(EConsTypeIterator)
class EConsType(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EConsType

    def __init__(self, *args):
        _gstlearn.EConsType_swiginit(self, _gstlearn.new_EConsType(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EConsType_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EConsType_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EConsType_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EConsType_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EConsType_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EConsType_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EConsType_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EConsType_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EConsType_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EConsType_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EConsType_fromValues(values)
    E_LOWER = _gstlearn.EConsType_E_LOWER
    E_DEFAULT = _gstlearn.EConsType_E_DEFAULT
    E_UPPER = _gstlearn.EConsType_E_UPPER
    E_EQUAL = _gstlearn.EConsType_E_EQUAL

    def toEnum(self):
        return _gstlearn.EConsType_toEnum(self)

# Register EConsType in _gstlearn:
_gstlearn.EConsType_swigregister(EConsType)
EConsType.LOWER = _gstlearn.cvar.EConsType_LOWER
EConsType.DEFAULT = _gstlearn.cvar.EConsType_DEFAULT
EConsType.UPPER = _gstlearn.cvar.EConsType_UPPER
EConsType.EQUAL = _gstlearn.cvar.EConsType_EQUAL

class EModelPropertyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EModelPropertyIterator

    def __init__(self, arg2):
        _gstlearn.EModelPropertyIterator_swiginit(self, _gstlearn.new_EModelPropertyIterator(arg2))

    def __ref__(self):
        return _gstlearn.EModelPropertyIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EModelPropertyIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EModelPropertyIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EModelPropertyIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EModelPropertyIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EModelPropertyIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EModelPropertyIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EModelPropertyIterator_getDescr(self)

# Register EModelPropertyIterator in _gstlearn:
_gstlearn.EModelPropertyIterator_swigregister(EModelPropertyIterator)
class EModelProperty(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EModelProperty

    def __init__(self, *args):
        _gstlearn.EModelProperty_swiginit(self, _gstlearn.new_EModelProperty(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EModelProperty_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EModelProperty_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EModelProperty_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EModelProperty_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EModelProperty_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EModelProperty_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EModelProperty_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EModelProperty_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EModelProperty_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EModelProperty_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EModelProperty_fromValues(values)
    E_NONE = _gstlearn.EModelProperty_E_NONE
    E_CONV = _gstlearn.EModelProperty_E_CONV
    E_ANAM = _gstlearn.EModelProperty_E_ANAM
    E_TAPE = _gstlearn.EModelProperty_E_TAPE
    E_GRAD = _gstlearn.EModelProperty_E_GRAD

    def toEnum(self):
        return _gstlearn.EModelProperty_toEnum(self)

# Register EModelProperty in _gstlearn:
_gstlearn.EModelProperty_swigregister(EModelProperty)
EModelProperty.NONE = _gstlearn.cvar.EModelProperty_NONE
EModelProperty.CONV = _gstlearn.cvar.EModelProperty_CONV
EModelProperty.ANAM = _gstlearn.cvar.EModelProperty_ANAM
EModelProperty.TAPE = _gstlearn.cvar.EModelProperty_TAPE
EModelProperty.GRAD = _gstlearn.cvar.EModelProperty_GRAD

class EMorphoIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EMorphoIterator

    def __init__(self, arg2):
        _gstlearn.EMorphoIterator_swiginit(self, _gstlearn.new_EMorphoIterator(arg2))

    def __ref__(self):
        return _gstlearn.EMorphoIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EMorphoIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EMorphoIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EMorphoIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EMorphoIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EMorphoIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EMorphoIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EMorphoIterator_getDescr(self)

# Register EMorphoIterator in _gstlearn:
_gstlearn.EMorphoIterator_swigregister(EMorphoIterator)
class EMorpho(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EMorpho

    def __init__(self, *args):
        _gstlearn.EMorpho_swiginit(self, _gstlearn.new_EMorpho(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EMorpho_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EMorpho_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EMorpho_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EMorpho_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EMorpho_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EMorpho_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EMorpho_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EMorpho_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EMorpho_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EMorpho_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EMorpho_fromValues(values)
    E_UNKNOWN = _gstlearn.EMorpho_E_UNKNOWN
    E_THRESH = _gstlearn.EMorpho_E_THRESH
    E_NEGATION = _gstlearn.EMorpho_E_NEGATION
    E_EROSION = _gstlearn.EMorpho_E_EROSION
    E_DILATION = _gstlearn.EMorpho_E_DILATION
    E_OPEN = _gstlearn.EMorpho_E_OPEN
    E_CLOSE = _gstlearn.EMorpho_E_CLOSE
    E_CC = _gstlearn.EMorpho_E_CC
    E_CCSIZE = _gstlearn.EMorpho_E_CCSIZE
    E_DISTANCE = _gstlearn.EMorpho_E_DISTANCE
    E_ANGLE = _gstlearn.EMorpho_E_ANGLE
    E_GRADIENT = _gstlearn.EMorpho_E_GRADIENT

    def toEnum(self):
        return _gstlearn.EMorpho_toEnum(self)

# Register EMorpho in _gstlearn:
_gstlearn.EMorpho_swigregister(EMorpho)
EMorpho.UNKNOWN = _gstlearn.cvar.EMorpho_UNKNOWN
EMorpho.THRESH = _gstlearn.cvar.EMorpho_THRESH
EMorpho.NEGATION = _gstlearn.cvar.EMorpho_NEGATION
EMorpho.EROSION = _gstlearn.cvar.EMorpho_EROSION
EMorpho.DILATION = _gstlearn.cvar.EMorpho_DILATION
EMorpho.OPEN = _gstlearn.cvar.EMorpho_OPEN
EMorpho.CLOSE = _gstlearn.cvar.EMorpho_CLOSE
EMorpho.CC = _gstlearn.cvar.EMorpho_CC
EMorpho.CCSIZE = _gstlearn.cvar.EMorpho_CCSIZE
EMorpho.DISTANCE = _gstlearn.cvar.EMorpho_DISTANCE
EMorpho.ANGLE = _gstlearn.cvar.EMorpho_ANGLE
EMorpho.GRADIENT = _gstlearn.cvar.EMorpho_GRADIENT

class ENeighIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ENeighIterator

    def __init__(self, arg2):
        _gstlearn.ENeighIterator_swiginit(self, _gstlearn.new_ENeighIterator(arg2))

    def __ref__(self):
        return _gstlearn.ENeighIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ENeighIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ENeighIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ENeighIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ENeighIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ENeighIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ENeighIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ENeighIterator_getDescr(self)

# Register ENeighIterator in _gstlearn:
_gstlearn.ENeighIterator_swigregister(ENeighIterator)
class ENeigh(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ENeigh

    def __init__(self, *args):
        _gstlearn.ENeigh_swiginit(self, _gstlearn.new_ENeigh(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ENeigh_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ENeigh_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ENeigh_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ENeigh_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ENeigh_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ENeigh_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ENeigh_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ENeigh_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ENeigh_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ENeigh_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ENeigh_fromValues(values)
    E_UNKNOWN = _gstlearn.ENeigh_E_UNKNOWN
    E_UNIQUE = _gstlearn.ENeigh_E_UNIQUE
    E_BENCH = _gstlearn.ENeigh_E_BENCH
    E_MOVING = _gstlearn.ENeigh_E_MOVING
    E_CELL = _gstlearn.ENeigh_E_CELL
    E_IMAGE = _gstlearn.ENeigh_E_IMAGE

    def toEnum(self):
        return _gstlearn.ENeigh_toEnum(self)

# Register ENeigh in _gstlearn:
_gstlearn.ENeigh_swigregister(ENeigh)
ENeigh.UNKNOWN = _gstlearn.cvar.ENeigh_UNKNOWN
ENeigh.UNIQUE = _gstlearn.cvar.ENeigh_UNIQUE
ENeigh.BENCH = _gstlearn.cvar.ENeigh_BENCH
ENeigh.MOVING = _gstlearn.cvar.ENeigh_MOVING
ENeigh.CELL = _gstlearn.cvar.ENeigh_CELL
ENeigh.IMAGE = _gstlearn.cvar.ENeigh_IMAGE

class ESpaceTypeIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ESpaceTypeIterator

    def __init__(self, arg2):
        _gstlearn.ESpaceTypeIterator_swiginit(self, _gstlearn.new_ESpaceTypeIterator(arg2))

    def __ref__(self):
        return _gstlearn.ESpaceTypeIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ESpaceTypeIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ESpaceTypeIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ESpaceTypeIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ESpaceTypeIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ESpaceTypeIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ESpaceTypeIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ESpaceTypeIterator_getDescr(self)

# Register ESpaceTypeIterator in _gstlearn:
_gstlearn.ESpaceTypeIterator_swigregister(ESpaceTypeIterator)
class ESpaceType(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ESpaceType

    def __init__(self, *args):
        _gstlearn.ESpaceType_swiginit(self, _gstlearn.new_ESpaceType(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ESpaceType_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ESpaceType_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ESpaceType_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ESpaceType_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ESpaceType_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ESpaceType_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ESpaceType_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ESpaceType_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ESpaceType_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ESpaceType_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ESpaceType_fromValues(values)
    E_COMPOSITE = _gstlearn.ESpaceType_E_COMPOSITE
    E_RN = _gstlearn.ESpaceType_E_RN
    E_SN = _gstlearn.ESpaceType_E_SN

    def toEnum(self):
        return _gstlearn.ESpaceType_toEnum(self)

# Register ESpaceType in _gstlearn:
_gstlearn.ESpaceType_swigregister(ESpaceType)
ESpaceType.COMPOSITE = _gstlearn.cvar.ESpaceType_COMPOSITE
ESpaceType.RN = _gstlearn.cvar.ESpaceType_RN
ESpaceType.SN = _gstlearn.cvar.ESpaceType_SN

class ESelectivityIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ESelectivityIterator

    def __init__(self, arg2):
        _gstlearn.ESelectivityIterator_swiginit(self, _gstlearn.new_ESelectivityIterator(arg2))

    def __ref__(self):
        return _gstlearn.ESelectivityIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ESelectivityIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ESelectivityIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ESelectivityIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ESelectivityIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ESelectivityIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ESelectivityIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ESelectivityIterator_getDescr(self)

# Register ESelectivityIterator in _gstlearn:
_gstlearn.ESelectivityIterator_swigregister(ESelectivityIterator)
class ESelectivity(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ESelectivity

    def __init__(self, *args):
        _gstlearn.ESelectivity_swiginit(self, _gstlearn.new_ESelectivity(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ESelectivity_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ESelectivity_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ESelectivity_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ESelectivity_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ESelectivity_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ESelectivity_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ESelectivity_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ESelectivity_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ESelectivity_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ESelectivity_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ESelectivity_fromValues(values)
    E_UNKNOWN = _gstlearn.ESelectivity_E_UNKNOWN
    E_Z = _gstlearn.ESelectivity_E_Z
    E_T = _gstlearn.ESelectivity_E_T
    E_Q = _gstlearn.ESelectivity_E_Q
    E_B = _gstlearn.ESelectivity_E_B
    E_M = _gstlearn.ESelectivity_E_M
    E_PROP = _gstlearn.ESelectivity_E_PROP
    E_QUANT = _gstlearn.ESelectivity_E_QUANT

    def toEnum(self):
        return _gstlearn.ESelectivity_toEnum(self)

# Register ESelectivity in _gstlearn:
_gstlearn.ESelectivity_swigregister(ESelectivity)
ESelectivity.UNKNOWN = _gstlearn.cvar.ESelectivity_UNKNOWN
ESelectivity.Z = _gstlearn.cvar.ESelectivity_Z
ESelectivity.T = _gstlearn.cvar.ESelectivity_T
ESelectivity.Q = _gstlearn.cvar.ESelectivity_Q
ESelectivity.B = _gstlearn.cvar.ESelectivity_B
ESelectivity.M = _gstlearn.cvar.ESelectivity_M
ESelectivity.PROP = _gstlearn.cvar.ESelectivity_PROP
ESelectivity.QUANT = _gstlearn.cvar.ESelectivity_QUANT

class EStatOptionIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EStatOptionIterator

    def __init__(self, arg2):
        _gstlearn.EStatOptionIterator_swiginit(self, _gstlearn.new_EStatOptionIterator(arg2))

    def __ref__(self):
        return _gstlearn.EStatOptionIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EStatOptionIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EStatOptionIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EStatOptionIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EStatOptionIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EStatOptionIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EStatOptionIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EStatOptionIterator_getDescr(self)

# Register EStatOptionIterator in _gstlearn:
_gstlearn.EStatOptionIterator_swigregister(EStatOptionIterator)
class EStatOption(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EStatOption

    def __init__(self, *args):
        _gstlearn.EStatOption_swiginit(self, _gstlearn.new_EStatOption(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EStatOption_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EStatOption_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EStatOption_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EStatOption_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EStatOption_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EStatOption_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EStatOption_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EStatOption_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EStatOption_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EStatOption_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EStatOption_fromValues(values)
    E_UNKNOWN = _gstlearn.EStatOption_E_UNKNOWN
    E_NUM = _gstlearn.EStatOption_E_NUM
    E_MEAN = _gstlearn.EStatOption_E_MEAN
    E_VAR = _gstlearn.EStatOption_E_VAR
    E_STDV = _gstlearn.EStatOption_E_STDV
    E_MINI = _gstlearn.EStatOption_E_MINI
    E_MAXI = _gstlearn.EStatOption_E_MAXI
    E_SUM = _gstlearn.EStatOption_E_SUM
    E_PROP = _gstlearn.EStatOption_E_PROP
    E_QUANT = _gstlearn.EStatOption_E_QUANT
    E_T = _gstlearn.EStatOption_E_T
    E_Q = _gstlearn.EStatOption_E_Q
    E_M = _gstlearn.EStatOption_E_M
    E_B = _gstlearn.EStatOption_E_B
    E_COV = _gstlearn.EStatOption_E_COV
    E_CORR = _gstlearn.EStatOption_E_CORR
    E_ZERO = _gstlearn.EStatOption_E_ZERO
    E_MEDIAN = _gstlearn.EStatOption_E_MEDIAN
    E_MEAN2 = _gstlearn.EStatOption_E_MEAN2
    E_VAR2 = _gstlearn.EStatOption_E_VAR2
    E_STDV2 = _gstlearn.EStatOption_E_STDV2
    E_SUM2 = _gstlearn.EStatOption_E_SUM2
    E_PLUS = _gstlearn.EStatOption_E_PLUS
    E_MOINS = _gstlearn.EStatOption_E_MOINS
    E_ORE = _gstlearn.EStatOption_E_ORE
    E_METAL = _gstlearn.EStatOption_E_METAL

    def toEnum(self):
        return _gstlearn.EStatOption_toEnum(self)

# Register EStatOption in _gstlearn:
_gstlearn.EStatOption_swigregister(EStatOption)
EStatOption.UNKNOWN = _gstlearn.cvar.EStatOption_UNKNOWN
EStatOption.NUM = _gstlearn.cvar.EStatOption_NUM
EStatOption.MEAN = _gstlearn.cvar.EStatOption_MEAN
EStatOption.VAR = _gstlearn.cvar.EStatOption_VAR
EStatOption.STDV = _gstlearn.cvar.EStatOption_STDV
EStatOption.MINI = _gstlearn.cvar.EStatOption_MINI
EStatOption.MAXI = _gstlearn.cvar.EStatOption_MAXI
EStatOption.SUM = _gstlearn.cvar.EStatOption_SUM
EStatOption.PROP = _gstlearn.cvar.EStatOption_PROP
EStatOption.QUANT = _gstlearn.cvar.EStatOption_QUANT
EStatOption.T = _gstlearn.cvar.EStatOption_T
EStatOption.Q = _gstlearn.cvar.EStatOption_Q
EStatOption.M = _gstlearn.cvar.EStatOption_M
EStatOption.B = _gstlearn.cvar.EStatOption_B
EStatOption.COV = _gstlearn.cvar.EStatOption_COV
EStatOption.CORR = _gstlearn.cvar.EStatOption_CORR
EStatOption.ZERO = _gstlearn.cvar.EStatOption_ZERO
EStatOption.MEDIAN = _gstlearn.cvar.EStatOption_MEDIAN
EStatOption.MEAN2 = _gstlearn.cvar.EStatOption_MEAN2
EStatOption.VAR2 = _gstlearn.cvar.EStatOption_VAR2
EStatOption.STDV2 = _gstlearn.cvar.EStatOption_STDV2
EStatOption.SUM2 = _gstlearn.cvar.EStatOption_SUM2
EStatOption.PLUS = _gstlearn.cvar.EStatOption_PLUS
EStatOption.MOINS = _gstlearn.cvar.EStatOption_MOINS
EStatOption.ORE = _gstlearn.cvar.EStatOption_ORE
EStatOption.METAL = _gstlearn.cvar.EStatOption_METAL

class EDirGenIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EDirGenIterator

    def __init__(self, arg2):
        _gstlearn.EDirGenIterator_swiginit(self, _gstlearn.new_EDirGenIterator(arg2))

    def __ref__(self):
        return _gstlearn.EDirGenIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EDirGenIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EDirGenIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EDirGenIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EDirGenIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EDirGenIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EDirGenIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EDirGenIterator_getDescr(self)

# Register EDirGenIterator in _gstlearn:
_gstlearn.EDirGenIterator_swigregister(EDirGenIterator)
class EDirGen(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EDirGen

    def __init__(self, *args):
        _gstlearn.EDirGen_swiginit(self, _gstlearn.new_EDirGen(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EDirGen_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EDirGen_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EDirGen_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EDirGen_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EDirGen_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EDirGen_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EDirGen_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EDirGen_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EDirGen_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EDirGen_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EDirGen_fromValues(values)
    E_VDC = _gstlearn.EDirGen_E_VDC
    E_RND = _gstlearn.EDirGen_E_RND

    def toEnum(self):
        return _gstlearn.EDirGen_toEnum(self)

# Register EDirGen in _gstlearn:
_gstlearn.EDirGen_swigregister(EDirGen)
EDirGen.VDC = _gstlearn.cvar.EDirGen_VDC
EDirGen.RND = _gstlearn.cvar.EDirGen_RND

class EGaussInvIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EGaussInvIterator

    def __init__(self, arg2):
        _gstlearn.EGaussInvIterator_swiginit(self, _gstlearn.new_EGaussInvIterator(arg2))

    def __ref__(self):
        return _gstlearn.EGaussInvIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EGaussInvIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EGaussInvIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EGaussInvIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EGaussInvIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EGaussInvIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EGaussInvIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EGaussInvIterator_getDescr(self)

# Register EGaussInvIterator in _gstlearn:
_gstlearn.EGaussInvIterator_swigregister(EGaussInvIterator)
class EGaussInv(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EGaussInv

    def __init__(self, *args):
        _gstlearn.EGaussInv_swiginit(self, _gstlearn.new_EGaussInv(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EGaussInv_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EGaussInv_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EGaussInv_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EGaussInv_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EGaussInv_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EGaussInv_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EGaussInv_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EGaussInv_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EGaussInv_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EGaussInv_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EGaussInv_fromValues(values)
    E_EMP = _gstlearn.EGaussInv_E_EMP
    E_HMT = _gstlearn.EGaussInv_E_HMT
    E_NN = _gstlearn.EGaussInv_E_NN

    def toEnum(self):
        return _gstlearn.EGaussInv_toEnum(self)

# Register EGaussInv in _gstlearn:
_gstlearn.EGaussInv_swigregister(EGaussInv)
EGaussInv.EMP = _gstlearn.cvar.EGaussInv_EMP
EGaussInv.HMT = _gstlearn.cvar.EGaussInv_HMT
EGaussInv.NN = _gstlearn.cvar.EGaussInv_NN

class ECalcMemberIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECalcMemberIterator

    def __init__(self, arg2):
        _gstlearn.ECalcMemberIterator_swiginit(self, _gstlearn.new_ECalcMemberIterator(arg2))

    def __ref__(self):
        return _gstlearn.ECalcMemberIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ECalcMemberIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ECalcMemberIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ECalcMemberIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ECalcMemberIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ECalcMemberIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ECalcMemberIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ECalcMemberIterator_getDescr(self)

# Register ECalcMemberIterator in _gstlearn:
_gstlearn.ECalcMemberIterator_swigregister(ECalcMemberIterator)
class ECalcMember(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ECalcMember

    def __init__(self, *args):
        _gstlearn.ECalcMember_swiginit(self, _gstlearn.new_ECalcMember(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ECalcMember_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ECalcMember_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ECalcMember_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ECalcMember_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ECalcMember_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ECalcMember_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ECalcMember_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ECalcMember_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ECalcMember_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ECalcMember_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ECalcMember_fromValues(values)
    E_LHS = _gstlearn.ECalcMember_E_LHS
    E_RHS = _gstlearn.ECalcMember_E_RHS
    E_VAR = _gstlearn.ECalcMember_E_VAR

    def toEnum(self):
        return _gstlearn.ECalcMember_toEnum(self)

# Register ECalcMember in _gstlearn:
_gstlearn.ECalcMember_swigregister(ECalcMember)
ECalcMember.LHS = _gstlearn.cvar.ECalcMember_LHS
ECalcMember.RHS = _gstlearn.cvar.ECalcMember_RHS
ECalcMember.VAR = _gstlearn.cvar.ECalcMember_VAR

class EPostUpscaleIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EPostUpscaleIterator

    def __init__(self, arg2):
        _gstlearn.EPostUpscaleIterator_swiginit(self, _gstlearn.new_EPostUpscaleIterator(arg2))

    def __ref__(self):
        return _gstlearn.EPostUpscaleIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EPostUpscaleIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EPostUpscaleIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EPostUpscaleIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EPostUpscaleIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EPostUpscaleIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EPostUpscaleIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EPostUpscaleIterator_getDescr(self)

# Register EPostUpscaleIterator in _gstlearn:
_gstlearn.EPostUpscaleIterator_swigregister(EPostUpscaleIterator)
class EPostUpscale(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EPostUpscale

    def __init__(self, *args):
        _gstlearn.EPostUpscale_swiginit(self, _gstlearn.new_EPostUpscale(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EPostUpscale_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EPostUpscale_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EPostUpscale_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EPostUpscale_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EPostUpscale_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EPostUpscale_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EPostUpscale_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EPostUpscale_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EPostUpscale_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EPostUpscale_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EPostUpscale_fromValues(values)
    E_UNKNOWN = _gstlearn.EPostUpscale_E_UNKNOWN
    E_NUM = _gstlearn.EPostUpscale_E_NUM
    E_MEAN = _gstlearn.EPostUpscale_E_MEAN
    E_MINI = _gstlearn.EPostUpscale_E_MINI
    E_MAXI = _gstlearn.EPostUpscale_E_MAXI

    def toEnum(self):
        return _gstlearn.EPostUpscale_toEnum(self)

# Register EPostUpscale in _gstlearn:
_gstlearn.EPostUpscale_swigregister(EPostUpscale)
EPostUpscale.UNKNOWN = _gstlearn.cvar.EPostUpscale_UNKNOWN
EPostUpscale.NUM = _gstlearn.cvar.EPostUpscale_NUM
EPostUpscale.MEAN = _gstlearn.cvar.EPostUpscale_MEAN
EPostUpscale.MINI = _gstlearn.cvar.EPostUpscale_MINI
EPostUpscale.MAXI = _gstlearn.cvar.EPostUpscale_MAXI

class EPostStatIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EPostStatIterator

    def __init__(self, arg2):
        _gstlearn.EPostStatIterator_swiginit(self, _gstlearn.new_EPostStatIterator(arg2))

    def __ref__(self):
        return _gstlearn.EPostStatIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EPostStatIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EPostStatIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EPostStatIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EPostStatIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EPostStatIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EPostStatIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EPostStatIterator_getDescr(self)

# Register EPostStatIterator in _gstlearn:
_gstlearn.EPostStatIterator_swigregister(EPostStatIterator)
class EPostStat(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EPostStat

    def __init__(self, *args):
        _gstlearn.EPostStat_swiginit(self, _gstlearn.new_EPostStat(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EPostStat_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EPostStat_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EPostStat_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EPostStat_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EPostStat_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EPostStat_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EPostStat_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EPostStat_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EPostStat_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EPostStat_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EPostStat_fromValues(values)
    E_UNKNOWN = _gstlearn.EPostStat_E_UNKNOWN
    E_MEAN = _gstlearn.EPostStat_E_MEAN
    E_VAR = _gstlearn.EPostStat_E_VAR
    E_VARP = _gstlearn.EPostStat_E_VARP
    E_STD = _gstlearn.EPostStat_E_STD
    E_STDP = _gstlearn.EPostStat_E_STDP
    E_MED = _gstlearn.EPostStat_E_MED
    E_MINI = _gstlearn.EPostStat_E_MINI
    E_MAXI = _gstlearn.EPostStat_E_MAXI

    def toEnum(self):
        return _gstlearn.EPostStat_toEnum(self)

# Register EPostStat in _gstlearn:
_gstlearn.EPostStat_swigregister(EPostStat)
EPostStat.UNKNOWN = _gstlearn.cvar.EPostStat_UNKNOWN
EPostStat.MEAN = _gstlearn.cvar.EPostStat_MEAN
EPostStat.VAR = _gstlearn.cvar.EPostStat_VAR
EPostStat.VARP = _gstlearn.cvar.EPostStat_VARP
EPostStat.STD = _gstlearn.cvar.EPostStat_STD
EPostStat.STDP = _gstlearn.cvar.EPostStat_STDP
EPostStat.MED = _gstlearn.cvar.EPostStat_MED
EPostStat.MINI = _gstlearn.cvar.EPostStat_MINI
EPostStat.MAXI = _gstlearn.cvar.EPostStat_MAXI

class EFormatNFIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EFormatNFIterator

    def __init__(self, arg2):
        _gstlearn.EFormatNFIterator_swiginit(self, _gstlearn.new_EFormatNFIterator(arg2))

    def __ref__(self):
        return _gstlearn.EFormatNFIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.EFormatNFIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.EFormatNFIterator_toNext(self)

    def toFront(self):
        return _gstlearn.EFormatNFIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.EFormatNFIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.EFormatNFIterator_getValue(self)

    def getKey(self):
        return _gstlearn.EFormatNFIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.EFormatNFIterator_getDescr(self)

# Register EFormatNFIterator in _gstlearn:
_gstlearn.EFormatNFIterator_swigregister(EFormatNFIterator)
class EFormatNF(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_EFormatNF

    def __init__(self, *args):
        _gstlearn.EFormatNF_swiginit(self, _gstlearn.new_EFormatNF(*args))

    @staticmethod
    def getSize():
        return _gstlearn.EFormatNF_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.EFormatNF_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.EFormatNF_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.EFormatNF_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.EFormatNF_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.EFormatNF_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.EFormatNF_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.EFormatNF_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.EFormatNF_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.EFormatNF_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.EFormatNF_fromValues(values)
    E_DEFAULT = _gstlearn.EFormatNF_E_DEFAULT
    E_ASCII = _gstlearn.EFormatNF_E_ASCII
    E_H5 = _gstlearn.EFormatNF_E_H5

    def toEnum(self):
        return _gstlearn.EFormatNF_toEnum(self)

# Register EFormatNF in _gstlearn:
_gstlearn.EFormatNF_swigregister(EFormatNF)
EFormatNF.DEFAULT = _gstlearn.cvar.EFormatNF_DEFAULT
EFormatNF.ASCII = _gstlearn.cvar.EFormatNF_ASCII
EFormatNF.H5 = _gstlearn.cvar.EFormatNF_H5

class ETestsIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ETestsIterator

    def __init__(self, arg2):
        _gstlearn.ETestsIterator_swiginit(self, _gstlearn.new_ETestsIterator(arg2))

    def __ref__(self):
        return _gstlearn.ETestsIterator___ref__(self)

    def hasNext(self):
        return _gstlearn.ETestsIterator_hasNext(self)

    def toNext(self):
        return _gstlearn.ETestsIterator_toNext(self)

    def toFront(self):
        return _gstlearn.ETestsIterator_toFront(self)

    def getEnum(self):
        return _gstlearn.ETestsIterator_getEnum(self)

    def getValue(self):
        return _gstlearn.ETestsIterator_getValue(self)

    def getKey(self):
        return _gstlearn.ETestsIterator_getKey(self)

    def getDescr(self):
        return _gstlearn.ETestsIterator_getDescr(self)

# Register ETestsIterator in _gstlearn:
_gstlearn.ETestsIterator_swigregister(ETestsIterator)
class ETests(AEnum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ETests

    def __init__(self, *args):
        _gstlearn.ETests_swiginit(self, _gstlearn.new_ETests(*args))

    @staticmethod
    def getSize():
        return _gstlearn.ETests_getSize()

    @staticmethod
    def getIterator():
        return _gstlearn.ETests_getIterator()

    @staticmethod
    def printAll():
        return _gstlearn.ETests_printAll()

    @staticmethod
    def getAllKeys(_from=-10):
        return _gstlearn.ETests_getAllKeys(_from)

    @staticmethod
    def getAllDescr(_from=-10):
        return _gstlearn.ETests_getAllDescr(_from)

    @staticmethod
    def existsKey(key):
        return _gstlearn.ETests_existsKey(key)

    @staticmethod
    def existsValue(value):
        return _gstlearn.ETests_existsValue(value)

    @staticmethod
    def fromKey(key):
        return _gstlearn.ETests_fromKey(key)

    @staticmethod
    def fromValue(value):
        return _gstlearn.ETests_fromValue(value)

    @staticmethod
    def fromKeys(keys):
        return _gstlearn.ETests_fromKeys(keys)

    @staticmethod
    def fromValues(values):
        return _gstlearn.ETests_fromValues(values)
    E_CASE0 = _gstlearn.ETests_E_CASE0
    E_CASE1 = _gstlearn.ETests_E_CASE1
    E_CASE2 = _gstlearn.ETests_E_CASE2

    def toEnum(self):
        return _gstlearn.ETests_toEnum(self)

# Register ETests in _gstlearn:
_gstlearn.ETests_swigregister(ETests)
ETests.CASE0 = _gstlearn.cvar.ETests_CASE0
ETests.CASE1 = _gstlearn.cvar.ETests_CASE1
ETests.CASE2 = _gstlearn.cvar.ETests_CASE2

class argClass(object):
    r"""


    C++ includes: ArgumentTest.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ival = property(_gstlearn.argClass_ival_get, _gstlearn.argClass_ival_set)
    rval = property(_gstlearn.argClass_rval_get, _gstlearn.argClass_rval_set)
    sval = property(_gstlearn.argClass_sval_get, _gstlearn.argClass_sval_set)

    def __init__(self, *args, **kwargs):
        r"""

        argClass::argClass
        """
        _gstlearn.argClass_swiginit(self, _gstlearn.new_argClass(*args, **kwargs))

    def getIval(self):
        r"""

        argClass::getIval
        """
        return _gstlearn.argClass_getIval(self)

    def setIval(self, iival):
        r"""

        argClass::setIval
        """
        return _gstlearn.argClass_setIval(self, iival)

    def getRval(self):
        r"""

        argClass::getRval
        """
        return _gstlearn.argClass_getRval(self)

    def setRval(self, rrval):
        r"""

        argClass::setRval
        """
        return _gstlearn.argClass_setRval(self, rrval)

    def getSval(self):
        r"""

        argClass::getSval
        """
        return _gstlearn.argClass_getSval(self)

    def setSval(self, ssval):
        r"""

        argClass::setSval
        """
        return _gstlearn.argClass_setSval(self, ssval)

    def display(self):
        r"""

        argClass::display
        """
        return _gstlearn.argClass_display(self)
    __swig_destroy__ = _gstlearn.delete_argClass

# Register argClass in _gstlearn:
_gstlearn.argClass_swigregister(argClass)

def argumentTestInt(value):
    r"""


    Function to test Integer argument  

    Parameters
    ----------
    * `value` :  
        Integer input argument  

    """
    return _gstlearn.argumentTestInt(value)

def argumentTestDouble(value):
    r"""


    Function to test Double argument  

    Parameters
    ----------
    * `value` :  
        Double input argument  

    """
    return _gstlearn.argumentTestDouble(value)

def argumentTestVectorInt(values):
    r"""


    """
    return _gstlearn.argumentTestVectorInt(values)

def argumentTestVectorDouble(values):
    r"""


    """
    return _gstlearn.argumentTestVectorDouble(values)

def argumentTestVectorVectorInt(values):
    r"""


    """
    return _gstlearn.argumentTestVectorVectorInt(values)

def argumentTestVectorVectorDouble(values):
    r"""


    """
    return _gstlearn.argumentTestVectorVectorDouble(values)

def argumentTestString(value):
    r"""


    """
    return _gstlearn.argumentTestString(value)

def argumentTestVectorString(values):
    r"""


    """
    return _gstlearn.argumentTestVectorString(values)

def argumentTestIntOverload(*args):
    r"""


    """
    return _gstlearn.argumentTestIntOverload(*args)

def argumentTestDoubleOverload(*args):
    r"""


    """
    return _gstlearn.argumentTestDoubleOverload(*args)

def argumentTestStringOverload(*args):
    r"""


    """
    return _gstlearn.argumentTestStringOverload(*args)

def argumentTestEnum(value):
    r"""


    """
    return _gstlearn.argumentTestEnum(value)

def argumentReturnInt(value):
    r"""


    """
    return _gstlearn.argumentReturnInt(value)

def argumentReturnDouble(value):
    r"""


    """
    return _gstlearn.argumentReturnDouble(value)

def argumentReturnVectorInt(values):
    r"""


    """
    return _gstlearn.argumentReturnVectorInt(values)

def argumentReturnVectorDouble(values):
    r"""


    """
    return _gstlearn.argumentReturnVectorDouble(values)

def argumentReturnVectorVectorInt(values):
    r"""


    """
    return _gstlearn.argumentReturnVectorVectorInt(values)

def argumentReturnVectorVectorDouble(values):
    r"""


    """
    return _gstlearn.argumentReturnVectorVectorDouble(values)

def argumentDefTestInt(argInt=2):
    r"""


    """
    return _gstlearn.argumentDefTestInt(argInt)

def argumentDefTestDbl(argDbl=2.):
    r"""


    """
    return _gstlearn.argumentDefTestDbl(argDbl)

def argumentDefTestStr(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentDefTestStr(*args, **kwargs)

def argumentDefTestVInt(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentDefTestVInt(*args, **kwargs)

def argumentDefTestVDbl(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentDefTestVDbl(*args, **kwargs)

def argumentDefTestVString(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentDefTestVString(*args, **kwargs)

def argumentDefTestVVInt(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentDefTestVVInt(*args, **kwargs)

def argumentDefTestVVDbl(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentDefTestVVDbl(*args, **kwargs)

def argumentTestMatrixDense(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentTestMatrixDense(*args, **kwargs)

def argumentTestMatrixSquare(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentTestMatrixSquare(*args, **kwargs)

def argumentTestMatrixSymmetric(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentTestMatrixSymmetric(*args, **kwargs)

def argumentReturnMatrix(nrows=2, ncols=3, seed=1312):
    r"""


    """
    return _gstlearn.argumentReturnMatrix(nrows, ncols, seed)

def argumentTestMatrixSparse(*args, **kwargs):
    r"""


    """
    return _gstlearn.argumentTestMatrixSparse(*args, **kwargs)

def argumentReturnMatrixSparse(nrows=2, ncols=3, zeroPercent=0.1, seed=1356):
    r"""


    """
    return _gstlearn.argumentReturnMatrixSparse(nrows, ncols, zeroPercent, seed)
class AStringable(object):
    r"""


    C++ includes: AStringable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        AStringable::AStringable
        Copy constructor: don't copy temporary file info  

        """
        _gstlearn.AStringable_swiginit(self, _gstlearn.new_AStringable(*args))
    __swig_destroy__ = _gstlearn.delete_AStringable

    def toString(self, strfmt=None):
        r"""

        AStringable::toString
        """
        return _gstlearn.AStringable_toString(self, strfmt)

    def display(self, strfmt=None):
        r"""

        AStringable::display
        """
        return _gstlearn.AStringable_display(self, strfmt)

# Register AStringable in _gstlearn:
_gstlearn.AStringable_swigregister(AStringable)

def messageFlush(string):
    r"""


    When message has been collected as a String, this function produces it out
    without passing through useless internal buffering  

    Parameters
    ----------
    * `string` :  
        String to be printed out  

    """
    return _gstlearn.messageFlush(string)

def messerrFlush(string):
    r"""


    When the error message has been collected as a String, this function produces it
    out without passing through useless internal buffering  

    Parameters
    ----------
    * `string` :  
        String to be produced  

    remark: This function is similar to messageFlush but dedicated to Errors  

    """
    return _gstlearn.messerrFlush(string)

def messerr(*args, **kwargs):
    r"""


    Print Error message  

    Parameters
    ----------
    * `format` :  
        Output format  
    * `...` :  
        Additional arguments  

    """
    return _gstlearn.messerr(*args, **kwargs)

def message(*args, **kwargs):
    r"""


    Print a formatted message  

    Parameters
    ----------
    * `format` :  
        Output format  
    * `...` :  
        Additional arguments  

    """
    return _gstlearn.message(*args, **kwargs)

def messageNoDiff(*args, **kwargs):
    r"""


    Print a formatted message (with "#NO_DIFF#" prefix)  

    Parameters
    ----------
    * `format` :  
        Output format  
    * `...` :  
        Additional arguments  

    """
    return _gstlearn.messageNoDiff(*args, **kwargs)

def mesArg(title, current, nmax):
    r"""


    Print a standard Error Message if an argument does not lie in Interval  

    Parameters
    ----------
    * `title` :  
        Title to be printed  
    * `current` :  
        Current value of the argument  
    * `nmax` :  
        Maximum (inclusive) possible value  

    """
    return _gstlearn.mesArg(title, current, nmax)

def checkArg(title, current, nmax):
    r"""


    """
    return _gstlearn.checkArg(title, current, nmax)

def messageAbort(*args, **kwargs):
    r"""


    Function for aborting the API  

    Parameters
    ----------
    * `format` :  
        Fatal error format  
    * `...` :  
        Additional arguments  

    """
    return _gstlearn.messageAbort(*args, **kwargs)

def mestitle(*args, **kwargs):
    r"""


    Print a message and underlines it with various formats  

    Parameters
    ----------
    * `level` :  
        Level of the title  
    * `format` :  
        Output format  
    * `...` :  
        Additional arguments  

    """
    return _gstlearn.mestitle(*args, **kwargs)

def mes_process(string, ntot, iech):
    r"""


    Conditionally print the progress of a procedure  

    Parameters
    ----------
    * `string` :  
        String to be printed  
    * `ntot` :  
        Total number of samples  
    * `iech` :  
        Rank of the current sample  

    remark: The value 'nproc' designates the quantile such that,  

    remark: when changed, the printout is provoked.  

    """
    return _gstlearn.mes_process(string, ntot, iech)

def toTitle(*args, **kwargs):
    r"""


    Print a message and underlines it with various formats  

    Parameters
    ----------
    * `level` :  
        Level of the title  
    * `format` :  
        Output format  
    * `...` :  
        Additional arguments  

    """
    return _gstlearn.toTitle(*args, **kwargs)

def toMatrix(*args):
    r"""


    Print the contents of a VectorDouble in a Matrix Form  

    Parameters
    ----------
    * `title` :  
        Title of the printout  
    * `colnames` :  
        Names of the columns (optional)  
    * `rownames` :  
        Names of the rows (optional)  
    * `bycol` :  
        true if values as sorted by column; false otherwise  
    * `nrows` :  
        Number of rows  
    * `ncols` :  
        Number of columns  
    * `tab` :  
        VectorInt containing the values  
    * `flagOverride` :  
        true to override printout limitations  
    * `flagSkipZero` :  
        when true, skip the zero values (represented by a '.' as for sparse matrix)  

    """
    return _gstlearn.toMatrix(*args)

def toVector(*args):
    r"""


    Printout a vector in a formatted manner  

    Parameters
    ----------
    * `title` :  
        Title of the printout (or empty string)  
    * `tab` :  
        Vector (integer values) to be printed  
    * `flagOverride` :  
        true to override printout limitations  

    Returns
    -------
    The string (terminated with a newline)  

    """
    return _gstlearn.toVector(*args)

def toStr(*args, **kwargs):
    r"""


    """
    return _gstlearn.toStr(*args, **kwargs)

def toInt(*args, **kwargs):
    r"""


    """
    return _gstlearn.toInt(*args, **kwargs)

def toInterval(zmin, zmax):
    r"""


    """
    return _gstlearn.toInterval(zmin, zmax)

def toVectorDouble(*args, **kwargs):
    r"""


    """
    return _gstlearn.toVectorDouble(*args, **kwargs)

def tab_prints(*args, **kwargs):
    r"""


    Tabulated printout of a string  

    Parameters
    ----------
    * `title` :  
        optional title (NULL if not defined)  
    * `string` :  
        String to be written  
    * `ncol` :  
        number of columns for the printout  
    * `justify` :  
        justification flag (EJustify::LEFT, EJustify::CENTER or EJustify::RIGHT)  

    """
    return _gstlearn.tab_prints(*args, **kwargs)

def tab_printg(*args, **kwargs):
    r"""


    Tabulated printout of a real value  

    Parameters
    ----------
    * `title` :  
        optional title (NULL if not defined)  
    * `value` :  
        Value to be written  
    * `ncol` :  
        number of columns for the printout  
    * `justify` :  
        justification flag (EJustify::LEFT, EJustify::CENTER or EJustify::RIGHT)  

    """
    return _gstlearn.tab_printg(*args, **kwargs)

def tab_printd(*args, **kwargs):
    r"""


    Tabulated printout of a double value  

    Parameters
    ----------
    * `title` :  
        optional title (NULL if not defined)  
    * `value` :  
        Value to be written  
    * `ncol` :  
        number of columns for the printout  
    * `justify` :  
        justification flag (EJustify::LEFT, EJustify::CENTER or EJustify::RIGHT)  

    """
    return _gstlearn.tab_printd(*args, **kwargs)

def tab_printi(*args, **kwargs):
    r"""


    Tabulated printout of an integer value  

    Parameters
    ----------
    * `title` :  
        optional title (NULL if not defined)  
    * `value` :  
        Value to be written  
    * `ncol` :  
        number of columns for the printout  
    * `justify` :  
        justification flag (EJustify::LEFT, EJustify::CENTER or EJustify::RIGHT)  

    """
    return _gstlearn.tab_printi(*args, **kwargs)

def tab_print_rc(*args, **kwargs):
    r"""


    Tabulated printout of a row or column value  

    Parameters
    ----------
    * `title` :  
        optional title (NULL if not defined)  
    * `mode` :  
        CASE_ROW or CASE_COL  
    * `value` :  
        Value to be written  
    * `ncol` :  
        number of columns for the printout  
    * `justify` :  
        justification flag (EJustify::LEFT, EJustify::CENTER or EJustify::RIGHT)  

    """
    return _gstlearn.tab_print_rc(*args, **kwargs)

def tab_print_rowname(string, taille):
    r"""


    Tabulated printout of a string (character size provided)  

    Parameters
    ----------
    * `string` :  
        String to be written  
    * `taille` :  
        Number of characters  

    remark: The string is printed (left-adjusted) on 'taille' characters  

    """
    return _gstlearn.tab_print_rowname(string, taille)

def print_matrix(*args):
    r"""


    """
    return _gstlearn.print_matrix(*args)

def print_trimat(title, mode, neq, tl):
    r"""


    Tabulated printout of a upper triangular matrix  

    Parameters
    ----------
    * `title` :  
        Title (Optional)  
    * `mode` :  
        1 if the matrix is stored linewise 2 if the matrix is stored columnwise  
    * `neq` :  
        size of the matrix  
    * `tl` :  
        array containing the upper triangular matrix  

    remark: The ordering (compatible with matrix_solve is mode==2)  

    """
    return _gstlearn.print_trimat(title, mode, neq, tl)

def print_imatrix(title, flag_limit, bycol, nx, ny, sel, tab):
    r"""


    Tabulated printout of a matrix (integer version)  

    Parameters
    ----------
    * `title` :  
        Title (Optional)  
    * `flag_limit` :  
        option for the limits  

        *   1 if limits must be applied  
        *   0 if the whole matrix is printed  
    * `bycol` :  
        1 if values in 'tab' are sorted by column, 0 otherwise  
    * `nx` :  
        number of columns in the matrix  
    * `ny` :  
        number of rows in the matrix  
    * `sel` :  
        array of selection or NULL  
    * `tab` :  
        array containing the matrix  

    """
    return _gstlearn.print_imatrix(title, flag_limit, bycol, nx, ny, sel, tab)

def print_vector(*args):
    r"""


    """
    return _gstlearn.print_vector(*args)

def print_ivector(*args):
    r"""


    """
    return _gstlearn.print_ivector(*args)
class AStringFormat(object):
    r"""


    C++ includes: AStringFormat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        AStringFormat::AStringFormat
        """
        _gstlearn.AStringFormat_swiginit(self, _gstlearn.new_AStringFormat(*args))
    __swig_destroy__ = _gstlearn.delete_AStringFormat

    def getLevel(self):
        r"""

        AStringFormat::getLevel
        """
        return _gstlearn.AStringFormat_getLevel(self)

    def hasTitle(self):
        r"""

        AStringFormat::hasTitle
        """
        return _gstlearn.AStringFormat_hasTitle(self)

    def getTitle(self):
        r"""

        AStringFormat::getTitle
        """
        return _gstlearn.AStringFormat_getTitle(self)

    def setTitle(self, title):
        r"""

        AStringFormat::setTitle
        """
        return _gstlearn.AStringFormat_setTitle(self, title)

# Register AStringFormat in _gstlearn:
_gstlearn.AStringFormat_swigregister(AStringFormat)
class ASerializable(object):
    r"""


    C++ includes: ASerializable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ASerializable

    def dumpToNF(self, *args, **kwargs):
        r"""

        ASerializable::dumpToNF
        Dump the contents of an object into an Output File using a given Output NF
        Format.  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Output File  
        * `format` :  
            Choice of the format (see remarks)  
        * `verbose` :  
            Verbose flag  

        Returns
        -------
        true or false  

        remark: In the argument 'format', the user can select the format for encoding
            the contents of the output file. If the value DEFAULT is used, the package
            uses the Format currently defined as the defaulted one. This default value
            can be updated using the method ASerializable::DefaultFormatNF()  

        """
        return _gstlearn.ASerializable_dumpToNF(self, *args, **kwargs)

    @staticmethod
    def buildFileName(status, filename, ensureDirExist=False):
        r"""

        ASerializable::buildFileName
        Build a standard filename for Read or Write operation  

        Parameters
        ----------
        * `status` :  
            1 for Read and 2 for Write  
        * `filename` :  
            Name of the filename (see remark)  
        * `ensureDirExist` :  
            When TRUE, the Directory is created if not already existing  

        Returns
        -------  

        """
        return _gstlearn.ASerializable_buildFileName(status, filename, ensureDirExist)

    @staticmethod
    def getFileIdentity(filename, verbose=False):
        r"""

        ASerializable::getFileIdentity
        Returns the Identity of a Neutral File which allows knowing its type  

        Parameters
        ----------
        * `filename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.ASerializable_getFileIdentity(filename, verbose)

    @staticmethod
    def setPrefixName(prefixName):
        r"""

        ASerializable::setPrefixName
        """
        return _gstlearn.ASerializable_setPrefixName(prefixName)

    @staticmethod
    def unsetPrefixName():
        r"""

        ASerializable::unsetPrefixName
        """
        return _gstlearn.ASerializable_unsetPrefixName()

    @staticmethod
    def getPrefixName():
        r"""

        ASerializable::getPrefixName
        """
        return _gstlearn.ASerializable_getPrefixName()

    def setDefaultFormatNF(self, format):
        r"""

        ASerializable::setDefaultFormatNF
        """
        return _gstlearn.ASerializable_setDefaultFormatNF(self, format)

    def _getNFName(self):
        r"""

        ASerializable::_getNFName
        """
        return _gstlearn.ASerializable__getNFName(self)

# Register ASerializable in _gstlearn:
_gstlearn.ASerializable_swigregister(ASerializable)
class NamingConvention(AStringable):
    r"""


    Naming Convention facility This class describes the way variables created within
    the current procedure will be named afterwards and will possibly be assigned a
    locator.  

    The generic name is generated as follows: 'prefix'.'varname'.'qualifier'.'rank'  

    *   prefix: string provided in the constructor of this class  
    *   varname: name of the (input) variable on which the procedure is performed  
    *   qualifier: type of element stored in the variable  
    *   rank: rank of the output variable (if several variables of the same type are
        generated)  

    The choice of the 'prefix' is done by the user when launching the procedure the
    other parameters are usually defined within the procedure.  

    For example, when running 'kriging' function with several variables defined in
    the input Db - say "Pb" abd "Zn" (they are assigned a Z-locator), using the
    following command: kriging( ... namconv = NamingConvention("MyPrefix") )  

    Then the kriging procedure generates variables such as:  

    *   MyPrefix.Pb.estim (estimation of Pb by CoKriging)  
    *   MyPrefix.Zn.estim (estimation of Zn by CoKriging)  
    *   MyPrefix.Pb.stdev (St. Dev. of estimation error of Pb by CoKriging)  
    *   MyPrefix.Zn.stdev (St. Dev. of estimation error of Zn by CoKriging)  

    Then the non-conditional simulation procedure generates variables such as:  

    *   MyPrefix.1 (for first simulation)  
    *   MyPrefix.2 (for second simulation) ...  

        Then the conditional simulation procedure generates variables such as:  
    *   MyPrefix.var.1 (for first simulation)  
    *   MyPrefix.var.2 (for second simulation) ...  

    Ultimately, the newly created variables are assigned a locator.  

    C++ includes: NamingConvention.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NamingConvention::NamingConvention
        """
        _gstlearn.NamingConvention_swiginit(self, _gstlearn.new_NamingConvention(*args))
    __swig_destroy__ = _gstlearn.delete_NamingConvention

    def toString(self, strfmt=None):
        r"""

        NamingConvention::toString
        AStringable Interface.  

        """
        return _gstlearn.NamingConvention_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        NamingConvention::create
        Construct an item of the Naming Convention Class  

        Parameters
        ----------
        * `prefix` :  
            Name given to the prefix  
        * `flag_varname` :  
            When TRUE, the 'varname' is included in the output names  
        * `flag_qualifier` :  
            When TRUE, the 'qualifier' is included in the output names  
        * `flag_locator` :  
            When TRUE, the output variables receive a 'locator'  
        * `locatorOutType` :  
            Type of locator assigned to the output variables  
        * `delim` :  
            Symbol used as a delimitor separating the different parts of the output
            names  
        * `cleanSameLocator` :  
            When TRUE and if 'flag_locator' is TRUE, all variables assigned to the same
            locator are cancelled beforehand  

        Returns
        -------  

        """
        return _gstlearn.NamingConvention_create(*args, **kwargs)

    def setNamesAndLocators(self, *args):
        r"""

        NamingConvention::setNamesAndLocators
        Newly created variables are named as follow:  

        'prefix'.'v[iatt]'.'qualifier'.'item_rank'  

        Parameters
        ----------
        * `dbin` :  
            Pointer to the input Db (kept for symmetry)  
        * `iatt` :  
            Attribute index of the variables in Input Db  
        * `dbout` :  
            Pointer to the output Db  
        * `iattout_start` :  
            Starting attribute index  
        * `qualifier` :  
            Optional qualifier  
        * `nitems` :  
            Number of items  
        * `flagSetLocator` :  
            True if the variable must be assigned the locator  
        * `locatorShift` :  
            Shift to be applied to the locator currently defined  

        """
        return _gstlearn.NamingConvention_setNamesAndLocators(self, *args)

    def setDelim(self, delim):
        r"""

        NamingConvention::setDelim
        """
        return _gstlearn.NamingConvention_setDelim(self, delim)

    def setLocatorOutType(self, l):
        r"""

        NamingConvention::setLocatorOutType
        """
        return _gstlearn.NamingConvention_setLocatorOutType(self, l)

    def setPrefix(self, prefix):
        r"""

        NamingConvention::setPrefix
        """
        return _gstlearn.NamingConvention_setPrefix(self, prefix)

    def setFlagClean(self, cleanSameLocator):
        r"""

        NamingConvention::setFlagClean
        """
        return _gstlearn.NamingConvention_setFlagClean(self, cleanSameLocator)

    def setLocators(self, dbout, iattout_start, nvar, nitems=1, locatorShift=0):
        r"""

        NamingConvention::setLocators
        """
        return _gstlearn.NamingConvention_setLocators(self, dbout, iattout_start, nvar, nitems, locatorShift)

    def isFlagQualifier(self):
        r"""

        NamingConvention::isFlagQualifier
        """
        return _gstlearn.NamingConvention_isFlagQualifier(self)

    def isFlagVarname(self):
        r"""

        NamingConvention::isFlagVarname
        """
        return _gstlearn.NamingConvention_isFlagVarname(self)

    def __repr__(self):
        return _gstlearn.NamingConvention___repr__(self)

# Register NamingConvention in _gstlearn:
_gstlearn.NamingConvention_swigregister(NamingConvention)
class ACalculator(object):
    r"""


    C++ includes: ACalculator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ACalculator

    def run(self):
        r"""

        ACalculator::run
        Run the calculator  

        Returns
        -------
        false if error, true otherwise  

        """
        return _gstlearn.ACalculator_run(self)

# Register ACalculator in _gstlearn:
_gstlearn.ACalculator_swigregister(ACalculator)
class ACalcDbVarCreator(ACalculator):
    r"""


    C++ includes: ACalcDbVarCreator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ACalcDbVarCreator

    def setDb(self, db):
        r"""

        ACalcDbVarCreator::setDb
        """
        return _gstlearn.ACalcDbVarCreator_setDb(self, db)

    def setNamingConvention(self, namconv):
        r"""

        ACalcDbVarCreator::setNamingConvention
        """
        return _gstlearn.ACalcDbVarCreator_setNamingConvention(self, namconv)

    def getDb(self):
        r"""

        ACalcDbVarCreator::getDb
        """
        return _gstlearn.ACalcDbVarCreator_getDb(self)

    def hasDb(self, verbose=False):
        r"""

        ACalcDbVarCreator::hasDb
        """
        return _gstlearn.ACalcDbVarCreator_hasDb(self, verbose)

    def getNamconv(self):
        r"""

        ACalcDbVarCreator::getNamconv
        """
        return _gstlearn.ACalcDbVarCreator_getNamconv(self)

# Register ACalcDbVarCreator in _gstlearn:
_gstlearn.ACalcDbVarCreator_swigregister(ACalcDbVarCreator)
class ACalcDbToDb(ACalculator):
    r"""


    C++ includes: ACalcDbToDb.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ACalcDbToDb

    def setDbin(self, dbin):
        r"""

        ACalcDbToDb::setDbin
        """
        return _gstlearn.ACalcDbToDb_setDbin(self, dbin)

    def setDbout(self, dbout):
        r"""

        ACalcDbToDb::setDbout
        """
        return _gstlearn.ACalcDbToDb_setDbout(self, dbout)

    def setNamingConvention(self, namconv):
        r"""

        ACalcDbToDb::setNamingConvention
        """
        return _gstlearn.ACalcDbToDb_setNamingConvention(self, namconv)

    def setMustShareSpaceDimension(self, mustShareSpaceDimension):
        r"""

        ACalcDbToDb::setMustShareSpaceDimension
        """
        return _gstlearn.ACalcDbToDb_setMustShareSpaceDimension(self, mustShareSpaceDimension)

    def getDbin(self):
        r"""

        ACalcDbToDb::getDbin
        """
        return _gstlearn.ACalcDbToDb_getDbin(self)

    def getDbout(self):
        r"""

        ACalcDbToDb::getDbout
        """
        return _gstlearn.ACalcDbToDb_getDbout(self)

    def getGridin(self):
        r"""

        ACalcDbToDb::getGridin
        """
        return _gstlearn.ACalcDbToDb_getGridin(self)

    def getGridout(self):
        r"""

        ACalcDbToDb::getGridout
        """
        return _gstlearn.ACalcDbToDb_getGridout(self)

    def hasDbin(self, verbose=True):
        r"""

        ACalcDbToDb::hasDbin
        """
        return _gstlearn.ACalcDbToDb_hasDbin(self, verbose)

    def hasDbout(self, verbose=True):
        r"""

        ACalcDbToDb::hasDbout
        """
        return _gstlearn.ACalcDbToDb_hasDbout(self, verbose)

    def isGridIn(self, verbose=True):
        r"""

        ACalcDbToDb::isGridIn
        """
        return _gstlearn.ACalcDbToDb_isGridIn(self, verbose)

    def isGridOut(self, verbose=True):
        r"""

        ACalcDbToDb::isGridOut
        """
        return _gstlearn.ACalcDbToDb_isGridOut(self, verbose)

# Register ACalcDbToDb in _gstlearn:
_gstlearn.ACalcDbToDb_swigregister(ACalcDbToDb)
class CalcMigrate(ACalcDbToDb):
    r"""


    C++ includes: CalcMigrate.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcMigrate::CalcMigrate
        """
        _gstlearn.CalcMigrate_swiginit(self, _gstlearn.new_CalcMigrate())
    __swig_destroy__ = _gstlearn.delete_CalcMigrate

    def setDmax(self, dmax):
        r"""

        CalcMigrate::setDmax
        """
        return _gstlearn.CalcMigrate_setDmax(self, dmax)

    def setFlagFill(self, flagFill):
        r"""

        CalcMigrate::setFlagFill
        """
        return _gstlearn.CalcMigrate_setFlagFill(self, flagFill)

    def setFlagInter(self, flagInter):
        r"""

        CalcMigrate::setFlagInter
        """
        return _gstlearn.CalcMigrate_setFlagInter(self, flagInter)

    def setFlagBall(self, flagBall):
        r"""

        CalcMigrate::setFlagBall
        """
        return _gstlearn.CalcMigrate_setFlagBall(self, flagBall)

    def setDistType(self, dist_type):
        r"""

        CalcMigrate::setDistType
        """
        return _gstlearn.CalcMigrate_setDistType(self, dist_type)

    def setIuids(self, iuids):
        r"""

        CalcMigrate::setIuids
        """
        return _gstlearn.CalcMigrate_setIuids(self, iuids)

    def setFlagLocate(self, flagLocate):
        r"""

        CalcMigrate::setFlagLocate
        """
        return _gstlearn.CalcMigrate_setFlagLocate(self, flagLocate)

    def setLocatorType(self, locatorType):
        r"""

        CalcMigrate::setLocatorType
        """
        return _gstlearn.CalcMigrate_setLocatorType(self, locatorType)

# Register CalcMigrate in _gstlearn:
_gstlearn.CalcMigrate_swigregister(CalcMigrate)

def migrate(*args, **kwargs):
    r"""


    Migrates a variable from one Db to another one  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Descriptor of the input Db  
    * `dbout` :  
        Descriptor of the output Db  
    * `name` :  
        Name of the attribute to be migrated  
    * `dist_type` :  
        Type of distance for calculating maximum distance 1 for L1 and 2 for L2
        distance  
    * `dmax` :  
        Array of maximum distances (optional)  
    * `flag_fill` :  
        Filling option  
    * `flag_inter` :  
        Interpolation  
    * `flag_ball` :  
        Use BallTree sorting algorithm when available  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.migrate(*args, **kwargs)

def migrateMulti(*args, **kwargs):
    r"""


    Migrates a set of variables from one Db to another one  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Descriptor of the input Db  
    * `dbout` :  
        Descriptor of the output Db  
    * `names` :  
        Name of the attribute to be migrated  
    * `dist_type` :  
        Type of distance for calculating maximum distance 1 for L1 and 2 for L2
        distance  
    * `dmax` :  
        Array of maximum distances (optional)  
    * `flag_fill` :  
        Filling option  
    * `flag_inter` :  
        Interpolation  
    * `flag_ball` :  
        Use BallTree sorting algorithm when available  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.migrateMulti(*args, **kwargs)

def migrateByAttribute(*args, **kwargs):
    r"""


    Migrates a variable from one Db to another one  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Descriptor of the input Db  
    * `dbout` :  
        Descriptor of the output Db  
    * `atts` :  
        Array of attributes to be migrated  
    * `dist_type` :  
        Type of distance for calculating maximum distance 1 for L1 and 2 for L2
        distance  
    * `dmax` :  
        Array of maximum distances (optional)  
    * `flag_fill` :  
        Filling option  
    * `flag_inter` :  
        Interpolation  
    * `flag_ball` :  
        Use BallTree sorting algorithm when available  
    * `namconv` :  
        Naming Convention  

    """
    return _gstlearn.migrateByAttribute(*args, **kwargs)

def migrateByLocator(*args, **kwargs):
    r"""


    Migrates all z-locator variables from one Db to another one  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Descriptor of the input Db  
    * `dbout` :  
        Descriptor of the output Db  
    * `locatorType` :  
        Locator Type  
    * `dist_type` :  
        Type of distance for calculating maximum distance 1 for L1 and 2 for L2
        distance  
    * `dmax` :  
        Array of maximum distances (optional)  
    * `flag_fill` :  
        Filling option  
    * `flag_inter` :  
        Interpolation  
    * `flag_ball` :  
        Use BallTree sorting algorithm when available  
    * `namconv` :  
        Naming convention  

    remark: The output variable receive the same locator as the input variables  

    """
    return _gstlearn.migrateByLocator(*args, **kwargs)

def manageExternalInformation(mode, locatorType, dbin, dbout, flag_created):
    r"""


    Derive the external information(s) from the Output db (if Grid) to the Input Db  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `mode` :  
        1 for allocation; -1 for deallocation  
    * `locatorType` :  
        Type of the pointer (ELoc)  
    * `dbin` :  
        Descriptor of the input Db  
    * `dbout` :  
        Descriptor of the output Db  
    * `flag_created` :  
        True if variables have been created  

    remark: This function only functions when the Output Db is a grid  

    remark: However, in case of a Point output Db, this function should not  

    remark: be used: the external drift functions should already be present  

    remark: in the output Db.  

    remark: If this is not the case, an error is issued.  

    """
    return _gstlearn.manageExternalInformation(mode, locatorType, dbin, dbout, flag_created)

def interpolateVariableToPoint(db_grid, iatt, np, xp, yp, zp, tab):
    r"""


    Interpolate a variable from a grid Db on discretization points  

    Parameters
    ----------
    * `db_grid` :  
        Descriptor of the grid parameters  
    * `iatt` :  
        Rank of the attribute in db_grid  
    * `np` :  
        Number of discretized points  
    * `xp` :  
        Array of first coordinates  
    * `yp` :  
        Array of second coordinates  
    * `zp` :  
        Array of third coordinates  
    * `tab` :  
        Output array  

    remark: The arguments 'xp', 'yp' and 'zp' must be defined in accordance  

    remark: with the space dimension in argument 'db_grid'  

    remark: A point which does not lie between two valuated grid nodes  

    remark: (in all space dimensions) is always set to FFFF  

    """
    return _gstlearn.interpolateVariableToPoint(db_grid, iatt, np, xp, yp, zp, tab)

def dbgridLineSampling(dbgrid, x1, x2, ndisc, ncut, cuts, nval_ret):
    r"""


    Sampling vertices within a Grid between two points  

    Returns
    -------
    Array of sampled vertices  

    Parameters
    ----------
    * `dbgrid` :  
        reference Grid  
    * `x1` :  
        Array giving the coordinates of the first point  
    * `x2` :  
        Array giving the coordinates of the second point  
    * `ndisc` :  
        Number of discretized points in the segment  
    * `ncut` :  
        Number of cutoffs  
    * `cuts` :  
        Array of cutoffs  
    * `nval_ret` :  
        Number of samples in the output array  

    remark: This function considers the segment [x1,x2] and subdivises it  

    remark: into 'ndisc' intervals. The endpoints of each interval correspond  

    remark: to two points in the space  

    remark: At each endpoint, the target variable is interpolated from the grid  

    remark: If the target variable values cross a cutoff, the coordinates of  

    remark: the intersection are calculated.  

    remark: The program returns the list of all these intersection coordinates  

    TODO FUTURE_REFACTOR  

    """
    return _gstlearn.dbgridLineSampling(dbgrid, x1, x2, ndisc, ncut, cuts, nval_ret)

def expandPointToGrid(db_point, db_grid, iatt, iatt_time, iatt_angle, iatt_scaleu, iatt_scalev, iatt_scalew, flag_index, distType, dmax, tab):
    r"""


    Expands a variable from the point structure into a variable in the grid
    structure  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db_point` :  
        Descriptor of the point parameters  
    * `db_grid` :  
        Descriptor of the grid parameters  
    * `iatt` :  
        Rank of the point attribute  
    * `iatt_time` :  
        Optional variable for Time shift  
    * `iatt_angle` :  
        Optional variable for anisotropy angle (around Z)  
    * `iatt_scaleu` :  
        Optional variable for anisotropy scale factor (U)  
    * `iatt_scalev` :  
        Optional variable for anisotropy scale factor (V)  
    * `iatt_scalew` :  
        Optional variable for anisotropy scale factor (W)  
    * `flag_index` :  
        1 if the Index must be assigned to grid node 0 the 'iatt' attribute is
        assigned instead  
    * `distType` :  
        Type of distance for calculating maximum distance 1 for L1 and 2 for L2
        distance  
    * `dmax` :  
        Array of maximum distances (optional)  
    * `tab` :  
        Output array  

    remark: When a Time Shift is present, this corresponds to Johnson-Mehl  

    remark: The Time Shift is an optional variable which increases the  

    remark: distance (the time-to-distance conversion is assumed to be 1)  

    remark: Only positive Time Shifts are considered  

    """
    return _gstlearn.expandPointToGrid(db_point, db_grid, iatt, iatt_time, iatt_angle, iatt_scaleu, iatt_scalev, iatt_scalew, flag_index, distType, dmax, tab)

def pointToBlock(dbpoint, dbgrid, option, flag_size, iatt_time, iatt_size, iatt_angle, iatt_scaleu, iatt_scalev, iatt_scalew):
    r"""


    Plunge a set of isolated points within a discretization grid in order to compute
    the voronoi of the points and derive:  

    *   the statistics on the volume and perimeter of the cells  
    *   the edge between cells  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbpoint` :  
        Descriptor of the point parameters  
    * `dbgrid` :  
        Descriptor of the grid parameters  
    * `option` :  
        Connectivity option (0 for cross and 1 for block)  
    * `flag_size` :  
        When 1, the border pixels report the border thickness When 0, the border
        pixels are painted in 1  
    * `iatt_time` :  
        Attribute of 'dbpoint'for Time shift (optional)  
    * `iatt_size` :  
        Attribute of 'dbpoint' giving size (optional)  
    * `iatt_angle` :  
        Optional variable for anisotropy angle (around Z)  
    * `iatt_scaleu` :  
        Optional variable for anisotropy scale factor (U)  
    * `iatt_scalev` :  
        Optional variable for anisotropy scale factor (V)  
    * `iatt_scalew` :  
        Optional variable for anisotropy scale factor (W)  

    remark: The value of 'flag_index' can be turned on for assigning  

    remark: the sample index to the grid cell (instead of the 'iatt' value)  

    remark: using: set_keypair("PTB_flag_index")  

    """
    return _gstlearn.pointToBlock(dbpoint, dbgrid, option, flag_size, iatt_time, iatt_size, iatt_angle, iatt_scaleu, iatt_scalev, iatt_scalew)

def migrateGridToCoor(db_grid, iatt, coords, tab):
    r"""


    Migrates a variable from the grid structure into a variable at points defined by
    coordinate vectors  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db_grid` :  
        descriptor of the grid parameters  
    * `iatt` :  
        rank of the grid attribute  
    * `coords` :  
        Array of coordinates (dimension: ndim, np)  
    * `tab` :  
        Output array (Dimension: number of discretized points)  

    """
    return _gstlearn.migrateGridToCoor(db_grid, iatt, coords, tab)

def expandPointToCoor(db1, iatt, coords, tab):
    r"""


    Expands a variable from one point Db into a variable at points defined by
    coordinate vectors (maximum 3D)  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db1` :  
        descriptor of the input parameters  
    * `iatt` :  
        rank of the input attribute  
    * `coords` :  
        Array of coordinates  
    * `tab` :  
        Output array (Dimension: number of discretized points)  

    """
    return _gstlearn.expandPointToCoor(db1, iatt, coords, tab)
class ACalcInterpolator(ACalcDbToDb):
    r"""


    C++ includes: ACalcInterpolator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ACalcInterpolator

    def setModel(self, model):
        r"""

        ACalcInterpolator::setModel
        """
        return _gstlearn.ACalcInterpolator_setModel(self, model)

    def setNeigh(self, neigh):
        r"""

        ACalcInterpolator::setNeigh
        """
        return _gstlearn.ACalcInterpolator_setNeigh(self, neigh)

    def setKrigopt(self, krigopt):
        r"""

        ACalcInterpolator::setKrigopt
        """
        return _gstlearn.ACalcInterpolator_setKrigopt(self, krigopt)

    def getModel(self):
        r"""

        ACalcInterpolator::getModel
        """
        return _gstlearn.ACalcInterpolator_getModel(self)

    def getNeigh(self):
        r"""

        ACalcInterpolator::getNeigh
        """
        return _gstlearn.ACalcInterpolator_getNeigh(self)

    def getKrigopt(self):
        r"""

        ACalcInterpolator::getKrigopt
        """
        return _gstlearn.ACalcInterpolator_getKrigopt(self)

    def hasModel(self, verbose=True):
        r"""

        ACalcInterpolator::hasModel
        """
        return _gstlearn.ACalcInterpolator_hasModel(self, verbose)

    def hasNeigh(self, verbose=True):
        r"""

        ACalcInterpolator::hasNeigh
        """
        return _gstlearn.ACalcInterpolator_hasNeigh(self, verbose)

# Register ACalcInterpolator in _gstlearn:
_gstlearn.ACalcInterpolator_swigregister(ACalcInterpolator)
class CalcStatistics(ACalcDbToDb):
    r"""


    C++ includes: CalcStatistics.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcStatistics::CalcStatistics
        """
        _gstlearn.CalcStatistics_swiginit(self, _gstlearn.new_CalcStatistics())
    __swig_destroy__ = _gstlearn.delete_CalcStatistics

    def getDboutMustBeGrid(self):
        r"""

        CalcStatistics::getDboutMustBeGrid
        """
        return _gstlearn.CalcStatistics_getDboutMustBeGrid(self)

    def setDboutMustBeGrid(self, dboutMustBeGrid):
        r"""

        CalcStatistics::setDboutMustBeGrid
        """
        return _gstlearn.CalcStatistics_setDboutMustBeGrid(self, dboutMustBeGrid)

    def setFlagStats(self, flagStats):
        r"""

        CalcStatistics::setFlagStats
        """
        return _gstlearn.CalcStatistics_setFlagStats(self, flagStats)

    def setRadius(self, radius):
        r"""

        CalcStatistics::setRadius
        """
        return _gstlearn.CalcStatistics_setRadius(self, radius)

    def setOper(self, oper):
        r"""

        CalcStatistics::setOper
        """
        return _gstlearn.CalcStatistics_setOper(self, oper)

    def setFlagRegr(self, flagRegr):
        r"""

        CalcStatistics::setFlagRegr
        """
        return _gstlearn.CalcStatistics_setFlagRegr(self, flagRegr)

    def setFlagCst(self, flagCst):
        r"""

        CalcStatistics::setFlagCst
        """
        return _gstlearn.CalcStatistics_setFlagCst(self, flagCst)

    def setName0(self, name0):
        r"""

        CalcStatistics::setName0
        """
        return _gstlearn.CalcStatistics_setName0(self, name0)

    def setNamaux(self, namaux):
        r"""

        CalcStatistics::setNamaux
        """
        return _gstlearn.CalcStatistics_setNamaux(self, namaux)

    def setRegrMode(self, regrMode):
        r"""

        CalcStatistics::setRegrMode
        """
        return _gstlearn.CalcStatistics_setRegrMode(self, regrMode)

    def setModel(self, model):
        r"""

        CalcStatistics::setModel
        """
        return _gstlearn.CalcStatistics_setModel(self, model)

# Register CalcStatistics in _gstlearn:
_gstlearn.CalcStatistics_swigregister(CalcStatistics)

def dbStatisticsOnGrid(*args, **kwargs):
    r"""


    Calculates the statistics on variables of an input Db per cell of an output Grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Input Db  
    * `dbgrid` :  
        Output DbGrid  
    * `oper` :  
        The statistical calculation  
    * `radius` :  
        Neighborhood radius  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.dbStatisticsOnGrid(*args, **kwargs)

def dbRegression(*args, **kwargs):
    r"""


    """
    return _gstlearn.dbRegression(*args, **kwargs)
class CalcGridToGrid(ACalcDbToDb):
    r"""


    C++ includes: CalcGridToGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcGridToGrid::CalcGridToGrid
        """
        _gstlearn.CalcGridToGrid_swiginit(self, _gstlearn.new_CalcGridToGrid())
    __swig_destroy__ = _gstlearn.delete_CalcGridToGrid

    def setFlagCopy(self, flagCopy):
        r"""

        CalcGridToGrid::setFlagCopy
        """
        return _gstlearn.CalcGridToGrid_setFlagCopy(self, flagCopy)

    def setFlagExpand(self, flagExpand):
        r"""

        CalcGridToGrid::setFlagExpand
        """
        return _gstlearn.CalcGridToGrid_setFlagExpand(self, flagExpand)

    def setFlagShrink(self, flagShrink):
        r"""

        CalcGridToGrid::setFlagShrink
        """
        return _gstlearn.CalcGridToGrid_setFlagShrink(self, flagShrink)

    def setFlagInter(self, flagInter):
        r"""

        CalcGridToGrid::setFlagInter
        """
        return _gstlearn.CalcGridToGrid_setFlagInter(self, flagInter)

    def setNameBots(self, name_bots):
        r"""

        CalcGridToGrid::setNameBots
        """
        return _gstlearn.CalcGridToGrid_setNameBots(self, name_bots)

    def setNameTops(self, name_tops):
        r"""

        CalcGridToGrid::setNameTops
        """
        return _gstlearn.CalcGridToGrid_setNameTops(self, name_tops)

# Register CalcGridToGrid in _gstlearn:
_gstlearn.CalcGridToGrid_swigregister(CalcGridToGrid)

def dbg2gCopy(*args, **kwargs):
    r"""


    """
    return _gstlearn.dbg2gCopy(*args, **kwargs)

def dbg2gExpand(*args, **kwargs):
    r"""


    """
    return _gstlearn.dbg2gExpand(*args, **kwargs)

def dbg2gShrink(*args, **kwargs):
    r"""


    """
    return _gstlearn.dbg2gShrink(*args, **kwargs)

def dbg2gInterpolate(*args, **kwargs):
    r"""


    """
    return _gstlearn.dbg2gInterpolate(*args, **kwargs)
class CalcSimuPost(ACalcDbToDb):
    r"""


    C++ includes: CalcSimuPost.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcSimuPost::CalcSimuPost
        """
        _gstlearn.CalcSimuPost_swiginit(self, _gstlearn.new_CalcSimuPost())
    __swig_destroy__ = _gstlearn.delete_CalcSimuPost

    def setNames(self, names):
        r"""

        CalcSimuPost::setNames
        """
        return _gstlearn.CalcSimuPost_setNames(self, names)

    def setNfact(self, nfact):
        r"""

        CalcSimuPost::setNfact
        """
        return _gstlearn.CalcSimuPost_setNfact(self, nfact)

    def setUpscale(self, upscale):
        r"""

        CalcSimuPost::setUpscale
        """
        return _gstlearn.CalcSimuPost_setUpscale(self, upscale)

    def setVerbose(self, verbose):
        r"""

        CalcSimuPost::setVerbose
        """
        return _gstlearn.CalcSimuPost_setVerbose(self, verbose)

    def setFlagMatch(self, match):
        r"""

        CalcSimuPost::setFlagMatch
        """
        return _gstlearn.CalcSimuPost_setFlagMatch(self, match)

    def setFlagUpscale(self, flagUpscale):
        r"""

        CalcSimuPost::setFlagUpscale
        """
        return _gstlearn.CalcSimuPost_setFlagUpscale(self, flagUpscale)

    def setStats(self, stats):
        r"""

        CalcSimuPost::setStats
        """
        return _gstlearn.CalcSimuPost_setStats(self, stats)

    def setCheckTargets(self, ranks):
        r"""

        CalcSimuPost::setCheckTargets
        """
        return _gstlearn.CalcSimuPost_setCheckTargets(self, ranks)

    def setCheckLevel(self, level):
        r"""

        CalcSimuPost::setCheckLevel
        """
        return _gstlearn.CalcSimuPost_setCheckLevel(self, level)

# Register CalcSimuPost in _gstlearn:
_gstlearn.CalcSimuPost_swigregister(CalcSimuPost)

def simuPost(*args, **kwargs):
    r"""


    Parameters
    ----------
    * `dbin` :  
        Input data base  
    * `dbout` :  
        Output data base (must be a Grid)  
    * `names` :  
        Vector of simulation names  
    * `flag_match` :  
        True if the ranks of simulations must match; otherwise: product  
    * `upscale` :  
        Option within EPostUpscale  
    * `stats` :  
        Vector of options within EPostStat  
    * `verbose` :  
        Verbose flag  
    * `check_targets` :  
        Rank (1-based) of the target element to be checked (0: None; -1: All)  
    * `check_level` :  
        0: Statistics; 1: Sample Selection; 2: Iteration definition  
    * `namconv` :  
        Naming convention  

    Returns
    -------
    Error code  

    remark:  

        *   N : number of variables in 'dbin' defined by 'names' (index 'n')  
        *   k_1, ..., k_N : number of outcomes for each variable  
        *   K : number of multivariate simulations according to 'flag_match' (index
            'k')  
        *   Transformation function 'F' from Z in R_N to Y in R_P (index 'p')  

    Description of the Flow Chart:  

    1.  Loop over cells of 'dbout' (index 'C')  
    2.  Loop over the simulations (index 'k')  
    3.  Find the active samples of 'dbin' in 'C' (index 's') and build table of
        Z_n^{k}(s)  
    4.  Apply the Transform function to table: Y_p^{k}(s)  
    5.  Upscale to the target cell according to upscaling rule '_upscale':
        up_Y_p^{k}(C)  
    6.  Compute statistics according to stat rule '_stats'  

    """
    return _gstlearn.simuPost(*args, **kwargs)
class CalcSimuPostDemo(CalcSimuPost):
    r"""


    C++ includes: CalcSimuPostDemo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcSimuPostDemo::CalcSimuPostDemo
        """
        _gstlearn.CalcSimuPostDemo_swiginit(self, _gstlearn.new_CalcSimuPostDemo())
    __swig_destroy__ = _gstlearn.delete_CalcSimuPostDemo

# Register CalcSimuPostDemo in _gstlearn:
_gstlearn.CalcSimuPostDemo_swigregister(CalcSimuPostDemo)

def simuPostDemo(*args, **kwargs):
    r"""


    This is a particular use of Simulation Post-Processing functions.  

    Its specificity is an embedded transformation function which transforms the
    multivariate simulation vector (combining the one outcome of each variable, and
    for a given sample) This transformation (which is provided as an example here):  

    *   uses the multivariate simulation vector in input (N elements)  
    *   produces an output vector (Dimension 2) with the *mean* and the *standard
        deviation* of the values of the input vector  

    For a detailed list of arguments, see simuPost  

    """
    return _gstlearn.simuPostDemo(*args, **kwargs)
class CalcSimuPostPropByLayer(CalcSimuPost):
    r"""


    This particular Multivariate Simulation post_processing considers each simulated
    variable as a thickness of ordered layers (define in R_N). For each cell of the
    output grid (defined in R_{N+1}, we calculate the proportion of each layer
    within the cell  

    C++ includes: CalcSimuPostPropByLayer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcSimuPostPropByLayer::CalcSimuPostPropByLayer
        """
        _gstlearn.CalcSimuPostPropByLayer_swiginit(self, _gstlearn.new_CalcSimuPostPropByLayer())
    __swig_destroy__ = _gstlearn.delete_CalcSimuPostPropByLayer

    def setFlagTopToBase(self, topToBase):
        r"""

        CalcSimuPostPropByLayer::setFlagTopToBase
        """
        return _gstlearn.CalcSimuPostPropByLayer_setFlagTopToBase(self, topToBase)

# Register CalcSimuPostPropByLayer in _gstlearn:
_gstlearn.CalcSimuPostPropByLayer_swigregister(CalcSimuPostPropByLayer)

def simuPostPropByLayer(*args, **kwargs):
    r"""


    This is a particular use of Simulation Post-Processing functions. Its
    specificity comes from its transformation function.  

    It is assumed that each input variable corresponds to the thickness of ordered
    layers. This function receives a vector of multivariate information (for each
    combination of simulation outcome and for each sample of the input 'db').  

    If N designates the number of elements of the input vector, the transformation
    returns a vector of N+1 elements. This vector corresponds to the percentage of
    each layer within the target block  

    remark: : Coding Rule  

    remark: : - code = 0 -Inf < z <= H1  

    remark: : - code = 1 H1 < z <= H1 + H2  

    remark: : - code = 2 H1 + H2 < z <= H1 + H2 + H3  

    remark: : - code = 3 H1 + H2 + ... < z <= + Inf  

    For a detailed list of arguments, see simuPost  

    """
    return _gstlearn.simuPostPropByLayer(*args, **kwargs)
class Tensor(AStringable):
    r"""


    TODO : public ASpaceObject.  

    C++ includes: Tensor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Tensor::Tensor
        """
        _gstlearn.Tensor_swiginit(self, _gstlearn.new_Tensor(*args))
    __swig_destroy__ = _gstlearn.delete_Tensor

    def toString(self, strfmt=None):
        r"""

        Tensor::toString
        Interface for AStringable.  

        """
        return _gstlearn.Tensor_toString(self, strfmt)

    def init(self, ndim):
        r"""

        Tensor::init
        """
        return _gstlearn.Tensor_init(self, ndim)

    def setTensorDirect2(self, tensor):
        r"""

        Tensor::setTensorDirect2
        """
        return _gstlearn.Tensor_setTensorDirect2(self, tensor)

    def setRadiusIsotropic(self, radius):
        r"""

        Tensor::setRadiusIsotropic
        """
        return _gstlearn.Tensor_setRadiusIsotropic(self, radius)

    def setRadiusVec(self, radius):
        r"""

        Tensor::setRadiusVec
        """
        return _gstlearn.Tensor_setRadiusVec(self, radius)

    def setRadiusDir(self, idim, radius):
        r"""

        Tensor::setRadiusDir
        """
        return _gstlearn.Tensor_setRadiusDir(self, idim, radius)

    def setRotation(self, rot):
        r"""

        Tensor::setRotation
        """
        return _gstlearn.Tensor_setRotation(self, rot)

    def setRotationAngles(self, angles):
        r"""

        Tensor::setRotationAngles
        TODO : Rotation angles in 2D  

        """
        return _gstlearn.Tensor_setRotationAngles(self, angles)

    def setRotationAngle(self, idim, angle):
        r"""

        Tensor::setRotationAngle
        """
        return _gstlearn.Tensor_setRotationAngle(self, idim, angle)

    def setRotationAnglesAndRadius(self, *args, **kwargs):
        r"""

        Tensor::setRotationAnglesAndRadius
        This functions defines jointly the rotation anisotropy and ranges. It allows
        initiating the tensor only once (saves time)  

        Parameters
        ----------
        * `angles` :  
            Vector of rotation angles (optional)  
        * `radius` :  
            Vector of ranges (optional)  

        """
        return _gstlearn.Tensor_setRotationAnglesAndRadius(self, *args, **kwargs)

    def getAngles(self):
        r"""

        Tensor::getAngles
        """
        return _gstlearn.Tensor_getAngles(self)

    def getTensorDirect(self):
        r"""

        Tensor::getTensorDirect
        """
        return _gstlearn.Tensor_getTensorDirect(self)

    def getTensorInverse(self):
        r"""

        Tensor::getTensorInverse
        """
        return _gstlearn.Tensor_getTensorInverse(self)

    def getTensorDirect2(self):
        r"""

        Tensor::getTensorDirect2
        """
        return _gstlearn.Tensor_getTensorDirect2(self)

    def getAngle(self, i):
        r"""

        Tensor::getAngle
        """
        return _gstlearn.Tensor_getAngle(self, i)

    def getRadius(self, *args):
        r"""

        Tensor::getRadius
        """
        return _gstlearn.Tensor_getRadius(self, *args)

    def getRotation(self):
        r"""

        Tensor::getRotation
        """
        return _gstlearn.Tensor_getRotation(self)

    def getMatrixDirect(self):
        r"""

        Tensor::getMatrixDirect
        """
        return _gstlearn.Tensor_getMatrixDirect(self)

    def getMatrixInverse(self):
        r"""

        Tensor::getMatrixInverse
        """
        return _gstlearn.Tensor_getMatrixInverse(self)

    def isIsotropic(self):
        r"""

        Tensor::isIsotropic
        """
        return _gstlearn.Tensor_isIsotropic(self)

    def hasRotation(self):
        r"""

        Tensor::hasRotation
        """
        return _gstlearn.Tensor_hasRotation(self)

    def getValue(self, idim, jdim):
        r"""

        Tensor::getValue
        """
        return _gstlearn.Tensor_getValue(self, idim, jdim)

    def applyDirect(self, vec):
        r"""

        Tensor::applyDirect
        """
        return _gstlearn.Tensor_applyDirect(self, vec)

    def applyInverse(self, vec):
        r"""

        Tensor::applyInverse
        """
        return _gstlearn.Tensor_applyInverse(self, vec)

    def applyInverseInPlace(self, *args):
        r"""

        Tensor::applyInverseInPlace
        """
        return _gstlearn.Tensor_applyInverseInPlace(self, *args)

    def applyInverse2InPlace(self, vec, out):
        r"""

        Tensor::applyInverse2InPlace
        """
        return _gstlearn.Tensor_applyInverse2InPlace(self, vec, out)

    def applyDirectInPlace(self, vec, out):
        r"""

        Tensor::applyDirectInPlace
        """
        return _gstlearn.Tensor_applyDirectInPlace(self, vec, out)

    def applyDirectSwapInPlace(self, vec, out):
        r"""

        Tensor::applyDirectSwapInPlace
        """
        return _gstlearn.Tensor_applyDirectSwapInPlace(self, vec, out)

    def isFlagDefinedByInverse2(self):
        r"""

        Tensor::isFlagDefinedByInverse2
        """
        return _gstlearn.Tensor_isFlagDefinedByInverse2(self)

# Register Tensor in _gstlearn:
_gstlearn.Tensor_swigregister(Tensor)
class Grid(AStringable, ASerializable):
    r"""


    C++ includes: Grid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Grid::Grid
        """
        _gstlearn.Grid_swiginit(self, _gstlearn.new_Grid(*args))
    __swig_destroy__ = _gstlearn.delete_Grid

    def initThread(self):
        r"""

        Grid::initThread
        """
        return _gstlearn.Grid_initThread(self)

    @staticmethod
    def gridIndices(nx, string, startFromZero=True, invert=True, verbose=False):
        r"""

        Grid::gridIndices
        Returns an array giving the ranks of the nodes (according to user's order) coded
        with standard order (according to gstlearn internal order)  

        Returns
        -------
        Array of indices  

        Parameters
        ----------
        * `nx` :  
            Array giving the number of cells per direction  
        * `string` :  
            String describing the sorting order  
        * `startFromZero` :  
            True if numbering must start from 0 (1 otherwise)  
        * `invert` :  
            Way to use the resulting array (see remark)  
        * `verbose` :  
            Verbose flag  

        remark: Example of string: "+x2-x1"  

        remark: if 'rank' designates the resulting vector of indices  

        remark: invert=True:  

        remark: rank[i] is the location of element 'i' of the user's array  

        remark: within a regular grid of gstlearn  

        remark: invert=False:  

        remark: rank[i] is the rank of the element of the user's array  

        remark: in position 'i' of the regular grid of gstlearn  

        """
        return _gstlearn.Grid_gridIndices(nx, string, startFromZero, invert, verbose)

    @staticmethod
    def generateMirrorIndex(nx, ix):
        r"""

        Grid::generateMirrorIndex
        Return the index of a sample when calculated from mirroring within an array
        whose indices vary between 0 and nx-1  

        Returns
        -------
        Rank of the restrained cell  

        Parameters
        ----------
        * `nx` :  
            Number of cells  
        * `ix` :  
            Rank of the cell to be restrained  

        """
        return _gstlearn.Grid_generateMirrorIndex(nx, ix)

    def resetFromSpaceDimension(self, ndim):
        r"""

        Grid::resetFromSpaceDimension
        """
        return _gstlearn.Grid_resetFromSpaceDimension(self, ndim)

    def resetFromGrid(self, grid):
        r"""

        Grid::resetFromGrid
        """
        return _gstlearn.Grid_resetFromGrid(self, grid)

    def resetFromVector(self, *args, **kwargs):
        r"""

        Grid::resetFromVector
        """
        return _gstlearn.Grid_resetFromVector(self, *args, **kwargs)

    def setX0(self, idim, value):
        r"""

        Grid::setX0
        """
        return _gstlearn.Grid_setX0(self, idim, value)

    def setDX(self, idim, value):
        r"""

        Grid::setDX
        """
        return _gstlearn.Grid_setDX(self, idim, value)

    def setNX(self, idim, value):
        r"""

        Grid::setNX
        """
        return _gstlearn.Grid_setNX(self, idim, value)

    def setRotationByMatrix(self, rotmat):
        r"""

        Grid::setRotationByMatrix
        """
        return _gstlearn.Grid_setRotationByMatrix(self, rotmat)

    def setRotationByVector(self, rotmat):
        r"""

        Grid::setRotationByVector
        """
        return _gstlearn.Grid_setRotationByVector(self, rotmat)

    def setRotationByAngles(self, angles):
        r"""

        Grid::setRotationByAngles
        """
        return _gstlearn.Grid_setRotationByAngles(self, angles)

    def setRotationByAngle(self, angle):
        r"""

        Grid::setRotationByAngle
        Define the rotation by the value of its first angle  

        Parameters
        ----------
        * `angle` :  
            Value of the first rotation angle  

        """
        return _gstlearn.Grid_setRotationByAngle(self, angle)

    def getNDim(self):
        r"""

        Grid::getNDim
        """
        return _gstlearn.Grid_getNDim(self)

    def getX0(self, idim):
        r"""

        Grid::getX0
        """
        return _gstlearn.Grid_getX0(self, idim)

    def getDX(self, idim):
        r"""

        Grid::getDX
        """
        return _gstlearn.Grid_getDX(self, idim)

    def getNX(self, idim):
        r"""

        Grid::getNX
        """
        return _gstlearn.Grid_getNX(self, idim)

    def getNTotal(self):
        r"""

        Grid::getNTotal
        """
        return _gstlearn.Grid_getNTotal(self)

    def getCellSize(self):
        r"""

        Grid::getCellSize
        """
        return _gstlearn.Grid_getCellSize(self)

    def getExtend(self, idim, flagCell=False):
        r"""

        Grid::getExtend
        """
        return _gstlearn.Grid_getExtend(self, idim, flagCell)

    def getVolume(self, flagCell=False):
        r"""

        Grid::getVolume
        """
        return _gstlearn.Grid_getVolume(self, flagCell)

    def getExtends(self, flagCell=False):
        r"""

        Grid::getExtends
        """
        return _gstlearn.Grid_getExtends(self, flagCell)

    def toString(self, strfmt=None):
        r"""

        Grid::toString
        Interface to AStringable.  

        """
        return _gstlearn.Grid_toString(self, strfmt)

    def copyParams(self, mode, gridaux):
        r"""

        Grid::copyParams
        Copy some parameters from Gridaux  

        Parameters
        ----------
        * `mode` :  
            Type of parameters to be copied 1 : Array of Grid Number of meshes 2 : Array
            of Grid origin 3 : Array of Grid Meshes 4 : Rotation  
        * `gridaux` :  
            Source Grid structure  

        """
        return _gstlearn.Grid_copyParams(self, mode, gridaux)

    def getCoordinate(self, rank, idim, flag_rotate=True):
        r"""

        Grid::getCoordinate
        """
        return _gstlearn.Grid_getCoordinate(self, rank, idim, flag_rotate)

    def getCoordinatesByRank(self, rank, flag_rotate=True):
        r"""

        Grid::getCoordinatesByRank
        Return the Vector of coordinates for a given grid node  

        Parameters
        ----------
        * `rank` :  
            Rank of the target grid node  
        * `flag_rotate` :  
            TRUE: perform the rotation; FALSE: skip rotation  

        Returns
        -------
        Vector of coordinates  

        """
        return _gstlearn.Grid_getCoordinatesByRank(self, rank, flag_rotate)

    def getCoordinatesByIndice(self, *args, **kwargs):
        r"""

        Grid::getCoordinatesByIndice
        Returns the coordinates of a grid node, defined by its indices  

        Parameters
        ----------
        * `indice` :  
            Vector of indices defining the target grid node  
        * `flag_rotate` :  
            True if the grid rotation must be taken into account  
        * `shift` :  
            Vector of shifts (dimension: ndim) 0 : no shift; -1 : minus half a cell-
            width; +1 plus half a cell-width  
        * `dxsPerCell` :  
            Vector of variable grid meshes (optional)  

        Returns
        -------  

        """
        return _gstlearn.Grid_getCoordinatesByIndice(self, *args, **kwargs)

    def getCoordinatesByCorner(self, icorner):
        r"""

        Grid::getCoordinatesByCorner
        Returns the coordinates of a Grid corner  

        Parameters
        ----------
        * `icorner` :  
            Vector specifying the corner (0: minimum; 1: maximum). (Dimension: ndim)  

        Returns
        -------
        The coordinates of a corner  

        """
        return _gstlearn.Grid_getCoordinatesByCorner(self, icorner)

    def getCellCoordinatesByCorner(self, *args, **kwargs):
        r"""

        Grid::getCellCoordinatesByCorner
        Returns the coordinates of a Grid cell corner  

        Parameters
        ----------
        * `node` :  
            Rank of the Target cell  
        * `shift` :  
            Vector of shifts (dimension: ndim) 0 : no shift; -1 : minus half a cell-
            width; +1 plus half a cell-width  
        * `dxsPerCell` :  
            Vector of variable mesh extensions at target cell  

        Returns
        -------
        The coordinates of a cell corner (possibly shifted)  

        """
        return _gstlearn.Grid_getCellCoordinatesByCorner(self, *args, **kwargs)

    def indicesToCoordinate(self, *args, **kwargs):
        r"""

        Grid::indicesToCoordinate
        """
        return _gstlearn.Grid_indicesToCoordinate(self, *args, **kwargs)

    def rankToCoordinate(self, *args, **kwargs):
        r"""

        Grid::rankToCoordinate
        """
        return _gstlearn.Grid_rankToCoordinate(self, *args, **kwargs)

    def rankToCoordinates(self, *args, **kwargs):
        r"""

        Grid::rankToCoordinates
        """
        return _gstlearn.Grid_rankToCoordinates(self, *args, **kwargs)

    def rankToCoordinatesInPlace(self, *args, **kwargs):
        r"""

        Grid::rankToCoordinatesInPlace
        """
        return _gstlearn.Grid_rankToCoordinatesInPlace(self, *args, **kwargs)

    def coordinateToIndices(self, coor, centered=False, eps=1.e-6):
        r"""

        Grid::coordinateToIndices
        """
        return _gstlearn.Grid_coordinateToIndices(self, coor, centered, eps)

    def coordinateToIndicesInPlace(self, coor, indice, centered=False, eps=1.e-6):
        r"""

        Grid::coordinateToIndicesInPlace
        Find the grid node to which the current sample is assigned  

        Parameters
        ----------
        * `coor` :  
            Sample coordinates  
        * `indice` :  
            Indices of the assigned grid node  
        * `centered` :  
            True for grid cell centered  
        * `eps` :  
            Epsilon to over-pass roundoff problem  

        Returns
        -------
        Error return code  

        """
        return _gstlearn.Grid_coordinateToIndicesInPlace(self, coor, indice, centered, eps)

    def coordinateToRank(self, coor, centered=False, eps=1.e-6):
        r"""

        Grid::coordinateToRank
        """
        return _gstlearn.Grid_coordinateToRank(self, coor, centered, eps)

    def getCenterIndices(self, flagSup=False):
        r"""

        Grid::getCenterIndices
        """
        return _gstlearn.Grid_getCenterIndices(self, flagSup)

    def generateGridIndices(self, string, startFromZero=True, invert=True, verbose=False):
        r"""

        Grid::generateGridIndices
        """
        return _gstlearn.Grid_generateGridIndices(self, string, startFromZero, invert, verbose)

    def sampleBelongsToCell(self, *args):
        r"""

        Grid::sampleBelongsToCell
        Check if a sample belongs to a Grid Cell  

        Parameters
        ----------
        * `coor` :  
            Sample coordinates (can be lower space dimension than the current Grid)  
        * `rank` :  
            Rank of the Grid cell  
        * `dxsPerCell` :  
            When defined, vector of cell extension; otherwise use dx  

        Returns
        -------
        Error return code  

        remark: Samples located exactly on the edge are considered as INSIDE  

        """
        return _gstlearn.Grid_sampleBelongsToCell(self, *args)

    def getRotAngles(self):
        r"""

        Grid::getRotAngles
        """
        return _gstlearn.Grid_getRotAngles(self)

    def getRotMat(self):
        r"""

        Grid::getRotMat
        """
        return _gstlearn.Grid_getRotMat(self)

    def getRotAngle(self, idim):
        r"""

        Grid::getRotAngle
        """
        return _gstlearn.Grid_getRotAngle(self, idim)

    def getNXs(self):
        r"""

        Grid::getNXs
        """
        return _gstlearn.Grid_getNXs(self)

    def getX0s(self):
        r"""

        Grid::getX0s
        """
        return _gstlearn.Grid_getX0s(self)

    def getDXs(self):
        r"""

        Grid::getDXs
        """
        return _gstlearn.Grid_getDXs(self)

    def getRotation(self):
        r"""

        Grid::getRotation
        """
        return _gstlearn.Grid_getRotation(self)

    def isSame(self, grid):
        r"""

        Grid::isSame
        Check that the current grid match the one provided as argument up to their
        common Space Dimension  

        Parameters
        ----------
        * `grid` :  
            Target grid to be checked against the current one  

        Returns
        -------
        True if the grid match  

        """
        return _gstlearn.Grid_isSame(self, grid)

    def isSameMesh(self, grid):
        r"""

        Grid::isSameMesh
        """
        return _gstlearn.Grid_isSameMesh(self, grid)

    def isRotated(self):
        r"""

        Grid::isRotated
        """
        return _gstlearn.Grid_isRotated(self)

    def isSameRotation(self, grid):
        r"""

        Grid::isSameRotation
        """
        return _gstlearn.Grid_isSameRotation(self, grid)

    def getAxis(self, idim):
        r"""

        Grid::getAxis
        Returns a vector with the coordinates along one axis. This is needed for the
        label of Grid representation Warning: Not considering any possible rotation.  

        Parameters
        ----------
        * `idim` :  
            Index of the Space Dimension  

        Returns
        -------  

        """
        return _gstlearn.Grid_getAxis(self, idim)

    def iteratorInit(self, *args, **kwargs):
        r"""

        Grid::iteratorInit
        Initialize an iterator on the grid  

        Parameters
        ----------
        * `order` :  
            Array giving the order of the Space Dimensions when iterating  

        """
        return _gstlearn.Grid_iteratorInit(self, *args, **kwargs)

    def iteratorNext(self, *args):
        r"""

        Grid::iteratorNext
        """
        return _gstlearn.Grid_iteratorNext(self, *args)

    def empty(self):
        r"""

        Grid::empty
        """
        return _gstlearn.Grid_empty(self)

    def dilate(self, mode, nshift, nx, dx, x0):
        r"""

        Grid::dilate
        Returns the characteristics of a dilated grid  

        Parameters
        ----------
        * `mode` :  
            1 for extending; -1 for compressing  
        * `nshift` :  
            Array of shifts  
        * `nx` :  
            Array of number of grid meshes  
        * `dx` :  
            Array of grid meshes  
        * `x0` :  
            Array of grid origins  

        """
        return _gstlearn.Grid_dilate(self, mode, nshift, nx, dx, x0)

    def multiple(self, nmult, flagCell, nx, dx, x0):
        r"""

        Grid::multiple
        Returns the characteristics of a multiple grid  

        Parameters
        ----------
        * `nmult` :  
            Array of multiplicity coefficients  
        * `flagCell` :  
            true for cell matching; 0 for point matching  
        * `nx` :  
            Array of number of grid meshes  
        * `dx` :  
            Array of grid meshes  
        * `x0` :  
            Array of grid origins  

        """
        return _gstlearn.Grid_multiple(self, nmult, flagCell, nx, dx, x0)

    def divider(self, nmult, flagCell, nx, dx, x0):
        r"""

        Grid::divider
        Returns the characteristics of a divider grid  

        Parameters
        ----------
        * `nmult` :  
            Array of subdivision coefficients  
        * `flagCell` :  
            true for cell matching; 0 for point matching  
        * `nx` :  
            Array of number of grid meshes  
        * `dx` :  
            Array of grid meshes  
        * `x0` :  
            Array of grid origins  

        """
        return _gstlearn.Grid_divider(self, nmult, flagCell, nx, dx, x0)

    def getMirrorIndex(self, idim, ix):
        r"""

        Grid::getMirrorIndex
        Return the index of a sample when calculated from mirroring within an array
        whose indices vary between 0 and nx-1  

        Returns
        -------
        Rank of the restrained cell  

        Parameters
        ----------
        * `idim` :  
            Rank of the space dimension  
        * `ix` :  
            Rank of the cell to be restrained  

        """
        return _gstlearn.Grid_getMirrorIndex(self, idim, ix)

    def isInside(self, indices):
        r"""

        Grid::isInside
        """
        return _gstlearn.Grid_isInside(self, indices)

    def indiceToCoordinate(self, *args, **kwargs):
        r"""

        Grid::indiceToCoordinate
        """
        return _gstlearn.Grid_indiceToCoordinate(self, *args, **kwargs)

    def indiceToRank(self, indice):
        r"""

        Grid::indiceToRank
        """
        return _gstlearn.Grid_indiceToRank(self, indice)

    def rankToIndice(self, rank, indices, minusOne=False):
        r"""

        Grid::rankToIndice
        Parameters
        ----------
        * `rank` :  
            Rank of the Node (in the meshing)  
        * `indices` :  
            Indices of the node in the grid system  
        * `minusOne` :  
            Consider that the number of cells in each direction should be reduced by
            one.  

        remark: : The number of nodes in the grid per direction  

        remark: : must be adapted (subtracting 1) due to interval.  

        """
        return _gstlearn.Grid_rankToIndice(self, rank, indices, minusOne)

    def indicesToCoordinateInPlace(self, *args, **kwargs):
        r"""

        Grid::indicesToCoordinateInPlace
        """
        return _gstlearn.Grid_indicesToCoordinateInPlace(self, *args, **kwargs)

    def __repr__(self):
        return _gstlearn.Grid___repr__(self)

# Register Grid in _gstlearn:
_gstlearn.Grid_swigregister(Grid)
SPACES = _gstlearn.SPACES

def skipBOM(ins):
    r"""


    This file contains all the OLD-STYLE declarations causing warnings on Windows
    They should gradually be replaced by modern statements However, they are kept
    there to keep track on these statements  

    """
    return _gstlearn.skipBOM(ins)

def toUpper(string):
    r"""


    """
    return _gstlearn.toUpper(string)

def toLower(string):
    r"""


    """
    return _gstlearn.toLower(string)

def matchKeyword(string1, string2, caseSensitive=True):
    r"""


    Check if two keywords are similar, up to their case  

    Parameters
    ----------
    * `string1` :  
        First keyword  
    * `string2` :  
        Second keyword  
    * `caseSensitive` :  
        true if the case of both strings should be considered Otherwise, both
        strings are converted into upper case before comparison  

    Returns
    -------
    true if both keywords are identical; false otherwise  

    """
    return _gstlearn.matchKeyword(string1, string2, caseSensitive)

def matchRegexp(string1, string2, caseSensitive=True):
    r"""


    Check if two keywords match up to "Regular Expression" on the second string
    and their case  

    Parameters
    ----------
    * `string1` :  
        First keyword  
    * `string2` :  
        Second keyword (through Regular Expression interpretation)  
    * `caseSensitive` :  
        true if the case of both strings should be considered Otherwise, both
        strings are converted into upper case before comparison  

    Returns
    -------
    true if both keywords are identical; false otherwise  

    """
    return _gstlearn.matchRegexp(string1, string2, caseSensitive)

def getRankInList(list, match, caseSensitive=True):
    r"""


    Return the rank of the (first) item in 'list' which matches 'match'  

    Parameters
    ----------
    * `list` :  
        List of keywords used for search  
    * `match` :  
        Searched pattern  
    * `caseSensitive` :  
        Case Sensitive flag  

    Returns
    -------
    The index of the matching item or -1  

    """
    return _gstlearn.getRankInList(list, match, caseSensitive)

def decodeInString(symbol, node, facies, caseSensitive=True):
    r"""


    Decode the input string 'node' as a one-character keyword followed by an integer
    rank The keyword must match the symbol. The integer rank is returned as 'facies'  

    Parameters
    ----------
    * `symbol` :  
    * `node` :  
    * `facies` :  
    * `caseSensitive` :  

    Returns
    -------
    Error returned code  

    """
    return _gstlearn.decodeInString(symbol, node, facies, caseSensitive)

def decodeInList(symbols, node, rank, facies, caseSensitive=True):
    r"""


    Decode the input string 'node' as a one-character keyword followed by an integer
    rank The keyword must match one of the symbols: its rank is 'rank' The integer
    rank is returned as 'facies'  

    Parameters
    ----------
    * `symbols` :  
    * `node` :  
    * `rank` :  
    * `facies` :  
    * `caseSensitive` :  

    Returns
    -------
    Error returned code  

    """
    return _gstlearn.decodeInList(symbols, node, rank, facies, caseSensitive)

def correctNamesForDuplicates(list):
    r"""


    Check that the names in 'list' are not conflicting with any previous name. If it
    does, increment its name by a version number.  

    Parameters
    ----------
    * `list` :  

    """
    return _gstlearn.correctNamesForDuplicates(list)

def correctNewNameForDuplicates(list, rank):
    r"""


    """
    return _gstlearn.correctNewNameForDuplicates(list, rank)

def incrementStringVersion(*args, **kwargs):
    r"""


    """
    return _gstlearn.incrementStringVersion(*args, **kwargs)

def concatenateString(*args, **kwargs):
    r"""


    """
    return _gstlearn.concatenateString(*args, **kwargs)

def concatenateStrings(*args, **kwargs):
    r"""


    """
    return _gstlearn.concatenateStrings(*args, **kwargs)

def generateMultipleNames(*args, **kwargs):
    r"""


    """
    return _gstlearn.generateMultipleNames(*args, **kwargs)

def expandList(*args):
    r"""


    """
    return _gstlearn.expandList(*args)

def getMaxStringSize(list):
    r"""


    Returns the maximum string size of a list of strings  

    Parameters
    ----------
    * `list` :  
        List of strings  

    Returns
    -------
    The maximum number of characters  

    """
    return _gstlearn.getMaxStringSize(list)

def separateKeywords(code):
    r"""


    Separate keywords in the input string The keywords are identified when switching
    between alpha, digit and other  

    Parameters
    ----------
    * `code` :  
        String to be split  

    Returns
    -------  

    """
    return _gstlearn.separateKeywords(code)

def toInteger(v):
    r"""


    Decode an integer from a string. Returns ITEST if impossible  

    Parameters
    ----------
    * `v` :  
        String to be decoded  

    Returns
    -------
    The integer value or ITEST (in case of failure)  

    """
    return _gstlearn.toInteger(v)

def toDouble(*args):
    r"""


    """
    return _gstlearn.toDouble(*args)

def toString(*args):
    r"""


    """
    return _gstlearn.toString(*args)

def askInt(text, defval=-1234567, authTest=False):
    r"""


    Ask interactively for the value of one integer  

    Parameters
    ----------
    * `text` :  
        Text of the question  
    * `defval` :  
        Default value (or IFFFF)  
    * `authTest` :  
        True if TEST value is authorized (TEST)  

    """
    return _gstlearn.askInt(text, defval, authTest)

def askDouble(text, defval=1.234e30, authTest=False):
    r"""


    Ask interactively for the value of one Real (Double)  

    Parameters
    ----------
    * `text` :  
        Text of the question  
    * `defval` :  
        Default value (or IFFFF)  
    * `authTest` :  
        True if a TEST answer is authorized (TEST)  

    """
    return _gstlearn.askDouble(text, defval, authTest)

def askBool(text, defval=False):
    r"""


    Ask interactively for the value of one boolean  

    Parameters
    ----------
    * `text` :  
        Text of the question  
    * `defval` :  
        Default value  

    """
    return _gstlearn.askBool(text, defval)

def trimRight(*args, **kwargs):
    r"""


    """
    return _gstlearn.trimRight(*args, **kwargs)

def trimLeft(*args, **kwargs):
    r"""


    """
    return _gstlearn.trimLeft(*args, **kwargs)

def trim(*args, **kwargs):
    r"""


    """
    return _gstlearn.trim(*args, **kwargs)

def erase(*args, **kwargs):
    r"""


    """
    return _gstlearn.erase(*args, **kwargs)

def decodeGridSorting(string, nx, verbose=False):
    r"""


    Decode the grid sorting order  

    Returns
    -------
    Array describing the order  

    Parameters
    ----------
    * `string` :  
        Name of the sorting string  
    * `nx` :  
        Array giving the number of cells per direction  
    * `verbose` :  
        Verbose flag  

    remark: The value of order[i] gives the dimension of the space along  

    remark: which sorting takes place at rank "i". This value is positive  

    remark: for increasing order and negative for decreasing order.  

    remark: 'order' values start from 1 (for first space dimension)  

    remark: Example: "+x1-x3+x2"  

    """
    return _gstlearn.decodeGridSorting(string, nx, verbose)

def gslStrcpy(dst, src):
    r"""


    """
    return _gstlearn.gslStrcpy(dst, src)

def gslStrcat(dst, src):
    r"""


    """
    return _gstlearn.gslStrcat(dst, src)

def gslSPrintf(*args, **kwargs):
    r"""


    """
    return _gstlearn.gslSPrintf(*args, **kwargs)

def gslStrtok(str, delim):
    r"""


    """
    return _gstlearn.gslStrtok(str, delim)

def gslStrncpy(dest, src, n):
    r"""


    """
    return _gstlearn.gslStrncpy(dest, src, n)

def gslScanf(*args, **kwargs):
    r"""


    """
    return _gstlearn.gslScanf(*args, **kwargs)

def gslSScanf(*args, **kwargs):
    r"""


    """
    return _gstlearn.gslSScanf(*args, **kwargs)

def gslFScanf(*args, **kwargs):
    r"""


    """
    return _gstlearn.gslFScanf(*args, **kwargs)
class Interval(AStringable):
    r"""


    C++ includes: Interval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Interval::Interval
        """
        _gstlearn.Interval_swiginit(self, _gstlearn.new_Interval(*args))
    __swig_destroy__ = _gstlearn.delete_Interval

    def toString(self, strfmt=None):
        r"""

        Interval::toString
        Interface for AStringable.  

        """
        return _gstlearn.Interval_toString(self, strfmt)

    def init(self, vmin=1.234e30, vmax=1.234e30, mininc=True, maxinc=False):
        r"""

        Interval::init
        """
        return _gstlearn.Interval_init(self, vmin, vmax, mininc, maxinc)

    def isMinDefined(self):
        r"""

        Interval::isMinDefined
        """
        return _gstlearn.Interval_isMinDefined(self)

    def isMaxDefined(self):
        r"""

        Interval::isMaxDefined
        """
        return _gstlearn.Interval_isMaxDefined(self)

    def isInside(self, value):
        r"""

        Interval::isInside
        """
        return _gstlearn.Interval_isInside(self, value)

    def isOutsideBelow(self, value):
        r"""

        Interval::isOutsideBelow
        """
        return _gstlearn.Interval_isOutsideBelow(self, value)

    def isOutsideAbove(self, value):
        r"""

        Interval::isOutsideAbove
        """
        return _gstlearn.Interval_isOutsideAbove(self, value)

    def getVmax(self):
        r"""

        Interval::getVmax
        """
        return _gstlearn.Interval_getVmax(self)

    def setVmax(self, vmax):
        r"""

        Interval::setVmax
        """
        return _gstlearn.Interval_setVmax(self, vmax)

    def getVmin(self):
        r"""

        Interval::getVmin
        """
        return _gstlearn.Interval_getVmin(self)

    def setVmin(self, vmin):
        r"""

        Interval::setVmin
        """
        return _gstlearn.Interval_setVmin(self, vmin)

    def getMaxIncluded(self):
        r"""

        Interval::getMaxIncluded
        """
        return _gstlearn.Interval_getMaxIncluded(self)

    def setMaxIncluded(self, maxIncluded):
        r"""

        Interval::setMaxIncluded
        """
        return _gstlearn.Interval_setMaxIncluded(self, maxIncluded)

    def getMinIncluded(self):
        r"""

        Interval::getMinIncluded
        """
        return _gstlearn.Interval_getMinIncluded(self)

    def setMinIncluded(self, minIncluded):
        r"""

        Interval::setMinIncluded
        """
        return _gstlearn.Interval_setMinIncluded(self, minIncluded)

    def getBounds(self):
        r"""

        Interval::getBounds
        """
        return _gstlearn.Interval_getBounds(self)

    def isValid(self):
        r"""

        Interval::isValid
        """
        return _gstlearn.Interval_isValid(self)

    def isDisjoint(self, m):
        r"""

        Interval::isDisjoint
        """
        return _gstlearn.Interval_isDisjoint(self, m)

    def __repr__(self):
        return _gstlearn.Interval___repr__(self)

# Register Interval in _gstlearn:
_gstlearn.Interval_swigregister(Interval)
class Limits(AStringable):
    r"""


    C++ includes: Limits.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Limits::Limits
        """
        _gstlearn.Limits_swiginit(self, _gstlearn.new_Limits(*args))
    __swig_destroy__ = _gstlearn.delete_Limits

    def toString(self, strfmt=None):
        r"""

        Limits::toString
        """
        return _gstlearn.Limits_toString(self, strfmt)

    @staticmethod
    def create(*args):
        r"""

        Limits::create
        """
        return _gstlearn.Limits_create(*args)

    def getNLimit(self):
        r"""

        Limits::getNLimit
        """
        return _gstlearn.Limits_getNLimit(self)

    def getBounds(self):
        r"""

        Limits::getBounds
        """
        return _gstlearn.Limits_getBounds(self)

    def getBound(self, iclass, mode=0):
        r"""

        Limits::getBound
        Retrieve the set of bounds or one bound  

        Parameters
        ----------
        * `iclass` :  
            Rank of the class  
        * `mode` :  
            0 for both bounds; 1 for lower bound; 2 for upper bound  

        Returns
        -------
        The vector of bound values  

        """
        return _gstlearn.Limits_getBound(self, iclass, mode)

    def getLowerBounds(self):
        r"""

        Limits::getLowerBounds
        """
        return _gstlearn.Limits_getLowerBounds(self)

    def getUpperBounds(self):
        r"""

        Limits::getUpperBounds
        """
        return _gstlearn.Limits_getUpperBounds(self)

    def getLowerIncluded(self):
        r"""

        Limits::getLowerIncluded
        """
        return _gstlearn.Limits_getLowerIncluded(self)

    def getUpperIncluded(self):
        r"""

        Limits::getUpperIncluded
        """
        return _gstlearn.Limits_getUpperIncluded(self)

    def isInside(self, value):
        r"""

        Limits::isInside
        """
        return _gstlearn.Limits_isInside(self, value)

    def empty(self):
        r"""

        Limits::empty
        """
        return _gstlearn.Limits_empty(self)

    def toCategory(self, *args, **kwargs):
        r"""

        Limits::toCategory
        """
        return _gstlearn.Limits_toCategory(self, *args, **kwargs)

    def toIndicator(self, *args, **kwargs):
        r"""

        Limits::toIndicator
        Create indicators variables on the intervals defined by the limits for a given
        variable in a Db.  
         Note:  

        *   If OptionIndicator is 1, the Db-class will contain the new indicator
            variables. There are as many new variables as they are classes. Each sample
            of the indicator variable for class 'iclass' is set to 1 if the sample
            belongs to this class or 0 otherwise.  
        *   If OptionIndicator is 0, the Db-class will contain one variable such that
            each sample contains the average of the variable calculated over the samples
            whose value belong to this class.  

        Parameters
        ----------
        * `db` :  
            Db containing the variable to be discretized (from which the indicators are
            computed)  
        * `name` :  
            Name of the variable in the Db to be discretized.  
        * `OptionIndicator` :  
            When 1, the function assignes the indicator variables. When 0, the function
            assignes the average of the class.  
        * `flagBelow` :  
            When True, consider samples below lowest bound  
        * `flagAbove` :  
            When True, consider samples above highest bound  
        * `namconv` :  
            Naming convention  

        Returns
        -------  

        """
        return _gstlearn.Limits_toIndicator(self, *args, **kwargs)

    def statistics(self, db, name, optionStat=1, flagBelow=False, flagAbove=False):
        r"""

        Limits::statistics
        Calculate the statistics per Class  

        Parameters
        ----------
        * `db` :  
            Target Db  
        * `name` :  
            Name of the Target Variable  
        * `optionStat` :  
            1 for Mean; 2 for Proportions  
        * `flagBelow` :  
            When TRUE, add a class for samples below lowest bound  
        * `flagAbove` :  
            When TRUE, add a class for samples above highest bound  

        Returns
        -------  

        """
        return _gstlearn.Limits_statistics(self, db, name, optionStat, flagBelow, flagAbove)

    def toCategoryByAttribute(self, db, iatt, namconv):
        r"""

        Limits::toCategoryByAttribute
        """
        return _gstlearn.Limits_toCategoryByAttribute(self, db, iatt, namconv)

    def toIndicatorByAttribute(self, *args, **kwargs):
        r"""

        Limits::toIndicatorByAttribute
        """
        return _gstlearn.Limits_toIndicatorByAttribute(self, *args, **kwargs)

    def __repr__(self):
        return _gstlearn.Limits___repr__(self)

# Register Limits in _gstlearn:
_gstlearn.Limits_swigregister(Limits)
class StatResults(object):
    r"""


    C++ includes: Utilities.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number = property(_gstlearn.StatResults_number_get, _gstlearn.StatResults_number_set)
    nvalid = property(_gstlearn.StatResults_nvalid_get, _gstlearn.StatResults_nvalid_set)
    mini = property(_gstlearn.StatResults_mini_get, _gstlearn.StatResults_mini_set)
    maxi = property(_gstlearn.StatResults_maxi_get, _gstlearn.StatResults_maxi_set)
    delta = property(_gstlearn.StatResults_delta_get, _gstlearn.StatResults_delta_set)
    mean = property(_gstlearn.StatResults_mean_get, _gstlearn.StatResults_mean_set)
    stdv = property(_gstlearn.StatResults_stdv_get, _gstlearn.StatResults_stdv_set)

    def __init__(self):
        r"""


        C++ includes: Utilities.hpp

        """
        _gstlearn.StatResults_swiginit(self, _gstlearn.new_StatResults())
    __swig_destroy__ = _gstlearn.delete_StatResults

# Register StatResults in _gstlearn:
_gstlearn.StatResults_swigregister(StatResults)

def isInteger(value, eps=1.e-10):
    r"""


    """
    return _gstlearn.isInteger(value, eps)

def getClosestInteger(value):
    r"""


    """
    return _gstlearn.getClosestInteger(value)

def isMultiple(nbig, nsmall):
    r"""


    """
    return _gstlearn.isMultiple(nbig, nsmall)

def isOdd(number):
    r"""


    """
    return _gstlearn.isOdd(number)

def isEven(number):
    r"""


    """
    return _gstlearn.isEven(number)

def isZero(value, eps=1.e-10):
    r"""


    """
    return _gstlearn.isZero(value, eps)

def isOne(value, eps=1.e-10):
    r"""


    """
    return _gstlearn.isOne(value, eps)

def isEqual(v1, v2, eps=1.e-10):
    r"""


    """
    return _gstlearn.isEqual(v1, v2, eps)

def getMin(val1, val2):
    r"""


    """
    return _gstlearn.getMin(val1, val2)

def getMax(val1, val2):
    r"""


    """
    return _gstlearn.getMax(val1, val2)

def ut_deg2rad(angle):
    r"""


    Translates from degree to radian  

    Parameters
    ----------
    * `angle` :  
        Angle in degrees  

    """
    return _gstlearn.ut_deg2rad(angle)

def ut_rad2deg(angle):
    r"""


    Translates from radian to degree  

    Parameters
    ----------
    * `angle` :  
        Angle in radian  

    """
    return _gstlearn.ut_rad2deg(angle)

def isEqualExtended(*args, **kwargs):
    r"""


    Function checking that two values are equal This verbose method is essentially
    used in tests.  

    Parameters
    ----------
    * `v1` :  
        First value to be compared  
    * `v2` :  
        Second value to be compared  
    * `eps` :  
        Tolerance used for comparison  
    * `flagRelative` :  
        when True, the values are compared without paying attention to their sign  
    * `flagAbsolute` :  
        when True, test is run on absolute difference  
    * `string` :  
        Message to be displayed when the vectors are not similar  

    Returns
    -------
    Boolean  

    """
    return _gstlearn.isEqualExtended(*args, **kwargs)

def ut_sort_double(safe, nech, ind, value):
    r"""


    Sorts the (double) array value() and the array ind() in the ascending order of
    value  

    Parameters
    ----------
    * `safe` :  
        1 if the value array if preserved 0 if the value array is also sorted  
    * `nech` :  
        number of samples  
    * `ind` :  
        output int array  
    * `value` :  
        input and output array  

    remark: If ind = NULL, ind is ignored  

    """
    return _gstlearn.ut_sort_double(safe, nech, ind, value)

def ut_statistics(nech, tab, sel=None, wgt=None):
    r"""


    Returns the statistics of an array in a StatResults structure  

    Parameters
    ----------
    * `nech` :  
        Number of samples  
    * `tab` :  
        Array of values  
    * `sel` :  
        Array containing the Selection or NULL  
    * `wgt` :  
        Array containing the Weights or NULL  

    """
    return _gstlearn.ut_statistics(nech, tab, sel, wgt)

def ut_stats_mima_print(title, nech, tab, sel):
    r"""


    Print minimum and maximum of an array  

    Parameters
    ----------
    * `title` :  
        Title  
    * `nech` :  
        Number of samples  
    * `tab` :  
        Array of values  
    * `sel` :  
        Array containing the Selection or NULL  

    """
    return _gstlearn.ut_stats_mima_print(title, nech, tab, sel)

def ut_facies_statistics(nech, tab, sel, nval, mini, maxi):
    r"""


    Returns the statistics of an array containing the facies  

    Parameters
    ----------
    * `nech` :  
        Number of samples  
    * `tab` :  
        Array of values  
    * `sel` :  
        Array containing the Selection or NULL  
    * `nval` :  
        Number of active values  
    * `mini` :  
        Minimum value  
    * `maxi` :  
        Maximum value  

    """
    return _gstlearn.ut_facies_statistics(nech, tab, sel, nval, mini, maxi)

def ut_classify(nech, tab, sel, nclass, start, pas, nmask, ntest, nout, classe):
    r"""


    Classify the samples into integer sieves  

    Parameters
    ----------
    * `nech` :  
        Number of samples  
    * `tab` :  
        Array of values  
    * `sel` :  
        Array containing the Selection or NULL  
    * `nclass` :  
        Number of sieve classes  
    * `start` :  
        Starting sieve value  
    * `pas` :  
        Width of the sieve  
    * `nmask` :  
        Number of masked values  
    * `ntest` :  
        Number of undefined values  
    * `nout` :  
        Number of values outside the classes  
    * `classe` :  
        Array for number of samples per sieve  

    """
    return _gstlearn.ut_classify(nech, tab, sel, nclass, start, pas, nmask, ntest, nout, classe)

def ut_median(tab, ntab):
    r"""


    Calculate the median from a table of values  

    Returns
    -------
    The median value  

    Parameters
    ----------
    * `tab` :  
        Array of values  
    * `ntab` :  
        Number of samples  

    """
    return _gstlearn.ut_median(tab, ntab)

def ut_cnp(n, k):
    r"""


    Compute combinations(n,k)  

    Returns
    -------
    Return the number of combinations of 'k' objects amongst 'n'  

    Parameters
    ----------
    * `n` :  
        Total number of objects (>= 1)  
    * `k` :  
        Selected number of objects (>= 1)  

    """
    return _gstlearn.ut_cnp(n, k)

def ut_pascal(ndim):
    r"""


    Create the matrix containing the Pascal Triangle coefficients  

    Returns
    -------
    A matrix (Dimension: ndim * ndim) containing the coefficients  

    Returns
    -------
    or NULL if core allocation problem has been encountered  

    Parameters
    ----------
    * `ndim` :  
        Size of the matrix  

    remark: The calling function must free the returned matrix  

    """
    return _gstlearn.ut_pascal(ndim)

def ut_combinations(n, maxk, ncomb):
    r"""


    Return all the combinations of k within n  

    Returns
    -------
    Return all the combinations of 'k' objects amongst 'n'  

    Parameters
    ----------
    * `n` :  
        Total number of objects (>1)  
    * `maxk` :  
        Selected number of objects (1<=maxk<n)  
    * `ncomb` :  
        Number of combinations  

    remark: The calling function must free the returned array.  

    """
    return _gstlearn.ut_combinations(n, maxk, ncomb)

def ut_shuffle_array(nrow, ncol, tab):
    r"""


    Shuffle an array (by line)  

    Parameters
    ----------
    * `nrow` :  
        Number of rows  
    * `ncol` :  
        Number of columns  
    * `tab` :  
        Array to be suffled  

    """
    return _gstlearn.ut_shuffle_array(nrow, ncol, tab)

def getListActiveToAbsolute(sel):
    r"""


    Returns the list of absolute indices for the only active samples A sample is
    active if its 'sel' value is equal to 1  

    Parameters
    ----------
    * `sel` :  
        Vector giving the status of all samples (Dimension: absolute)  

    Returns
    -------  

    """
    return _gstlearn.getListActiveToAbsolute(sel)

def getMapAbsoluteToRelative(sel, verbose=False):
    r"""


    Returns the map such that MAP[iabs] = iact. A sample is active if its 'sel'
    value is equal to 1  

    Parameters
    ----------
    * `sel` :  
        Vector giving the status of all samples (Dimension: absolute)  
    * `verbose` :  
        Verbose flag  

    Returns
    -------
    The map (dimension: nrel)  

    """
    return _gstlearn.getMapAbsoluteToRelative(sel, verbose)

def getRankMapAbsoluteToRelative(map, iabs):
    r"""


    Returns the rank of the relative grid node from its absolute index using the Map  

    Parameters
    ----------
    * `map` :  
        The <int,int> map  
    * `iabs` :  
        Absolute rank of the grid node  

    Returns
    -------
    Rank of the corresponding active (relative) grid node (or -1 is not found)  

    """
    return _gstlearn.getRankMapAbsoluteToRelative(map, iabs)

def getRankMapRelativeToAbsolute(map, irel):
    r"""


    """
    return _gstlearn.getRankMapRelativeToAbsolute(map, irel)

def operate_Identify(oper):
    r"""


    Identify the pointer to a function with following functionality: y = f(x)  

    Parameters
    ----------
    * `oper` :  
        Gives the type of operation to be performed 1: returns the value itslef (no
        change) -1: returns its inverse 2: returns the squared value -2: returns the
        inverse of the squared value 3: returns its square root -3: returns the
        inverse of the square root  

    Returns
    -------
    Pointer to the specified function  

    """
    return _gstlearn.operate_Identify(oper)

def operate_Identity(x):
    r"""


    """
    return _gstlearn.operate_Identity(x)

def operate_Inverse(x):
    r"""


    """
    return _gstlearn.operate_Inverse(x)

def operate_Square(x):
    r"""


    """
    return _gstlearn.operate_Square(x)

def operate_InverseSquare(x):
    r"""


    """
    return _gstlearn.operate_InverseSquare(x)

def operate_Sqrt(x):
    r"""


    """
    return _gstlearn.operate_Sqrt(x)

def operate_InverseSqrt(x):
    r"""


    """
    return _gstlearn.operate_InverseSqrt(x)

def modifyOperator(oper, oldval, value):
    r"""


    Update an Old by a New value according to 'oper'  

    Parameters
    ----------
    * `oper` :  
        A keywork of EOperator enum  
    * `oldval` :  
        Old value  
    * `value` :  
        New value  

    """
    return _gstlearn.modifyOperator(oper, oldval, value)

def roundZero(value, eps=1.e-6):
    r"""


    Round off the value if close enough to zero. This ensures that the printout of a
    very small value does not come out with a non-significant negative sign This
    trick should only serve to make printouts similar on different platforms.  

    Parameters
    ----------
    * `value` :  
        Input value  
    * `eps` :  
        Tolerance to check that the value is considered as small  

    Returns
    -------
    The value itself or a very small positive value if the input value is too small.  

    """
    return _gstlearn.roundZero(value, eps)

def truncateDecimals(value, ndec=0):
    r"""


    Rounding a double to a given number of decimals (from:
    https://stackoverflow.com/questions/304011/truncate-a-decimal-value-
    in-c/304013#304013)  

    Parameters
    ----------
    * `value` :  
        Value to be rounded up  
    * `ndec` :  
        Number of significant decimals  

    """
    return _gstlearn.truncateDecimals(value, ndec)

def truncateDigits(value, ndigits):
    r"""


    Rounding a double to a given number of decimals  

    Parameters
    ----------
    * `value` :  
        Value to be rounded up  
    * `ndigits` :  
        Number of significant digits  

    """
    return _gstlearn.truncateDigits(value, ndigits)

def setInternalDebug(status):
    r"""


    """
    return _gstlearn.setInternalDebug(status)

def isInternalDebug():
    r"""


    """
    return _gstlearn.isInternalDebug()

def print_range(title, ntab, tab, sel):
    r"""


    Print the range of values in an array  

    Parameters
    ----------
    * `title` :  
        optional title (NULL if not defined)  
    * `ntab` :  
        number of values  
    * `tab` :  
        array of values  
    * `sel` :  
        (optional) selection  

    """
    return _gstlearn.print_range(title, ntab, tab, sel)

def convertIndptrToIndices(ncumul, cumul, tab):
    r"""


    TODO: transfer this in swig_inc.i.  

    """
    return _gstlearn.convertIndptrToIndices(ncumul, cumul, tab)
class CSVformat(AStringable):
    r"""


    C++ includes: CSVformat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CSVformat::CSVformat
        """
        _gstlearn.CSVformat_swiginit(self, _gstlearn.new_CSVformat(*args))
    __swig_destroy__ = _gstlearn.delete_CSVformat

    def toString(self, strfmt=None):
        r"""

        CSVformat::toString
        Interface to AStringable.  

        """
        return _gstlearn.CSVformat_toString(self, strfmt)

    def getCharDec(self):
        r"""

        CSVformat::getCharDec
        """
        return _gstlearn.CSVformat_getCharDec(self)

    def getCharSep(self):
        r"""

        CSVformat::getCharSep
        """
        return _gstlearn.CSVformat_getCharSep(self)

    def getFlagHeader(self):
        r"""

        CSVformat::getFlagHeader
        """
        return _gstlearn.CSVformat_getFlagHeader(self)

    def getNaString(self):
        r"""

        CSVformat::getNaString
        """
        return _gstlearn.CSVformat_getNaString(self)

    def getNSkip(self):
        r"""

        CSVformat::getNSkip
        """
        return _gstlearn.CSVformat_getNSkip(self)

    def setFlagHeader(self, flagHeader):
        r"""

        CSVformat::setFlagHeader
        """
        return _gstlearn.CSVformat_setFlagHeader(self, flagHeader)

    def setCharDec(self, charDec):
        r"""

        CSVformat::setCharDec
        """
        return _gstlearn.CSVformat_setCharDec(self, charDec)

    def setCharSep(self, charSep):
        r"""

        CSVformat::setCharSep
        """
        return _gstlearn.CSVformat_setCharSep(self, charSep)

    def setNaString(self, naString):
        r"""

        CSVformat::setNaString
        """
        return _gstlearn.CSVformat_setNaString(self, naString)

    def setNSkip(self, nskip):
        r"""

        CSVformat::setNSkip
        """
        return _gstlearn.CSVformat_setNSkip(self, nskip)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        CSVformat::create
        """
        return _gstlearn.CSVformat_create(*args, **kwargs)

    def __repr__(self):
        return _gstlearn.CSVformat___repr__(self)

# Register CSVformat in _gstlearn:
_gstlearn.CSVformat_swigregister(CSVformat)
class AFunction(object):
    r"""


    C++ includes: AFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        AFunction::AFunction
        """
        if self.__class__ == AFunction:
            _self = None
        else:
            _self = self
        _gstlearn.AFunction_swiginit(self, _gstlearn.new_AFunction(_self, ))
    __swig_destroy__ = _gstlearn.delete_AFunction

    def eval(self, x):
        r"""

        AFunction::eval
        """
        return _gstlearn.AFunction_eval(self, x)
    def __disown__(self):
        self.this.disown()
        _gstlearn.disown_AFunction(self)
        return weakref.proxy(self)

# Register AFunction in _gstlearn:
_gstlearn.AFunction_swigregister(AFunction)
class AFunctional(object):
    r"""


    C++ includes: AFunctional.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        AFunctional::AFunctional
        """
        if self.__class__ == AFunctional:
            _self = None
        else:
            _self = self
        _gstlearn.AFunctional_swiginit(self, _gstlearn.new_AFunctional(_self, *args))
    __swig_destroy__ = _gstlearn.delete_AFunctional

    def getFunctionValue(self, pos):
        r"""

        AFunctional::getFunctionValue
        """
        return _gstlearn.AFunctional_getFunctionValue(self, pos)

    def getNdim(self):
        r"""

        AFunctional::getNdim
        """
        return _gstlearn.AFunctional_getNdim(self)

    def setNdim(self, ndim):
        r"""

        AFunctional::setNdim
        """
        return _gstlearn.AFunctional_setNdim(self, ndim)

    def getFunctionValues(self, db, useSel=True):
        r"""

        AFunctional::getFunctionValues
        """
        return _gstlearn.AFunctional_getFunctionValues(self, db, useSel)
    def __disown__(self):
        self.this.disown()
        _gstlearn.disown_AFunctional(self)
        return weakref.proxy(self)

# Register AFunctional in _gstlearn:
_gstlearn.AFunctional_swigregister(AFunctional)
class FunctionalSpirale(AFunctional):
    r"""


    C++ includes: FunctionalSpirale.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        FunctionalSpirale::FunctionalSpirale
        """
        _gstlearn.FunctionalSpirale_swiginit(self, _gstlearn.new_FunctionalSpirale(*args))
    __swig_destroy__ = _gstlearn.delete_FunctionalSpirale

    def getFunctionValue(self, coor):
        r"""

        FunctionalSpirale::getFunctionValue
        Return the angle (in degrees) of the spiral at a given coordinate  

        Parameters
        ----------
        * `coor` :  
            2-D coordinates of the target  

        Returns
        -------  

        """
        return _gstlearn.FunctionalSpirale_getFunctionValue(self, coor)

    def getFunctionMatrix(self, coor):
        r"""

        FunctionalSpirale::getFunctionMatrix
        Return the anisotropy rotation matrix at a given coordinate  

        Parameters
        ----------
        * `coor` :  
            2-D coordinates of the target  

        Returns
        -------  

        """
        return _gstlearn.FunctionalSpirale_getFunctionMatrix(self, coor)

    def getFunctionVectors(self, db, cova):
        r"""

        FunctionalSpirale::getFunctionVectors
        """
        return _gstlearn.FunctionalSpirale_getFunctionVectors(self, db, cova)

# Register FunctionalSpirale in _gstlearn:
_gstlearn.FunctionalSpirale_swigregister(FunctionalSpirale)
class OptDbg(object):
    r"""


    Operate the list of active Debug options These options correspond to various
    keywords chosen from a close list (see EDbg.hpp). When one of these options is
    switched ON, some statements are printed each time this particular option is
    concerned  

    As example, to produce specific output during all Kriging steps, you should use;  

        OptCst::define(EDbg::KRIGING)  

    To cancel this option, it suffices to use:  

        OptCst::undefine(EDbg::KRIGING)  

    To know the current status of all these environmental parameters, use the
    display() function.  

    A complementary option is to use the Reference: this is an index such that, when
    the rank of the target matches this number, all the flags are turned ON
    automatically. This Reference index is provided as a 1-based number.  

    C++ includes: OptDbg.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def reset():
        r"""

        OptDbg::reset
        """
        return _gstlearn.OptDbg_reset()

    @staticmethod
    def queryByKey(name):
        r"""

        OptDbg::queryByKey
        """
        return _gstlearn.OptDbg_queryByKey(name)

    @staticmethod
    def defineByKey(name):
        r"""

        OptDbg::defineByKey
        Switching ON a option  

        Parameters
        ----------
        * `name` :  
            Description of the option (Name)  

        """
        return _gstlearn.OptDbg_defineByKey(name)

    @staticmethod
    def undefineByKey(name):
        r"""

        OptDbg::undefineByKey
        Switching OFF a option  

        Parameters
        ----------
        * `name` :  
            Description of the option (Name)  

        """
        return _gstlearn.OptDbg_undefineByKey(name)

    @staticmethod
    def query(option, discardForce=False):
        r"""

        OptDbg::query
        Check if a DEBUG option has been switched ON or NOT  

        Parameters
        ----------
        * `option` :  
            Type of the option to be searched for  
        * `discardForce` :  
            When TRUE, does not consider the "forcing" option (see remarks)  

        remark: The use of gstlearn enables the user to FORCE the switch ON of one or
            several debugging options. This is the case for example when you want to
            trace the processing of a specific target (defined using setReference). When
            this option is switched OFF, this specific case is not taken into account  

        Returns
        -------
        TRUE if the option is switch ON, FALSE otherwise  

        """
        return _gstlearn.OptDbg_query(option, discardForce)

    @staticmethod
    def define(option):
        r"""

        OptDbg::define
        Switching ON a option  

        Parameters
        ----------
        * `option` :  
            Description of the option (Keyword)  

        """
        return _gstlearn.OptDbg_define(option)

    @staticmethod
    def undefine(option):
        r"""

        OptDbg::undefine
        Switching OFF an option  

        Parameters
        ----------
        * `option` :  
            Description of the Option (Keyword)  

        """
        return _gstlearn.OptDbg_undefine(option)

    @staticmethod
    def defineAll():
        r"""

        OptDbg::defineAll
        """
        return _gstlearn.OptDbg_defineAll()

    @staticmethod
    def undefineAll():
        r"""

        OptDbg::undefineAll
        """
        return _gstlearn.OptDbg_undefineAll()

    @staticmethod
    def display():
        r"""

        OptDbg::display
        """
        return _gstlearn.OptDbg_display()

    @staticmethod
    def setCurrentIndex(cur_index):
        r"""

        OptDbg::setCurrentIndex
        """
        return _gstlearn.OptDbg_setCurrentIndex(cur_index)

    @staticmethod
    def isReferenceDefined():
        r"""

        OptDbg::isReferenceDefined
        """
        return _gstlearn.OptDbg_isReferenceDefined()

    @staticmethod
    def setReference(index):
        r"""

        OptDbg::setReference
        """
        return _gstlearn.OptDbg_setReference(index)

    @staticmethod
    def getReference():
        r"""

        OptDbg::getReference
        """
        return _gstlearn.OptDbg_getReference()

    @staticmethod
    def force():
        r"""

        OptDbg::force
        """
        return _gstlearn.OptDbg_force()

    @staticmethod
    def getCurrentIndex():
        r"""

        OptDbg::getCurrentIndex
        """
        return _gstlearn.OptDbg_getCurrentIndex()

    def __init__(self):
        r"""


        Operate the list of active Debug options These options correspond to various
        keywords chosen from a close list (see EDbg.hpp). When one of these options is
        switched ON, some statements are printed each time this particular option is
        concerned  

        As example, to produce specific output during all Kriging steps, you should use;  

            OptCst::define(EDbg::KRIGING)  

        To cancel this option, it suffices to use:  

            OptCst::undefine(EDbg::KRIGING)  

        To know the current status of all these environmental parameters, use the
        display() function.  

        A complementary option is to use the Reference: this is an index such that, when
        the rank of the target matches this number, all the flags are turned ON
        automatically. This Reference index is provided as a 1-based number.  

        C++ includes: OptDbg.hpp

        """
        _gstlearn.OptDbg_swiginit(self, _gstlearn.new_OptDbg())
    __swig_destroy__ = _gstlearn.delete_OptDbg

# Register OptDbg in _gstlearn:
_gstlearn.OptDbg_swigregister(OptDbg)
class OptCst(object):
    r"""


    Operate the list of Constant options. These options correspond to various
    keywords chosen from a close list (see ECst.hpp).  

    One option should be used according to the following example:  

        OptCst::define(ECst::NTCAR, 20)  

    to set that the printing format for a variable should now be on 20 characters
    (max).  

    To know the current status of all these environmental parameters, use the
    display() function.  

    C++ includes: OptCst.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def query(option):
        r"""

        OptCst::query
        """
        return _gstlearn.OptCst_query(option)

    @staticmethod
    def queryByKey(name):
        r"""

        OptCst::queryByKey
        """
        return _gstlearn.OptCst_queryByKey(name)

    @staticmethod
    def define(option, value):
        r"""

        OptCst::define
        """
        return _gstlearn.OptCst_define(option, value)

    @staticmethod
    def defineByKey(name, value):
        r"""

        OptCst::defineByKey
        """
        return _gstlearn.OptCst_defineByKey(name, value)

    @staticmethod
    def display():
        r"""

        OptCst::display
        """
        return _gstlearn.OptCst_display()

    def __init__(self):
        r"""


        Operate the list of Constant options. These options correspond to various
        keywords chosen from a close list (see ECst.hpp).  

        One option should be used according to the following example:  

            OptCst::define(ECst::NTCAR, 20)  

        to set that the printing format for a variable should now be on 20 characters
        (max).  

        To know the current status of all these environmental parameters, use the
        display() function.  

        C++ includes: OptCst.hpp

        """
        _gstlearn.OptCst_swiginit(self, _gstlearn.new_OptCst())
    __swig_destroy__ = _gstlearn.delete_OptCst

# Register OptCst in _gstlearn:
_gstlearn.OptCst_swigregister(OptCst)
class OptCustom(object):
    r"""


    Operate the list of Constant options (defined by the user within an open list)  

    C++ includes: OptCustom.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def query(name, valdef=0.):
        r"""

        OptCustom::query
        """
        return _gstlearn.OptCustom_query(name, valdef)

    @staticmethod
    def define(name, value):
        r"""

        OptCustom::define
        """
        return _gstlearn.OptCustom_define(name, value)

    @staticmethod
    def undefine(name):
        r"""

        OptCustom::undefine
        """
        return _gstlearn.OptCustom_undefine(name)

    @staticmethod
    def display():
        r"""

        OptCustom::display
        """
        return _gstlearn.OptCustom_display()

    def __init__(self):
        r"""


        Operate the list of Constant options (defined by the user within an open list)  

        C++ includes: OptCustom.hpp

        """
        _gstlearn.OptCustom_swiginit(self, _gstlearn.new_OptCustom())
    __swig_destroy__ = _gstlearn.delete_OptCustom

# Register OptCustom in _gstlearn:
_gstlearn.OptCustom_swigregister(OptCustom)
class StdoutRedirect(object):
    r"""


    Redirection facility This function is used to redirect the output of the script
    to an auxiliary file This facility is used within the non-regression tests
    calling: std::stringstream sfn; sfn << gslBaseName(**FILE**) << ".out";
    StdoutRedirect sr(sfn.str(), argc, argv); The redirection can be cancelled (with
    no argument modification) if the number of arguments 'argc' is larger than a
    given threshold By default, this threshold is set to 1 (name of executable
    itself) This can even be modified by adding 'number' different from 1 if some
    arguments are compulsory.  

    C++ includes: File.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""

        StdoutRedirect::StdoutRedirect
        """
        _gstlearn.StdoutRedirect_swiginit(self, _gstlearn.new_StdoutRedirect(*args, **kwargs))
    __swig_destroy__ = _gstlearn.delete_StdoutRedirect

    def start(self, file):
        r"""

        StdoutRedirect::start
        Save current stdout handle and redirect std::cout to a file  

        Parameters
        ----------
        * `file` :  
            File path to be written  

        """
        return _gstlearn.StdoutRedirect_start(self, file)

    def stop(self):
        r"""

        StdoutRedirect::stop
        Restore original stdout  

        """
        return _gstlearn.StdoutRedirect_stop(self)

# Register StdoutRedirect in _gstlearn:
_gstlearn.StdoutRedirect_swigregister(StdoutRedirect)

def gslFopen(*args):
    r"""


    """
    return _gstlearn.gslFopen(*args)

def gslFileExist(*args):
    r"""


    """
    return _gstlearn.gslFileExist(*args)

def gslBaseName(path, keepExtension=False):
    r"""


    """
    return _gstlearn.gslBaseName(path, keepExtension)

def gslGetEnv(name):
    r"""


    """
    return _gstlearn.gslGetEnv(name)

def gslSafeGetline(_is, t):
    r"""


    Get line from an input text stream whatever the end of line convention. Thanks
    to: https://stackoverflow.com/a/6089413  

    """
    return _gstlearn.gslSafeGetline(_is, t)
class VectorHelper(object):
    r"""


    C++ includes: VectorHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def initVVInt(nval1, nval2, value=0):
        r"""

        VectorHelper::initVVInt
        """
        return _gstlearn.VectorHelper_initVVInt(nval1, nval2, value)

    @staticmethod
    def initVInt(*args):
        r"""

        VectorHelper::initVInt
        """
        return _gstlearn.VectorHelper_initVInt(*args)

    @staticmethod
    def initVDouble(*args):
        r"""

        VectorHelper::initVDouble
        """
        return _gstlearn.VectorHelper_initVDouble(*args)

    @staticmethod
    def initVVDouble(*args):
        r"""

        VectorHelper::initVVDouble
        """
        return _gstlearn.VectorHelper_initVVDouble(*args)

    @staticmethod
    def initVString(ntab, names):
        r"""

        VectorHelper::initVString
        """
        return _gstlearn.VectorHelper_initVString(ntab, names)

    @staticmethod
    def dump(*args):
        r"""

        VectorHelper::dump
        """
        return _gstlearn.VectorHelper_dump(*args)

    @staticmethod
    def toStringAsSpan(vec):
        r"""

        VectorHelper::toStringAsSpan
        """
        return _gstlearn.VectorHelper_toStringAsSpan(vec)

    @staticmethod
    def toStringAsVD(vec):
        r"""

        VectorHelper::toStringAsVD
        """
        return _gstlearn.VectorHelper_toStringAsVD(vec)

    @staticmethod
    def toStringAsVVD(vec):
        r"""

        VectorHelper::toStringAsVVD
        """
        return _gstlearn.VectorHelper_toStringAsVVD(vec)

    @staticmethod
    def toStringAsVVI(vec):
        r"""

        VectorHelper::toStringAsVVI
        """
        return _gstlearn.VectorHelper_toStringAsVVI(vec)

    @staticmethod
    def toStringAsVS(vec):
        r"""

        VectorHelper::toStringAsVS
        """
        return _gstlearn.VectorHelper_toStringAsVS(vec)

    @staticmethod
    def toStringAsVI(vec):
        r"""

        VectorHelper::toStringAsVI
        """
        return _gstlearn.VectorHelper_toStringAsVI(vec)

    @staticmethod
    def dumpStats(title, vectin, nmax=-1):
        r"""

        VectorHelper::dumpStats
        """
        return _gstlearn.VectorHelper_dumpStats(title, vectin, nmax)

    @staticmethod
    def dumpRange(*args):
        r"""

        VectorHelper::dumpRange
        """
        return _gstlearn.VectorHelper_dumpRange(*args)

    @staticmethod
    def dumpNNZ(title, vect, nclass=10):
        r"""

        VectorHelper::dumpNNZ
        """
        return _gstlearn.VectorHelper_dumpNNZ(title, vect, nclass)

    @staticmethod
    def maximum(*args):
        r"""

        VectorHelper::maximum
        """
        return _gstlearn.VectorHelper_maximum(*args)

    @staticmethod
    def minimum(*args):
        r"""

        VectorHelper::minimum
        """
        return _gstlearn.VectorHelper_minimum(*args)

    @staticmethod
    def product(*args):
        r"""

        VectorHelper::product
        """
        return _gstlearn.VectorHelper_product(*args)

    @staticmethod
    def countUndefined(vec):
        r"""

        VectorHelper::countUndefined
        """
        return _gstlearn.VectorHelper_countUndefined(vec)

    @staticmethod
    def countDefined(vec):
        r"""

        VectorHelper::countDefined
        """
        return _gstlearn.VectorHelper_countDefined(vec)

    @staticmethod
    def hasUndefined(vec):
        r"""

        VectorHelper::hasUndefined
        """
        return _gstlearn.VectorHelper_hasUndefined(vec)

    @staticmethod
    def extensionDiagonal(mini, maxi):
        r"""

        VectorHelper::extensionDiagonal
        Calculate the diagonal of the box extension  

        Parameters
        ----------
        * `mini` :  
            Array of lower coordinates of the box  
        * `maxi` :  
            Array of upper coordinates of the box  

        Returns
        -------  

        remark: If one coordinate is undefined, TEST is returned.  

        """
        return _gstlearn.VectorHelper_extensionDiagonal(mini, maxi)

    @staticmethod
    def count(vec):
        r"""

        VectorHelper::count
        """
        return _gstlearn.VectorHelper_count(vec)

    @staticmethod
    def cumul(*args):
        r"""

        VectorHelper::cumul
        """
        return _gstlearn.VectorHelper_cumul(*args)

    @staticmethod
    def cumulLog(vec):
        r"""

        VectorHelper::cumulLog
        """
        return _gstlearn.VectorHelper_cumulLog(vec)

    @staticmethod
    def cumulIncrement(vec):
        r"""

        VectorHelper::cumulIncrement
        """
        return _gstlearn.VectorHelper_cumulIncrement(vec)

    @staticmethod
    def mean(vec):
        r"""

        VectorHelper::mean
        """
        return _gstlearn.VectorHelper_mean(vec)

    @staticmethod
    def variance(vec, scaleByN=False):
        r"""

        VectorHelper::variance
        """
        return _gstlearn.VectorHelper_variance(vec, scaleByN)

    @staticmethod
    def stdv(vec, scaleByN=False):
        r"""

        VectorHelper::stdv
        """
        return _gstlearn.VectorHelper_stdv(vec, scaleByN)

    @staticmethod
    def normL1(vec):
        r"""

        VectorHelper::normL1
        """
        return _gstlearn.VectorHelper_normL1(vec)

    @staticmethod
    def norminf(vec):
        r"""

        VectorHelper::norminf
        """
        return _gstlearn.VectorHelper_norminf(vec)

    @staticmethod
    def median(vec):
        r"""

        VectorHelper::median
        """
        return _gstlearn.VectorHelper_median(vec)

    @staticmethod
    def normDistance(veca, vecb):
        r"""

        VectorHelper::normDistance
        """
        return _gstlearn.VectorHelper_normDistance(veca, vecb)

    @staticmethod
    def correlation(veca, vecb):
        r"""

        VectorHelper::correlation
        """
        return _gstlearn.VectorHelper_correlation(veca, vecb)

    @staticmethod
    def quantiles(vec, probas):
        r"""

        VectorHelper::quantiles
        Calculate the quantiles  

        Parameters
        ----------
        * `vec` :  
            Array of values  
        * `probas` :  
            Array of probabilities (sorted by ascending order)  

        Returns
        -------
        Vector of data values for the different probabilities  

        """
        return _gstlearn.VectorHelper_quantiles(vec, probas)

    @staticmethod
    def isConstant(*args):
        r"""

        VectorHelper::isConstant
        Check if the contents of a vector is constant (equal to 'refval' is defined)  

        Parameters
        ----------
        * `vect` :  
            Input vector  
        * `refval` :  
            Reference value (ITEST if not defined)  

        Returns
        -------  

        """
        return _gstlearn.VectorHelper_isConstant(*args)

    @staticmethod
    def isEqual(*args):
        r"""

        VectorHelper::isEqual
        """
        return _gstlearn.VectorHelper_isEqual(*args)

    @staticmethod
    def isEqualExtended(*args, **kwargs):
        r"""

        VectorHelper::isEqualExtended
        Function checking that two values are equal This verbose option is essentially
        used in tests.  

        Parameters
        ----------
        * `v1` :  
            First value to be compared  
        * `v2` :  
            Second value to be compared  
        * `eps` :  
            Tolerance used for comparison  
        * `flagRelative` :  
            when True, the values are compared without paying attention to their sign  
        * `flagAbsolute` :  
            when True, test is run on absolute difference  
        * `string` :  
            Message to be displayed when the vectors are not similar  

        Returns
        -------
        Boolean  

        note: : When the two vectors do not share the same dimension, the test is not
            performed and a message is printed.  

        """
        return _gstlearn.VectorHelper_isEqualExtended(*args, **kwargs)

    @staticmethod
    def sequenceInPlace(n, vec):
        r"""

        VectorHelper::sequenceInPlace
        """
        return _gstlearn.VectorHelper_sequenceInPlace(n, vec)

    @staticmethod
    def sequence(*args):
        r"""

        VectorHelper::sequence
        Create an output vector going from 'valFrom' to 'ValTo' by step of 'valStep'
        Create a vector containing the a sequence of numbers  

        Parameters
        ----------
        * `valFrom` :  
            Starting value  
        * `valTo` :  
            Ending value  
        * `valStep` :  
            Step  
        * `ratio` :  
            The whole sequence can be ultimately scaled by 'ratio'  

        Returns
        -------  

        """
        return _gstlearn.VectorHelper_sequence(*args)

    @staticmethod
    def fill(*args):
        r"""

        VectorHelper::fill
        """
        return _gstlearn.VectorHelper_fill(*args)

    @staticmethod
    def fillUndef(vec, repl):
        r"""

        VectorHelper::fillUndef
        """
        return _gstlearn.VectorHelper_fillUndef(vec, repl)

    @staticmethod
    def add(veca, vecb):
        r"""

        VectorHelper::add
        """
        return _gstlearn.VectorHelper_add(veca, vecb)

    @staticmethod
    def addInPlace(*args):
        r"""

        VectorHelper::addInPlace
        """
        return _gstlearn.VectorHelper_addInPlace(*args)

    @staticmethod
    def addSquareInPlace(dest, src):
        r"""

        VectorHelper::addSquareInPlace
        Performs: veca += vecb**2  

        Parameters
        ----------
        * `dest` :  
            Input/Output vector  
        * `src` :  
            Auxiliary vector  

        """
        return _gstlearn.VectorHelper_addSquareInPlace(dest, src)

    @staticmethod
    def subtract(*args):
        r"""

        VectorHelper::subtract
        Return a vector containing vecb - veca (integer version)  

        Parameters
        ----------
        * `veca` :  
            Input Vector  
        * `vecb` :  
            Input Vector  

        Returns
        -------  

        """
        return _gstlearn.VectorHelper_subtract(*args)

    @staticmethod
    def subtractInPlace(*args):
        r"""

        VectorHelper::subtractInPlace
        """
        return _gstlearn.VectorHelper_subtractInPlace(*args)

    @staticmethod
    def multiply(veca, vecb):
        r"""

        VectorHelper::multiply
        """
        return _gstlearn.VectorHelper_multiply(veca, vecb)

    @staticmethod
    def multiplyInPlace(*args):
        r"""

        VectorHelper::multiplyInPlace
        """
        return _gstlearn.VectorHelper_multiplyInPlace(*args)

    @staticmethod
    def divide(veca, vecb):
        r"""

        VectorHelper::divide
        """
        return _gstlearn.VectorHelper_divide(veca, vecb)

    @staticmethod
    def divideInPlace(*args):
        r"""

        VectorHelper::divideInPlace
        """
        return _gstlearn.VectorHelper_divideInPlace(*args)

    @staticmethod
    def multiplyComplexInPlace(vecaRe, vecaIm, vecbRe, vecbIm, resRe, resIm):
        r"""

        VectorHelper::multiplyComplexInPlace
        """
        return _gstlearn.VectorHelper_multiplyComplexInPlace(vecaRe, vecaIm, vecbRe, vecbIm, resRe, resIm)

    @staticmethod
    def multiplyConstant(vec, v):
        r"""

        VectorHelper::multiplyConstant
        """
        return _gstlearn.VectorHelper_multiplyConstant(vec, v)

    @staticmethod
    def multiplyConstantInPlace(vec, v, vecout):
        r"""

        VectorHelper::multiplyConstantInPlace
        """
        return _gstlearn.VectorHelper_multiplyConstantInPlace(vec, v, vecout)

    @staticmethod
    def multiplyConstantSelfInPlace(vec, v):
        r"""

        VectorHelper::multiplyConstantSelfInPlace
        """
        return _gstlearn.VectorHelper_multiplyConstantSelfInPlace(vec, v)

    @staticmethod
    def addMultiplyConstantInPlace(*args):
        r"""

        VectorHelper::addMultiplyConstantInPlace
        """
        return _gstlearn.VectorHelper_addMultiplyConstantInPlace(*args)

    @staticmethod
    def divideConstant(vec, v):
        r"""

        VectorHelper::divideConstant
        """
        return _gstlearn.VectorHelper_divideConstant(vec, v)

    @staticmethod
    def copy(*args):
        r"""

        VectorHelper::copy
        """
        return _gstlearn.VectorHelper_copy(*args)

    @staticmethod
    def addConstant(*args):
        r"""

        VectorHelper::addConstant
        """
        return _gstlearn.VectorHelper_addConstant(*args)

    @staticmethod
    def mean1AndMean2ToStdev(mean1, mean2, std, number):
        r"""

        VectorHelper::mean1AndMean2ToStdev
        """
        return _gstlearn.VectorHelper_mean1AndMean2ToStdev(mean1, mean2, std, number)

    @staticmethod
    def normalize(*args):
        r"""

        VectorHelper::normalize
        """
        return _gstlearn.VectorHelper_normalize(*args)

    @staticmethod
    def normalizeFromGaussianDistribution(vec, mini=0., maxi=1.):
        r"""

        VectorHelper::normalizeFromGaussianDistribution
        """
        return _gstlearn.VectorHelper_normalizeFromGaussianDistribution(vec, mini, maxi)

    @staticmethod
    def normalScore(*args, **kwargs):
        r"""

        VectorHelper::normalScore
        """
        return _gstlearn.VectorHelper_normalScore(*args, **kwargs)

    @staticmethod
    def qnormVec(vec):
        r"""

        VectorHelper::qnormVec
        """
        return _gstlearn.VectorHelper_qnormVec(vec)

    @staticmethod
    def pnormVec(vec):
        r"""

        VectorHelper::pnormVec
        """
        return _gstlearn.VectorHelper_pnormVec(vec)

    @staticmethod
    def concatenate(veca, vecb):
        r"""

        VectorHelper::concatenate
        """
        return _gstlearn.VectorHelper_concatenate(veca, vecb)

    @staticmethod
    def concatenateInPlace(veca, vecb):
        r"""

        VectorHelper::concatenateInPlace
        """
        return _gstlearn.VectorHelper_concatenateInPlace(veca, vecb)

    @staticmethod
    def power(vec, power):
        r"""

        VectorHelper::power
        """
        return _gstlearn.VectorHelper_power(vec, power)

    @staticmethod
    def inverse(vec):
        r"""

        VectorHelper::inverse
        """
        return _gstlearn.VectorHelper_inverse(vec)

    @staticmethod
    def crossProduct3D(veca, vecb):
        r"""

        VectorHelper::crossProduct3D
        Cross product (limited to 3D)  

        Parameters
        ----------
        * `veca` :  
            First vector  
        * `vecb` :  
            Second Vector  

        Returns
        -------  

        """
        return _gstlearn.VectorHelper_crossProduct3D(veca, vecb)

    @staticmethod
    def crossProduct3DInPlace(a, b, v):
        r"""

        VectorHelper::crossProduct3DInPlace
        """
        return _gstlearn.VectorHelper_crossProduct3DInPlace(a, b, v)

    @staticmethod
    def cumsum(vecin, flagAddZero, revert=False):
        r"""

        VectorHelper::cumsum
        """
        return _gstlearn.VectorHelper_cumsum(vecin, flagAddZero, revert)

    @staticmethod
    def cumulateInPlace(vec):
        r"""

        VectorHelper::cumulateInPlace
        """
        return _gstlearn.VectorHelper_cumulateInPlace(vec)

    @staticmethod
    def cumulate(veca, vecb, coeff=1., addval=0.):
        r"""

        VectorHelper::cumulate
        """
        return _gstlearn.VectorHelper_cumulate(veca, vecb, coeff, addval)

    @staticmethod
    def getMostSignificant(vec, tol=1.e-6, nmax=-1):
        r"""

        VectorHelper::getMostSignificant
        Display the first significant values of the input vector. A "significant"
        value is a value larger than 'tol' in absolute value Values are listed by
        decreasing importance.  

        Parameters
        ----------
        * `vec` :  
            Input Vector  
        * `tol` :  
            Tolerance above which a value is significant (in absolute value)  
        * `nmax` :  
            Limit on the number of values printed (-1: no limit)  

        """
        return _gstlearn.VectorHelper_getMostSignificant(vec, tol, nmax)

    @staticmethod
    def simulateUniform(n=1, mini=0., maxi=1.):
        r"""

        VectorHelper::simulateUniform
        """
        return _gstlearn.VectorHelper_simulateUniform(n, mini, maxi)

    @staticmethod
    def simulateBernoulli(n=1, proba=0.5, vone=1., velse=0.):
        r"""

        VectorHelper::simulateBernoulli
        """
        return _gstlearn.VectorHelper_simulateBernoulli(n, proba, vone, velse)

    @staticmethod
    def simulateGaussian(n=1, mean=0., sigma=1.):
        r"""

        VectorHelper::simulateGaussian
        """
        return _gstlearn.VectorHelper_simulateGaussian(n, mean, sigma)

    @staticmethod
    def sampleRanks(ntotal, proportion=0., number=0, seed=242141, optSort=0):
        r"""

        VectorHelper::sampleRanks
        Sample a set of 'ntotal' ranks (unique occurrence)  

        Parameters
        ----------
        * `ntotal` :  
            Dimension to be sampled  
        * `proportion` :  
            Proportion of elected samples (in [0,1])  
        * `number` :  
            Number of elected samples  
        * `seed` :  
            Seed used for the random number generator  
        * `optSort` :  
            Sorting: 0 for None; 1 for Ascending; -1 for Descending  

        Returns
        -------
        A vector of indices lying between 0 and ntotal-1. No duplicate.  

        remark: If 'proportion' and 'number' are not specified,  

        remark: the output vector has dimension equal to 'ntotal'  

        """
        return _gstlearn.VectorHelper_sampleRanks(ntotal, proportion, number, seed, optSort)

    @staticmethod
    def normalizeCodir(ndim, codir):
        r"""

        VectorHelper::normalizeCodir
        Fix plausible values for the Direction coefficients. They must be defined and
        with norm equal to 1  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `codir` :  
            Input/Output Direction coefficients  

        """
        return _gstlearn.VectorHelper_normalizeCodir(ndim, codir)

    @staticmethod
    def isInList(vec, item):
        r"""

        VectorHelper::isInList
        """
        return _gstlearn.VectorHelper_isInList(vec, item)

    @staticmethod
    def sort(*args):
        r"""

        VectorHelper::sort
        """
        return _gstlearn.VectorHelper_sort(*args)

    @staticmethod
    def sortInPlace(*args):
        r"""

        VectorHelper::sortInPlace
        """
        return _gstlearn.VectorHelper_sortInPlace(*args)

    @staticmethod
    def isSorted(vec, ascending=True):
        r"""

        VectorHelper::isSorted
        """
        return _gstlearn.VectorHelper_isSorted(vec, ascending)

    @staticmethod
    def unique(*args):
        r"""

        VectorHelper::unique
        """
        return _gstlearn.VectorHelper_unique(*args)

    @staticmethod
    def orderRanks(*args):
        r"""

        VectorHelper::orderRanks
        Returns the permutation which rearranges the input vector into any order  

        Parameters
        ----------
        * `vecin` :  
            Input vector  
        * `ascending` :  
            True for ascending order; False otherwise  
        * `size` :  
            Optional vector dimension  

        Returns
        -------
        Vector of orders  

        """
        return _gstlearn.VectorHelper_orderRanks(*args)

    @staticmethod
    def sortRanks(vecin, ascending=True, size=-1):
        r"""

        VectorHelper::sortRanks
        """
        return _gstlearn.VectorHelper_sortRanks(vecin, ascending, size)

    @staticmethod
    def reorder(*args):
        r"""

        VectorHelper::reorder
        """
        return _gstlearn.VectorHelper_reorder(*args)

    @staticmethod
    def revert(*args):
        r"""

        VectorHelper::revert
        """
        return _gstlearn.VectorHelper_revert(*args)

    @staticmethod
    def sample(vecin, indKeep):
        r"""

        VectorHelper::sample
        Create an output VectorDouble by selecting some indices of the Input
        VectorDouble 'vecin'.  

        Parameters
        ----------
        * `vecin` :  
            Input Rectangular Matrix  
        * `indKeep` :  
            Set of Indices to be kept (all if not defined)  

        """
        return _gstlearn.VectorHelper_sample(vecin, indKeep)

    @staticmethod
    def arrangeInPlace(*args):
        r"""

        VectorHelper::arrangeInPlace
        Sorts the (int) array value() and the array ranks() if provided  

        Parameters
        ----------
        * `safe` :  
            1 if the value array if preserved 0 if the value array is also sorted  
        * `ascending` :  
            True for ascending order; False for descending order  
        * `size` :  
            Optional size  
        * `ranks` :  
            intput and output int array  
        * `values` :  
            input and output int array  

        remark: If ranks = NULL, ranks is ignored  

        remark: When using 'size', the remaining part of arrays is unchanged  

        """
        return _gstlearn.VectorHelper_arrangeInPlace(*args)

    @staticmethod
    def filter(vecin, vmin=-1234567, vmax=-1234567, ascending=True):
        r"""

        VectorHelper::filter
        From an input list, filter out all the elements which do no lie within [vmin,
        vmax[, suppress double occurrences and sort them out (ascending or descending)  

        Parameters
        ----------
        * `vecin` :  
            Input array (integer)  
        * `vmin` :  
            lower bound included (or ITEST)  
        * `vmax` :  
            upper bound excluded (or ITEST)  
        * `ascending` :  
            True for ascending order; False for descending order  

        Returns
        -------
        Output array (integers)  

        """
        return _gstlearn.VectorHelper_filter(vecin, vmin, vmax, ascending)

    @staticmethod
    def complement(vec, sel):
        r"""

        VectorHelper::complement
        Returns the list complementary to 'sel' within 'vecin'  

        Parameters
        ----------
        * `vec` :  
            Initial list  
        * `sel` :  
            Vector of forbidden elements  

        Returns
        -------
        Complementary list  

        """
        return _gstlearn.VectorHelper_complement(vec, sel)

    @staticmethod
    def rangeVals(vec):
        r"""

        VectorHelper::rangeVals
        """
        return _gstlearn.VectorHelper_rangeVals(vec)

    @staticmethod
    def unflattenInPlace(vd, vvd):
        r"""

        VectorHelper::unflattenInPlace
        """
        return _gstlearn.VectorHelper_unflattenInPlace(vd, vvd)

    @staticmethod
    def flatten(*args):
        r"""

        VectorHelper::flatten
        """
        return _gstlearn.VectorHelper_flatten(*args)

    @staticmethod
    def unflatten(*args):
        r"""

        VectorHelper::unflatten
        """
        return _gstlearn.VectorHelper_unflatten(*args)

    @staticmethod
    def flattenInPlace(*args):
        r"""

        VectorHelper::flattenInPlace
        """
        return _gstlearn.VectorHelper_flattenInPlace(*args)

    @staticmethod
    def linearCombinationInPlace(val1, vd1, val2, vd2, outv):
        r"""

        VectorHelper::linearCombinationInPlace
        """
        return _gstlearn.VectorHelper_linearCombinationInPlace(val1, vd1, val2, vd2, outv)

    @staticmethod
    def innerProduct(*args):
        r"""

        VectorHelper::innerProduct
        """
        return _gstlearn.VectorHelper_innerProduct(*args)

    @staticmethod
    def linearCombinationVVDInPlace(*args):
        r"""

        VectorHelper::linearCombinationVVDInPlace
        """
        return _gstlearn.VectorHelper_linearCombinationVVDInPlace(*args)

    @staticmethod
    def suppressTest(vecin):
        r"""

        VectorHelper::suppressTest
        """
        return _gstlearn.VectorHelper_suppressTest(vecin)

    @staticmethod
    def extractInPlace(vecin, vecout, start):
        r"""

        VectorHelper::extractInPlace
        Extract the part of a vector 'vecin' (dimensioned to dimension of 'vecout')
        starting at address 'istart' and copy it into 'vecout'  

        Parameters
        ----------
        * `vecin` :  
            Initial vector  
        * `vecout` :  
            Resulting vector (already allocated)  
        * `start` :  
            Starting address (within 'vecin')  

        """
        return _gstlearn.VectorHelper_extractInPlace(vecin, vecout, start)

    @staticmethod
    def mergeInPlace(vecin, vecout, start):
        r"""

        VectorHelper::mergeInPlace
        Merge 'vecin' into 'vecout' starting at address 'istart'  

        Parameters
        ----------
        * `vecin` :  
            Initial vector  
        * `vecout` :  
            Vector where 'vecin' should be copied  
        * `start` :  
            Starting address (in 'vecout')  

        """
        return _gstlearn.VectorHelper_mergeInPlace(vecin, vecout, start)

    @staticmethod
    def transformVD(tab, oper_choice=1):
        r"""

        VectorHelper::transformVD
        Transform a vector of double values as follows  

        Parameters
        ----------
        * `tab` :  
            Vector of double values  
        * `oper_choice` :  
            Operation on the diagonal term (see Utilities::operate_XXX)  

        """
        return _gstlearn.VectorHelper_transformVD(tab, oper_choice)

    @staticmethod
    def squeezeAndStretchInPlaceForward(vecin, vecout, origin, mesh, top, bot):
        r"""

        VectorHelper::squeezeAndStretchInPlaceForward
        Operate the squeeze-and-stretch algorithm forward (see remarks)  

        Parameters
        ----------
        * `vecin` :  
            Input vector (in structural system)  
        * `vecout` :  
            Output vector (in sugar box system)  
        * `origin` :  
            Origin of the vertical axis (structural system)  
        * `mesh` :  
            Mesh of the vertical axis (structural system)  
        * `top` :  
            Elevation of the Top surface  
        * `bot` :  
            Elevation of the Bottom surface  

        remark: The information is contained in 'vecin' which is defined on a regular 1D
            grid  

        remark: in the structural system. The purpose is to sample the relevant sub-
            information  

        remark: (between 'top' and 'bot') densely in 'vecout'  

        """
        return _gstlearn.VectorHelper_squeezeAndStretchInPlaceForward(vecin, vecout, origin, mesh, top, bot)

    @staticmethod
    def squeezeAndStretchInPlaceBackward(vecin, vecout, origin, mesh, top, bot):
        r"""

        VectorHelper::squeezeAndStretchInPlaceBackward
        Operate the squeeze-and-stretch algorithm backward (see remarks)  

        Parameters
        ----------
        * `vecin` :  
            Input vector (in sugar box system)  
        * `vecout` :  
            Output vector (in structural system)  
        * `origin` :  
            Origin of the vertical axis (structural system)  
        * `mesh` :  
            Mesh of the vertical axis (structural system)  
        * `top` :  
            Elevation of the Top surface  
        * `bot` :  
            Elevation of the Bottom surface  

        remark: The information is contained in 'vecin' which is defined on a regular 1D
            grid  

        remark: (characterized by 'base' and 'mesh')  

        remark: Extend the relevant information, lying between 'bot' and 'top' in order
            to fill  

        remark: the whole vector 'vecout'  

        """
        return _gstlearn.VectorHelper_squeezeAndStretchInPlaceBackward(vecin, vecout, origin, mesh, top, bot)

    @staticmethod
    def whereMinimum(tab):
        r"""

        VectorHelper::whereMinimum
        Find the location of the minimum value within a vector  

        Returns
        -------
        Rank of the minimum value  

        Parameters
        ----------
        * `tab` :  
            Vector of values  

        """
        return _gstlearn.VectorHelper_whereMinimum(tab)

    @staticmethod
    def whereMaximum(tab):
        r"""

        VectorHelper::whereMaximum
        Find the location of the maximum value within a vector  

        Returns
        -------
        Rank of the maximum value  

        Parameters
        ----------
        * `tab` :  
            Vector of values  

        """
        return _gstlearn.VectorHelper_whereMaximum(tab)

    @staticmethod
    def whereElement(tab, target):
        r"""

        VectorHelper::whereElement
        """
        return _gstlearn.VectorHelper_whereElement(tab, target)

    @staticmethod
    def norm(*args):
        r"""

        VectorHelper::norm
        """
        return _gstlearn.VectorHelper_norm(*args)

    @staticmethod
    def isIsotropic(sampleRanks):
        r"""

        VectorHelper::isIsotropic
        """
        return _gstlearn.VectorHelper_isIsotropic(sampleRanks)

    @staticmethod
    def reduceOne(vecin, index):
        r"""

        VectorHelper::reduceOne
        Reduce the input vector 'vecin' by suppressing the element referred by 'index'  

        Parameters
        ----------
        * `vecin` :  
            Input vector (double)  
        * `index` :  
            Index to be suppressed  

        """
        return _gstlearn.VectorHelper_reduceOne(vecin, index)

    @staticmethod
    def reduce(vecin, vindex):
        r"""

        VectorHelper::reduce
        Reduce the input vector 'vecin' by suppressing the elements referred by 'index'  

        Parameters
        ----------
        * `vecin` :  
            Input vector (double)  
        * `vindex` :  
            Vector of indices to be suppressed  

        """
        return _gstlearn.VectorHelper_reduce(vecin, vindex)

    @staticmethod
    def compress(vecin, vindex):
        r"""

        VectorHelper::compress
        Reduce the input vector 'vecin' by returning the only elements referred by
        'index'  

        Parameters
        ----------
        * `vecin` :  
            Input vector (double)  
        * `vindex` :  
            Vector of indices to be kept  

        """
        return _gstlearn.VectorHelper_compress(vecin, vindex)

    @staticmethod
    def truncateDecimalsInPlace(vec, ndec):
        r"""

        VectorHelper::truncateDecimalsInPlace
        """
        return _gstlearn.VectorHelper_truncateDecimalsInPlace(vec, ndec)

    @staticmethod
    def truncateDigitsInPlace(vec, ndec):
        r"""

        VectorHelper::truncateDigitsInPlace
        """
        return _gstlearn.VectorHelper_truncateDigitsInPlace(vec, ndec)

    @staticmethod
    def simulateGaussianInPlace(*args):
        r"""

        VectorHelper::simulateGaussianInPlace
        """
        return _gstlearn.VectorHelper_simulateGaussianInPlace(*args)

    def __init__(self):
        r"""


        C++ includes: VectorHelper.hpp

        """
        _gstlearn.VectorHelper_swiginit(self, _gstlearn.new_VectorHelper())
    __swig_destroy__ = _gstlearn.delete_VectorHelper

# Register VectorHelper in _gstlearn:
_gstlearn.VectorHelper_swigregister(VectorHelper)
class VH(VectorHelper):
    r"""


    C++ includes: VectorHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        C++ includes: VectorHelper.hpp

        """
        _gstlearn.VH_swiginit(self, _gstlearn.new_VH())
    __swig_destroy__ = _gstlearn.delete_VH

# Register VH in _gstlearn:
_gstlearn.VH_swigregister(VH)
class Plane(AStringable):
    r"""


    C++ includes: Plane.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Plane::Plane
        """
        _gstlearn.Plane_swiginit(self, _gstlearn.new_Plane(*args))
    __swig_destroy__ = _gstlearn.delete_Plane

    def toString(self, strfmt=None):
        r"""

        Plane::toString
        """
        return _gstlearn.Plane_toString(self, strfmt)

    def getIntercept(self):
        r"""

        Plane::getIntercept
        """
        return _gstlearn.Plane_getIntercept(self)

    def setIntercept(self, intercept):
        r"""

        Plane::setIntercept
        """
        return _gstlearn.Plane_setIntercept(self, intercept)

    def getRndval(self):
        r"""

        Plane::getRndval
        """
        return _gstlearn.Plane_getRndval(self)

    def setRndval(self, rndval):
        r"""

        Plane::setRndval
        """
        return _gstlearn.Plane_setRndval(self, rndval)

    def getValue(self):
        r"""

        Plane::getValue
        """
        return _gstlearn.Plane_getValue(self)

    def setValue(self, value):
        r"""

        Plane::setValue
        """
        return _gstlearn.Plane_setValue(self, value)

    def setCoor(self, *args):
        r"""

        Plane::setCoor
        """
        return _gstlearn.Plane_setCoor(self, *args)

    def getCoor(self, *args):
        r"""

        Plane::getCoor
        """
        return _gstlearn.Plane_getCoor(self, *args)

    @staticmethod
    def poissonPlanesGenerate(dbgrid, np):
        r"""

        Plane::poissonPlanesGenerate
        Generate the Poisson planes that cover the grid  

        Parameters
        ----------
        * `dbgrid` :  
            Db corresponding to the target grid  
        * `np` :  
            Number of planes  

        remark: The array 'planes' contains successively a,b,c,d such that  

        remark: ax + by + cz + d = 0  

        remark: The valuation of each line is assigned a uniform value [0,1]  

        """
        return _gstlearn.Plane_poissonPlanesGenerate(dbgrid, np)

    def __repr__(self):
        return _gstlearn.Plane___repr__(self)

# Register Plane in _gstlearn:
_gstlearn.Plane_swigregister(Plane)

def FFTn(ndim, dims, Re, Im, iSign=1, scaling=1.):
    r"""


    Calculate the FFT in a space of dimension N  

    Returns
    -------
    Error return code  

    """
    return _gstlearn.FFTn(ndim, dims, Re, Im, iSign, scaling)

def evalCovFFTTimeSlice(hmax, time, N, funcSpectrum):
    r"""


    perform the FFT transform for a First-Order Space Time evolution equation  

    Parameters
    ----------
    * `hmax` :  
        Maximum spatial distances (Dimension: spatial ndim)  
    * `time` :  
        Time of the covariance slice  
    * `N` :  
        Discretization number (in each spatial dimension)  
    * `funcSpectrum` :  
        External adequate spectrum evaluation function  

    Returns
    -------
    Array of spatio-temporal covariance  

    """
    return _gstlearn.evalCovFFTTimeSlice(hmax, time, N, funcSpectrum)

def evalCovFFTSpatial(hmax, N, funcSpectrum):
    r"""


    """
    return _gstlearn.evalCovFFTSpatial(hmax, N, funcSpectrum)

def fftshift(dims, data):
    r"""


    """
    return _gstlearn.fftshift(dims, data)
class PolyPoint2D(object):
    r"""


    C++ includes: PolyLine2D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rank = property(_gstlearn.PolyPoint2D_rank_get, _gstlearn.PolyPoint2D_rank_set)
    dist = property(_gstlearn.PolyPoint2D_dist_get, _gstlearn.PolyPoint2D_dist_set)
    coor = property(_gstlearn.PolyPoint2D_coor_get, _gstlearn.PolyPoint2D_coor_set)

    def __init__(self):
        r"""


        C++ includes: PolyLine2D.hpp

        """
        _gstlearn.PolyPoint2D_swiginit(self, _gstlearn.new_PolyPoint2D())
    __swig_destroy__ = _gstlearn.delete_PolyPoint2D

# Register PolyPoint2D in _gstlearn:
_gstlearn.PolyPoint2D_swigregister(PolyPoint2D)
class PolyLine2D(AStringable, ASerializable):
    r"""


    C++ includes: PolyLine2D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        PolyLine2D::PolyLine2D
        """
        _gstlearn.PolyLine2D_swiginit(self, _gstlearn.new_PolyLine2D(*args))
    __swig_destroy__ = _gstlearn.delete_PolyLine2D

    def toString(self, strfmt=None):
        r"""

        PolyLine2D::toString
        Interface of AStringable.  

        """
        return _gstlearn.PolyLine2D_toString(self, strfmt)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        PolyLine2D::createFromNF
        """
        return _gstlearn.PolyLine2D_createFromNF(NFFilename, verbose)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        PolyLine2D::create
        """
        return _gstlearn.PolyLine2D_create(*args, **kwargs)

    def getNPoints(self):
        r"""

        PolyLine2D::getNPoints
        """
        return _gstlearn.PolyLine2D_getNPoints(self)

    def init(self, x, y):
        r"""

        PolyLine2D::init
        """
        return _gstlearn.PolyLine2D_init(self, x, y)

    def getX(self, *args):
        r"""

        PolyLine2D::getX
        """
        return _gstlearn.PolyLine2D_getX(self, *args)

    def getY(self, *args):
        r"""

        PolyLine2D::getY
        """
        return _gstlearn.PolyLine2D_getY(self, *args)

    def getPoint(self, i):
        r"""

        PolyLine2D::getPoint
        """
        return _gstlearn.PolyLine2D_getPoint(self, i)

    def getXmin(self):
        r"""

        PolyLine2D::getXmin
        """
        return _gstlearn.PolyLine2D_getXmin(self)

    def getYmin(self):
        r"""

        PolyLine2D::getYmin
        """
        return _gstlearn.PolyLine2D_getYmin(self)

    def getXmax(self):
        r"""

        PolyLine2D::getXmax
        """
        return _gstlearn.PolyLine2D_getXmax(self)

    def getYmax(self):
        r"""

        PolyLine2D::getYmax
        """
        return _gstlearn.PolyLine2D_getYmax(self)

    def addPoint(self, x, y):
        r"""

        PolyLine2D::addPoint
        """
        return _gstlearn.PolyLine2D_addPoint(self, x, y)

    def setX(self, x):
        r"""

        PolyLine2D::setX
        """
        return _gstlearn.PolyLine2D_setX(self, x)

    def setY(self, y):
        r"""

        PolyLine2D::setY
        """
        return _gstlearn.PolyLine2D_setY(self, y)

    def getPLIndex(self, xy0):
        r"""

        PolyLine2D::getPLIndex
        Returns the point of the PolyLine located at shortest distance from Target  

        Returns
        -------
        PolyPoint2D structure  

        Parameters
        ----------
        * `xy0` :  
            Coordinates of the target point  

        """
        return _gstlearn.PolyLine2D_getPLIndex(self, xy0)

    def distanceBetweenPoints(self, ap, al, xy1, xy2):
        r"""

        PolyLine2D::distanceBetweenPoints
        Find the shortest distance between two points (x1,y1) and (x2,y2) passing
        through a polyline  

        Returns
        -------
        Minimum distance  

        Parameters
        ----------
        * `ap` :  
            Coefficient applied to the projected distances  
        * `al` :  
            Coefficient applied to the distance along line  
        * `xy1` :  
            Coordinates of the first point  
        * `xy2` :  
            Coordinates of the second point  

        """
        return _gstlearn.PolyLine2D_distanceBetweenPoints(self, ap, al, xy1, xy2)

    def distanceAlongPolyline(self, pldist1, pldist2):
        r"""

        PolyLine2D::distanceAlongPolyline
        Find the shortest distance between two points (x1,y1) and (x2,y2) which belong
        to the current polyline  

        Returns
        -------
        Minimum distance  

        Parameters
        ----------
        * `pldist1` :  
            First PolyPoint2D structure  
        * `pldist2` :  
            Second PolyPoint2D structure  

        """
        return _gstlearn.PolyLine2D_distanceAlongPolyline(self, pldist1, pldist2)

    def angleAtPolyline(self, pldist, nb_neigh=0):
        r"""

        PolyLine2D::angleAtPolyline
        """
        return _gstlearn.PolyLine2D_angleAtPolyline(self, pldist, nb_neigh)

    def distanceAtPolyline(self, pldist, target, nb_neigh):
        r"""

        PolyLine2D::distanceAtPolyline
        """
        return _gstlearn.PolyLine2D_distanceAtPolyline(self, pldist, target, nb_neigh)

    def __repr__(self):
        return _gstlearn.PolyLine2D___repr__(self)

# Register PolyLine2D in _gstlearn:
_gstlearn.PolyLine2D_swigregister(PolyLine2D)

def distanceBetweenPolylines(poly1, poly2, pldist1, pldist2):
    r"""


    """
    return _gstlearn.distanceBetweenPolylines(poly1, poly2, pldist1, pldist2)

def dbUnfoldPolyline(*args, **kwargs):
    r"""


    Unfold a 2-D Db with respect to a polyline  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `polyline` :  
        PolyLine2D structure  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.dbUnfoldPolyline(*args, **kwargs)

def dbFoldPolyline(*args, **kwargs):
    r"""


    Fold an input Db into an output Db with respect to a polyline  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `cols` :  
        Vector of the target variable ranks  
    * `polyline` :  
        PolyLine2D structure  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.dbFoldPolyline(*args, **kwargs)

def dbFromPolylines(*args, **kwargs):
    r"""


    Calculate quantities on the Db by comparison with top and bottom polylines  

    Parameters
    ----------
    * `db` :  
        Pointer to the Db where relevant information will be stored  
    * `top` :  
        2-D Polyline defining the Top surface  
    * `bot` :  
        2-D Polyline defining the Bottom surface  
    * `nb_neigh` :  
        Size of neighborhood radius (for regularizing the angle calculation)  
    * `flagMask` :  
        Mask if the target is outside the two polylines  
    * `namconv` :  
        Naming convention  

    Returns
    -------
    Error return code  

    remark: Three variables are created:  

    remark: 1 - Minimum distance between Target and Polylines  

    remark: 2 - Distance between Polylines at Target location  

    remark: 3 - Average angle of Polylines at Target location  

    """
    return _gstlearn.dbFromPolylines(*args, **kwargs)

def law_set_old_style(style):
    r"""


    Set the type of Usage for Random Number Generation  

    Parameters
    ----------
    * `style` :  
        true for using Old Style; false for using New Style  

    """
    return _gstlearn.law_set_old_style(style)

def law_get_random_seed():
    r"""


    read the seed for the random number generator  

    Returns
    -------
    The current value of the seed (integer)  

    """
    return _gstlearn.law_get_random_seed()

def law_set_random_seed(seed):
    r"""


    Sets the seed for the random number generator  

    Parameters
    ----------
    * `seed` :  
        the new value given to the seed  

    """
    return _gstlearn.law_set_random_seed(seed)

def law_uniform(mini=0., maxi=1.):
    r"""


    Draw a random number according to a uniform distribution  

    Returns
    -------
    Uniform random value within an interval  

    Parameters
    ----------
    * `mini` :  
        minimum value  
    * `maxi` :  
        maximum value  

    """
    return _gstlearn.law_uniform(mini, maxi)

def law_int_uniform(mini, maxi):
    r"""


    Draw an integer random number according to a uniform distribution  

    Returns
    -------
    Integer Uniform random value within an interval  

    Parameters
    ----------
    * `mini` :  
        minimum value  
    * `maxi` :  
        maximum value  

    """
    return _gstlearn.law_int_uniform(mini, maxi)

def law_gaussian(mean=0., sigma=1.):
    r"""


    Generate random numbers according to a gaussian distribution  

    Returns
    -------
    Gaussian random value  

    Parameters
    ----------
    * `mean` :  
        Mean of the Normal Distribution  
    * `sigma` :  
        Standard deviation of the Normal Distribution  

    """
    return _gstlearn.law_gaussian(mean, sigma)

def law_exponential(_lambda=1.):
    r"""


    Generate random numbers according to exponential distribution  

    Returns
    -------
    Exponential random value  

    Parameters
    ----------
    * `lambda` :  
        Parameter of exponential distribution  

    """
    return _gstlearn.law_exponential(_lambda)

def law_gamma(alpha, beta=1.):
    r"""


    Generate random numbers according to a gamma distribution  

    Returns
    -------
    Gamma random value  

    Parameters
    ----------
    * `alpha` :  
        parameter of the gamma distribution  
    * `beta` :  
        Second parameter of the Gamma distribution  

    """
    return _gstlearn.law_gamma(alpha, beta)

def law_df_poisson(i, parameter):
    r"""


    """
    return _gstlearn.law_df_poisson(i, parameter)

def law_df_poisson_vec(_is, parameter):
    r"""


    """
    return _gstlearn.law_df_poisson_vec(_is, parameter)

def law_poisson(parameter):
    r"""


    Generate random number according to a poisson distribution  

    Returns
    -------
    Poisson random value  

    Parameters
    ----------
    * `parameter` :  
        parameter of the Poisson distribution  

    remark: Method Ahrens-Dieter (1973)  

    """
    return _gstlearn.law_poisson(parameter)

def law_stable_standard_agd(alpha, beta):
    r"""


    Generate random numbers according to a standard stable distribution  

    Returns
    -------
    Stable value with standard parameters (gamma=1,delta=0,alpha!=1)  

    Parameters
    ----------
    * `alpha` :  
        value of the alpha parameter  
    * `beta` :  
        value of the beta parameter  

    """
    return _gstlearn.law_stable_standard_agd(alpha, beta)

def law_stable_standard_a1gd(beta):
    r"""


    Generate random numbers according to a standard stable distribution (alpha=1)  

    Returns
    -------
    Stable value with standard parameters (alpha=gamma=1,delta=0)  

    Parameters
    ----------
    * `beta` :  
        value of the beta parameter  

    """
    return _gstlearn.law_stable_standard_a1gd(beta)

def law_stable_standard_abgd(alpha):
    r"""


    Generate random numbers according to a standard stable distribution  

    Returns
    -------
    Stable value with std. parameters (beta=gamma=1,delta=0,alpha!=1)  

    Parameters
    ----------
    * `alpha` :  
        value of the alpha parameter  

    """
    return _gstlearn.law_stable_standard_abgd(alpha)

def law_stable_a(alpha, beta, gamma, delta):
    r"""


    Generate random numbers according to a stable distribution (alpha != 1)  

    Returns
    -------
    Stable value with unit parameters  

    Parameters
    ----------
    * `alpha` :  
        value of the alpha parameter  
    * `beta` :  
        value of the beta parameter  
    * `gamma` :  
        value of the gamma parameter  
    * `delta` :  
        value of the delta parameter  

    """
    return _gstlearn.law_stable_a(alpha, beta, gamma, delta)

def law_stable_a1(beta, gamma, delta):
    r"""


    Generate random numbers according to a stable distribution (alpha=1)  

    Returns
    -------
    Stable value with unit parameters  

    Parameters
    ----------
    * `beta` :  
        value of the beta parameter  
    * `gamma` :  
        value of the gamma parameter  
    * `delta` :  
        value of the delta parameter  

    """
    return _gstlearn.law_stable_a1(beta, gamma, delta)

def law_stable(alpha, beta, gamma, delta):
    r"""


    Generate random numbers according to a stable distribution  

    Returns
    -------
    Stable value with unit parameters  

    Parameters
    ----------
    * `alpha` :  
        value of the alpha parameter  
    * `beta` :  
        value of the beta parameter  
    * `gamma` :  
        value of the gamma parameter  
    * `delta` :  
        value of the delta parameter  

    """
    return _gstlearn.law_stable(alpha, beta, gamma, delta)

def law_binomial(n, p):
    r"""


    Generates a binomial value  

    Returns
    -------
    The binomial value  

    Parameters
    ----------
    * `n` :  
        Number of trials  
    * `p` :  
        Event probability  

    """
    return _gstlearn.law_binomial(n, p)

def law_beta1(parameter1, parameter2):
    r"""


    Generate random numbers according to a beta distribution (first kind)  

    Returns
    -------
    Beta random value (first kind)  

    Parameters
    ----------
    * `parameter1` :  
        first parameter of the beta distribution  
    * `parameter2` :  
        first parameter of the beta distribution  

    """
    return _gstlearn.law_beta1(parameter1, parameter2)

def law_beta2(parameter1, parameter2):
    r"""


    Generate random numbers according to a beta distribution (second kind)  

    Returns
    -------
    Beta random value (second kind)  

    Parameters
    ----------
    * `parameter1` :  
        first parameter of the beta distribution  
    * `parameter2` :  
        first parameter of the beta distribution  

    """
    return _gstlearn.law_beta2(parameter1, parameter2)

def law_df_gaussian(value):
    r"""


    Density function of a gaussian distribution  

    Returns
    -------
    Gaussian density function  

    Parameters
    ----------
    * `value` :  
        raw value  

    """
    return _gstlearn.law_df_gaussian(value)

def law_dnorm(value, mean, std):
    r"""


    Density function of a (non-normalized) gaussian distribution  

    Returns
    -------
    Gaussian density function  

    Parameters
    ----------
    * `value` :  
        Raw value  
    * `mean` :  
        Mean value  
    * `std` :  
        Standard deviation  

    """
    return _gstlearn.law_dnorm(value, mean, std)

def law_cdf_gaussian(value):
    r"""


    Cumulated density function of a gaussian distribution  

    Returns
    -------
    Gaussian cumulated density function  

    Parameters
    ----------
    * `value` :  
        raw value  

    remark: Handbook P932 (26.2.17) precision <7.5 E-08  

    """
    return _gstlearn.law_cdf_gaussian(value)

def law_invcdf_gaussian(value):
    r"""


    Inverse cumulated density function of a gaussian distribution  

    Returns
    -------
    Inverse of gaussian cumulated density function  

    Parameters
    ----------
    * `value` :  
        cumulative density  

    """
    return _gstlearn.law_invcdf_gaussian(value)

def law_gaussian_between_bounds(binf, bsup):
    r"""


    Generates a gaussian value which lies in an interval  

    Returns
    -------
    The gaussian value  

    Parameters
    ----------
    * `binf` :  
        lower bound of the interval  
    * `bsup` :  
        upper bound of the interval  

    """
    return _gstlearn.law_gaussian_between_bounds(binf, bsup)

def law_df_bigaussian(vect, mean, correl):
    r"""


    Density function of a bigaussian distribution  

    Returns
    -------
    Gaussian density function  

    Parameters
    ----------
    * `vect` :  
        Array of values (Dimension = 2)  
    * `mean` :  
        Array of means (Dimension = 2)  
    * `correl` :  
        Correlation matrix (Dimension: 2*2)  

    """
    return _gstlearn.law_df_bigaussian(vect, mean, correl)

def law_df_quadgaussian(vect, correl):
    r"""


    Density function of a quadrigaussian distribution  

    Returns
    -------
    Gaussian density function  

    Parameters
    ----------
    * `vect` :  
        Array of values (Dimension = nvar)  
    * `correl` :  
        Correlation matrix (Dimension: nvar*nvar)  

    """
    return _gstlearn.law_df_quadgaussian(vect, correl)

def law_df_multigaussian(vect, correl):
    r"""


    Density function of a multigaussian distribution  

    Returns
    -------
    Gaussian density function  

    Parameters
    ----------
    * `vect` :  
        Array of values (Dimension = nvar)  
    * `correl` :  
        Correlation matrix (Dimension: nvar*nvar)  

    """
    return _gstlearn.law_df_multigaussian(vect, correl)

def law_random_path(nech):
    r"""


    Define a random path  

    Parameters
    ----------
    * `nech` :  
        : Number of samples  

    """
    return _gstlearn.law_random_path(nech)

def law_exp_sample(tabin, mode, nvar, nechin, nechout, niter, nconst, consts, seed, percent):
    r"""


    Sample a multivariate empirical distribution  

    Returns
    -------
    Address to the newly created array  

    Parameters
    ----------
    * `tabin` :  
        Input array  
    * `mode` :  
        Describes the way 'tabin' and 'tabout' are filled 1: by column; 2: by row  
    * `nvar` :  
        Number of variables (input and output)  
    * `nechin` :  
        Number of samples in the input array  
    * `nechout` :  
        Number of created samples  
    * `niter` :  
        Maximum number of iterations  
    * `nconst` :  
        Number of constraints  
    * `consts` :  
        Array of constraints (optional) (Dimension: nconst * (nvar+1)) This array is
        entered by line  
    * `seed` :  
        Value for the seed generator  
    * `percent` :  
        Dimension of the convolution kernel expressed as a percentage of the
        dispersion st. dev. Should be between 0 and 100  

    remark: The input array must be isotopic (otherwise, an error is issued)  

    remark: The resulting VectorDouble if dimensionned to nvar * nechout  

    remark: Consider nvar1 = nvar + 1  

    remark: Sample temp[1:nvar1] is authorized for Constraint 'iconst' if:  

    remark: Sum_ivar1^{1:nvar1) consts[iconst,ivar1) * temp[ivar1] > 0  

    """
    return _gstlearn.law_exp_sample(tabin, mode, nvar, nechin, nechout, niter, nconst, consts, seed, percent)

def sampleInteger(minit, maxi):
    r"""


    Returns an integer sampled uniformly wihtin the interval [mini, maxi]  

    Parameters
    ----------
    * `mini` :  
        Lower bound (included)  
    * `maxi` :  
        Upper bound (included)  

    """
    return _gstlearn.sampleInteger(minit, maxi)

def mvndst_infin(low, sup):
    r"""


    Set the flags for the bound of numerical integration  

    Returns
    -------
    Flag for the bound  

    Parameters
    ----------
    * `low` :  
        Lower integration bound  
    * `sup` :  
        Upper integration bound  

    """
    return _gstlearn.mvndst_infin(low, sup)

def mvndst(n, lower, upper, infin, correl, maxpts, abseps, releps, error, value, inform):
    r"""


    Multivariate Normal Probability  

    Parameters
    ----------
    * `n` :  
        Number of variables  
    * `lower` :  
        Array of lower integration limits  
    * `upper` :  
        Array of upper integration limits  
    * `infin` :  
        Array of integration limit flags  

        *   <0 for ]-Infinity; +Infinity[  
        *   =0 for ]-Infinity; upper]  
        *   =1 for [lower; +Infinity[  
        *   =2 for [lower; upper]  
    * `correl` :  
        Array of correlation coefficients  
    * `maxpts` :  
        Maximum number of function values allowed  
    * `abseps` :  
        Absolute error tolerance  
    * `releps` :  
        Relative error tolerance  
    * `error` :  
        Estimated absolute error with 90% confidence level  
    * `value` :  
        Estimated value for the integral  
    * `inform` :  
        Returned code  

    remark: The array correl must be entered as the non-diagonal upper part  

    remark: of the correlation matrix, entered by line  

    remark: This subroutine uses an algorithm given in the paper:  

    remark: "Numerical Computation of Multivariate Normal Probabilities", in  

    remark: J. of Computational and Graphical Stat., 1(1992), pp. 141-149, by  

    remark: Alan Genz  

    remark: Department of Mathematics  

    remark: Washington State University  

    remark: Pullman, WA 99164-3113  

    remark: Email : AlanGenz@wsu.edu  

    """
    return _gstlearn.mvndst(n, lower, upper, infin, correl, maxpts, abseps, releps, error, value, inform)

def mvndst2n(lower, upper, means, correl, maxpts, abseps, releps, error, value, inform):
    r"""


    Calculate the multigaussian integral (non-normalized)  

    Parameters
    ----------
    * `lower` :  
        Array of lower bounds (Dimension: nvar)  
    * `upper` :  
        Array of upper bounds (Dimension: nvar)  
    * `means` :  
        Array of means (Dimension: 2)  
    * `correl` :  
        Correlation matrix (Dimension: 2*2)  
    * `maxpts` :  
        Maximum number of function values allowed  
    * `abseps` :  
        Absolute error tolerance  
    * `releps` :  
        Relative error tolerance  
    * `error` :  
        Estimated absolute error with 90% confidence level  
    * `value` :  
        Estimated value for the integral  
    * `inform` :  
        Returned code  

    """
    return _gstlearn.mvndst2n(lower, upper, means, correl, maxpts, abseps, releps, error, value, inform)

def mvndst4(lower, upper, correl, maxpts, abseps, releps, error, value, inform):
    r"""


    Calculate the quadri-variable gaussian integral  

    Parameters
    ----------
    * `lower` :  
        Array of lower bounds  
    * `upper` :  
        Array of upper bounds  
    * `correl` :  
        Correlation matrix (Dimension: 4*4)  
    * `maxpts` :  
        Maximum number of function values allowed  
    * `abseps` :  
        Absolute error tolerance  
    * `releps` :  
        Relative error tolerance  
    * `error` :  
        Estimated absolute error with 90% confidence level  
    * `value` :  
        Estimated value for the integral  
    * `inform` :  
        Returned code  

    """
    return _gstlearn.mvndst4(lower, upper, correl, maxpts, abseps, releps, error, value, inform)

def besselj_table(x, alpha, nb, b):
    r"""


    This routine calculates Bessel functions J SUB(NB+ALPHA) (X) for non-negative
    argument X, and non-negative order NB+ALPHA.  

    Returns
    -------
    Error return code : NCALC  

    Returns
    -------
    NCALC < -1: An argument is out of range.  

    Returns
    -------
    1 < NCALC < NB: Not all requested function values could be calculated
    accurately.  

    Returns
    -------
    BY(I) contains correct function values  

    Parameters
    ----------
    * `x` :  
        Working precision non-negative real argument for which J's are to be
        calculated.  
    * `alpha` :  
        Working precision fractional part of order for which J's are to be
        calculated. 0 <= ALPHA < 1.0.  
    * `nb` :  
        Integer number of functions to be calculated, NB > 0 The first function
        calculated is of order ALPHA, and the last is of order (NB - 1 + ALPHA).  
    * `b` :  
        Working precision output vector of length NB. If the routine terminates
        normally (NCALC=NB), the vector b[] contains the functions Y(ALPHA,X), ...
        ,Y(NB-1+ALPHA,X),  

    remark: This program is based on a program written by David J. Sookne (2)  

    remark: that computes values of the Bessel functions J or I of real  

    remark: argument and integer order. Modifications include the  

    remark: restriction of the computation to the J Bessel function of  

    remark: non-negative real argument, the extension of the computation to  

    remark: arbitrary positive order, and the elimination of most underflow.  

    remark: References: "A Note on Backward Recurrence Algorithms," Olver, F.  

    remark: W. J., and Sookne, D. J., Math. Comp. 26, 1972, pp 941-947.  

    remark: "Bessel Functions of Real Argument and Integer Order," Sookne, D.  

    remark: J., NBS Jour. of Res. B. 77B, 1973, pp 125-132.  

    """
    return _gstlearn.besselj_table(x, alpha, nb, b)

def besselj(x, n):
    r"""


    """
    return _gstlearn.besselj(x, n)

def besselk(x, alpha, nb, bk):
    r"""


    This routine calculates modified Bessel functions of the second kind, K
    SUB(N+ALPHA) (X), for non-negative argument X and non-negative order N+ALPHA  

    Returns
    -------
    Error return code :  

    Returns
    -------
    NCALC < -1: An argument is out of range.  

    Returns
    -------
    0 < NCALC < NB: Not all requested function values could be calculated
    accurately.  

    Returns
    -------
    BK(I) contains correct function values for I <= NCALC, and contains the ratios  

    Returns
    -------
    K(ALPHA+I-1,X)/K(ALPHA+I-2,X) for the rest of the array.  

    Parameters
    ----------
    * `x` :  
        Working precision non-negative real argument for which K's are to
        calculated. If K's are to be calculated, X must not be greater than XMAX.  
    * `alpha` :  
        Working precision fractional part of order for which K's are to be
        calculated. 0 <= ALPHA <1.0.  
    * `nb` :  
        Integer number of functions to be calculated, NB > 0. The first function
        calculated is of order ALPHA, and the last is of order (NB - 1 + ALPHA).  
    * `bk` :  
        Working precision output vector of length NB. If the routine terminates
        normally (NCALC=NB), the vector BK contains the functions : K(ALPHA,X), ...
        , K(NB-1+ALPHA,X),  

    remark: This program is based on a program written by J. B. Campbell (2)  

    remark: that computes values of the Bessel functions K of real argument  

    remark: and real order. References: "On Temme's Algorithm for the
        \remark  Modified Bessel Functions of the Third Kind," Campbell, J. B.,  

    remark: TOMS 6(4), Dec. 1980, pp. 581-586. "A FORTRAN IV Subroutine for
        \remark  the Modified Bessel Functions of the Third Kind of Real Order and
        \remark  Real Argument," Campbell, J. B., Report NRC/ERB-925, National  

    remark: Research Council, Canada.  

    """
    return _gstlearn.besselk(x, alpha, nb, bk)

def loggamma(parameter):
    r"""


    Calculation of the logarithm of the gamma function  

    Returns
    -------
    Logarithm of the gamma function  

    Parameters
    ----------
    * `parameter` :  
        raw value  

    """
    return _gstlearn.loggamma(parameter)

def ut_legendre(n, v, flagNorm=True):
    r"""


    Returns the Legendre Function described as follows:  

    legendre_p(n,v) = 1/{2^n n!) d^n/dx^n [x^2-1)^n with |x|<=1  

    If flagNorm is switched ON, the Boost library cannot be used anymore. We have to
    rely on the ode provided by X; Freulon.  

    Parameters
    ----------
    * `n` :  
        Degree of the Legendre Polynomial to be computed (n >= 0)  
    * `v` :  
        Value for which the polynomial is evaluated (-1 <= v <= 1)  
    * `flagNorm` :  
        True for normalized and 0 otherwise  

    Returns
    -------
    Value of the Legendre polynomial.  

    """
    return _gstlearn.ut_legendre(n, v, flagNorm)

def ut_legendreVec(n, vecin, flagNorm):
    r"""


    """
    return _gstlearn.ut_legendreVec(n, vecin, flagNorm)

def ut_legendreMatNorm(n, v):
    r"""


    """
    return _gstlearn.ut_legendreMatNorm(n, v)

def ut_legendreAssociatedMat(l, v, flagNorm=True):
    r"""


    Returns the Associated Legendre Function described as follows:  

    > > > In the case flagNorm=true Using the relations: P_0^0 (x) = 1 P_{l+1}^{l+1}
    > > > (x) = - sqrt((2l+3)/(2l+2)) * (1-x^2)^{1/2} * P_{l}^{l}(x) P_{l+1}^{m} (x)
    > > > = sqrt((2l+3)(2l+1)/((l-m+1)(l+m+1))) * x * P_{l}^{m}(x) -
    > > > sqrt((2l+3)/(2l-1)*(l+m)/(l+m+1)*(l-m)/(l-m+1)) P_{l-1}^m(x) Changing l to
    > > > l-1, P_{l}^{l} (x) = - a0 * (1-x^2)^{1/2} * P_{l-1}^{l-1}(x) with a0 =
    > > > sqrt((2l+1)/(2l)) P_{l}^{m} (x) = a * x * P_{l-1}^{m}(x) - b P_{l-2}^m(x)
    > > > with a = sqrt((2l+1)(2l-1)/(l-m)/(l+m)) and b =
    > > > sqrt((2l+1)/(2l-3)*(l+m-1)/(l+m)*(l-m-1)/(l-m))  

    > > > In the case flagNorm=false Using the relations: P_0^0 (x) = 1
    > > > P_{l+1}^{l+1} (x) = - sqrt((2l+3)/(2l+2)) * (1-x^2)^{1/2} * P_{l}^{l}(x)
    > > > P_{l+1}^{m} (x) = sqrt((2l+3)(2l+1)/((l-m+1)(l+m+1))) * x * P_{l}^{m}(x) -
    > > > sqrt((2l+3)/(2l-1)*(l+m)/(l+m+1)*(l-m)/(l-m+1)) P_{l-1}^m(x) Changing l to
    > > > l-1, P_{l}^{l} (x) = - a0 * (1-x^2)^{1/2} * P_{l-1}^{l-1}(x) with a0 =
    > > > sqrt((2l+1)/(2l)) P_{l}^{m} (x) = a * x * P_{l-1}^{m}(x) - b P_{l-2}^m(x)
    > > > with a = sqrt((2l+1)(2l-1)/(l-m)/(l+m)) and b =
    > > > sqrt((2l+1)/(2l-3)*(l+m-1)/(l+m)*(l-m-1)/(l-m))  

    Parameters
    ----------
    * `l` :  
        Degree of the Legendre Polynomial to be computed (n >= 0)  
    * `v` :  
        Value for which the polynomial is evaluated (-1 <= v <= 1)  
    * `flagNorm` :  
        Normalized when True  

    Returns
    -------
    A matrix of the (normalized) associated Legendre functions: P_l^m (x) for 0 <= m
    <= l  

    """
    return _gstlearn.ut_legendreAssociatedMat(l, v, flagNorm)

def ut_flegendre(n, k0, theta, flagNorm=True):
    r"""


    Returns the Spherical Legendre normalized function. According to boost Library
    documentation, this returns  

    Y_n^m(theta, phi) = sqrt{{(2n+1)(n-m)!} / {4pi(n+m)!}} P_n^m(cos(theta))e{imphi}  

    with phi=0 and m = |k0|  

    If flagNorm is switched ON, the previous result is multiplied by:  

    sqrt(2 * pi)  

    Parameters
    ----------
    * `n` :  
        Degree  
    * `k0` :  
        Order (ABS(k0) <= n)  
    * `theta` :  
        Theta angle in radian  
    * `flagNorm` :  
        for normalized and 0 otherwise  

    """
    return _gstlearn.ut_flegendre(n, k0, theta, flagNorm)

def ut_sphericalHarmonic(n, k, theta, phi):
    r"""


    Returns the Spherical harmonic  

    Parameters
    ----------
    * `n` :  
        Degree of HS (n >= 0)  
    * `k` :  
        Order of the HS (-n <= k <= n)  
    * `theta` :  
        Colatitude angle in radian (0 <= theta <= pi  
    * `phi` :  
        Longitude angle in radian (0 <= phi <= 2* pi)  

    """
    return _gstlearn.ut_sphericalHarmonic(n, k, theta, phi)

def ut_sphericalHarmonicVec(n, k, theta, phi):
    r"""


    """
    return _gstlearn.ut_sphericalHarmonicVec(n, k, theta, phi)

def golden_search(func_evaluate, user_data, tolstop, a0, c0, test_loc, niter):
    r"""


    Golden Search algorithm  

    Returns
    -------
    The estimated value  

    Parameters
    ----------
    * `func_evaluate` :  
        Evaluating function  
    * `user_data` :  
        User Data  
    * `tolstop` :  
        Tolerance parameter  
    * `a0` :  
        Initial value for lower bound of interval  
    * `c0` :  
        Initial value for upper bound of interval  
    * `test_loc` :  
        Final value of the evaluating function  
    * `niter` :  
        Number of iterations  

    """
    return _gstlearn.golden_search(func_evaluate, user_data, tolstop, a0, c0, test_loc, niter)

def ut_chebychev_count(func, cheb_elem, x, blin):
    r"""


    Evaluate the number of coefficients necessary to evaluate a function (at a
    sample location) at a given approximation  

    Returns
    -------
    Minimum number of necessary coefficients  

    Parameters
    ----------
    * `func` :  
        Function to be approximated  
    * `cheb_elem` :  
        Cheb_Elem structure  
    * `x` :  
        Sampling value  
    * `blin` :  
        Array of coefficients for polynomial expansion  

    """
    return _gstlearn.ut_chebychev_count(func, cheb_elem, x, blin)

def ut_chebychev_coeffs(func, cheb_elem, blin):
    r"""


    Calculates the coefficients of the Chebychev polynomial which is an
    approximation of a given function  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `func` :  
        Function to be approximated  
    * `cheb_elem` :  
        Cheb_Elem structure  
    * `blin` :  
        Array of coefficients for polynomial expansion  

    """
    return _gstlearn.ut_chebychev_coeffs(func, cheb_elem, blin)

def ut_vandercorput(n, flag_sym, flag_rot, ntri_arg, coord):
    r"""


    Generate a Van Der Corput list of points in R^3  

    Parameters
    ----------
    * `n` :  
        Number of points  
    * `flag_sym` :  
        Duplicate the samples by symmetry  
    * `flag_rot` :  
        Perform a random rotation  
    * `ntri_arg` :  
        Number of points  
    * `coord` :  
        Array of point coordinates (Dimension: 3*ntri)  

    """
    return _gstlearn.ut_vandercorput(n, flag_sym, flag_rot, ntri_arg, coord)

def ut_icosphere(n, flag_rot, ntri_arg, coord):
    r"""


    Generate regular Icosahedron discretization  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `n` :  
        Number of discretization steps  
    * `flag_rot` :  
        Perform a random rotation  
    * `ntri_arg` :  
        Number of points  
    * `coord` :  
        Array of point coordinates (Dimension: 3*ntri)  

    remark: As random number are used in this function, a specific seed  

    remark: is fixed here  

    """
    return _gstlearn.ut_icosphere(n, flag_rot, ntri_arg, coord)

def ut_factorial(k):
    r"""


    Calculates the factorial coefficient  

    Returns
    -------
    Returned value  

    Parameters
    ----------
    * `k` :  
        Value  

    """
    return _gstlearn.ut_factorial(k)

def ut_log_factorial(nbpoly, factor):
    r"""


    Calculates the nbpoly log-factorial coefficients  

    Parameters
    ----------
    * `nbpoly` :  
        Number of terms  
    * `factor` :  
        logarithm of factorials  

    """
    return _gstlearn.ut_log_factorial(nbpoly, factor)

def vanDerCorput(n, nd):
    r"""


    Function to compute the vector Van der Corput sequence or the Halton sequence  

    Parameters
    ----------
    * `n` :  
        The number of values to be computed  
    * `nd` :  
        The dimension of output sequence  

    Returns
    -------
    A matrix of dimensions [n,nd] with the sequence values (between 0 and 1)  

    note: The dimension nd should be lower or equal to 50.  

    """
    return _gstlearn.vanDerCorput(n, nd)

def fillLegendreMatrix(r, legendreOrder):
    r"""


    """
    return _gstlearn.fillLegendreMatrix(r, legendreOrder)

def solve_P2(a, b, c, x):
    r"""


    Find the roots of a polynomial of order 2: ax^2 + bx + c = 0  

    Returns
    -------
    Number of real solutions  

    Parameters
    ----------
    * `a`, `b`, `c` :  
        Coefficients of the polynomial  
    * `x` :  
        Array of real solutions (Dimension: 2)  

    remark: When the solution is double, the returned number os 1.  

    """
    return _gstlearn.solve_P2(a, b, c, x)

def solve_P3(a, b, c, d, x):
    r"""


    Find the roots of a polynomial of order 3: a*x^3 + b*x^2 + c*x + d = 0  

    Returns
    -------
    Number of real solutions  

    Parameters
    ----------
    * `a`, `b`, `c`, `d` :  
        Coefficients of the polynomial  
    * `x` :  
        Array of real solutions (Dimension: 3)  

    remark: When the solution is double, the returned number os 1.  

    """
    return _gstlearn.solve_P3(a, b, c, d, x)
class Indirection(AStringable):
    r"""


    C++ includes: Indirection.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _gstlearn.delete_Indirection

    def __init__(self, *args):
        r"""

        Indirection::Indirection
        """
        _gstlearn.Indirection_swiginit(self, _gstlearn.new_Indirection(*args))

    def toString(self, strfmt=None):
        r"""

        Indirection::toString
        Interface to AStringable.  

        """
        return _gstlearn.Indirection_toString(self, strfmt)

    def buildFromSel(self, sel):
        r"""

        Indirection::buildFromSel
        Build the needed information from Selection array A sample is active if its
        'sel' value is equal to 1  

        Parameters
        ----------
        * `sel` :  
            Vector giving the status of all samples (Dimension: absolute)  

        """
        return _gstlearn.Indirection_buildFromSel(self, sel)

    def buildFromRankRInA(self, rels, nabs):
        r"""

        Indirection::buildFromRankRInA
        """
        return _gstlearn.Indirection_buildFromRankRInA(self, rels, nabs)

    def buildFromMap(self, map, nabs):
        r"""

        Indirection::buildFromMap
        """
        return _gstlearn.Indirection_buildFromMap(self, map, nabs)

    def getAToR(self, iabs):
        r"""

        Indirection::getAToR
        """
        return _gstlearn.Indirection_getAToR(self, iabs)

    def getRToA(self, irel):
        r"""

        Indirection::getRToA
        """
        return _gstlearn.Indirection_getRToA(self, irel)

    def getAbsSize(self):
        r"""

        Indirection::getAbsSize
        """
        return _gstlearn.Indirection_getAbsSize(self)

    def getRelSize(self):
        r"""

        Indirection::getRelSize
        """
        return _gstlearn.Indirection_getRelSize(self)

    def setMode(self, mode):
        r"""

        Indirection::setMode
        """
        return _gstlearn.Indirection_setMode(self, mode)

    def isDefined(self):
        r"""

        Indirection::isDefined
        """
        return _gstlearn.Indirection_isDefined(self)

    def getRelRanks(self):
        r"""

        Indirection::getRelRanks
        """
        return _gstlearn.Indirection_getRelRanks(self)

    def getMode(self):
        r"""

        Indirection::getMode
        """
        return _gstlearn.Indirection_getMode(self)

    def __repr__(self):
        return _gstlearn.Indirection___repr__(self)

# Register Indirection in _gstlearn:
_gstlearn.Indirection_swigregister(Indirection)
class GeometryHelper(object):
    r"""


    C++ includes: GeometryHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def rotationGetSinCos(angle, cosa, sina):
        r"""

        GeometryHelper::rotationGetSinCos
        Calculates the trigonometric features  

        Parameters
        ----------
        * `angle` :  
            input angle (in degrees)  
        * `cosa` :  
            cosine function  
        * `sina` :  
            sine function  

        """
        return _gstlearn.GeometryHelper_rotationGetSinCos(angle, cosa, sina)

    @staticmethod
    def rotationMatrixIdentityInPlace(ndim, rot):
        r"""

        GeometryHelper::rotationMatrixIdentityInPlace
        Initialize a rotation matrix  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `rot` :  
            Rotation matrix  

        """
        return _gstlearn.GeometryHelper_rotationMatrixIdentityInPlace(ndim, rot)

    @staticmethod
    def rotation2DMatrixInPlace(angle, rot):
        r"""

        GeometryHelper::rotation2DMatrixInPlace
        Calculates the 2-D rotation matrix  

        Parameters
        ----------
        * `angle` :  
            Rotation angle (in degrees)  
        * `rot` :  
            Rotation matrix (Dimension = 4)  

        """
        return _gstlearn.GeometryHelper_rotation2DMatrixInPlace(angle, rot)

    @staticmethod
    def rotation3DMatrixInPlace(alpha, beta, gamma, rot):
        r"""

        GeometryHelper::rotation3DMatrixInPlace
        Calculates the 3-D rotation matrix  

        Parameters
        ----------
        * `alpha` :  
            angle (in degrees) / oz  
        * `beta` :  
            angle (in degrees) / oy'  
        * `gamma` :  
            angle (in degrees) / ox''  
        * `rot` :  
            direct rotation matrix (Dimension = 9)  

        """
        return _gstlearn.GeometryHelper_rotation3DMatrixInPlace(alpha, beta, gamma, rot)

    @staticmethod
    def rotationMatrixInPlace(ndim, angles, rot):
        r"""

        GeometryHelper::rotationMatrixInPlace
        Calculates the rotation matrix  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `angles` :  
            Array of angles  
        * `rot` :  
            direct rotation matrix (dimensionned to ndim*ndim)  

        """
        return _gstlearn.GeometryHelper_rotationMatrixInPlace(ndim, angles, rot)

    @staticmethod
    def rotationMatrix(ndim, angles):
        r"""

        GeometryHelper::rotationMatrix
        Calculates the rotation matrix. Returns the rotation matrix as a VectorDouble  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `angles` :  
            Array of angles  

        """
        return _gstlearn.GeometryHelper_rotationMatrix(ndim, angles)

    @staticmethod
    def rotationGetAnglesInPlace(*args):
        r"""

        GeometryHelper::rotationGetAnglesInPlace
        """
        return _gstlearn.GeometryHelper_rotationGetAnglesInPlace(*args)

    @staticmethod
    def rotationCopy(ndim, rotin, rotout):
        r"""

        GeometryHelper::rotationCopy
        Copy a rotation matrix  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `rotin` :  
            Input rotation matrix  
        * `rotout` :  
            Output rotation matrix (already allocated)  

        """
        return _gstlearn.GeometryHelper_rotationCopy(ndim, rotin, rotout)

    @staticmethod
    def rotationIsIdentity(ndim, rot, eps=1.e-10):
        r"""

        GeometryHelper::rotationIsIdentity
        Starting from a rotation matrix, check it is different from the Identity  

        Returns
        -------
        False if a rotation is defined; True if it is an Identity  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `rot` :  
            Rotation matrix  
        * `eps` :  
            Tolerance  

        """
        return _gstlearn.GeometryHelper_rotationIsIdentity(ndim, rot, eps)

    @staticmethod
    def rotationMatrixDerivativesInPlace(ndim, angles, dR):
        r"""

        GeometryHelper::rotationMatrixDerivativesInPlace
        """
        return _gstlearn.GeometryHelper_rotationMatrixDerivativesInPlace(ndim, angles, dR)

    @staticmethod
    def rotation2DMatrixDerivativesInPlace(angle, dR):
        r"""

        GeometryHelper::rotation2DMatrixDerivativesInPlace
        """
        return _gstlearn.GeometryHelper_rotation2DMatrixDerivativesInPlace(angle, dR)

    @staticmethod
    def rotation3DMatrixDerivativesInPlace(angles, dR):
        r"""

        GeometryHelper::rotation3DMatrixDerivativesInPlace
        """
        return _gstlearn.GeometryHelper_rotation3DMatrixDerivativesInPlace(angles, dR)

    @staticmethod
    def EulerToRotation(*args, **kwargs):
        r"""

        GeometryHelper::EulerToRotation
        Returns the Rotation matrix, starting from the Euler angles  

        Parameters
        ----------
        * `angles` :  
            Ordered list of Euler angles  
        * `convrot` :  
            Rotation convention  

        Returns
        -------  

        remark: The code is coming from the following reference (BSD license)  

        remark: https://github.com/matthew-
            brett/transforms3d/blob/master/transforms3d/euler.py  

        """
        return _gstlearn.GeometryHelper_EulerToRotation(*args, **kwargs)

    @staticmethod
    def EulerToRotationDerivatives(*args, **kwargs):
        r"""

        GeometryHelper::EulerToRotationDerivatives
        """
        return _gstlearn.GeometryHelper_EulerToRotationDerivatives(*args, **kwargs)

    @staticmethod
    def EulerToRotationDerivativesInPlace(*args, **kwargs):
        r"""

        GeometryHelper::EulerToRotationDerivativesInPlace
        """
        return _gstlearn.GeometryHelper_EulerToRotationDerivativesInPlace(*args, **kwargs)

    @staticmethod
    def rotationGetRandomDirection(ct, st, a, codir):
        r"""

        GeometryHelper::rotationGetRandomDirection
        Rotation of a Direction in 3-D  

        Parameters
        ----------
        * `ct`, `st` :  
            Cosine and Sine of the rotation angle  
        * `a` :  
            Random direction  
        * `codir` :  
            Direction to be rotated  

        """
        return _gstlearn.GeometryHelper_rotationGetRandomDirection(ct, st, a, codir)

    @staticmethod
    def rotationGetDirection2D(angles, codir):
        r"""

        GeometryHelper::rotationGetDirection2D
        Convert angles to a set of Directions  

        Parameters
        ----------
        * `angles` :  
            Vector giving the angles characteristics (in degrees) As this provides
            rotation in 2D, 'angles' is dimensioned to 'ndir' (one angle requires a
            single value)  
        * `codir` :  
            Vector of the direction (Dim: ndir * ndim)  

        remark: 'ndir' is given by the dimension of 'angles', 'ndim' is given by 'codir'  

        """
        return _gstlearn.GeometryHelper_rotationGetDirection2D(angles, codir)

    @staticmethod
    def rotationGetDirectionDefault(ndim, codir):
        r"""

        GeometryHelper::rotationGetDirectionDefault
        Create a Direction (used as default)  

        Parameters
        ----------
        * `ndim` :  
            Number of space dimensions  
        * `codir` :  
            Vector of the direction (Dim: ndim)  

        """
        return _gstlearn.GeometryHelper_rotationGetDirectionDefault(ndim, codir)

    @staticmethod
    def rotationGetAnglesFromCodirInPlace(codir, angles):
        r"""

        GeometryHelper::rotationGetAnglesFromCodirInPlace
        Calculates the rotation angle from the direction coefficient  

        Parameters
        ----------
        * `codir` :  
            Direction vector (Dimension = ndim)  
        * `angles` :  
            Rotation angles (Dimension = ndim)  

        """
        return _gstlearn.GeometryHelper_rotationGetAnglesFromCodirInPlace(codir, angles)

    @staticmethod
    def rotationGetAngles(codir, flagResize=False):
        r"""

        GeometryHelper::rotationGetAngles
        From the vector of direction coefficients (codir) returns the vector of angles  

        Parameters
        ----------
        * `codir` :  
            Input vector giving the direction coefficients  
        * `flagResize` :  
            When TRUE (and if in 2-D) the returned vector is resized to 1  

        Returns
        -------  

        """
        return _gstlearn.GeometryHelper_rotationGetAngles(codir, flagResize)

    @staticmethod
    def rotationFromIncrements(incr, flagDegree=False):
        r"""

        GeometryHelper::rotationFromIncrements
        Returns the set of angles for the rotation (in radians)  

        Parameters
        ----------
        * `incr` :  
            Vector of increment values along main space axes  
        * `flagDegree` :  
            when TRUE, convert into degrees; otherwise in radians  

        Returns
        -------
        VectorDouble  

        """
        return _gstlearn.GeometryHelper_rotationFromIncrements(incr, flagDegree)

    @staticmethod
    def rotationToEuler(*args, **kwargs):
        r"""

        GeometryHelper::rotationToEuler
        Returns the Euler angles, starting from a rotation matrix  

        Parameters
        ----------
        * `M` :  
            Input matrix  
        * `convrot` :  
            Rotation convention  
        * `eps` :  
            Tolerance  

        Returns
        -------  

        remark: The code is coming from the following reference (BSD license)  

        remark: https://github.com/matthew-
            brett/transforms3d/blob/master/transforms3d/euler.py  

        """
        return _gstlearn.GeometryHelper_rotationToEuler(*args, **kwargs)

    @staticmethod
    def distancePointToSegment(x0, y0, x1, y1, x2, y2, xd, yd, nint):
        r"""

        GeometryHelper::distancePointToSegment
        Find the shortest distance between the point (x0,y0) and the segment with the
        two end points (x1,y1) and (x2,y2)  

        Returns
        -------
        Minimum algebraic distance (positive or negative)  

        Parameters
        ----------
        * `x0`, `y0` :  
            Coordinates of the target point  
        * `x1`, `y1` :  
            Coordinate of the first end-point of the segment  
        * `x2`, `y2` :  
            Coordinate of the second end-point of the segment  
        * `xd`, `yd` :  
            Coordinates of the closest point  
        * `nint` :  
            =1 if the projection belongs to the segment =0 if it is set to one of the
            segment vertices  

        """
        return _gstlearn.GeometryHelper_distancePointToSegment(x0, y0, x1, y1, x2, y2, xd, yd, nint)

    @staticmethod
    def segmentIntersect(xd1, yd1, xe1, ye1, xd2, yd2, xe2, ye2, xint, yint):
        r"""

        GeometryHelper::segmentIntersect
        Check if two 2-D segments intersect  

        Returns
        -------
        True if there is an intersection; False otherwise  

        Parameters
        ----------
        * `xd1`, `yd1` :  
            Starting point for the first segment  
        * `xe1`, `ye1` :  
            Ending point for the first segment  
        * `xd2`, `yd2` :  
            Starting point for the second segment  
        * `xe2`, `ye2` :  
            Ending point for the second segment  
        * `xint`, `yint` :  
            Coordinates of the intersection  

        """
        return _gstlearn.GeometryHelper_segmentIntersect(xd1, yd1, xe1, ye1, xd2, yd2, xe2, ye2, xint, yint)

    @staticmethod
    def geodeticAngularDistance(long1, lat1, long2, lat2, radius=1.):
        r"""

        GeometryHelper::geodeticAngularDistance
        Calculate the geodetic angular distance between two points on the sphere  

        Returns
        -------
        Angular distance  

        Parameters
        ----------
        * `long1` :  
            Longitude of the first point (in degrees)  
        * `lat1` :  
            Latitude of the first point (in degrees)  
        * `long2` :  
            Longitude of the second point (in degrees)  
        * `lat2` :  
            Latitude of the second point (in degrees)  
        * `radius` :  
            Radius of the sphere  

        """
        return _gstlearn.GeometryHelper_geodeticAngularDistance(long1, lat1, long2, lat2, radius)

    @staticmethod
    def geodeticAngles(long1, lat1, long2, lat2, long3, lat3, a, b, c, A, B, C):
        r"""

        GeometryHelper::geodeticAngles
        Calculate all geodetic angles from a spherical triangle  

        Parameters
        ----------
        * `long1` :  
            Longitude of the first point (in degrees)  
        * `lat1` :  
            Latitude of the first point (in degrees)  
        * `long2` :  
            Longitude of the second point (in degrees)  
        * `lat2` :  
            Latitude of the second point (in degrees)  
        * `long3` :  
            Longitude of the third point (in degrees)  
        * `lat3` :  
            Latitude of the third point (in degrees)  
        * `a` :  
            Angle (P2,O,P3)  
        * `b` :  
            Angle (P3,O,P1)  
        * `c` :  
            Angle (P1,O,P2)  
        * `A` :  
            Angle (P2,P1,P3)  
        * `B` :  
            Angle (P3,P2,P1)  
        * `C` :  
            Angle (P1,P3,P2)  

        """
        return _gstlearn.GeometryHelper_geodeticAngles(long1, lat1, long2, lat2, long3, lat3, a, b, c, A, B, C)

    @staticmethod
    def geodeticTrianglePerimeter(long1, lat1, long2, lat2, long3, lat3):
        r"""

        GeometryHelper::geodeticTrianglePerimeter
        Calculate the perimeter of the spherical triangle  

        Returns
        -------
        The Perimeter of the spherical triangle  

        Parameters
        ----------
        * `long1` :  
            Longitude of the first point (in degrees)  
        * `lat1` :  
            Latitude of the first point (in degrees)  
        * `long2` :  
            Longitude of the second point (in degrees)  
        * `lat2` :  
            Latitude of the second point (in degrees)  
        * `long3` :  
            Longitude of the third point (in degrees)  
        * `lat3` :  
            Latitude of the third point (in degrees)  

        """
        return _gstlearn.GeometryHelper_geodeticTrianglePerimeter(long1, lat1, long2, lat2, long3, lat3)

    @staticmethod
    def geodeticTriangleSurface(long1, lat1, long2, lat2, long3, lat3):
        r"""

        GeometryHelper::geodeticTriangleSurface
        Calculate the surface of the spherical triangle  

        Returns
        -------
        The Surface of the spherical triangle (with unit radius)  

        Parameters
        ----------
        * `long1` :  
            Longitude of the first point (in degrees)  
        * `lat1` :  
            Latitude of the first point (in degrees)  
        * `long2` :  
            Longitude of the second point (in degrees)  
        * `lat2` :  
            Latitude of the second point (in degrees)  
        * `long3` :  
            Longitude of the third point (in degrees)  
        * `lat3` :  
            Latitude of the third point (in degrees)  

        """
        return _gstlearn.GeometryHelper_geodeticTriangleSurface(long1, lat1, long2, lat2, long3, lat3)

    @staticmethod
    def isInSphericalTriangle(coor, surface, pts1, pts2, pts3, wgts, eps=1.e-6):
        r"""

        GeometryHelper::isInSphericalTriangle
        Is a point inside a spherical triangle  

        Returns
        -------
        1 if the point belongs to the spherical triangle; 0 otherwise  

        Parameters
        ----------
        * `coor` :  
            Coordinates of the target point (long,lat)  
        * `surface` :  
            Surface of the spherical triangle  
        * `pts1` :  
            Coordinates of the first point of the triangle  
        * `pts2` :  
            Coordinates of the second point of the triangle  
        * `pts3` :  
            Coordinates of the third point of the triangle  
        * `eps` :  
            Tolerance  
        * `wgts` :  
            Array of weights  

        """
        return _gstlearn.GeometryHelper_isInSphericalTriangle(coor, surface, pts1, pts2, pts3, wgts, eps)

    @staticmethod
    def isInSphericalTriangleOptimized(coor, ptsa, ptsb, ptsc, wgts, eps=1.e-6):
        r"""

        GeometryHelper::isInSphericalTriangleOptimized
        Is a point inside a spherical triangle  

        Returns
        -------
        True if the point belongs to the spherical triangle; False otherwise  

        Parameters
        ----------
        * `coor` :  
            Coordinates of the target point (long,lat)  
        * `ptsa` :  
            Coordinates of the first point of the triangle  
        * `ptsb` :  
            Coordinates of the second point of the triangle  
        * `ptsc` :  
            Coordinates of the third point of the triangle  
        * `eps` :  
            Tolerance  
        * `wgts` :  
            Array of weights  

        """
        return _gstlearn.GeometryHelper_isInSphericalTriangleOptimized(coor, ptsa, ptsb, ptsc, wgts, eps)

    @staticmethod
    def convertLongLatTo3D(longitude, latitude, dilate=1., radius_arg=1.):
        r"""

        GeometryHelper::convertLongLatTo3D
        Returns the Vector of Longitude/Latitude corresponding to Sample coordinates in
        3-D  

        Parameters
        ----------
        * `longitude` :  
            Array of longitude values  
        * `latitude` :  
            Array of latitude values  
        * `dilate` :  
            Dilation factor  
        * `radius_arg` :  
            Radius (if not defined, taken from variety definition)  

        Returns
        -------  

        """
        return _gstlearn.GeometryHelper_convertLongLatTo3D(longitude, latitude, dilate, radius_arg)

    @staticmethod
    def convert3DToLongLat(x, y, z, radius_arg=1.):
        r"""

        GeometryHelper::convert3DToLongLat
        """
        return _gstlearn.GeometryHelper_convert3DToLongLat(x, y, z, radius_arg)

    @staticmethod
    def convertCart2Sph(x, y, z, rlong, rlat, radius_arg=1.):
        r"""

        GeometryHelper::convertCart2Sph
        Convert the cartesian coordinates into spherical coordinates  

        Parameters
        ----------
        * `x` :  
            First cartesian coordinate  
        * `y` :  
            Second cartesian coordinate  
        * `z` :  
            Third cartesian coordinate  
        * `radius_arg` :  
            Radius of the sphere (Earth if TEST)  
        * `rlong` :  
            Longitude (in degrees)  
        * `rlat` :  
            Latitude (in degrees)  

        """
        return _gstlearn.GeometryHelper_convertCart2Sph(x, y, z, rlong, rlat, radius_arg)

    @staticmethod
    def convertSph2Cart(rlong, rlat, x, y, z, radius_arg=1.):
        r"""

        GeometryHelper::convertSph2Cart
        Convert the spherical coordinates into cartesian coordinates  

        Parameters
        ----------
        * `rlong` :  
            Longitude (in degrees)  
        * `rlat` :  
            Latitude (in degrees)  
        * `radius_arg` :  
            radius of the sphere (Earth if TEST)  
        * `x` :  
            First cartesian coordinate  
        * `y` :  
            Second cartesian coordinate  
        * `z` :  
            Third cartesian coordinate  

        """
        return _gstlearn.GeometryHelper_convertSph2Cart(rlong, rlat, x, y, z, radius_arg)

    @staticmethod
    def gradXYToRotmat(dzoverdx, dzoverdy):
        r"""

        GeometryHelper::gradXYToRotmat
        Calculate the rotation matrix starting from the partial derivatives along X and
        Y of a tilted plane  

        Parameters
        ----------
        * `dzoverdx` :  
            Partial derivative along X  
        * `dzoverdy` :  
            Partial derivative along Y  

        """
        return _gstlearn.GeometryHelper_gradXYToRotmat(dzoverdx, dzoverdy)

    @staticmethod
    def getDirectionsInR3(U):
        r"""

        GeometryHelper::getDirectionsInR3
        """
        return _gstlearn.GeometryHelper_getDirectionsInR3(U)

    @staticmethod
    def getDirectionsInRn(U):
        r"""

        GeometryHelper::getDirectionsInRn
        Function to compute directions in Rd  

        Parameters
        ----------
        * `U` :  
            a matrix [n, d] of uniform values between [0,1]. 'n' is the number of
            direction and 'd' is the dimension of the space  

        Returns
        -------
        A vector of a matrix [n, d] of the coordinates of the 'n' directions in the
        Euclidean space Rd.  

        """
        return _gstlearn.GeometryHelper_getDirectionsInRn(U)

    @staticmethod
    def formatAngle(anglein, basis=360.):
        r"""

        GeometryHelper::formatAngle
        Format an Angle to be lying in [0, basis]  

        Parameters
        ----------
        * `anglein` :  
            Input angle value  
        * `basis` :  
            Basis (should be 360 by default; could be 180 for variogram or covariance)  

        Returns
        -------  

        """
        return _gstlearn.GeometryHelper_formatAngle(anglein, basis)

    @staticmethod
    def formatAngles(anglesin, basis=360.):
        r"""

        GeometryHelper::formatAngles
        """
        return _gstlearn.GeometryHelper_formatAngles(anglesin, basis)

    @staticmethod
    def rayTriangleIntersect(dir, v0, v1, v2):
        r"""

        GeometryHelper::rayTriangleIntersect
        """
        return _gstlearn.GeometryHelper_rayTriangleIntersect(dir, v0, v1, v2)

    @staticmethod
    def sphBarCoord(sphPts, apices, meshes):
        r"""

        GeometryHelper::sphBarCoord
        Calculate the Barycenter coordinates of points with in the Spherical Meshing  

        Parameters
        ----------
        * `sphPts` :  
            Coordinates of target samples (dim = np * 3)  
        * `apices` :  
            Coordinates of the apices of the Meshing  
        * `meshes` :  
            Mesh information of the Meshing  

        Returns
        -------
        A vector of barycenters (dimension = 4 * np) where  

        *   1: rank of the triangle  
        *   2, 3, 4: barycentric coordinates  

        """
        return _gstlearn.GeometryHelper_sphBarCoord(sphPts, apices, meshes)

    @staticmethod
    def getCosineAngularTolerance(tolang):
        r"""

        GeometryHelper::getCosineAngularTolerance
        Returns the cosine of the angular tolerance  

        Parameters
        ----------
        * `tolang` :  
            Angular tolerance  

        """
        return _gstlearn.GeometryHelper_getCosineAngularTolerance(tolang)

    @staticmethod
    def getEllipse(center, rx, ry, theta, count=360):
        r"""

        GeometryHelper::getEllipse
        """
        return _gstlearn.GeometryHelper_getEllipse(center, rx, ry, theta, count)

    def __init__(self):
        r"""


        C++ includes: GeometryHelper.hpp

        """
        _gstlearn.GeometryHelper_swiginit(self, _gstlearn.new_GeometryHelper())
    __swig_destroy__ = _gstlearn.delete_GeometryHelper

# Register GeometryHelper in _gstlearn:
_gstlearn.GeometryHelper_swigregister(GeometryHelper)
class GH(GeometryHelper):
    r"""


    C++ includes: GeometryHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        C++ includes: GeometryHelper.hpp

        """
        _gstlearn.GH_swiginit(self, _gstlearn.new_GH())
    __swig_destroy__ = _gstlearn.delete_GH

# Register GH in _gstlearn:
_gstlearn.GH_swigregister(GH)
class Rotation(AStringable):
    r"""


    TODO : public ASpaceObject.  

    C++ includes: Rotation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Rotation::Rotation
        """
        _gstlearn.Rotation_swiginit(self, _gstlearn.new_Rotation(*args))
    __swig_destroy__ = _gstlearn.delete_Rotation

    @staticmethod
    def isMatrixRotation(rotmat, verbose):
        r"""

        Rotation::isMatrixRotation
        Check if a matrix is a rotation matrix  

        Returns
        -------
        true if the matrix is a rotation matrix; false otherwise  

        Parameters
        ----------
        * `rotmat` :  
            Square matrix to be checked  
        * `verbose` :  
            1 for the verbose option  

        remark: A rotation matrix must be orthogonal with determinant equal to 1  

        """
        return _gstlearn.Rotation_isMatrixRotation(rotmat, verbose)

    def getNDim(self):
        r"""

        Rotation::getNDim
        """
        return _gstlearn.Rotation_getNDim(self)

    def isRotated(self):
        r"""

        Rotation::isRotated
        """
        return _gstlearn.Rotation_isRotated(self)

    def getAngles(self):
        r"""

        Rotation::getAngles
        """
        return _gstlearn.Rotation_getAngles(self)

    def getAngle(self, idim):
        r"""

        Rotation::getAngle
        """
        return _gstlearn.Rotation_getAngle(self, idim)

    def getDerivativesInPlace(self, res):
        r"""

        Rotation::getDerivativesInPlace
        """
        return _gstlearn.Rotation_getDerivativesInPlace(self, res)

    def getDerivatives(self):
        r"""

        Rotation::getDerivatives
        """
        return _gstlearn.Rotation_getDerivatives(self)

    def resetFromSpaceDimension(self, ndim):
        r"""

        Rotation::resetFromSpaceDimension
        """
        return _gstlearn.Rotation_resetFromSpaceDimension(self, ndim)

    def toString(self, strfmt=None):
        r"""

        Rotation::toString
        """
        return _gstlearn.Rotation_toString(self, strfmt)

    def setMatrixDirect(self, rotmat):
        r"""

        Rotation::setMatrixDirect
        """
        return _gstlearn.Rotation_setMatrixDirect(self, rotmat)

    def setMatrixDirectVec(self, rotmat):
        r"""

        Rotation::setMatrixDirectVec
        """
        return _gstlearn.Rotation_setMatrixDirectVec(self, rotmat)

    def setAngles(self, angles):
        r"""

        Rotation::setAngles
        """
        return _gstlearn.Rotation_setAngles(self, angles)

    def setIdentity(self):
        r"""

        Rotation::setIdentity
        """
        return _gstlearn.Rotation_setIdentity(self)

    def rotateDirect(self, inv, outv):
        r"""

        Rotation::rotateDirect
        """
        return _gstlearn.Rotation_rotateDirect(self, inv, outv)

    def rotateInverse(self, inv, outv):
        r"""

        Rotation::rotateInverse
        """
        return _gstlearn.Rotation_rotateInverse(self, inv, outv)

    def isIdentity(self):
        r"""

        Rotation::isIdentity
        """
        return _gstlearn.Rotation_isIdentity(self)

    def isSame(self, rot):
        r"""

        Rotation::isSame
        """
        return _gstlearn.Rotation_isSame(self, rot)

    def getMatrixDirectVec(self):
        r"""

        Rotation::getMatrixDirectVec
        """
        return _gstlearn.Rotation_getMatrixDirectVec(self)

    def getMatrixInverseVec(self):
        r"""

        Rotation::getMatrixInverseVec
        """
        return _gstlearn.Rotation_getMatrixInverseVec(self)

    def getMatrixDirect(self, *args):
        r"""

        Rotation::getMatrixDirect
        """
        return _gstlearn.Rotation_getMatrixDirect(self, *args)

    def getMatrixInverse(self, *args):
        r"""

        Rotation::getMatrixInverse
        """
        return _gstlearn.Rotation_getMatrixInverse(self, *args)

# Register Rotation in _gstlearn:
_gstlearn.Rotation_swigregister(Rotation)
class ABiTargetCheck(AStringable, ICloneable):
    r"""


    This class performs the test between two Space Points (usually the target point
    first and the tentative point second) The function isOK returns TRUE if the two
    space points are "comparable" with respect to the current criterion Examples:  

    *   if the criterion is based on FAULTS, the method isOK returns TRUE if the two
        space points are not separated by any fault segment  
    *   if the criterion is based on DISTANCE, the method isOK returns TRUE if the
        distance between the two space points is smaller than a threshold distance
        (registered as a member of the BiTargetCheckDistance class)  

    C++ includes: ABiTargetCheck.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ABiTargetCheck::ABiTargetCheck
        """
        if self.__class__ == ABiTargetCheck:
            _self = None
        else:
            _self = self
        _gstlearn.ABiTargetCheck_swiginit(self, _gstlearn.new_ABiTargetCheck(_self, *args))
    __swig_destroy__ = _gstlearn.delete_ABiTargetCheck

    def isOK(self, T1, T2):
        r"""

        ABiTargetCheck::isOK
        """
        return _gstlearn.ABiTargetCheck_isOK(self, T1, T2)

    def isValid(self, dbin, dbout):
        r"""

        ABiTargetCheck::isValid
        """
        return _gstlearn.ABiTargetCheck_isValid(self, dbin, dbout)

    def __repr__(self):
        return _gstlearn.ABiTargetCheck___repr__(self)
    def __disown__(self):
        self.this.disown()
        _gstlearn.disown_ABiTargetCheck(self)
        return weakref.proxy(self)

# Register ABiTargetCheck in _gstlearn:
_gstlearn.ABiTargetCheck_swigregister(ABiTargetCheck)
class BiTargetCheckBench(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckBench.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckBench::BiTargetCheckBench
        """
        _gstlearn.BiTargetCheckBench_swiginit(self, _gstlearn.new_BiTargetCheckBench(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckBench

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckBench::isOK
        """
        return _gstlearn.BiTargetCheckBench_isOK(self, T1, T2)

    def isValid(self, dbin, dbout):
        r"""

        BiTargetCheckBench::isValid
        """
        return _gstlearn.BiTargetCheckBench_isValid(self, dbin, dbout)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckBench_clone(self)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckBench::toString
        ICloneable Interface.  

        Interface to AStringable  

        """
        return _gstlearn.BiTargetCheckBench_toString(self, strfmt)

    @staticmethod
    def create(idim_bench, width):
        r"""

        BiTargetCheckBench::create
        """
        return _gstlearn.BiTargetCheckBench_create(idim_bench, width)

    def getWidth(self):
        r"""

        BiTargetCheckBench::getWidth
        """
        return _gstlearn.BiTargetCheckBench_getWidth(self)

    def __repr__(self):
        return _gstlearn.BiTargetCheckBench___repr__(self)

# Register BiTargetCheckBench in _gstlearn:
_gstlearn.BiTargetCheckBench_swigregister(BiTargetCheckBench)
class BiTargetCheckCell(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckCell.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckCell::BiTargetCheckCell
        """
        _gstlearn.BiTargetCheckCell_swiginit(self, _gstlearn.new_BiTargetCheckCell(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckCell

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckCell::isOK
        """
        return _gstlearn.BiTargetCheckCell_isOK(self, T1, T2)

    def isValid(self, dbin, dbout):
        r"""

        BiTargetCheckCell::isValid
        """
        return _gstlearn.BiTargetCheckCell_isValid(self, dbin, dbout)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckCell_clone(self)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckCell::toString
        ICloneable Interface.  

        Interface to AStringable  

        """
        return _gstlearn.BiTargetCheckCell_toString(self, strfmt)

    @staticmethod
    def create(dbgrid=None):
        r"""

        BiTargetCheckCell::create
        """
        return _gstlearn.BiTargetCheckCell_create(dbgrid)

    def __repr__(self):
        return _gstlearn.BiTargetCheckCell___repr__(self)

# Register BiTargetCheckCell in _gstlearn:
_gstlearn.BiTargetCheckCell_swigregister(BiTargetCheckCell)
class BiTargetCheckDistance(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckDistance.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckDistance::BiTargetCheckDistance
        """
        _gstlearn.BiTargetCheckDistance_swiginit(self, _gstlearn.new_BiTargetCheckDistance(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckDistance

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckDistance_clone(self)

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckDistance::isOK
        ICloneable Interface.  

        """
        return _gstlearn.BiTargetCheckDistance_isOK(self, T1, T2)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        BiTargetCheckDistance::create
        """
        return _gstlearn.BiTargetCheckDistance_create(*args, **kwargs)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckDistance::toString
        Interface to AStringable.  

        """
        return _gstlearn.BiTargetCheckDistance_toString(self, strfmt)

    def getNDim(self):
        r"""

        BiTargetCheckDistance::getNDim
        """
        return _gstlearn.BiTargetCheckDistance_getNDim(self)

    def getAnisoCoeffs(self):
        r"""

        BiTargetCheckDistance::getAnisoCoeffs
        """
        return _gstlearn.BiTargetCheckDistance_getAnisoCoeffs(self)

    def getAnisoCoeff(self, i):
        r"""

        BiTargetCheckDistance::getAnisoCoeff
        """
        return _gstlearn.BiTargetCheckDistance_getAnisoCoeff(self, i)

    def getAnisoRotMats(self):
        r"""

        BiTargetCheckDistance::getAnisoRotMats
        """
        return _gstlearn.BiTargetCheckDistance_getAnisoRotMats(self)

    def getAnisoRotMat(self, i):
        r"""

        BiTargetCheckDistance::getAnisoRotMat
        """
        return _gstlearn.BiTargetCheckDistance_getAnisoRotMat(self, i)

    def getFlagAniso(self):
        r"""

        BiTargetCheckDistance::getFlagAniso
        """
        return _gstlearn.BiTargetCheckDistance_getFlagAniso(self)

    def getFlagRotation(self):
        r"""

        BiTargetCheckDistance::getFlagRotation
        """
        return _gstlearn.BiTargetCheckDistance_getFlagRotation(self)

    def getRadius(self):
        r"""

        BiTargetCheckDistance::getRadius
        """
        return _gstlearn.BiTargetCheckDistance_getRadius(self)

    def setNDim(self, ndim):
        r"""

        BiTargetCheckDistance::setNDim
        """
        return _gstlearn.BiTargetCheckDistance_setNDim(self, ndim)

    def setAnisoCoeffs(self, anisoCoeffs):
        r"""

        BiTargetCheckDistance::setAnisoCoeffs
        """
        return _gstlearn.BiTargetCheckDistance_setAnisoCoeffs(self, anisoCoeffs)

    def setAnisoRotMat(self, anisoRotMat):
        r"""

        BiTargetCheckDistance::setAnisoRotMat
        """
        return _gstlearn.BiTargetCheckDistance_setAnisoRotMat(self, anisoRotMat)

    def setFlagAniso(self, flagAniso):
        r"""

        BiTargetCheckDistance::setFlagAniso
        """
        return _gstlearn.BiTargetCheckDistance_setFlagAniso(self, flagAniso)

    def setFlagRotation(self, flagRotation):
        r"""

        BiTargetCheckDistance::setFlagRotation
        """
        return _gstlearn.BiTargetCheckDistance_setFlagRotation(self, flagRotation)

    def setRadius(self, radius):
        r"""

        BiTargetCheckDistance::setRadius
        """
        return _gstlearn.BiTargetCheckDistance_setRadius(self, radius)

    def getDistance(self):
        r"""

        BiTargetCheckDistance::getDistance
        """
        return _gstlearn.BiTargetCheckDistance_getDistance(self)

    def getIncr(self):
        r"""

        BiTargetCheckDistance::getIncr
        """
        return _gstlearn.BiTargetCheckDistance_getIncr(self)

    def getNormalizedDistance(self, dd):
        r"""

        BiTargetCheckDistance::getNormalizedDistance
        """
        return _gstlearn.BiTargetCheckDistance_getNormalizedDistance(self, dd)

    def __repr__(self):
        return _gstlearn.BiTargetCheckDistance___repr__(self)

# Register BiTargetCheckDistance in _gstlearn:
_gstlearn.BiTargetCheckDistance_swigregister(BiTargetCheckDistance)
class BiTargetCheckFaults(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckFaults.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckFaults::BiTargetCheckFaults
        """
        _gstlearn.BiTargetCheckFaults_swiginit(self, _gstlearn.new_BiTargetCheckFaults(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckFaults

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckFaults_clone(self)

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckFaults::isOK
        ICloneable Interface.  

        """
        return _gstlearn.BiTargetCheckFaults_isOK(self, T1, T2)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckFaults::toString
        Interface to AStringable.  

        """
        return _gstlearn.BiTargetCheckFaults_toString(self, strfmt)

    @staticmethod
    def create(faults):
        r"""

        BiTargetCheckFaults::create
        """
        return _gstlearn.BiTargetCheckFaults_create(faults)

    def __repr__(self):
        return _gstlearn.BiTargetCheckFaults___repr__(self)

# Register BiTargetCheckFaults in _gstlearn:
_gstlearn.BiTargetCheckFaults_swigregister(BiTargetCheckFaults)
class BiTargetCheckCode(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckCode.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckCode::BiTargetCheckCode
        """
        _gstlearn.BiTargetCheckCode_swiginit(self, _gstlearn.new_BiTargetCheckCode(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckCode

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckCode_clone(self)

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckCode::isOK
        ICloneable Interface.  

        """
        return _gstlearn.BiTargetCheckCode_isOK(self, T1, T2)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckCode::toString
        Interface to AStringable.  

        """
        return _gstlearn.BiTargetCheckCode_toString(self, strfmt)

    @staticmethod
    def create(optcode=1, tolcode=1.e-6):
        r"""

        BiTargetCheckCode::create
        """
        return _gstlearn.BiTargetCheckCode_create(optcode, tolcode)

    def __repr__(self):
        return _gstlearn.BiTargetCheckCode___repr__(self)

# Register BiTargetCheckCode in _gstlearn:
_gstlearn.BiTargetCheckCode_swigregister(BiTargetCheckCode)
class BiTargetCheckDate(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckDate.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckDate::BiTargetCheckDate
        """
        _gstlearn.BiTargetCheckDate_swiginit(self, _gstlearn.new_BiTargetCheckDate(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckDate

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckDate_clone(self)

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckDate::isOK
        ICloneable Interface.  

        """
        return _gstlearn.BiTargetCheckDate_isOK(self, T1, T2)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckDate::toString
        Interface to AStringable.  

        """
        return _gstlearn.BiTargetCheckDate_toString(self, strfmt)

    @staticmethod
    def create(deltamin, deltamax):
        r"""

        BiTargetCheckDate::create
        """
        return _gstlearn.BiTargetCheckDate_create(deltamin, deltamax)

    def __repr__(self):
        return _gstlearn.BiTargetCheckDate___repr__(self)

# Register BiTargetCheckDate in _gstlearn:
_gstlearn.BiTargetCheckDate_swigregister(BiTargetCheckDate)
class BiTargetCheckGeometry(ABiTargetCheck):
    r"""


    C++ includes: BiTargetCheckGeometry.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BiTargetCheckGeometry::BiTargetCheckGeometry
        """
        _gstlearn.BiTargetCheckGeometry_swiginit(self, _gstlearn.new_BiTargetCheckGeometry(*args))
    __swig_destroy__ = _gstlearn.delete_BiTargetCheckGeometry

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.BiTargetCheckGeometry_clone(self)

    def isOK(self, T1, T2):
        r"""

        BiTargetCheckGeometry::isOK
        ICloneable Interface.  

        """
        return _gstlearn.BiTargetCheckGeometry_isOK(self, T1, T2)

    def toString(self, strfmt=None):
        r"""

        BiTargetCheckGeometry::toString
        Interface to AStringable.  

        """
        return _gstlearn.BiTargetCheckGeometry_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        BiTargetCheckGeometry::create
        """
        return _gstlearn.BiTargetCheckGeometry_create(*args, **kwargs)

    def getDist(self):
        r"""

        BiTargetCheckGeometry::getDist
        """
        return _gstlearn.BiTargetCheckGeometry_getDist(self)

    def __repr__(self):
        return _gstlearn.BiTargetCheckGeometry___repr__(self)

# Register BiTargetCheckGeometry in _gstlearn:
_gstlearn.BiTargetCheckGeometry_swigregister(BiTargetCheckGeometry)
class AArray(AStringable):
    r"""


    C++ includes: AArray.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        AArray::AArray
        """
        _gstlearn.AArray_swiginit(self, _gstlearn.new_AArray(*args))
    __swig_destroy__ = _gstlearn.delete_AArray

    def toString(self, strfmt=None):
        r"""

        AArray::toString
        Interface for AStringable.  

        """
        return _gstlearn.AArray_toString(self, strfmt)

    def init(self, ndims):
        r"""

        AArray::init
        """
        return _gstlearn.AArray_init(self, ndims)

    def indiceToRank(self, indice):
        r"""

        AArray::indiceToRank
        """
        return _gstlearn.AArray_indiceToRank(self, indice)

    def rankToIndice(self, *args):
        r"""

        AArray::rankToIndice
        """
        return _gstlearn.AArray_rankToIndice(self, *args)

    def getNDim(self):
        r"""

        AArray::getNDim
        """
        return _gstlearn.AArray_getNDim(self)

    def getNPixels(self):
        r"""

        AArray::getNPixels
        """
        return _gstlearn.AArray_getNPixels(self)

    def getNDimsExt(self, ndimMax):
        r"""

        AArray::getNDimsExt
        """
        return _gstlearn.AArray_getNDimsExt(self, ndimMax)

    def getNDims(self, *args):
        r"""

        AArray::getNDims
        """
        return _gstlearn.AArray_getNDims(self, *args)

    def __repr__(self):
        return _gstlearn.AArray___repr__(self)

# Register AArray in _gstlearn:
_gstlearn.AArray_swigregister(AArray)
class Array(AArray):
    r"""


    C++ includes: Array.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Array::Array
        """
        _gstlearn.Array_swiginit(self, _gstlearn.new_Array(*args))
    __swig_destroy__ = _gstlearn.delete_Array

    def init(self, ndims):
        r"""

        Array::init
        """
        return _gstlearn.Array_init(self, ndims)

    def getValue(self, indice):
        r"""

        Array::getValue
        """
        return _gstlearn.Array_getValue(self, indice)

    def setValue(self, indice, value):
        r"""

        Array::setValue
        """
        return _gstlearn.Array_setValue(self, indice, value)

    def getValues(self):
        r"""

        Array::getValues
        """
        return _gstlearn.Array_getValues(self)

    def setValues(self, values):
        r"""

        Array::setValues
        """
        return _gstlearn.Array_setValues(self, values)

    def __repr__(self):
        return _gstlearn.Array___repr__(self)

# Register Array in _gstlearn:
_gstlearn.Array_swigregister(Array)
class BImage(AArray):
    r"""


    C++ includes: BImage.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BImage::BImage
        """
        _gstlearn.BImage_swiginit(self, _gstlearn.new_BImage(*args))
    __swig_destroy__ = _gstlearn.delete_BImage

    def toString(self, strfmt=None):
        r"""

        BImage::toString
        Interface for AStringable.  

        """
        return _gstlearn.BImage_toString(self, strfmt)

    def init(self, ndims):
        r"""

        BImage::init
        """
        return _gstlearn.BImage_init(self, ndims)

    def getValues(self):
        r"""

        BImage::getValues
        """
        return _gstlearn.BImage_getValues(self)

    def setValues(self, values):
        r"""

        BImage::setValues
        """
        return _gstlearn.BImage_setValues(self, values)

    def getBImage(self, i, j, k):
        r"""

        BImage::getBImage
        """
        return _gstlearn.BImage_getBImage(self, i, j, k)

    def getOffset(self, i, j, k):
        r"""

        BImage::getOffset
        """
        return _gstlearn.BImage_getOffset(self, i, j, k)

    def getMaskoff(self, i, j, k):
        r"""

        BImage::getMaskoff
        """
        return _gstlearn.BImage_getMaskoff(self, i, j, k)

    def setValue(self, i, c):
        r"""

        BImage::setValue
        """
        return _gstlearn.BImage_setValue(self, i, c)

    def getValue(self, *args):
        r"""

        BImage::getValue
        """
        return _gstlearn.BImage_getValue(self, *args)

    def setMaskoff(self, i, j, k):
        r"""

        BImage::setMaskoff
        """
        return _gstlearn.BImage_setMaskoff(self, i, j, k)

    def setOffset(self, i, j, k):
        r"""

        BImage::setOffset
        """
        return _gstlearn.BImage_setOffset(self, i, j, k)

    def getAllocSize(self):
        r"""

        BImage::getAllocSize
        """
        return _gstlearn.BImage_getAllocSize(self)

    def isInside(self, i, j, k):
        r"""

        BImage::isInside
        """
        return _gstlearn.BImage_isInside(self, i, j, k)

    def getAddress(self, i, j, k):
        r"""

        BImage::getAddress
        """
        return _gstlearn.BImage_getAddress(self, i, j, k)

    def __repr__(self):
        return _gstlearn.BImage___repr__(self)

# Register BImage in _gstlearn:
_gstlearn.BImage_swigregister(BImage)
class BImageStringFormat(AStringFormat):
    r"""


    C++ includes: BImageStringFormat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        BImageStringFormat::BImageStringFormat
        """
        _gstlearn.BImageStringFormat_swiginit(self, _gstlearn.new_BImageStringFormat(*args))
    __swig_destroy__ = _gstlearn.delete_BImageStringFormat

    def getCharOne(self):
        r"""

        BImageStringFormat::getCharOne
        """
        return _gstlearn.BImageStringFormat_getCharOne(self)

    def getCharZero(self):
        r"""

        BImageStringFormat::getCharZero
        """
        return _gstlearn.BImageStringFormat_getCharZero(self)

    def getIndMin(self, *args):
        r"""

        BImageStringFormat::getIndMin
        """
        return _gstlearn.BImageStringFormat_getIndMin(self, *args)

    def getIndMax(self, *args):
        r"""

        BImageStringFormat::getIndMax
        """
        return _gstlearn.BImageStringFormat_getIndMax(self, *args)

# Register BImageStringFormat in _gstlearn:
_gstlearn.BImageStringFormat_swigregister(BImageStringFormat)
class Faults(AStringable, ASerializable):
    r"""


    C++ includes: Faults.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Faults::Faults
        """
        _gstlearn.Faults_swiginit(self, _gstlearn.new_Faults(*args))
    __swig_destroy__ = _gstlearn.delete_Faults

    def toString(self, strfmt=None):
        r"""

        Faults::toString
        Interface for AStringable.  

        """
        return _gstlearn.Faults_toString(self, strfmt)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        Faults::createFromNF
        """
        return _gstlearn.Faults_createFromNF(NFFilename, verbose)

    def getNFaults(self):
        r"""

        Faults::getNFaults
        """
        return _gstlearn.Faults_getNFaults(self)

    def addFault(self, fault):
        r"""

        Faults::addFault
        """
        return _gstlearn.Faults_addFault(self, fault)

    def getFaults(self):
        r"""

        Faults::getFaults
        """
        return _gstlearn.Faults_getFaults(self)

    def getFault(self, ifault):
        r"""

        Faults::getFault
        """
        return _gstlearn.Faults_getFault(self, ifault)

    def isSplitByFault(self, xt1, yt1, xt2, yt2):
        r"""

        Faults::isSplitByFault
        """
        return _gstlearn.Faults_isSplitByFault(self, xt1, yt1, xt2, yt2)

    def isSplitByFaultSP(self, P1, P2):
        r"""

        Faults::isSplitByFaultSP
        """
        return _gstlearn.Faults_isSplitByFaultSP(self, P1, P2)

    def __repr__(self):
        return _gstlearn.Faults___repr__(self)

# Register Faults in _gstlearn:
_gstlearn.Faults_swigregister(Faults)
class ShapeParameter(AStringable):
    r"""


    C++ includes: ShapeParameter.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeParameter::ShapeParameter
        """
        _gstlearn.ShapeParameter_swiginit(self, _gstlearn.new_ShapeParameter(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeParameter

    def toString(self, strfmt=None):
        r"""

        ShapeParameter::toString
        Interface to AStringable.  

        """
        return _gstlearn.ShapeParameter_toString(self, strfmt)

    def getLaw(self):
        r"""

        ShapeParameter::getLaw
        """
        return _gstlearn.ShapeParameter_getLaw(self)

    def getValarg(self, *args):
        r"""

        ShapeParameter::getValarg
        """
        return _gstlearn.ShapeParameter_getValarg(self, *args)

    def getNbValarg(self):
        r"""

        ShapeParameter::getNbValarg
        """
        return _gstlearn.ShapeParameter_getNbValarg(self)

    def setLaw(self, law):
        r"""

        ShapeParameter::setLaw
        """
        return _gstlearn.ShapeParameter_setLaw(self, law)

    def setValarg(self, iarg, value):
        r"""

        ShapeParameter::setValarg
        """
        return _gstlearn.ShapeParameter_setValarg(self, iarg, value)

    def generateValue(self):
        r"""

        ShapeParameter::generateValue
        """
        return _gstlearn.ShapeParameter_generateValue(self)

    def __repr__(self):
        return _gstlearn.ShapeParameter___repr__(self)

# Register ShapeParameter in _gstlearn:
_gstlearn.ShapeParameter_swigregister(ShapeParameter)
class AShape(AStringable, ICloneable):
    r"""


    Class defining the generic shape of the objects for Boolean Model  

    C++ includes: AShape.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AShape

    def toString(self, strfmt=None):
        r"""

        AShape::toString
        Interface to AStringable.  

        """
        return _gstlearn.AShape_toString(self, strfmt)

    def getType(self):
        r"""

        AShape::getType
        Interface for AShape.  

        """
        return _gstlearn.AShape_getType(self)

    def getNParams(self):
        r"""

        AShape::getNParams
        """
        return _gstlearn.AShape_getNParams(self)

    def getFlagCutZ(self):
        r"""

        AShape::getFlagCutZ
        """
        return _gstlearn.AShape_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        AShape::generateObject
        """
        return _gstlearn.AShape_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        AShape::belongObject
        """
        return _gstlearn.AShape_belongObject(self, coor, object)

    def getFactorX2Y(self):
        r"""

        AShape::getFactorX2Y
        """
        return _gstlearn.AShape_getFactorX2Y(self)

    def getFactorX2Z(self):
        r"""

        AShape::getFactorX2Z
        """
        return _gstlearn.AShape_getFactorX2Z(self)

    def getFactorY2Z(self):
        r"""

        AShape::getFactorY2Z
        """
        return _gstlearn.AShape_getFactorY2Z(self)

    def getProportion(self):
        r"""

        AShape::getProportion
        """
        return _gstlearn.AShape_getProportion(self)

    def getParamName(self, ipar):
        r"""

        AShape::getParamName
        """
        return _gstlearn.AShape_getParamName(self, ipar)

    def getParam(self, *args):
        r"""

        AShape::getParam
        """
        return _gstlearn.AShape_getParam(self, *args)

    def setFactorX2Y(self, factorX2Y):
        r"""

        AShape::setFactorX2Y
        """
        return _gstlearn.AShape_setFactorX2Y(self, factorX2Y)

    def setFactorX2Z(self, factorX2Z):
        r"""

        AShape::setFactorX2Z
        """
        return _gstlearn.AShape_setFactorX2Z(self, factorX2Z)

    def setFactorY2Z(self, factorY2Z):
        r"""

        AShape::setFactorY2Z
        """
        return _gstlearn.AShape_setFactorY2Z(self, factorY2Z)

    def setProportion(self, proportion):
        r"""

        AShape::setProportion
        """
        return _gstlearn.AShape_setProportion(self, proportion)

    def setParamName(self, ipar, name):
        r"""

        AShape::setParamName
        """
        return _gstlearn.AShape_setParamName(self, ipar, name)

    def setParam(self, ipar, iarg, value):
        r"""

        AShape::setParam
        """
        return _gstlearn.AShape_setParam(self, ipar, iarg, value)

    def setParamDefault(self, ipar, name, value):
        r"""

        AShape::setParamDefault
        """
        return _gstlearn.AShape_setParamDefault(self, ipar, name, value)

    def setLaw(self, ipar, law):
        r"""

        AShape::setLaw
        """
        return _gstlearn.AShape_setLaw(self, ipar, law)

    def initParams(self, count):
        r"""

        AShape::initParams
        """
        return _gstlearn.AShape_initParams(self, count)

    def generateParam(self, ipar):
        r"""

        AShape::generateParam
        """
        return _gstlearn.AShape_generateParam(self, ipar)

    def __repr__(self):
        return _gstlearn.AShape___repr__(self)

# Register AShape in _gstlearn:
_gstlearn.AShape_swigregister(AShape)
class ShapeParallelepiped(AShape):
    r"""


    C++ includes: ShapeParallelepiped.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeParallelepiped::ShapeParallelepiped
        """
        _gstlearn.ShapeParallelepiped_swiginit(self, _gstlearn.new_ShapeParallelepiped(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeParallelepiped

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShapeParallelepiped_clone(self)

    def getType(self):
        r"""

        ShapeParallelepiped::getType
        Interface for ICloneable.  

        """
        return _gstlearn.ShapeParallelepiped_getType(self)

    def getNParams(self):
        r"""

        ShapeParallelepiped::getNParams
        """
        return _gstlearn.ShapeParallelepiped_getNParams(self)

    def getFlagCutZ(self):
        r"""

        ShapeParallelepiped::getFlagCutZ
        """
        return _gstlearn.ShapeParallelepiped_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        ShapeParallelepiped::generateObject
        Generate the geometry of the object  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  

        """
        return _gstlearn.ShapeParallelepiped_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        ShapeParallelepiped::belongObject
        Check if the pixel (x,y,z) belongs to the object  

        Returns
        -------
        1 if the pixel is in the grain, 0 if it is in the pore  

        """
        return _gstlearn.ShapeParallelepiped_belongObject(self, coor, object)

    def __repr__(self):
        return _gstlearn.ShapeParallelepiped___repr__(self)

# Register ShapeParallelepiped in _gstlearn:
_gstlearn.ShapeParallelepiped_swigregister(ShapeParallelepiped)
class ShapeEllipsoid(AShape):
    r"""


    C++ includes: ShapeEllipsoid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeEllipsoid::ShapeEllipsoid
        """
        _gstlearn.ShapeEllipsoid_swiginit(self, _gstlearn.new_ShapeEllipsoid(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeEllipsoid

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShapeEllipsoid_clone(self)

    def getType(self):
        r"""

        ShapeEllipsoid::getType
        Interface for ICloneable.  

        """
        return _gstlearn.ShapeEllipsoid_getType(self)

    def getNParams(self):
        r"""

        ShapeEllipsoid::getNParams
        """
        return _gstlearn.ShapeEllipsoid_getNParams(self)

    def getFlagCutZ(self):
        r"""

        ShapeEllipsoid::getFlagCutZ
        """
        return _gstlearn.ShapeEllipsoid_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        ShapeEllipsoid::generateObject
        Generate the geometry of the object  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  

        """
        return _gstlearn.ShapeEllipsoid_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        ShapeEllipsoid::belongObject
        Check if the pixel (x,y,z) belongs to the object  

        Returns
        -------
        1 if the pixel is in the grain, 0 if it is in the pore  

        """
        return _gstlearn.ShapeEllipsoid_belongObject(self, coor, object)

    def __repr__(self):
        return _gstlearn.ShapeEllipsoid___repr__(self)

# Register ShapeEllipsoid in _gstlearn:
_gstlearn.ShapeEllipsoid_swigregister(ShapeEllipsoid)
class ShapeParaboloid(AShape):
    r"""


    C++ includes: ShapeParaboloid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeParaboloid::ShapeParaboloid
        """
        _gstlearn.ShapeParaboloid_swiginit(self, _gstlearn.new_ShapeParaboloid(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeParaboloid

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShapeParaboloid_clone(self)

    def getType(self):
        r"""

        ShapeParaboloid::getType
        Interface for ICloneable.  

        """
        return _gstlearn.ShapeParaboloid_getType(self)

    def getNParams(self):
        r"""

        ShapeParaboloid::getNParams
        """
        return _gstlearn.ShapeParaboloid_getNParams(self)

    def getFlagCutZ(self):
        r"""

        ShapeParaboloid::getFlagCutZ
        """
        return _gstlearn.ShapeParaboloid_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        ShapeParaboloid::generateObject
        Generate the geometry of the object  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  

        """
        return _gstlearn.ShapeParaboloid_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        ShapeParaboloid::belongObject
        Check if the pixel (x,y,z) belongs to the object  

        Returns
        -------
        1 if the pixel is in the grain, 0 if it is in the pore  

        """
        return _gstlearn.ShapeParaboloid_belongObject(self, coor, object)

    def __repr__(self):
        return _gstlearn.ShapeParaboloid___repr__(self)

# Register ShapeParaboloid in _gstlearn:
_gstlearn.ShapeParaboloid_swigregister(ShapeParaboloid)
class ShapeHalfEllipsoid(AShape):
    r"""


    C++ includes: ShapeHalfEllipsoid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeHalfEllipsoid::ShapeHalfEllipsoid
        """
        _gstlearn.ShapeHalfEllipsoid_swiginit(self, _gstlearn.new_ShapeHalfEllipsoid(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeHalfEllipsoid

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShapeHalfEllipsoid_clone(self)

    def getType(self):
        r"""

        ShapeHalfEllipsoid::getType
        Interface for ICloneable.  

        """
        return _gstlearn.ShapeHalfEllipsoid_getType(self)

    def getNParams(self):
        r"""

        ShapeHalfEllipsoid::getNParams
        """
        return _gstlearn.ShapeHalfEllipsoid_getNParams(self)

    def getFlagCutZ(self):
        r"""

        ShapeHalfEllipsoid::getFlagCutZ
        """
        return _gstlearn.ShapeHalfEllipsoid_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        ShapeHalfEllipsoid::generateObject
        Generate the geometry of the object  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  

        """
        return _gstlearn.ShapeHalfEllipsoid_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        ShapeHalfEllipsoid::belongObject
        Check if the pixel (x,y,z) belongs to the object  

        Returns
        -------
        1 if the pixel is in the grain, 0 if it is in the pore  

        """
        return _gstlearn.ShapeHalfEllipsoid_belongObject(self, coor, object)

    def __repr__(self):
        return _gstlearn.ShapeHalfEllipsoid___repr__(self)

# Register ShapeHalfEllipsoid in _gstlearn:
_gstlearn.ShapeHalfEllipsoid_swigregister(ShapeHalfEllipsoid)
class ShapeHalfParaboloid(AShape):
    r"""


    C++ includes: ShapeHalfParaboloid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeHalfParaboloid::ShapeHalfParaboloid
        """
        _gstlearn.ShapeHalfParaboloid_swiginit(self, _gstlearn.new_ShapeHalfParaboloid(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeHalfParaboloid

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShapeHalfParaboloid_clone(self)

    def getType(self):
        r"""

        ShapeHalfParaboloid::getType
        Interface for ICloneable.  

        """
        return _gstlearn.ShapeHalfParaboloid_getType(self)

    def getNParams(self):
        r"""

        ShapeHalfParaboloid::getNParams
        """
        return _gstlearn.ShapeHalfParaboloid_getNParams(self)

    def getFlagCutZ(self):
        r"""

        ShapeHalfParaboloid::getFlagCutZ
        """
        return _gstlearn.ShapeHalfParaboloid_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        ShapeHalfParaboloid::generateObject
        Generate the geometry of the object  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  

        """
        return _gstlearn.ShapeHalfParaboloid_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        ShapeHalfParaboloid::belongObject
        Check if the pixel (x,y,z) belongs to the object  

        Returns
        -------
        1 if the pixel is in the grain, 0 if it is in the pore  

        """
        return _gstlearn.ShapeHalfParaboloid_belongObject(self, coor, object)

    def __repr__(self):
        return _gstlearn.ShapeHalfParaboloid___repr__(self)

# Register ShapeHalfParaboloid in _gstlearn:
_gstlearn.ShapeHalfParaboloid_swigregister(ShapeHalfParaboloid)
class ShapeHalfSinusoid(AShape):
    r"""


    C++ includes: ShapeHalfSinusoid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ShapeHalfSinusoid::ShapeHalfSinusoid
        """
        _gstlearn.ShapeHalfSinusoid_swiginit(self, _gstlearn.new_ShapeHalfSinusoid(*args))
    __swig_destroy__ = _gstlearn.delete_ShapeHalfSinusoid

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShapeHalfSinusoid_clone(self)

    def getType(self):
        r"""

        ShapeHalfSinusoid::getType
        Interface for ICloneable.  

        """
        return _gstlearn.ShapeHalfSinusoid_getType(self)

    def getNParams(self):
        r"""

        ShapeHalfSinusoid::getNParams
        """
        return _gstlearn.ShapeHalfSinusoid_getNParams(self)

    def getFlagCutZ(self):
        r"""

        ShapeHalfSinusoid::getFlagCutZ
        """
        return _gstlearn.ShapeHalfSinusoid_getFlagCutZ(self)

    def generateObject(self, ndim=3):
        r"""

        ShapeHalfSinusoid::generateObject
        Generate the geometry of the object  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  

        """
        return _gstlearn.ShapeHalfSinusoid_generateObject(self, ndim)

    def belongObject(self, coor, object):
        r"""

        ShapeHalfSinusoid::belongObject
        Check if the pixel (x,y,z) belongs to the object  

        Returns
        -------
        1 if the pixel is in the grain, 0 if it is in the pore  

        """
        return _gstlearn.ShapeHalfSinusoid_belongObject(self, coor, object)

    def __repr__(self):
        return _gstlearn.ShapeHalfSinusoid___repr__(self)

# Register ShapeHalfSinusoid in _gstlearn:
_gstlearn.ShapeHalfSinusoid_swigregister(ShapeHalfSinusoid)
class ModelBoolean(AStringable):
    r"""


    C++ includes: ModelBoolean.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ModelBoolean::ModelBoolean
        """
        _gstlearn.ModelBoolean_swiginit(self, _gstlearn.new_ModelBoolean(*args))
    __swig_destroy__ = _gstlearn.delete_ModelBoolean

    def toString(self, strfmt=None):
        r"""

        ModelBoolean::toString
        Interface to AStringable.  

        """
        return _gstlearn.ModelBoolean_toString(self, strfmt)

    def getNbTokens(self):
        r"""

        ModelBoolean::getNbTokens
        """
        return _gstlearn.ModelBoolean_getNbTokens(self)

    def addToken(self, token):
        r"""

        ModelBoolean::addToken
        """
        return _gstlearn.ModelBoolean_addToken(self, token)

    def normalizeProportions(self):
        r"""

        ModelBoolean::normalizeProportions
        Normalize the proportions  

        """
        return _gstlearn.ModelBoolean_normalizeProportions(self)

    def generateObject(self, ndim):
        r"""

        ModelBoolean::generateObject
        """
        return _gstlearn.ModelBoolean_generateObject(self, ndim)

    def getToken(self, itok):
        r"""

        ModelBoolean::getToken
        """
        return _gstlearn.ModelBoolean_getToken(self, itok)

    def isFlagStat(self):
        r"""

        ModelBoolean::isFlagStat
        """
        return _gstlearn.ModelBoolean_isFlagStat(self)

    def getThetaCst(self):
        r"""

        ModelBoolean::getThetaCst
        """
        return _gstlearn.ModelBoolean_getThetaCst(self)

    def setFlagStat(self, flagStat):
        r"""

        ModelBoolean::setFlagStat
        """
        return _gstlearn.ModelBoolean_setFlagStat(self, flagStat)

    def setThetaCst(self, thetaCst):
        r"""

        ModelBoolean::setThetaCst
        """
        return _gstlearn.ModelBoolean_setThetaCst(self, thetaCst)

    def __repr__(self):
        return _gstlearn.ModelBoolean___repr__(self)

# Register ModelBoolean in _gstlearn:
_gstlearn.ModelBoolean_swigregister(ModelBoolean)
class ASpace(AStringable, ICloneable):
    r"""


    Base classe for space definitions.  

    If the space instance is a sub-space from a parent SpaceComposit _offset is
    used. Otherwise it is set to 0. Example : if I am RN(1) in RN(2)+RN(1), offset
    is 2  

    C++ includes: ASpace.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_ASpace

    def getType(self):
        r"""

        ASpace::getType
        Return the concrete space type.  

        """
        return _gstlearn.ASpace_getType(self)

    def setOrigin(self, origin):
        r"""

        ASpace::setOrigin
        Update the origin of the space.  

        """
        return _gstlearn.ASpace_setOrigin(self, origin)

    def getNDim(self, ispace=-1):
        r"""

        ASpace::getNDim
        Get the number of dimensions.  

        """
        return _gstlearn.ASpace_getNDim(self, ispace)

    def getOffset(self, ispace=-1):
        r"""

        ASpace::getOffset
        Get the offset index for coordinates.  

        """
        return _gstlearn.ASpace_getOffset(self, ispace)

    def getOrigin(self, ispace=-1):
        r"""

        ASpace::getOrigin
        Return the space origin coordinates.  

        """
        return _gstlearn.ASpace_getOrigin(self, ispace)

    def getNComponents(self):
        r"""

        ASpace::getNComponents
        Get the number of space components.  

        """
        return _gstlearn.ASpace_getNComponents(self)

    def getComponent(self, ispace=-1):
        r"""

        ASpace::getComponent
        Return the space component at index ispace.  

        """
        return _gstlearn.ASpace_getComponent(self, ispace)

    def toString(self, *args):
        r"""

        ASpace::toString
        Dump a space in a string (given the space index)  

        """
        return _gstlearn.ASpace_toString(self, *args)

    def isEqual(self, space):
        r"""

        ASpace::isEqual
        Return true if the given space is equal to me (same dimension and space
        definition)  

        """
        return _gstlearn.ASpace_isEqual(self, space)

    def getDistances(self, p1, p2):
        r"""

        ASpace::getDistances
        Return all the distances (one by space component) between two space points.  

        """
        return _gstlearn.ASpace_getDistances(self, p1, p2)

    def getDistancePointVectInPlace(self, p1, p2, res, ranks):
        r"""

        ASpace::getDistancePointVectInPlace
        """
        return _gstlearn.ASpace_getDistancePointVectInPlace(self, p1, p2, res, ranks)

    def move(self, p1, vec):
        r"""

        ASpace::move
        Not to be overriden.  

        Move the given space point by the given vector.  

        Move the given space point by the given vector  

        """
        return _gstlearn.ASpace_move(self, p1, vec)

    def getDistance(self, *args):
        r"""

        ASpace::getDistance
        Return the distance between two space points with the given tensor.  

        TODO : test Tensor dimension  

        """
        return _gstlearn.ASpace_getDistance(self, *args)

    def getFrequentialDistance(self, p1, p2, tensor, ispace=-1):
        r"""

        ASpace::getFrequentialDistance
        Return the distance in frequential domain between two space points with the
        given tensor.  

        TODO : test tensor size  

        """
        return _gstlearn.ASpace_getFrequentialDistance(self, p1, p2, tensor, ispace)

    def getIncrement(self, p1, p2, ispace=-1):
        r"""

        ASpace::getIncrement
        Return the increment vector between two space points.  

        TODO : test tensor size  

        """
        return _gstlearn.ASpace_getIncrement(self, p1, p2, ispace)

    def getIncrementInPlace(self, p1, p2, ptemp, ispace=-1):
        r"""

        ASpace::getIncrementInPlace
        TODO : test tensor size  

        """
        return _gstlearn.ASpace_getIncrementInPlace(self, p1, p2, ptemp, ispace)

    def getUnitaryVector(self):
        r"""

        ASpace::getUnitaryVector
        """
        return _gstlearn.ASpace_getUnitaryVector(self)

    def projCoord(self, coord, ispace=-1):
        r"""

        ASpace::projCoord
        Project the coordinates in the given space.  

        TODO : Memory copies !  

        """
        return _gstlearn.ASpace_projCoord(self, coord, ispace)

    def setOffset(self, offset):
        r"""

        ASpace::setOffset
        Customize the dimension offset index of the current space TODO : to be made
        private.  

        """
        return _gstlearn.ASpace_setOffset(self, offset)

    @staticmethod
    def getDefaultSpaceIfNull(space):
        r"""

        ASpace::getDefaultSpaceIfNull
        """
        return _gstlearn.ASpace_getDefaultSpaceIfNull(space)

    def __repr__(self):
        return _gstlearn.ASpace___repr__(self)

# Register ASpace in _gstlearn:
_gstlearn.ASpace_swigregister(ASpace)
class SpaceComposite(ASpace):
    r"""


    C++ includes: SpaceComposite.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _gstlearn.delete_SpaceComposite

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.SpaceComposite_clone(self)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        SpaceComposite::create
        ICloneable interface.  

        """
        return _gstlearn.SpaceComposite_create(*args, **kwargs)

    def getType(self):
        r"""

        SpaceComposite::getType
        Return the concrete space type.  

        """
        return _gstlearn.SpaceComposite_getType(self)

    def setOrigin(self, origin):
        r"""

        SpaceComposite::setOrigin
        Update the origin of the space.  

        """
        return _gstlearn.SpaceComposite_setOrigin(self, origin)

    def getNDim(self, ispace=-1):
        r"""

        SpaceComposite::getNDim
        Get the number of dimensions.  

        """
        return _gstlearn.SpaceComposite_getNDim(self, ispace)

    def getOffset(self, ispace=-1):
        r"""

        SpaceComposite::getOffset
        Get the offset index for coordinates.  

        """
        return _gstlearn.SpaceComposite_getOffset(self, ispace)

    def getOrigin(self, ispace=-1):
        r"""

        SpaceComposite::getOrigin
        Return the space origin coordinates.  

        """
        return _gstlearn.SpaceComposite_getOrigin(self, ispace)

    def getNComponents(self):
        r"""

        SpaceComposite::getNComponents
        Get the number of space components.  

        """
        return _gstlearn.SpaceComposite_getNComponents(self)

    def getComponent(self, ispace=-1):
        r"""

        SpaceComposite::getComponent
        Return the space component at index ispace.  

        """
        return _gstlearn.SpaceComposite_getComponent(self, ispace)

    def toString(self, strfmt=None, ispace=0):
        r"""

        SpaceComposite::toString
        Dump a space in a string (given the space index)  

        """
        return _gstlearn.SpaceComposite_toString(self, strfmt, ispace)

    def isEqual(self, space):
        r"""

        SpaceComposite::isEqual
        Return true if the given space is equal to me (same dimension and space
        definition)  

        """
        return _gstlearn.SpaceComposite_isEqual(self, space)

    def getDistances(self, p1, p2):
        r"""

        SpaceComposite::getDistances
        Return all the distances (one by space component) between two space points.  

        """
        return _gstlearn.SpaceComposite_getDistances(self, p1, p2)

    def addSpaceComponent(self, comp):
        r"""

        SpaceComposite::addSpaceComponent
        Add a space component to me (for exemple RN(1) for time dimension)  

        """
        return _gstlearn.SpaceComposite_addSpaceComponent(self, comp)

    def __repr__(self):
        return _gstlearn.SpaceComposite___repr__(self)

# Register SpaceComposite in _gstlearn:
_gstlearn.SpaceComposite_swigregister(SpaceComposite)
class ASpaceObject(AStringable):
    r"""


    This class is the base class for all objects that need to know what is its space
    definition. All ASpaceObject can access to the number of space dimensions and
    can ask to calculate a distance between two ASpaceObjects.  

    This class also stores a unique (static) default global space that will be used
    as default space when creating a ASpaceObject (without a predefined space). It
    is possible to modify the default space definition at any time. Space definition
    of pre-existing ASpaceObjects remains the same. (no more shared pointer)  

    C++ includes: ASpaceObject.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_ASpaceObject

    def toString(self, strfmt=None):
        r"""

        ASpaceObject::toString
        AStringable interface.  

        """
        return _gstlearn.ASpaceObject_toString(self, strfmt)

    def getSpace(self):
        r"""

        ASpaceObject::getSpace
        Accessor to the current object space context.  

        """
        return _gstlearn.ASpaceObject_getSpace(self)

    def setSpace(self, space):
        r"""

        ASpaceObject::setSpace
        """
        return _gstlearn.ASpaceObject_setSpace(self, space)

    def getUnitaryVector(self):
        r"""

        ASpaceObject::getUnitaryVector
        Return unitary vector for the current space context.  

        """
        return _gstlearn.ASpaceObject_getUnitaryVector(self)

    def isConsistent(self, *args):
        r"""

        ASpaceObject::isConsistent
        """
        return _gstlearn.ASpaceObject_isConsistent(self, *args)

    def getNDim(self, ispace=-1):
        r"""

        ASpaceObject::getNDim
        Shortcuts to ASpace methods.  

        Return the number of dimension of the current space context  

        """
        return _gstlearn.ASpaceObject_getNDim(self, ispace)

    def getOrigin(self, ispace=-1):
        r"""

        ASpaceObject::getOrigin
        Return the current space context origin coordinates.  

        """
        return _gstlearn.ASpaceObject_getOrigin(self, ispace)

    def getDistance(self, p1, p2, ispace=0):
        r"""

        ASpaceObject::getDistance
        Return the distance between two space points for the current space context.  

        """
        return _gstlearn.ASpaceObject_getDistance(self, p1, p2, ispace)

    def getDistances(self, p1, p2):
        r"""

        ASpaceObject::getDistances
        Return all the distances (space composits) between two space points for the
        current space context.  

        """
        return _gstlearn.ASpaceObject_getDistances(self, p1, p2)

    def getIncrement(self, p1, p2, ispace=0):
        r"""

        ASpaceObject::getIncrement
        Return the increment vector between two space points for the current space
        context.  

        """
        return _gstlearn.ASpaceObject_getIncrement(self, p1, p2, ispace)

    def getIncrementInPlace(self, p1, p2, ptemp, ispace=-1):
        r"""

        ASpaceObject::getIncrementInPlace
        """
        return _gstlearn.ASpaceObject_getIncrementInPlace(self, p1, p2, ptemp, ispace)

    def __repr__(self):
        return _gstlearn.ASpaceObject___repr__(self)

# Register ASpaceObject in _gstlearn:
_gstlearn.ASpaceObject_swigregister(ASpaceObject)

def defineDefaultSpace(type, ndim=2, param=0.):
    r"""


    (Re)Defining the unique default global space  

    Factory for defining the unique default global space (optional parameter can be
    used for sphere radius for example)  

    Parameters
    ----------
    * `type` :  
        Space type (RN, SN, ...)  
    * `ndim` :  
        Number of dimensions  
    * `param` :  
        Optional space parameter (ex: radius of the sphere)  

    """
    return _gstlearn.defineDefaultSpace(type, ndim, param)

def setDefaultSpace(space):
    r"""


    Defining the default space from another one.  

    Set the unique default global space from another one.  

    Parameters
    ----------
    * `space` :  

    """
    return _gstlearn.setDefaultSpace(space)

def getDefaultSpaceType():
    r"""


    Return a clone of the unique default global space.  

    """
    return _gstlearn.getDefaultSpaceType()

def getDefaultSpaceDimension():
    r"""


    """
    return _gstlearn.getDefaultSpaceDimension()

def getDefaultSpace():
    r"""


    """
    return _gstlearn.getDefaultSpace()

def getDefaultSpaceSh():
    r"""


    """
    return _gstlearn.getDefaultSpaceSh()

def isDefaultSpaceSphere():
    r"""


    """
    return _gstlearn.isDefaultSpaceSphere()
class SpacePoint(ASpaceObject):
    r"""


    C++ includes: SpacePoint.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SpacePoint::SpacePoint
        """
        _gstlearn.SpacePoint_swiginit(self, _gstlearn.new_SpacePoint(*args))
    __swig_destroy__ = _gstlearn.delete_SpacePoint

    def spacePointOnSubspace(self, ispace=-1):
        r"""

        SpacePoint::spacePointOnSubspace
        TODO : Memory copies  

        """
        return _gstlearn.SpacePoint_spacePointOnSubspace(self, ispace)

    def __eq__(self, v):
        return _gstlearn.SpacePoint___eq__(self, v)

    def getCoords(self):
        r"""

        SpacePoint::getCoords
        """
        return _gstlearn.SpacePoint_getCoords(self)

    def getCoordRef(self):
        r"""

        SpacePoint::getCoordRef
        """
        return _gstlearn.SpacePoint_getCoordRef(self)

    def getCoordUnprotected(self):
        r"""

        SpacePoint::getCoordUnprotected
        """
        return _gstlearn.SpacePoint_getCoordUnprotected(self)

    def getCoord(self, idim):
        r"""

        SpacePoint::getCoord
        """
        return _gstlearn.SpacePoint_getCoord(self, idim)

    def setCoord(self, *args):
        r"""

        SpacePoint::setCoord
        """
        return _gstlearn.SpacePoint_setCoord(self, *args)

    def setCoords(self, *args):
        r"""

        SpacePoint::setCoords
        """
        return _gstlearn.SpacePoint_setCoords(self, *args)

    def setIech(self, iech):
        r"""

        SpacePoint::setIech
        """
        return _gstlearn.SpacePoint_setIech(self, iech)

    def setProjected(self, status):
        r"""

        SpacePoint::setProjected
        """
        return _gstlearn.SpacePoint_setProjected(self, status)

    def getIech(self):
        r"""

        SpacePoint::getIech
        """
        return _gstlearn.SpacePoint_getIech(self)

    def isProjected(self):
        r"""

        SpacePoint::isProjected
        """
        return _gstlearn.SpacePoint_isProjected(self)

    def isConsistent(self, space):
        r"""

        SpacePoint::isConsistent
        Return true if the point is consistent with the provided space.  

        """
        return _gstlearn.SpacePoint_isConsistent(self, space)

    def move(self, vec):
        r"""

        SpacePoint::move
        Move me by the given vector.  

        """
        return _gstlearn.SpacePoint_move(self, vec)

    def getDistance(self, pt, ispace=-1):
        r"""

        SpacePoint::getDistance
        Return the distance between 'this' and another point.  

        """
        return _gstlearn.SpacePoint_getDistance(self, pt, ispace)

    def getDistances(self, pt):
        r"""

        SpacePoint::getDistances
        Return all the distance (space composits) between 'this' and another point.  

        """
        return _gstlearn.SpacePoint_getDistances(self, pt)

    def getIncrement(self, pt, ispace=-1):
        r"""

        SpacePoint::getIncrement
        Return the increment vector between 'this' and another point.  

        """
        return _gstlearn.SpacePoint_getIncrement(self, pt, ispace)

    def getIncrementInPlace(self, inc, pt, ispace=-1):
        r"""

        SpacePoint::getIncrementInPlace
        """
        return _gstlearn.SpacePoint_getIncrementInPlace(self, inc, pt, ispace)

    def setFFFF(self):
        r"""

        SpacePoint::setFFFF
        Fill with TEST values to simulate a missing Space Point.  

        """
        return _gstlearn.SpacePoint_setFFFF(self)

    def isFFFF(self):
        r"""

        SpacePoint::isFFFF
        Check if the SpacePoint is actually defined.  

        """
        return _gstlearn.SpacePoint_isFFFF(self)

    def getCosineToDirection(self, T2, codir):
        r"""

        SpacePoint::getCosineToDirection
        Return the cosine of the angle between the bipoint and a reference direction.  

        """
        return _gstlearn.SpacePoint_getCosineToDirection(self, T2, codir)

    def getOrthogonalDistance(self, P2, codir):
        r"""

        SpacePoint::getOrthogonalDistance
        Return the orthogonal distance between a bipair and a reference direction.  

        """
        return _gstlearn.SpacePoint_getOrthogonalDistance(self, P2, codir)

    def setCoordFromAngle(self, angles):
        r"""

        SpacePoint::setCoordFromAngle
        Initialize coordinates from angles /// TODO : to be removed.  

        Initialize point coordinates from angles  

        TODO : initialize coordinates from angles for more than 2D & valid only for
        space RN ? To be kept ?  

        """
        return _gstlearn.SpacePoint_setCoordFromAngle(self, angles)

    def toString(self, strfmt=None):
        r"""

        SpacePoint::toString
        Convert space point to string.  

        """
        return _gstlearn.SpacePoint_toString(self, strfmt)

    def __repr__(self):
        return _gstlearn.SpacePoint___repr__(self)

# Register SpacePoint in _gstlearn:
_gstlearn.SpacePoint_swigregister(SpacePoint)
class SpaceTarget(SpacePoint):
    r"""


    C++ includes: SpaceTarget.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SpaceTarget::SpaceTarget
        """
        _gstlearn.SpaceTarget_swiginit(self, _gstlearn.new_SpaceTarget(*args))
    __swig_destroy__ = _gstlearn.delete_SpaceTarget

    @staticmethod
    def create(*args, **kwargs):
        r"""

        SpaceTarget::create
        """
        return _gstlearn.SpaceTarget_create(*args, **kwargs)

    def getCoordAsSP(self):
        r"""

        SpaceTarget::getCoordAsSP
        """
        return _gstlearn.SpaceTarget_getCoordAsSP(self)

    def getExtend(self, *args):
        r"""

        SpaceTarget::getExtend
        """
        return _gstlearn.SpaceTarget_getExtend(self, *args)

    def setExtend(self, *args):
        r"""

        SpaceTarget::setExtend
        """
        return _gstlearn.SpaceTarget_setExtend(self, *args)

    def getExtendP(self):
        r"""

        SpaceTarget::getExtendP
        """
        return _gstlearn.SpaceTarget_getExtendP(self)

    def getExtendPM(self):
        r"""

        SpaceTarget::getExtendPM
        """
        return _gstlearn.SpaceTarget_getExtendPM(self)

    def setCode(self, code):
        r"""

        SpaceTarget::setCode
        """
        return _gstlearn.SpaceTarget_setCode(self, code)

    def setDate(self, date):
        r"""

        SpaceTarget::setDate
        """
        return _gstlearn.SpaceTarget_setDate(self, date)

    def getCode(self):
        r"""

        SpaceTarget::getCode
        """
        return _gstlearn.SpaceTarget_getCode(self)

    def getDate(self):
        r"""

        SpaceTarget::getDate
        """
        return _gstlearn.SpaceTarget_getDate(self)

    def checkExtend(self):
        r"""

        SpaceTarget::checkExtend
        """
        return _gstlearn.SpaceTarget_checkExtend(self)

    def checkCode(self):
        r"""

        SpaceTarget::checkCode
        """
        return _gstlearn.SpaceTarget_checkCode(self)

    def checkDate(self):
        r"""

        SpaceTarget::checkDate
        """
        return _gstlearn.SpaceTarget_checkDate(self)

    def toString(self, strfmt=None):
        r"""

        SpaceTarget::toString
        Convert space point to string.  

        """
        return _gstlearn.SpaceTarget_toString(self, strfmt)

    def __repr__(self):
        return _gstlearn.SpaceTarget___repr__(self)

# Register SpaceTarget in _gstlearn:
_gstlearn.SpaceTarget_swigregister(SpaceTarget)
class SpaceRN(ASpace):
    r"""


    C++ includes: SpaceRN.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _gstlearn.delete_SpaceRN

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.SpaceRN_clone(self)

    def getType(self):
        r"""

        SpaceRN::getType
        ICloneable interface.  

        Return the concrete space type  

        """
        return _gstlearn.SpaceRN_getType(self)

    @staticmethod
    def create(ndim):
        r"""

        SpaceRN::create
        """
        return _gstlearn.SpaceRN_create(ndim)

    def getDistancePointVectInPlace(self, p1, p2, res, ranks):
        r"""

        SpaceRN::getDistancePointVectInPlace
        """
        return _gstlearn.SpaceRN_getDistancePointVectInPlace(self, p1, p2, res, ranks)

    def __repr__(self):
        return _gstlearn.SpaceRN___repr__(self)

# Register SpaceRN in _gstlearn:
_gstlearn.SpaceRN_swigregister(SpaceRN)
class ASpaceShape(object):
    r"""


    TODO : to be kept ?  

    C++ includes: SpaceShape.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        ASpaceShape::ASpaceShape
        """
        _gstlearn.ASpaceShape_swiginit(self, _gstlearn.new_ASpaceShape())
    __swig_destroy__ = _gstlearn.delete_ASpaceShape

# Register ASpaceShape in _gstlearn:
_gstlearn.ASpaceShape_swigregister(ASpaceShape)
class Cone(ASpaceShape):
    r"""


    C++ includes: SpaceShape.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        Cone::Cone
        """
        _gstlearn.Cone_swiginit(self, _gstlearn.new_Cone())
    __swig_destroy__ = _gstlearn.delete_Cone
    angle = property(_gstlearn.Cone_angle_get, _gstlearn.Cone_angle_set)

# Register Cone in _gstlearn:
_gstlearn.Cone_swigregister(Cone)
class Cylinder(ASpaceShape):
    r"""


    C++ includes: SpaceShape.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        Cylinder::Cylinder
        """
        _gstlearn.Cylinder_swiginit(self, _gstlearn.new_Cylinder())
    __swig_destroy__ = _gstlearn.delete_Cylinder
    radius = property(_gstlearn.Cylinder_radius_get, _gstlearn.Cylinder_radius_set)

# Register Cylinder in _gstlearn:
_gstlearn.Cylinder_swigregister(Cylinder)
class Pencil(ASpaceShape):
    r"""


    C++ includes: SpaceShape.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_Pencil

    def __init__(self, *args):
        r"""

        Pencil::Pencil
        """
        _gstlearn.Pencil_swiginit(self, _gstlearn.new_Pencil(*args))

    def setAngle(self, ang):
        r"""

        Pencil::setAngle
        """
        return _gstlearn.Pencil_setAngle(self, ang)
    angle = property(_gstlearn.Pencil_angle_get, _gstlearn.Pencil_angle_set)
    radius = property(_gstlearn.Pencil_radius_get, _gstlearn.Pencil_radius_set)

# Register Pencil in _gstlearn:
_gstlearn.Pencil_swigregister(Pencil)
class ALinearOp(object):
    r"""


    C++ includes: ALinearOp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ALinearOp

    def getSize(self):
        r"""

        ALinearOp::getSize
        """
        return _gstlearn.ALinearOp_getSize(self)

    def evalDirect(self, *args):
        r"""

        ALinearOp::evalDirect
        """
        return _gstlearn.ALinearOp_evalDirect(self, *args)

    def multiplyByValueAndAddDiagonal(self, v1=1., v2=0.):
        r"""

        ALinearOp::multiplyByValueAndAddDiagonal
        """
        return _gstlearn.ALinearOp_multiplyByValueAndAddDiagonal(self, v1, v2)

    def resetModif(self):
        r"""

        ALinearOp::resetModif
        """
        return _gstlearn.ALinearOp_resetModif(self)

    def setUseFactor(self, usefactor):
        r"""

        ALinearOp::setUseFactor
        """
        return _gstlearn.ALinearOp_setUseFactor(self, usefactor)

# Register ALinearOp in _gstlearn:
_gstlearn.ALinearOp_swigregister(ALinearOp)
class ASimulable(ALinearOp):
    r"""


    C++ includes: ASimulable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ASimulable

    def evalSimulate(self, *args):
        r"""

        ASimulable::evalSimulate
        """
        return _gstlearn.ASimulable_evalSimulate(self, *args)

    def simulate(self):
        r"""

        ASimulable::simulate
        """
        return _gstlearn.ASimulable_simulate(self)

# Register ASimulable in _gstlearn:
_gstlearn.ASimulable_swigregister(ASimulable)
class AMatrix(AStringable, ICloneable):
    r"""


    This class is the root of the Matrix organization in gstlearn A matrix is a 2-D
    organization: it is characterized by its number of rows and its number of
    columns. Although the user should not bother with this remark, the elements of a
    matrix processed in 'gstlearn' are stored in a Row-major format. This is to say
    that the internal rank of an element characterized by its row and column numbers
    is: (icol * getNRows() + irow)  

    Since gstlearn version v1.3:  

    *   Dense Matrices storage and algebra rely on Eigen3 library only  
    *   Sparse Matrices storage and algebra rely on Eigen3 or cs library (see
        MatrixSparse.hpp)  

    C++ includes: AMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AMatrix

    def reset(self, nrows, ncols):
        r"""

        AMatrix::reset
        """
        return _gstlearn.AMatrix_reset(self, nrows, ncols)

    def resetFromValue(self, nrows, ncols, value):
        r"""

        AMatrix::resetFromValue
        Reset the matrix to new dimensions and fill with a new value.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  
        * `value` :  
            The new value used to fill the matrix  

        """
        return _gstlearn.AMatrix_resetFromValue(self, nrows, ncols, value)

    def resetFromArray(self, nrows, ncols, tab, byCol=True):
        r"""

        AMatrix::resetFromArray
        Reset the matrix from an array of double values.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  
        * `tab` :  
            The array of values  
        * `byCol` :  
            True if values are column-major in the array  

        """
        return _gstlearn.AMatrix_resetFromArray(self, nrows, ncols, tab, byCol)

    def resetFromVD(self, nrows, ncols, tab, byCol=True):
        r"""

        AMatrix::resetFromVD
        Reset the matrix from a vector of double values.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  
        * `tab` :  
            The vector of values  
        * `byCol` :  
            True if values are column-major in the vector  

        """
        return _gstlearn.AMatrix_resetFromVD(self, nrows, ncols, tab, byCol)

    def resetFromVVD(self, tab, byCol=True):
        r"""

        AMatrix::resetFromVVD
        Reset the matrix from an array of double values.  

        Parameters
        ----------
        * `tab` :  
            The array of values  
        * `byCol` :  
            True if values are column-major in the array  

        """
        return _gstlearn.AMatrix_resetFromVVD(self, tab, byCol)

    def toString(self, strfmt=None):
        r"""

        AMatrix::toString
        Interface to AStringable.  

        """
        return _gstlearn.AMatrix_toString(self, strfmt)

    def clear(self):
        r"""

        AMatrix::clear
        """
        return _gstlearn.AMatrix_clear(self)

    def isDense(self):
        r"""

        AMatrix::isDense
        Interface to AMatrix.  

        Returns if the matrix belongs to the MatrixDense class (avoids dynamic_cast)  

        """
        return _gstlearn.AMatrix_isDense(self)

    def isSparse(self):
        r"""

        AMatrix::isSparse
        Returns if the current matrix is Sparse  

        """
        return _gstlearn.AMatrix_isSparse(self)

    def isSquare(self, printWhyNot=False):
        r"""

        AMatrix::isSquare
        Check if the matrix is (non empty) square  

        Indicate if the given matrce is a square matrix  

        Parameters
        ----------
        * `printWhyNot` :  
            Print the message is the answer is false  

        Returns
        -------
        true if the matrix is square  

        """
        return _gstlearn.AMatrix_isSquare(self, printWhyNot)

    def isValid(self, irow, icol, printWhyNot=False):
        r"""

        AMatrix::isValid
        Indicate if the given indices are valid for the current matrix size  

        Indicate if the given indices are valid for the current matrix size  

        Parameters
        ----------
        * `irow` :  
            Row index  
        * `icol` :  
            Column index  
        * `printWhyNot` :  
            Print the message is the answer is false  

        Returns
        -------
        true if indices are valid for the current matrix size  

        """
        return _gstlearn.AMatrix_isValid(self, irow, icol, printWhyNot)

    def isIdentity(self, printWhyNot=False):
        r"""

        AMatrix::isIdentity
        Check if the matrix is square and Identity  

        Indicate if the current matrix is the Identity  

        Parameters
        ----------
        * `printWhyNot` :  
            Print the message is the answer is false  

        Returns
        -------
        true if the current matrix is the Identity  

        """
        return _gstlearn.AMatrix_isIdentity(self, printWhyNot)

    def isSymmetric(self, eps=1.e-10, printWhyNot=False):
        r"""

        AMatrix::isSymmetric
        Check if the input matrix is (non empty and square) symmetric  

        Indicate if the current matrix is symmetric  

        Parameters
        ----------
        * `eps` :  
            Epsilon for double equality comparison  
        * `printWhyNot` :  
            Print the message is the answer is false  

        Returns
        -------
        true if the current matrix is symmetric  

        """
        return _gstlearn.AMatrix_isSymmetric(self, eps, printWhyNot)

    def mustBeSymmetric(self):
        r"""

        AMatrix::mustBeSymmetric
        Say if the matrix must be symmetric  

        """
        return _gstlearn.AMatrix_mustBeSymmetric(self)

    def setColumn(self, icol, tab, flagCheck=True):
        r"""

        AMatrix::setColumn
        Set the contents of a Column  

        """
        return _gstlearn.AMatrix_setColumn(self, icol, tab, flagCheck)

    def setColumnToConstant(self, icol, value, flagCheck=True):
        r"""

        AMatrix::setColumnToConstant
        Set the contents of a Column to a constant value  

        """
        return _gstlearn.AMatrix_setColumnToConstant(self, icol, value, flagCheck)

    def setRow(self, irow, tab, flagCheck=True):
        r"""

        AMatrix::setRow
        Set the contents of a Row  

        """
        return _gstlearn.AMatrix_setRow(self, irow, tab, flagCheck)

    def setRowToConstant(self, irow, value, flagCheck=True):
        r"""

        AMatrix::setRowToConstant
        Set the contents of a Row to a constant value  

        """
        return _gstlearn.AMatrix_setRowToConstant(self, irow, value, flagCheck)

    def setDiagonal(self, tab, flagCheck=True):
        r"""

        AMatrix::setDiagonal
        Set the contents of the (main) Diagonal  

        Reset the contents of a matrix by setting all terms to 0 and update diagonal
        terms from the input argument 'tab'  

        Parameters
        ----------
        * `tab` :  
            Input vector to be copied to the diagonal of the output matrix  
        * `flagCheck` :  
            When True, check the input arguments  

        """
        return _gstlearn.AMatrix_setDiagonal(self, tab, flagCheck)

    def setDiagonalToConstant(self, value=1.):
        r"""

        AMatrix::setDiagonalToConstant
        Set the contents of the (main) Diagonal to a constant value  

        """
        return _gstlearn.AMatrix_setDiagonalToConstant(self, value)

    def transposeInPlace(self):
        r"""

        AMatrix::transposeInPlace
        Transpose the matrix in place  

        """
        return _gstlearn.AMatrix_transposeInPlace(self)

    def transpose(self):
        r"""

        AMatrix::transpose
        Transpose the matrix and return it as a copy  

        """
        return _gstlearn.AMatrix_transpose(self)

    def addScalar(self, v):
        r"""

        AMatrix::addScalar
        Add a value to each matrix component  

        Parameters
        ----------
        * `v` :  
            Add a scalar value to all (valid) terms of the current matrix  

        """
        return _gstlearn.AMatrix_addScalar(self, v)

    def addScalarDiag(self, v):
        r"""

        AMatrix::addScalarDiag
        Add value to matrix diagonal  

        Parameters
        ----------
        * `v` :  
            Add constant value to the diagonal of the current Matrix  

        """
        return _gstlearn.AMatrix_addScalarDiag(self, v)

    def prodScalar(self, v):
        r"""

        AMatrix::prodScalar
        Multiply each matrix component by a value  

        Parameters
        ----------
        * `v` :  
            Multiply all the terms of the matrix by the scalar 'v'  

        """
        return _gstlearn.AMatrix_prodScalar(self, v)

    def fill(self, value):
        r"""

        AMatrix::fill
        Set all the values of the Matrix at once  

        Fill 'this' with the constant 'value'  

        Parameters
        ----------
        * `value` :  
            Constant value used for filling 'this'  

        """
        return _gstlearn.AMatrix_fill(self, value)

    def multiplyRow(self, vec):
        r"""

        AMatrix::multiplyRow
        Multiply a Matrix row-wise  

        """
        return _gstlearn.AMatrix_multiplyRow(self, vec)

    def multiplyColumn(self, vec):
        r"""

        AMatrix::multiplyColumn
        Multiply a Matrix column-wise  

        """
        return _gstlearn.AMatrix_multiplyColumn(self, vec)

    def divideRow(self, vec):
        r"""

        AMatrix::divideRow
        Divide a Matrix row-wise  

        """
        return _gstlearn.AMatrix_divideRow(self, vec)

    def divideColumn(self, vec):
        r"""

        AMatrix::divideColumn
        Divide a Matrix column-wise  

        """
        return _gstlearn.AMatrix_divideColumn(self, vec)

    def prodVecMat(self, x, transpose=False):
        r"""

        AMatrix::prodVecMat
        Perform 'vec' * 'this'  

        """
        return _gstlearn.AMatrix_prodVecMat(self, x, transpose)

    def prodMatVec(self, x, transpose=False):
        r"""

        AMatrix::prodMatVec
        Perform 'this' * 'vec'  

        """
        return _gstlearn.AMatrix_prodMatVec(self, x, transpose)

    def getRow(self, irow):
        r"""

        AMatrix::getRow
        Extract a Row  

        """
        return _gstlearn.AMatrix_getRow(self, irow)

    def getColumn(self, icol):
        r"""

        AMatrix::getColumn
        Extract a Column  

        """
        return _gstlearn.AMatrix_getColumn(self, icol)

    def prodMatMatInPlace(self, x, y, transposeX=False, transposeY=False):
        r"""

        AMatrix::prodMatMatInPlace
        Multiply matrix 'x' by matrix 'y' and store the result in 'this'  

        Store the product of 'x'(or 't(x)') by 'y' (or 't(y') in this  

        Parameters
        ----------
        * `x` :  
            First Matrix  
        * `y` :  
            Second matrix  
        * `transposeX` :  
            True if first matrix must be transposed  
        * `transposeY` :  
            True if second matrix must be transposed  

        """
        return _gstlearn.AMatrix_prodMatMatInPlace(self, x, y, transposeX, transposeY)

    def getMatrixToTriplet(self, shiftRow=0, shiftCol=0):
        r"""

        AMatrix::getMatrixToTriplet
        Extract the contents of the matrix  

        From a matrix of any type, creates the three vectors of the triplet (specific
        format for creating efficiently a Sparse matrix) It only takes the only non-zero
        elements of the matrix  

        """
        return _gstlearn.AMatrix_getMatrixToTriplet(self, shiftRow, shiftCol)

    def addMatInPlace(self, y, cx=1., cy=1.):
        r"""

        AMatrix::addMatInPlace
        Add a matrix (multiplied by a constant)  

        Add the matrix 'y' to the current Matrix  

        Parameters
        ----------
        * `y` :  
            Matrix to be added  
        * `cx` :  
            Multiplicative parameter for this  
        * `cy` :  
            Multiplicative parameter for y  

        """
        return _gstlearn.AMatrix_addMatInPlace(self, y, cx, cy)

    def prodMatInPlace(self, matY, transposeY=False):
        r"""

        AMatrix::prodMatInPlace
        Multiply 'this' by matrix 'y' and store in 'this'  

        """
        return _gstlearn.AMatrix_prodMatInPlace(self, matY, transposeY)

    def prodNormMatMatInPlace(self, a, m, transpose=False):
        r"""

        AMatrix::prodNormMatMatInPlace
        Product 't(A)' %*% 'M' %*% 'A' or 'A' %*% 'M' %*% 't(A)' stored in 'this'  

        Product 't(A)' %*% 'M' %*% 'A' or 'A' %*% 'M' %*% 't(A)' stored in 'this'  

        Parameters
        ----------
        * `a` :  
            Matrix A  
        * `m` :  
            Matrix M  
        * `transpose` :  
            True for first implementation, False for the second  

        """
        return _gstlearn.AMatrix_prodNormMatMatInPlace(self, a, m, transpose)

    def prodNormMatVecInPlace(self, *args, **kwargs):
        r"""

        AMatrix::prodNormMatVecInPlace
        Product 't(A)' %*% ['vec'] %*% 'A' or 'A' %*% ['vec'] %*% 't(A)' stored in
        'this'  

        """
        return _gstlearn.AMatrix_prodNormMatVecInPlace(self, *args, **kwargs)

    def resize(self, nrows, ncols):
        r"""

        AMatrix::resize
        Resize the matrix to new dimensions (this method doesn't change the storage
        type)  

        Modify the dimension of the matrix (if needed)  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  

        """
        return _gstlearn.AMatrix_resize(self, nrows, ncols)

    def getValue(self, irow, icol, flagCheck=True):
        r"""

        AMatrix::getValue
        Gets the value at row 'irow' and column 'icol'  

        """
        return _gstlearn.AMatrix_getValue(self, irow, icol, flagCheck)

    def setValue(self, irow, icol, value, flagCheck=True):
        r"""

        AMatrix::setValue
        Sets the value at row 'irow' and column 'icol'  

        """
        return _gstlearn.AMatrix_setValue(self, irow, icol, value, flagCheck)

    def updValue(self, irow, icol, oper, value, flagCheck=True):
        r"""

        AMatrix::updValue
        Update the value at row 'irow' and column 'icol'  

        """
        return _gstlearn.AMatrix_updValue(self, irow, icol, oper, value, flagCheck)

    def addValue(self, irow, icol, value):
        r"""

        AMatrix::addValue
        Add a value to a matrix term  

        """
        return _gstlearn.AMatrix_addValue(self, irow, icol, value)

    def isSame(self, m, eps=1.e-4, printWhyNot=False):
        r"""

        AMatrix::isSame
        Check if a matrix is the same as me (norm L1)  

        Check that Matrix 'm' is equal to the current Matrix  

        Parameters
        ----------
        * `m` :  
            Matrix to be compared to the current Matrix  
        * `eps` :  
            Epsilon for double equality comparison  
        * `printWhyNot` :  
            Print the message is the answer is false  

        Returns
        -------
        true if 'm' is equal to the current Matrix  

        """
        return _gstlearn.AMatrix_isSame(self, m, eps, printWhyNot)

    def isSameSize(self, m):
        r"""

        AMatrix::isSameSize
        Check that both matrix have the same number of rows and columns  

        Check that Matrix 'm' share the same dimensions as current one  

        Parameters
        ----------
        * `m` :  
            Matrix to be compared to the current Matrix  

        Returns
        -------
        true if 'm' has same dimensions as the current Matrix  

        """
        return _gstlearn.AMatrix_isSameSize(self, m)

    def empty(self):
        r"""

        AMatrix::empty
        Returns if the current matrix is Empty  

        """
        return _gstlearn.AMatrix_empty(self)

    def compare(self, mat):
        r"""

        AMatrix::compare
        Returns the sum of absolute difference between argument and this  

        """
        return _gstlearn.AMatrix_compare(self, mat)

    def getNRows(self):
        r"""

        AMatrix::getNRows
        Returns the number of rows  

        """
        return _gstlearn.AMatrix_getNRows(self)

    def getNCols(self):
        r"""

        AMatrix::getNCols
        Returns the number of columns  

        """
        return _gstlearn.AMatrix_getNCols(self)

    def size(self):
        r"""

        AMatrix::size
        Get the total number of elements of the (full) matrix  

        """
        return _gstlearn.AMatrix_size(self)

    def getValues(self, byCol=True):
        r"""

        AMatrix::getValues
        Returns the contents of the whole matrix as a VectorDouble  

        """
        return _gstlearn.AMatrix_getValues(self, byCol)

    def getDiagonal(self, shift=0):
        r"""

        AMatrix::getDiagonal
        Extract a Diagonal (main or secondary) of this  

        """
        return _gstlearn.AMatrix_getDiagonal(self, shift)

    def isColumnDefined(self, icol):
        r"""

        AMatrix::isColumnDefined
        Checks if a Column is valid (contains a non TEST value)  

        """
        return _gstlearn.AMatrix_isColumnDefined(self, icol)

    def isRowDefined(self, irow):
        r"""

        AMatrix::isRowDefined
        Checks if a Row is valid (contains a non TEST value)  

        """
        return _gstlearn.AMatrix_isRowDefined(self, irow)

    def getNColDefined(self):
        r"""

        AMatrix::getNColDefined
        Define the number of defined columns  

        """
        return _gstlearn.AMatrix_getNColDefined(self)

    def getNRowDefined(self):
        r"""

        AMatrix::getNRowDefined
        Define the number of defined rows  

        """
        return _gstlearn.AMatrix_getNRowDefined(self)

    def getColumnByRowRange(self, icol, rowFrom, rowTo):
        r"""

        AMatrix::getColumnByRowRange
        Extract a portion of a Column  

        """
        return _gstlearn.AMatrix_getColumnByRowRange(self, icol, rowFrom, rowTo)

    def isNonNegative(self, verbose=False):
        r"""

        AMatrix::isNonNegative
        Check if the matrix does not contain any negative element  

        Check if all the elements of a matrix are non-negative  

        Returns
        -------
        True if the matrix is non-negative; False otherwise  

        Parameters
        ----------
        * `verbose` :  
            True for the verbose option  

        """
        return _gstlearn.AMatrix_isNonNegative(self, verbose)

    def prodMatVecInPlace(self, x, y, transpose=False):
        r"""

        AMatrix::prodMatVecInPlace
        """
        return _gstlearn.AMatrix_prodMatVecInPlace(self, x, y, transpose)

    def prodMatVecInPlacePtr(self, x, y, transpose=False):
        r"""

        AMatrix::prodMatVecInPlacePtr
        """
        return _gstlearn.AMatrix_prodMatVecInPlacePtr(self, x, y, transpose)

    def prodVecMatInPlace(self, x, y, transpose=False):
        r"""

        AMatrix::prodVecMatInPlace
        Perform 'y' = 'x' * 'this'  

        """
        return _gstlearn.AMatrix_prodVecMatInPlace(self, x, y, transpose)

    def prodVecMatInPlacePtr(self, x, y, transpose=False):
        r"""

        AMatrix::prodVecMatInPlacePtr
        """
        return _gstlearn.AMatrix_prodVecMatInPlacePtr(self, x, y, transpose)

    def quadraticMatrix(self, x, y):
        r"""

        AMatrix::quadraticMatrix
        Perform x %*% mat %*% y  

        """
        return _gstlearn.AMatrix_quadraticMatrix(self, x, y)

    def invert(self):
        r"""

        AMatrix::invert
        Matrix inversion in place  

        """
        return _gstlearn.AMatrix_invert(self)

    def solve(self, b, x):
        r"""

        AMatrix::solve
        Solving the Matrix Linear system  

        """
        return _gstlearn.AMatrix_solve(self, b, x)

    def dumpElements(self, title, ifrom, ito):
        r"""

        AMatrix::dumpElements
        Dump a specific range of samples from the internal storage  

        """
        return _gstlearn.AMatrix_dumpElements(self, title, ifrom, ito)

    def dumpStatistics(self, title):
        r"""

        AMatrix::dumpStatistics
        Dump statistics on the Matrix  

        """
        return _gstlearn.AMatrix_dumpStatistics(self, title)

    def setIdentity(self, value=1.):
        r"""

        AMatrix::setIdentity
        Sets the matrix as Identity  

        """
        return _gstlearn.AMatrix_setIdentity(self, value)

    def fillRandom(self, seed=432432, zeroPercent=0):
        r"""

        AMatrix::fillRandom
        """
        return _gstlearn.AMatrix_fillRandom(self, seed, zeroPercent)

    def setValues(self, values, byCol=True):
        r"""

        AMatrix::setValues
        Filling the matrix with an array of values Note that this array is ALWAYS
        dimensioned to the total number of elements in the matrix. Kept for
        compatibility with old code where matrix contents was stored as a VectorDouble  

        Parameters
        ----------
        * `values` :  
        * `byCol` :  
            true for Column major; false for Row Major  

        """
        return _gstlearn.AMatrix_setValues(self, values, byCol)

    def getMeanByColumn(self, icol):
        r"""

        AMatrix::getMeanByColumn
        """
        return _gstlearn.AMatrix_getMeanByColumn(self, icol)

    def getMinimum(self):
        r"""

        AMatrix::getMinimum
        """
        return _gstlearn.AMatrix_getMinimum(self)

    def getMaximum(self):
        r"""

        AMatrix::getMaximum
        """
        return _gstlearn.AMatrix_getMaximum(self)

    def getNormInf(self):
        r"""

        AMatrix::getNormInf
        """
        return _gstlearn.AMatrix_getNormInf(self)

    def copyReduce(self, x, validRows, validCols):
        r"""

        AMatrix::copyReduce
        """
        return _gstlearn.AMatrix_copyReduce(self, x, validRows, validCols)

    def copyElements(self, m, factor=1.):
        r"""

        AMatrix::copyElements
        Copy the contents of matrix 'm' into 'this' Warning: matrices must have the same
        dimensions (not checked)  

        Parameters
        ----------
        * `m` :  
            Input matrix  
        * `factor` :  
            Multiplicative factor (applied to each element)  

        """
        return _gstlearn.AMatrix_copyElements(self, m, factor)

    def setFlagCheckAddress(self, flagCheckAddress):
        r"""

        AMatrix::setFlagCheckAddress
        """
        return _gstlearn.AMatrix_setFlagCheckAddress(self, flagCheckAddress)

    def makePositiveColumn(self):
        r"""

        AMatrix::makePositiveColumn
        Modify the contents of the matrix so that each column has a positive sum of
        elements. If this is not the case, simply invert the sign of the column  

        """
        return _gstlearn.AMatrix_makePositiveColumn(self)

    def linearCombination(self, val1, mat1, val2=1., mat2=None, val3=1., mat3=None):
        r"""

        AMatrix::linearCombination
        Perfom the algebraic equation this = val1 * mat1 + val2 * mat2 + val3 * mat3.  

        Parameters
        ----------
        * `val1` :  
            Coefficient of first matrx  
        * `mat1` :  
            First matrix (optional)  
        * `val2` :  
            Coefficient of second matrix  
        * `mat2` :  
            Second matrix (optional)  
        * `val3` :  
            Coefficient of third matrix  
        * `mat3` :  
            Third matrix (optional)  

        """
        return _gstlearn.AMatrix_linearCombination(self, val1, mat1, val2, mat2, val3, mat3)

    def __repr__(self):
        return _gstlearn.AMatrix___repr__(self)

# Register AMatrix in _gstlearn:
_gstlearn.AMatrix_swigregister(AMatrix)

def setMultiThread(nthreads):
    r"""


    """
    return _gstlearn.setMultiThread(nthreads)

def getMultiThread():
    r"""


    """
    return _gstlearn.getMultiThread()

def isMultiThread():
    r"""


    """
    return _gstlearn.isMultiThread()
class MatrixDense(AMatrix):
    r"""


    Dense Matrix This class provides all the functions that can be performed using a
    Matrix stored in "Dense" format (in opposition to the "Sparse" format). This
    class can be derived in the case the matrix is Square, and even more if it is
    Square and Symmetric.  

    C++ includes: MatrixDense.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MatrixDense::MatrixDense
        """
        _gstlearn.MatrixDense_swiginit(self, _gstlearn.new_MatrixDense(*args))
    __swig_destroy__ = _gstlearn.delete_MatrixDense

    def toTL(self):
        return _gstlearn.MatrixDense_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.MatrixDense_clone(self)

    def isDense(self):
        r"""

        MatrixDense::isDense
        Cloneable interface.  

        Interface for AMatrix  

        Returns if the matrix belongs to the MatrixSparse class (avoids dynamic_cast)  

        """
        return _gstlearn.MatrixDense_isDense(self)

    def isSparse(self):
        r"""

        MatrixDense::isSparse
        Returns if the current matrix is Sparse  

        """
        return _gstlearn.MatrixDense_isSparse(self)

    def mustBeSymmetric(self):
        r"""

        MatrixDense::mustBeSymmetric
        Say if the matrix must be symmetric  

        """
        return _gstlearn.MatrixDense_mustBeSymmetric(self)

    def setValue(self, irow, icol, value, flagCheck=False):
        r"""

        MatrixDense::setValue
        Set the value for in a matrix cell  

        """
        return _gstlearn.MatrixDense_setValue(self, irow, icol, value, flagCheck)

    def getValue(self, irow, icol, flagCheck=False):
        r"""

        MatrixDense::getValue
        Get the value from a matrix cell  

        """
        return _gstlearn.MatrixDense_getValue(self, irow, icol, flagCheck)

    def updValue(self, irow, icol, oper, value, flagCheck=False):
        r"""

        MatrixDense::updValue
        Update the contents of a matrix cell  

        """
        return _gstlearn.MatrixDense_updValue(self, irow, icol, oper, value, flagCheck)

    def setColumn(self, icol, tab, flagCheck=False):
        r"""

        MatrixDense::setColumn
        Set the contents of a Column  

        """
        return _gstlearn.MatrixDense_setColumn(self, icol, tab, flagCheck)

    def setColumnToConstant(self, icol, value, flagCheck=False):
        r"""

        MatrixDense::setColumnToConstant
        Set the contents of a Column to a constant value  

        """
        return _gstlearn.MatrixDense_setColumnToConstant(self, icol, value, flagCheck)

    def setRow(self, irow, tab, flagCheck=False):
        r"""

        MatrixDense::setRow
        Set the contents of a Row  

        """
        return _gstlearn.MatrixDense_setRow(self, irow, tab, flagCheck)

    def setRowToConstant(self, irow, value, flagCheck=False):
        r"""

        MatrixDense::setRowToConstant
        Set the contents of a Row to a constant value  

        """
        return _gstlearn.MatrixDense_setRowToConstant(self, irow, value, flagCheck)

    def setDiagonal(self, tab, flagCheck=False):
        r"""

        MatrixDense::setDiagonal
        Set the contents of the (main) Diagonal  

        """
        return _gstlearn.MatrixDense_setDiagonal(self, tab, flagCheck)

    def setDiagonalToConstant(self, value=1.):
        r"""

        MatrixDense::setDiagonalToConstant
        Set the contents of the (main) Diagonal to a constant value  

        """
        return _gstlearn.MatrixDense_setDiagonalToConstant(self, value)

    def addScalar(self, v):
        r"""

        MatrixDense::addScalar
        Add a value to each matrix component  

        """
        return _gstlearn.MatrixDense_addScalar(self, v)

    def addScalarDiag(self, v):
        r"""

        MatrixDense::addScalarDiag
        Add value to matrix diagonal  

        """
        return _gstlearn.MatrixDense_addScalarDiag(self, v)

    def prodScalar(self, v):
        r"""

        MatrixDense::prodScalar
        Multiply each matrix component by a value  

        """
        return _gstlearn.MatrixDense_prodScalar(self, v)

    def fill(self, value):
        r"""

        MatrixDense::fill
        Set all the values of the Matrix at once  

        """
        return _gstlearn.MatrixDense_fill(self, value)

    def multiplyRow(self, vec):
        r"""

        MatrixDense::multiplyRow
        Multiply a Matrix row-wise  

        """
        return _gstlearn.MatrixDense_multiplyRow(self, vec)

    def multiplyColumn(self, vec):
        r"""

        MatrixDense::multiplyColumn
        Multiply a Matrix column-wise  

        """
        return _gstlearn.MatrixDense_multiplyColumn(self, vec)

    def divideRow(self, vec):
        r"""

        MatrixDense::divideRow
        Divide a Matrix row-wise  

        """
        return _gstlearn.MatrixDense_divideRow(self, vec)

    def divideColumn(self, vec):
        r"""

        MatrixDense::divideColumn
        Divide a Matrix column-wise  

        """
        return _gstlearn.MatrixDense_divideColumn(self, vec)

    def prodVecMat(self, x, transpose=False):
        r"""

        MatrixDense::prodVecMat
        Perform 'vec' * 'this'  

        """
        return _gstlearn.MatrixDense_prodVecMat(self, x, transpose)

    def prodMatVec(self, x, transpose=False):
        r"""

        MatrixDense::prodMatVec
        Perform 'this' * 'vec'  

        """
        return _gstlearn.MatrixDense_prodMatVec(self, x, transpose)

    def getRow(self, irow):
        r"""

        MatrixDense::getRow
        Extract a Row  

        """
        return _gstlearn.MatrixDense_getRow(self, irow)

    def getColumn(self, icol):
        r"""

        MatrixDense::getColumn
        Extract a Column  

        """
        return _gstlearn.MatrixDense_getColumn(self, icol)

    def getColumnPtr(self, icol):
        r"""

        MatrixDense::getColumnPtr
        """
        return _gstlearn.MatrixDense_getColumnPtr(self, icol)

    def prodMatMatInPlace(self, x, y, transposeX=False, transposeY=False):
        r"""

        MatrixDense::prodMatMatInPlace
        Multiply matrix 'x' by matrix 'y' and store the result in 'this'  

        """
        return _gstlearn.MatrixDense_prodMatMatInPlace(self, x, y, transposeX, transposeY)

    @staticmethod
    def create(*args):
        r"""

        MatrixDense::create
        """
        return _gstlearn.MatrixDense_create(*args)

    @staticmethod
    def createFromVVD(X):
        r"""

        MatrixDense::createFromVVD
        Converts a VectorVectorDouble into a Matrix Note: the input argument is stored
        by row (if coming from [] specification)  

        Parameters
        ----------
        * `X` :  
            Input VectorVectorDouble argument  

        Returns
        -------
        The returned rectangular matrix  

        remark: : the matrix is transposed implicitly while reading  

        """
        return _gstlearn.MatrixDense_createFromVVD(X)

    @staticmethod
    def createFromVD(X, nrow, ncol, byCol=False, invertColumnOrder=False):
        r"""

        MatrixDense::createFromVD
        """
        return _gstlearn.MatrixDense_createFromVD(X, nrow, ncol, byCol, invertColumnOrder)

    def addMatInPlace(self, y, cx=1., cy=1.):
        r"""

        MatrixDense::addMatInPlace
        The next functions use specific definition of matrix (to avoid dynamic_cast)
        rather than manipulating AMatrix. They are not generic of AMatrix anymore.
        WARNING: output matrix should not match any of input matrices (speed up).  

        Add a matrix (multiplied by a constant)  

        """
        return _gstlearn.MatrixDense_addMatInPlace(self, y, cx, cy)

    def prodNormMatMatInPlace(self, a, m, transpose=False):
        r"""

        MatrixDense::prodNormMatMatInPlace
        Product 't(A)' %*% 'M' %*% 'A' or 'A' %*% 'M' %*% 't(A)' stored in 'this'  

        Product of matrices, stored in 'this'  

        *   transpose = true: t('a') * 'm' * 'a'  
        *   transpose = false: 'a' * 'm' * t('a')  

        Parameters
        ----------
        * `a` :  
            First input matrix  
        * `m` :  
            Second input matrix  
        * `transpose` :  
            True if 'a' should be transposed beforehand  

        note: : 'a' and 'm' may NOT coincide with 'this'  

        """
        return _gstlearn.MatrixDense_prodNormMatMatInPlace(self, a, m, transpose)

    def prodNormMatVecInPlace(self, *args, **kwargs):
        r"""

        MatrixDense::prodNormMatVecInPlace
        Product 't(A)' %*% ['vec'] %*% 'A' or 'A' %*% ['vec'] %*% 't(A)' stored in
        'this'  

        Product 't(A)' %*% ['vec'] %*% 'A' or 'A' %*% ['vec'] %*% 't(A)' stored in
        'this'  

        Parameters
        ----------
        * `a` :  
            Input matrix  
        * `vec` :  
            Input vector  
        * `transpose` :  
            When True, the input Matrix is transposed  

        """
        return _gstlearn.MatrixDense_prodNormMatVecInPlace(self, *args, **kwargs)

    def getEigenValues(self):
        r"""

        MatrixDense::getEigenValues
        """
        return _gstlearn.MatrixDense_getEigenValues(self)

    def getEigenVectors(self):
        r"""

        MatrixDense::getEigenVectors
        """
        return _gstlearn.MatrixDense_getEigenVectors(self)

    def invert2(self, res):
        r"""

        MatrixDense::invert2
        TODO : check beforehand if matrix is invertible ?  

        """
        return _gstlearn.MatrixDense_invert2(self, res)

    @staticmethod
    def glue(A1, A2, flagShiftRow, flagShiftCol):
        r"""

        MatrixDense::glue
        """
        return _gstlearn.MatrixDense_glue(A1, A2, flagShiftRow, flagShiftCol)

    @staticmethod
    def sample(*args, **kwargs):
        r"""

        MatrixDense::sample
        Create an output Rectangular Matrix by selecting some rows and columns of the
        Input matrix 'A'.  

        Parameters
        ----------
        * `res` :  
            Output Rectangular Matrix  
        * `A` :  
            Input Rectangular Matrix  
        * `rowKeep` :  
            Set of Rows to be kept (all if not defined)  
        * `colKeep` :  
            Set of Columns to be kept (all if not defined)  
        * `flagInvertRow` :  
            when True, transform 'rowKeep' into 'rowDrop'  
        * `flagInvertCol` :  
            when True, transform 'colKeep' into 'colDrop'  

        """
        return _gstlearn.MatrixDense_sample(*args, **kwargs)

    def unsample(self, A, rowFetch, colFetch, flagInvertRow=False, flagInvertCol=False):
        r"""

        MatrixDense::unsample
        Set the values contained in 'A' into the current matrix.  

        Parameters
        ----------
        * `A` :  
            Input Matrix  
        * `rowFetch` :  
            Set of row indices of 'this' where values of 'A' should be stored  
        * `colFetch` :  
            Set of column indices of'this' where values of 'A' should be stored  
        * `flagInvertRow` :  
            when True, transform 'rowFetch' into 'rowAvoid'  
        * `flagInvertCol` :  
            when True, transform 'colFetch' into 'colAvoid'  

        """
        return _gstlearn.MatrixDense_unsample(self, A, rowFetch, colFetch, flagInvertRow, flagInvertCol)

    def compressMatLC(self, matLC, transpose=False):
        r"""

        MatrixDense::compressMatLC
        Perform the compressing product, according to 'transpose'.  

        *   False: 'this'[nrows,ncols] %*% t('matLC')[ncolsCL,nrowsCL] ->
            mat[nrows,ncolsCL]  
        *   True: t('matLC')[ncolsCL,nrowsCL] %*% 'this'[nrows,ncols] ->
            mat[ncolsCL,ncols]  

        Parameters
        ----------
        * `matLC` :  
        * `transpose` :  

        Returns
        -------
        MatrixDense  

        """
        return _gstlearn.MatrixDense_compressMatLC(self, matLC, transpose)

    def addRow(self, nrow_added=1):
        r"""

        MatrixDense::addRow
        """
        return _gstlearn.MatrixDense_addRow(self, nrow_added)

    def addColumn(self, ncolumn_added=1):
        r"""

        MatrixDense::addColumn
        """
        return _gstlearn.MatrixDense_addColumn(self, ncolumn_added)

    def prodMatMatInPlaceOptim(self, x, y, transposeX=False, transposeY=False):
        r"""

        MatrixDense::prodMatMatInPlaceOptim
        """
        return _gstlearn.MatrixDense_prodMatMatInPlaceOptim(self, x, y, transposeX, transposeY)

    def __repr__(self):
        return _gstlearn.MatrixDense___repr__(self)

# Register MatrixDense in _gstlearn:
_gstlearn.MatrixDense_swigregister(MatrixDense)
class MatrixSparse(AMatrix, ALinearOp):
    r"""


    Sparse Matrix  

    Handle a sparse matrix that can be symmetrical, square or not. Storage relies
    either on Eigen3 Library (see opt_eigen flag) or cs code. Default storage option
    can be set globally by using setGlobalFlagEigen  

    C++ includes: MatrixSparse.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MatrixSparse::MatrixSparse
        """
        _gstlearn.MatrixSparse_swiginit(self, _gstlearn.new_MatrixSparse(*args))
    __swig_destroy__ = _gstlearn.delete_MatrixSparse

    def toTL(self):
        return _gstlearn.MatrixSparse_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.MatrixSparse_clone(self)

    def getSize(self):
        r"""

        MatrixSparse::getSize
        Cloneable interface.  

        """
        return _gstlearn.MatrixSparse_getSize(self)

    def isFlagEigen(self):
        r"""

        MatrixSparse::isFlagEigen
        """
        return _gstlearn.MatrixSparse_isFlagEigen(self)

    def isSparse(self):
        r"""

        MatrixSparse::isSparse
        Interface for AMatrix.  

        Returns if the current matrix is Sparse  

        """
        return _gstlearn.MatrixSparse_isSparse(self)

    def isDense(self):
        r"""

        MatrixSparse::isDense
        Returns if the matrix belongs to the MatrixSparse class (avoids dynamic_cast)  

        """
        return _gstlearn.MatrixSparse_isDense(self)

    def setValue(self, irow, icol, value, flagCheck=True):
        r"""

        MatrixSparse::setValue
        Set the value for a matrix cell  

        """
        return _gstlearn.MatrixSparse_setValue(self, irow, icol, value, flagCheck)

    def getValue(self, row, col, flagCheck=True):
        r"""

        MatrixSparse::getValue
        Get the value from a matrix cell  

        """
        return _gstlearn.MatrixSparse_getValue(self, row, col, flagCheck)

    def updValue(self, irow, icol, oper, value, flagCheck=True):
        r"""

        MatrixSparse::updValue
        Modifies the contents of a matrix cell  

        """
        return _gstlearn.MatrixSparse_updValue(self, irow, icol, oper, value, flagCheck)

    def getRowAsMatrixSparse(self, irow, coeff=1.):
        r"""

        MatrixSparse::getRowAsMatrixSparse
        Extract a Row  

        """
        return _gstlearn.MatrixSparse_getRowAsMatrixSparse(self, irow, coeff)

    def getColumnAsMatrixSparse(self, icol, coeff=1.):
        r"""

        MatrixSparse::getColumnAsMatrixSparse
        Extract a Column  

        """
        return _gstlearn.MatrixSparse_getColumnAsMatrixSparse(self, icol, coeff)

    def setColumn(self, icol, tab, flagCheck=True):
        r"""

        MatrixSparse::setColumn
        Set the contents of a Column  

        Fill a column of an already existing Sparse matrix, using 'tab' as entry The
        input 'tab' corresponds to the whole column contents  

        Parameters
        ----------
        * `icol` :  
            Column rank  
        * `tab` :  
            Vector containing the information (Dimension: nrows)  
        * `flagCheck` :  
            When True, check the consistency of arguments  

        """
        return _gstlearn.MatrixSparse_setColumn(self, icol, tab, flagCheck)

    def setColumnToConstant(self, icol, value, flagCheck=True):
        r"""

        MatrixSparse::setColumnToConstant
        Set the contents of a Column to a constant  

        """
        return _gstlearn.MatrixSparse_setColumnToConstant(self, icol, value, flagCheck)

    def setRow(self, irow, tab, flagCheck=True):
        r"""

        MatrixSparse::setRow
        Set the contents of a Row  

        Fill a row of an already existing Sparse matrix, using 'tab' as entry The input
        'tab' corresponds to the whole row contents  

        Parameters
        ----------
        * `irow` :  
            Row rank  
        * `tab` :  
            Vector containing the information (Dimension: ncols)  
        * `flagCheck` :  
            True if the validity check must be performed  

        **Warning**: : This method only copies the values at the non-zero existing
            entries  

        """
        return _gstlearn.MatrixSparse_setRow(self, irow, tab, flagCheck)

    def setRowToConstant(self, irow, value, flagCheck=True):
        r"""

        MatrixSparse::setRowToConstant
        Set the contents of a Row to a constant  

        """
        return _gstlearn.MatrixSparse_setRowToConstant(self, irow, value, flagCheck)

    def setDiagonal(self, tab, flagCheck=True):
        r"""

        MatrixSparse::setDiagonal
        """
        return _gstlearn.MatrixSparse_setDiagonal(self, tab, flagCheck)

    def setDiagonalToConstant(self, value=1.):
        r"""

        MatrixSparse::setDiagonalToConstant
        Set the contents of the (main) Diagonal to a constant value  

        """
        return _gstlearn.MatrixSparse_setDiagonalToConstant(self, value)

    def transpose(self):
        r"""

        MatrixSparse::transpose
        Transpose the matrix and return it as a copy  

        """
        return _gstlearn.MatrixSparse_transpose(self)

    def addScalar(self, v):
        r"""

        MatrixSparse::addScalar
        Add a value to each matrix component  

        Parameters
        ----------
        * `v` :  
            Add a scalar value to all terms of the current matrix  

        """
        return _gstlearn.MatrixSparse_addScalar(self, v)

    def addScalarDiag(self, v):
        r"""

        MatrixSparse::addScalarDiag
        Add value to matrix diagonal  

        Parameters
        ----------
        * `v` :  
            Add constant value to the diagonal of the current Matrix  

        """
        return _gstlearn.MatrixSparse_addScalarDiag(self, v)

    def prodScalar(self, v):
        r"""

        MatrixSparse::prodScalar
        Multiply each matrix component by a value  

        Parameters
        ----------
        * `v` :  
            Multiply all the terms of the matrix by the scalar 'v'  

        """
        return _gstlearn.MatrixSparse_prodScalar(self, v)

    def fill(self, value):
        r"""

        MatrixSparse::fill
        Set all the values of the matrix at once  

        Parameters
        ----------
        * `value` :  
            Constant value used for filling 'this'  

        """
        return _gstlearn.MatrixSparse_fill(self, value)

    def multiplyRow(self, vec):
        r"""

        MatrixSparse::multiplyRow
        Multiply the matrix row-wise  

        Multiply a Matrix row-wise  

        """
        return _gstlearn.MatrixSparse_multiplyRow(self, vec)

    def multiplyColumn(self, vec):
        r"""

        MatrixSparse::multiplyColumn
        Multiply the matrix column-wise  

        Multiply a Matrix column-wise  

        """
        return _gstlearn.MatrixSparse_multiplyColumn(self, vec)

    def divideRow(self, vec):
        r"""

        MatrixSparse::divideRow
        Divide the matrix row-wise  

        Divide a Matrix row-wise  

        """
        return _gstlearn.MatrixSparse_divideRow(self, vec)

    def divideColumn(self, vec):
        r"""

        MatrixSparse::divideColumn
        Divide the matrix column-wise  

        Divide a Matrix column-wise  

        """
        return _gstlearn.MatrixSparse_divideColumn(self, vec)

    def prodVecMat(self, x, transpose=False):
        r"""

        MatrixSparse::prodVecMat
        Perform y = x %*% 'this'  

        """
        return _gstlearn.MatrixSparse_prodVecMat(self, x, transpose)

    def prodMatVec(self, x, transpose=False):
        r"""

        MatrixSparse::prodMatVec
        Perform y = 'this' %*% x  

        """
        return _gstlearn.MatrixSparse_prodMatVec(self, x, transpose)

    def prodMatMatInPlace(self, x, y, transposeX=False, transposeY=False):
        r"""

        MatrixSparse::prodMatMatInPlace
        Multiply matrix 'x' by matrix 'y' and store the result in 'this'  

        Store the product of 'x' by 'y' in this  

        Parameters
        ----------
        * `x` :  
            First Matrix  
        * `y` :  
            Second matrix  
        * `transposeX` :  
            True if First matrix is transposed  
        * `transposeY` :  
            True if Second matrix is transposed  

        """
        return _gstlearn.MatrixSparse_prodMatMatInPlace(self, x, y, transposeX, transposeY)

    def getMatrixToTriplet(self, shiftRow=0, shiftCol=0):
        r"""

        MatrixSparse::getMatrixToTriplet
        Extract the contents of the matrix  

        From a matrix of any type, creates the triplet (specific format for creating
        efficiently a Sparse matrix) It only takes the only non-zero elements of the
        matrix  

        """
        return _gstlearn.MatrixSparse_getMatrixToTriplet(self, shiftRow, shiftCol)

    def toString(self, strfmt=None):
        r"""

        MatrixSparse::toString
        Interface to AStringable.  

        """
        return _gstlearn.MatrixSparse_toString(self, strfmt)

    @staticmethod
    def create(*args):
        r"""

        MatrixSparse::create
        """
        return _gstlearn.MatrixSparse_create(*args)

    @staticmethod
    def createFromTriplet(NF_T, nrow=0, ncol=0, nrowmax=-1, opt_eigen=-1):
        r"""

        MatrixSparse::createFromTriplet
        """
        return _gstlearn.MatrixSparse_createFromTriplet(NF_T, nrow, ncol, nrowmax, opt_eigen)

    @staticmethod
    def addMatMat(x, y, cx=1., cy=1.):
        r"""

        MatrixSparse::addMatMat
        """
        return _gstlearn.MatrixSparse_addMatMat(x, y, cx, cy)

    @staticmethod
    def diagVec(vec, opt_eigen=-1):
        r"""

        MatrixSparse::diagVec
        """
        return _gstlearn.MatrixSparse_diagVec(vec, opt_eigen)

    @staticmethod
    def diagConstant(number, value=1., opt_eigen=-1):
        r"""

        MatrixSparse::diagConstant
        """
        return _gstlearn.MatrixSparse_diagConstant(number, value, opt_eigen)

    @staticmethod
    def diagMat(A, oper_choice, opt_eigen=-1):
        r"""

        MatrixSparse::diagMat
        Construct a sparse matrix with the diagonal of 'A', where each element is
        transformed  

        Parameters
        ----------
        * `A` :  
            Input sparse matrix  
        * `oper_choice` :  
            Operation on the diagonal term (see Utilities::operate_XXX)  
        * `opt_eigen` :  
            Option for choosing Eigen Library or not  

        Returns
        -------  

        """
        return _gstlearn.MatrixSparse_diagMat(A, oper_choice, opt_eigen)

    @staticmethod
    def glue(A1, A2, flagShiftRow, flagShiftCol):
        r"""

        MatrixSparse::glue
        """
        return _gstlearn.MatrixSparse_glue(A1, A2, flagShiftRow, flagShiftCol)

    @staticmethod
    def glueInPlace(A1, A2, flagShiftRow, flagShiftCol):
        r"""

        MatrixSparse::glueInPlace
        """
        return _gstlearn.MatrixSparse_glueInPlace(A1, A2, flagShiftRow, flagShiftCol)

    def addMatInPlace(self, y, cx=1., cy=1.):
        r"""

        MatrixSparse::addMatInPlace
        The next functions use specific definition of matrix (to avoid dynamic_cast)
        rather than manipulating AMatrix. They are no more generic of AMatrix.  

        Add a matrix (multiplied by a constant)  

        Updates the current Matrix as a linear combination of matrices as follows: this
        <- cx * this + cy * y  

        Parameters
        ----------
        * `cx` :  
            Coefficient applied to the current Matrix  
        * `cy` :  
            Coefficient applied to the Matrix 'y'  
        * `y` :  
            Second Matrix in the Linear combination  

        """
        return _gstlearn.MatrixSparse_addMatInPlace(self, y, cx, cy)

    def prodNormMatMatInPlace(self, a, m, transpose=False):
        r"""

        MatrixSparse::prodNormMatMatInPlace
        Product 't(A)' %*% 'M' %*% 'A' or 'A' %*% 'M' %*% 't(A)' stored in 'this'  

        """
        return _gstlearn.MatrixSparse_prodNormMatMatInPlace(self, a, m, transpose)

    def prodNormMatVecInPlace(self, *args, **kwargs):
        r"""

        MatrixSparse::prodNormMatVecInPlace
        Product 't(A)' %*% ['vec'] %*% 'A' or 'A' %*% ['vec'] %*% 't(A)' stored in
        'this'  

        """
        return _gstlearn.MatrixSparse_prodNormMatVecInPlace(self, *args, **kwargs)

    def resetFromValue(self, nrows, ncols, value):
        r"""

        MatrixSparse::resetFromValue
        Reset the matrix to new dimensions and fill with a new value.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  
        * `value` :  
            The new value used to fill the matrix  

        """
        return _gstlearn.MatrixSparse_resetFromValue(self, nrows, ncols, value)

    def resetFromArray(self, nrows, ncols, tab, byCol=True):
        r"""

        MatrixSparse::resetFromArray
        Reset the matrix from an array of double values.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  
        * `tab` :  
            The array of values  
        * `byCol` :  
            True if values are column-major in the array  

        """
        return _gstlearn.MatrixSparse_resetFromArray(self, nrows, ncols, tab, byCol)

    def resetFromVD(self, nrows, ncols, tab, byCol=True):
        r"""

        MatrixSparse::resetFromVD
        Reset the matrix from a vector of double values.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows  
        * `ncols` :  
            New number of columns  
        * `tab` :  
            The vector of values  
        * `byCol` :  
            True if values are column-major in the vector  

        """
        return _gstlearn.MatrixSparse_resetFromVD(self, nrows, ncols, tab, byCol)

    def resetFromVVD(self, tab, byCol=True):
        r"""

        MatrixSparse::resetFromVVD
        Reset the matrix from an array of double values.  

        Parameters
        ----------
        * `tab` :  
            The array of values  
        * `byCol` :  
            True if values are column-major in the array  

        """
        return _gstlearn.MatrixSparse_resetFromVVD(self, tab, byCol)

    def resetFromTriplet(self, NF_T):
        r"""

        MatrixSparse::resetFromTriplet
        """
        return _gstlearn.MatrixSparse_resetFromTriplet(self, NF_T)

    @staticmethod
    def dumpElements(title, ifrom, ito):
        r"""

        MatrixSparse::dumpElements
        Dump a specific range of samples from the internal storage  

        """
        return _gstlearn.MatrixSparse_dumpElements(title, ifrom, ito)

    def fillRandom(self, seed=432432, zeroPercent=0):
        r"""

        MatrixSparse::fillRandom
        Set all the values of the Matrix with random values  

        """
        return _gstlearn.MatrixSparse_fillRandom(self, seed, zeroPercent)

    def addValue(self, row, col, value):
        r"""

        MatrixSparse::addValue
        """
        return _gstlearn.MatrixSparse_addValue(self, row, col, value)

    def L1Norm(self):
        r"""

        MatrixSparse::L1Norm
        """
        return _gstlearn.MatrixSparse_L1Norm(self)

    def getStats(self, nrows, ncols, count, percent):
        r"""

        MatrixSparse::getStats
        """
        return _gstlearn.MatrixSparse_getStats(self, nrows, ncols, count, percent)

    def scaleByDiag(self):
        r"""

        MatrixSparse::scaleByDiag
        """
        return _gstlearn.MatrixSparse_scaleByDiag(self)

    def addVecInPlaceVD(self, x, y):
        r"""

        MatrixSparse::addVecInPlaceVD
        """
        return _gstlearn.MatrixSparse_addVecInPlaceVD(self, x, y)

    def setConstant(self, value):
        r"""

        MatrixSparse::setConstant
        """
        return _gstlearn.MatrixSparse_setConstant(self, value)

    def extractDiag(self, oper_choice=1):
        r"""

        MatrixSparse::extractDiag
        """
        return _gstlearn.MatrixSparse_extractDiag(self, oper_choice)

    def prodNormDiagVecInPlace(self, vec, oper=1):
        r"""

        MatrixSparse::prodNormDiagVecInPlace
        Perform: 'this' = diag('vec') %*% 'A' %*% diag('vec')  

        Parameters
        ----------
        * `vec` :  
            Input Vector  
        * `oper_choice` :  
            Type of transformation  

        """
        return _gstlearn.MatrixSparse_prodNormDiagVecInPlace(self, vec, oper)

    def extractSubmatrixByRanks(self, rank_rows, rank_cols):
        r"""

        MatrixSparse::extractSubmatrixByRanks
        """
        return _gstlearn.MatrixSparse_extractSubmatrixByRanks(self, rank_rows, rank_cols)

    def extractSubmatrixByColor(self, colors, ref_color, row_ok, col_ok):
        r"""

        MatrixSparse::extractSubmatrixByColor
        """
        return _gstlearn.MatrixSparse_extractSubmatrixByColor(self, colors, ref_color, row_ok, col_ok)

    def colorCoding(self):
        r"""

        MatrixSparse::colorCoding
        """
        return _gstlearn.MatrixSparse_colorCoding(self)

    def getNonZeros(self):
        r"""

        MatrixSparse::getNonZeros
        """
        return _gstlearn.MatrixSparse_getNonZeros(self)

    def gibbs(self, iech, zcur, yk, sk):
        r"""

        MatrixSparse::gibbs
        """
        return _gstlearn.MatrixSparse_gibbs(self, iech, zcur, yk, sk)

    def forwardLU(self, b, x, flagLower=True):
        r"""

        MatrixSparse::forwardLU
        """
        return _gstlearn.MatrixSparse_forwardLU(self, b, x, flagLower)

    def forceDimension(self, maxRows, maxCols):
        r"""

        MatrixSparse::forceDimension
        """
        return _gstlearn.MatrixSparse_forceDimension(self, maxRows, maxCols)

    def __repr__(self):
        return _gstlearn.MatrixSparse___repr__(self)

# Register MatrixSparse in _gstlearn:
_gstlearn.MatrixSparse_swigregister(MatrixSparse)

def createFromAnyMatrix(mat, opt_eigen=-1):
    r"""


    Transform any matrix into a Sparse format  

    """
    return _gstlearn.createFromAnyMatrix(mat, opt_eigen)

def setUpdateNonZeroValue(status=2):
    r"""


    """
    return _gstlearn.setUpdateNonZeroValue(status)

def getUpdateNonZeroValue():
    r"""


    """
    return _gstlearn.getUpdateNonZeroValue()

def prodNormDiagVec(a, vec, oper_choice=1):
    r"""


    Product 'Diag(vec)' %*% 'A' %*% 'Diag(vec)'  

    """
    return _gstlearn.prodNormDiagVec(a, vec, oper_choice)

def setGlobalFlagEigen(flagEigen):
    r"""


    Manage global flag for EIGEN.  

    Modify the parameter for using EIGEN library or not. Warning: this must be
    performed very early in the script in order to forbid mixing two different
    styles.  

    Parameters
    ----------
    * `flagEigen` :  
        True if EIGEN library must be used; False otherwise (cs is used)  

    """
    return _gstlearn.setGlobalFlagEigen(flagEigen)

def isGlobalFlagEigen():
    r"""


    """
    return _gstlearn.isGlobalFlagEigen()
class MatrixSquare(MatrixDense):
    r"""


    Square Matrix  

    C++ includes: MatrixSquare.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MatrixSquare::MatrixSquare
        """
        _gstlearn.MatrixSquare_swiginit(self, _gstlearn.new_MatrixSquare(*args))
    __swig_destroy__ = _gstlearn.delete_MatrixSquare

    def toTL(self):
        return _gstlearn.MatrixSquare_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.MatrixSquare_clone(self)

    def determinant(self):
        r"""

        MatrixSquare::determinant
        ICloneable interface.  

        Interface for AMatrix  

        """
        return _gstlearn.MatrixSquare_determinant(self)

    def isSquare(self, printWhyNot=False):
        r"""

        MatrixSquare::isSquare
        Check if the matrix is (non empty) square  

        """
        return _gstlearn.MatrixSquare_isSquare(self, printWhyNot)

    def mustBeSymmetric(self):
        r"""

        MatrixSquare::mustBeSymmetric
        Say if the matrix must be symmetric  

        """
        return _gstlearn.MatrixSquare_mustBeSymmetric(self)

    def getNSize(self):
        r"""

        MatrixSquare::getNSize
        Returns the size of the matrix (nrows=ncols)  

        """
        return _gstlearn.MatrixSquare_getNSize(self)

    def resetFromVVD(self, tab, byCol=True):
        r"""

        MatrixSquare::resetFromVVD
        Reset the matrix from an array of double values.  

        Parameters
        ----------
        * `tab` :  
            The array of values  
        * `byCol` :  
            True if values are column-major in the array  

        """
        return _gstlearn.MatrixSquare_resetFromVVD(self, tab, byCol)

    @staticmethod
    def createFromVVD(X):
        r"""

        MatrixSquare::createFromVVD
        Converts a VectorVectorDouble into a Matrix Note: the input argument is stored
        by row (if coming from [] specification)  

        Parameters
        ----------
        * `X` :  
            Input VectorVectorDouble argument  

        Returns
        -------
        The returned square matrix  

        remark: : the matrix is transposed implicitly while reading  

        """
        return _gstlearn.MatrixSquare_createFromVVD(X)

    @staticmethod
    def createFromVD(X, nrow, byCol=False, invertColumnOrder=False):
        r"""

        MatrixSquare::createFromVD
        """
        return _gstlearn.MatrixSquare_createFromVD(X, nrow, byCol, invertColumnOrder)

    def trace(self):
        r"""

        MatrixSquare::trace
        """
        return _gstlearn.MatrixSquare_trace(self)

    def innerMatrix(self, x, r1, r2):
        r"""

        MatrixSquare::innerMatrix
        Perform inner product  

        Perform the product: this = t(R1) %*% X %*% R2 + t(R2) %*% X %*% R1  

        Parameters
        ----------
        * `x` :  
            Square matrix  
        * `r1` :  
            Left Hand Matrix  
        * `r2` :  
            Right Hand Matrix  

        remark: The number of rows of Y must be equal to the dimension of X  

        remark: The output matrix is square with dimension equal to the number of
            columns of Y  

        """
        return _gstlearn.MatrixSquare_innerMatrix(self, x, r1, r2)

    def prodDiagByVector(self, diag):
        r"""

        MatrixSquare::prodDiagByVector
        Multiply the diagonal by a vector  

        """
        return _gstlearn.MatrixSquare_prodDiagByVector(self, diag)

    def divideDiagByVector(self, diag):
        r"""

        MatrixSquare::divideDiagByVector
        Divide the diagonal by a vector  

        """
        return _gstlearn.MatrixSquare_divideDiagByVector(self, diag)

    def prodByDiagInPlace(self, mode, c):
        r"""

        MatrixSquare::prodByDiagInPlace
        Multiply by a Diagonal matrix provided as VectorDouble (in place)  

        Performs the 'this' %*% diag(c) where c is a vector  

        Parameters
        ----------
        * `mode` :  
            0: c as is; 1: sqrt(c); 2: 1/c; 3: 1/sqrt(c)  
        * `c` :  
            vector  

        """
        return _gstlearn.MatrixSquare_prodByDiagInPlace(self, mode, c)

    def normVec(self, vec):
        r"""

        MatrixSquare::normVec
        """
        return _gstlearn.MatrixSquare_normVec(self, vec)

    def decomposeLU(self, tls, tus, eps=1.e-20):
        r"""

        MatrixSquare::decomposeLU
        LU Decomposition of a square matrix (not necessarily symmetric)  

        Parameters
        ----------
        * `tls` :  
            Output square matrix containing lower triangle (stored columnwise)  
        * `tus` :  
            Output square matrix containing upper triangle (stored linewise)  
        * `eps` :  
            Tolerance  

        remark: The output matrices 'tus' and 'tls' must be dimensioned beforehand  

        """
        return _gstlearn.MatrixSquare_decomposeLU(self, tls, tus, eps)

    def __repr__(self):
        return _gstlearn.MatrixSquare___repr__(self)

# Register MatrixSquare in _gstlearn:
_gstlearn.MatrixSquare_swigregister(MatrixSquare)

def prodNormMatMat(*args):
    r"""


    Product 't(A)' %*% 'M' %*% 'A' or 'A' %*% 'M' %*% 't(A)'  

    """
    return _gstlearn.prodNormMatMat(*args)

def prodNormMat(*args):
    r"""


    Product 't(A)' %*% 'A' or 'A' %*% 't(A)'  

    """
    return _gstlearn.prodNormMat(*args)
class NF_Triplet(object):
    r"""


    Stores the contents of a sparse matrix in Triplet form The format is adapter to
    Eigen or to csparse  

    C++ includes: NF_Triplet.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        NF_Triplet::NF_Triplet
        """
        _gstlearn.NF_Triplet_swiginit(self, _gstlearn.new_NF_Triplet(*args))
    __swig_destroy__ = _gstlearn.delete_NF_Triplet

    def toTL(self):
        return _gstlearn.NF_Triplet_toTL(self)

    def add(self, irow, icol, value):
        r"""

        NF_Triplet::add
        """
        return _gstlearn.NF_Triplet_add(self, irow, icol, value)

    def getNElements(self):
        r"""

        NF_Triplet::getNElements
        """
        return _gstlearn.NF_Triplet_getNElements(self)

    def getNRows(self):
        r"""

        NF_Triplet::getNRows
        """
        return _gstlearn.NF_Triplet_getNRows(self)

    def getNCols(self):
        r"""

        NF_Triplet::getNCols
        """
        return _gstlearn.NF_Triplet_getNCols(self)

    def force(self, nrow, ncol):
        r"""

        NF_Triplet::force
        Force the dimension of the Sparse matrix This is done by adding a fictitious
        sample at position 'nrow-1' and 'ncol-1' with value 0  

        Parameters
        ----------
        * `nrow` :  
            Ultimate number of rows  
        * `ncol` :  
            Ultimate number of columns  

        """
        return _gstlearn.NF_Triplet_force(self, nrow, ncol)

    def getRow(self, i):
        r"""

        NF_Triplet::getRow
        """
        return _gstlearn.NF_Triplet_getRow(self, i)

    def getCol(self, i):
        r"""

        NF_Triplet::getCol
        """
        return _gstlearn.NF_Triplet_getCol(self, i)

    def getValue(self, i):
        r"""

        NF_Triplet::getValue
        """
        return _gstlearn.NF_Triplet_getValue(self, i)

    def getValues(self):
        r"""

        NF_Triplet::getValues
        """
        return _gstlearn.NF_Triplet_getValues(self)

    def getRows(self, flag_from_1=False):
        r"""

        NF_Triplet::getRows
        """
        return _gstlearn.NF_Triplet_getRows(self, flag_from_1)

    def getCols(self, flag_from_1=False):
        r"""

        NF_Triplet::getCols
        """
        return _gstlearn.NF_Triplet_getCols(self, flag_from_1)

    def appendInPlace(self, T2):
        r"""

        NF_Triplet::appendInPlace
        Append NF_Triplet 'T2' at the end of the current one  

        Parameters
        ----------
        * `T2` :  
            NF_Triplet to be appended  

        """
        return _gstlearn.NF_Triplet_appendInPlace(self, T2)

# Register NF_Triplet in _gstlearn:
_gstlearn.NF_Triplet_swigregister(NF_Triplet)
class MatrixSymmetric(MatrixSquare):
    r"""


    Square Symmetric matrices  

    C++ includes: MatrixSymmetric.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MatrixSymmetric::MatrixSymmetric
        """
        _gstlearn.MatrixSymmetric_swiginit(self, _gstlearn.new_MatrixSymmetric(*args))
    __swig_destroy__ = _gstlearn.delete_MatrixSymmetric

    def toTL(self):
        return _gstlearn.MatrixSymmetric_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.MatrixSymmetric_clone(self)

    def mustBeSymmetric(self):
        r"""

        MatrixSymmetric::mustBeSymmetric
        ICloneable interface.  

        Interface to AMatrix  

        """
        return _gstlearn.MatrixSymmetric_mustBeSymmetric(self)

    def isSymmetric(self, eps=1.e-10, printWhyNot=False):
        r"""

        MatrixSymmetric::isSymmetric
        Check if the input matrix is (non empty and square) symmetric  

        Indicate if the current matrix is symmetric  

        Parameters
        ----------
        * `eps` :  
            Epsilon for double equality comparison  
        * `printWhyNot` :  
            Print the message is the answer is false  

        Returns
        -------
        true if the current matrix is symmetric  

        """
        return _gstlearn.MatrixSymmetric_isSymmetric(self, eps, printWhyNot)

    def resetFromVVD(self, tab, byCol=True):
        r"""

        MatrixSymmetric::resetFromVVD
        Reset the matrix from an array of double values.  

        Parameters
        ----------
        * `tab` :  
            The array of values  
        * `byCol` :  
            True if values are column-major in the array  

        """
        return _gstlearn.MatrixSymmetric_resetFromVVD(self, tab, byCol)

    def normMatrix(self, *args, **kwargs):
        r"""

        MatrixSymmetric::normMatrix
        Perform the product: this = t(Y) %*% X %*% Y (T=false) or Y % X %*% t(Y)
        (T=true)  

        Parameters
        ----------
        * `y` :  
            Matrix (possibly rectangular)  
        * `x` :  
            Square matrix (optional)  
        * `transpose` :  
            transposition flag (T in the description)  

        remark: The number of rows of Y must be equal to the dimension of X  

        remark: The output matrix is square with dimension equal to the number of
            columns of Y  

        """
        return _gstlearn.MatrixSymmetric_normMatrix(self, *args, **kwargs)

    @staticmethod
    def createFromVVD(X):
        r"""

        MatrixSymmetric::createFromVVD
        Converts a VectorVectorDouble into a Square Symmetric Matrix Note: the input
        argument is stored by row (if coming from [] specification)  

        Parameters
        ----------
        * `X` :  
            Input VectorVectorDouble argument  

        Returns
        -------
        The returned square symmetric matrix  

        remark: : the matrix is transposed implicitly while reading  

        """
        return _gstlearn.MatrixSymmetric_createFromVVD(X)

    @staticmethod
    def createFromVD(X):
        r"""

        MatrixSymmetric::createFromVD
        """
        return _gstlearn.MatrixSymmetric_createFromVD(X)

    @staticmethod
    def createFromTLTU(neq, tl):
        r"""

        MatrixSymmetric::createFromTLTU
        Create the Symmetric matrix as the product of 'tl' (lower triangle) by its
        transpose  

        Parameters
        ----------
        * `neq` :  
            Number of rows or columns in the system  
        * `tl` :  
            Lower triangular matrix defined by column (Dimension; neq*(neq+1)/2)  

        """
        return _gstlearn.MatrixSymmetric_createFromTLTU(neq, tl)

    @staticmethod
    def createFromTriangle(mode, neq, tl):
        r"""

        MatrixSymmetric::createFromTriangle
        Fill a square matrix with a triangular matrix  

        Parameters
        ----------
        * `mode` :  
            0: TL (upper); 1: TL (lower)  
        * `neq` :  
            number of equations in the system  
        * `tl` :  
            Triangular matrix (any part)  

        """
        return _gstlearn.MatrixSymmetric_createFromTriangle(mode, neq, tl)

    @staticmethod
    def createRandomDefinitePositive(neq, seed=13242):
        r"""

        MatrixSymmetric::createRandomDefinitePositive
        """
        return _gstlearn.MatrixSymmetric_createRandomDefinitePositive(neq, seed)

    @staticmethod
    def sample(res, A, rowKeep, flagInvert=False):
        r"""

        MatrixSymmetric::sample
        Create an output Square Symmetric Matrix by selecting some rows (and columns) of
        the Input matrix 'A'.  

        Parameters
        ----------
        * `res` :  
            Output Square Symmetric Matrix  
        * `A` :  
            Input Square Symmetric Matrix  
        * `rowKeep` :  
            Set of Rows (same for columns) to be kept  
        * `flagInvert` :  
            when True, transform 'rowKeep' into 'rowDrop'  

        """
        return _gstlearn.MatrixSymmetric_sample(res, A, rowKeep, flagInvert)

    def computeEigen(self, optionPositive=True):
        r"""

        MatrixSymmetric::computeEigen
        """
        return _gstlearn.MatrixSymmetric_computeEigen(self, optionPositive)

    def computeGeneralizedEigen(self, b, optionPositive=True):
        r"""

        MatrixSymmetric::computeGeneralizedEigen
        """
        return _gstlearn.MatrixSymmetric_computeGeneralizedEigen(self, b, optionPositive)

    def computeGeneralizedInverse(self, tabout, maxicond=1.e20, eps=1.e-20):
        r"""

        MatrixSymmetric::computeGeneralizedInverse
        Calculate the generalized inverse of the input square symmetric matrix  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `tabout` :  
            Inverted matrix (suqrae symmetric)  
        * `maxicond` :  
            Maximum value for the Condition Index (MAX(ABS(eigval)))  
        * `eps` :  
            Tolerance  

        remark: The input and output matrices can match  

        """
        return _gstlearn.MatrixSymmetric_computeGeneralizedInverse(self, tabout, maxicond, eps)

    def isDefinitePositive(self):
        r"""

        MatrixSymmetric::isDefinitePositive
        Check if a matrix is definite positive  

        Returns
        -------
        True if the matrix is definite positive; False otherwise  

        """
        return _gstlearn.MatrixSymmetric_isDefinitePositive(self)

    def minimizeWithConstraintsInPlace(self, gmat, aemat, bemat, aimat, bimat, xmat):
        r"""

        MatrixSymmetric::minimizeWithConstraintsInPlace
        Minimize 1/2 t(x) %*% H %*% x + t(g) %*% x under the constraints t(Ae) %*% x =
        be and t(Ai) %*% x = bi  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `gmat` :  
            right-hand side vector (Dimension: neq)  
        * `aemat` :  
            Matrix rectangular for equalities (Dimension: neq * nae)  
        * `bemat` :  
            right-hand side for equalities (Dimension: nae)  
        * `aimat` :  
            Matrix rectangular for inequalities (Dimension: neq * nai)  
        * `bimat` :  
            right-hand side for inequalities (Dimension: nai)  
        * `xmat` :  
            solution of the linear system with constraints (neq)  

        REMARKS: The initial xmat has to be satisfied by all the constraints.  

        """
        return _gstlearn.MatrixSymmetric_minimizeWithConstraintsInPlace(self, gmat, aemat, bemat, aimat, bimat, xmat)

    def _isPhysicallyPresent(self, irow, icol):
        r"""

        MatrixSymmetric::_isPhysicallyPresent
        Say if (irow, icol) is stored physically or not  

        """
        return _gstlearn.MatrixSymmetric__isPhysicallyPresent(self, irow, icol)

    def _setValues(self, values, byCol=True):
        r"""

        MatrixSymmetric::_setValues
        **Warning**: : values is provided as a square complete matrix  

        """
        return _gstlearn.MatrixSymmetric__setValues(self, values, byCol)

    def _invert(self):
        r"""

        MatrixSymmetric::_invert
        """
        return _gstlearn.MatrixSymmetric__invert(self)

    def _matrix_qo(self, gmat, xmat):
        r"""

        MatrixSymmetric::_matrix_qo
        Solve a linear system: H %*% g = x  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `gmat` :  
            right-hand side vector (Dimension: neq)  
        * `xmat` :  
            solution vector (Dimension: neq)  

        remark: In output, 'this' contains the inverse matrix  

        """
        return _gstlearn.MatrixSymmetric__matrix_qo(self, gmat, xmat)

    def _matrix_qoc(self, flag_invert, gmat, na, amat, bmat, xmat, _lambda):
        r"""

        MatrixSymmetric::_matrix_qoc
        Minimize 1/2 t(x) %*% H %*% x + t(g) %*% x under the constraints t(A) %*% x = b  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `flag_invert` :  
            Tells if the inverse has already been calculated  
        * `gmat` :  
            right-hand side vector (Dimension: neq)  
        * `na` :  
            Number of equalities  
        * `amat` :  
            matrix for inequalities (Dimension: neq * na)  
        * `bmat` :  
            inequality vector (Dimension: na)  
        * `xmat` :  
            solution of the linear system with no constraint. On return, solution with
            constraints (Dimension: neq)  
        * `lambda` :  
            working vector (Dimension: na)  

        remark: In input:  

        remark: If flag_invert== 1, H is provided as the generalized inverse  

        remark: and x contains the solution of the linear system with no constraint  

        remark: If flag_invert==0, H is the primal matrix  

        remark: In output, H contains the inverse matrix  

        """
        return _gstlearn.MatrixSymmetric__matrix_qoc(self, flag_invert, gmat, na, amat, bmat, xmat, _lambda)

    def _constraintsError(self, active, aimat, bimat, xmat, vmat, flag):
        r"""

        MatrixSymmetric::_constraintsError
        Calculate how constraints are fulfilled  

        Returns
        -------
        Count of the constraints not fulfilled  

        Parameters
        ----------
        * `active` :  
            Array of active/non active inequalities (optional)  
        * `aimat` :  
            Inequality material (Dimension: neq * nai)  
        * `bimat` :  
            right-hand side for inequalities (Dimension: nai)  
        * `xmat` :  
            solution of the linear system with no constraint (neq)  
        * `vmat` :  
            matrix of errors (if not NULL)  
        * `flag` :  
            array specifying if constraint is active (if not NULL)  

        """
        return _gstlearn.MatrixSymmetric__constraintsError(self, active, aimat, bimat, xmat, vmat, flag)

    @staticmethod
    def _constraintsConcatenateMat(nae, nai, neq, active, tabemat, tabimat, tabout):
        r"""

        MatrixSymmetric::_constraintsConcatenateMat
        Concatenate the equality and the active inequality material  

        Returns
        -------
        The total number of constraints  

        Parameters
        ----------
        * `nae` :  
            Number of equalities  
        * `nai` :  
            Number of inequalities  
        * `neq` :  
            First dimension of the array  
        * `active` :  
            Array of active/non active inequalities  
        * `tabemat` :  
            Equality material (Dimension: neq * nai)  
        * `tabimat` :  
            Inequality material  
        * `tabout` :  
            Output array  

        """
        return _gstlearn.MatrixSymmetric__constraintsConcatenateMat(nae, nai, neq, active, tabemat, tabimat, tabout)

    @staticmethod
    def _constraintsConcatenateVD(nae, nai, active, tabemat, tabimat, tabout):
        r"""

        MatrixSymmetric::_constraintsConcatenateVD
        Concatenate the equality and the active inequality material  

        Returns
        -------
        The total number of constraints  

        Parameters
        ----------
        * `nae` :  
            Number of equalities  
        * `nai` :  
            Number of inequalities  
        * `active` :  
            Array of active/non active inequalities  
        * `tabemat` :  
            Equality material (Dimension: neq * nai)  
        * `tabimat` :  
            Inequality material  
        * `tabout` :  
            Output array  

        """
        return _gstlearn.MatrixSymmetric__constraintsConcatenateVD(nae, nai, active, tabemat, tabimat, tabout)

    @staticmethod
    def _constraintsCount(nai, active):
        r"""

        MatrixSymmetric::_constraintsCount
        Count the number of active constraints  

        Returns
        -------
        Number of active constraints  

        Parameters
        ----------
        * `nai` :  
            Number of constraints  
        * `active` :  
            Array of constraint status  

        """
        return _gstlearn.MatrixSymmetric__constraintsCount(nai, active)

    def _terminateEigen(self, eigenValues, eigenVectors, optionPositive=True, changeOrder=False):
        r"""

        MatrixSymmetric::_terminateEigen
        """
        return _gstlearn.MatrixSymmetric__terminateEigen(self, eigenValues, eigenVectors, optionPositive, changeOrder)

    def compress0MatLC(self, matLC):
        r"""

        MatrixSymmetric::compress0MatLC
        """
        return _gstlearn.MatrixSymmetric_compress0MatLC(self, matLC)

    def __repr__(self):
        return _gstlearn.MatrixSymmetric___repr__(self)

# Register MatrixSymmetric in _gstlearn:
_gstlearn.MatrixSymmetric_swigregister(MatrixSymmetric)
class MatrixFactory(object):
    r"""


    C++ includes: MatrixFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def prodMatMat(x, y, transposeX=False, transposeY=False):
        r"""

        MatrixFactory::prodMatMat
        Performs the product of two matrices: X * Y  

        Returns
        -------
        Pointer to the newly created AMatrix matrix  

        Parameters
        ----------
        * `x` :  
            First AMatrix matrix  
        * `y` :  
            Second AMatrix matrix  
        * `transposeX` :  
            True if First matrix is transposed  
        * `transposeY` :  
            True if Second matrix is transposed  

        remark: : To be called as follows: MatrixSparse* mat =
            MatrixFactory::prodMatMat<MatrixSparse>(x, y);  

        TODO : Why 2 methods for MatrixFactory::prodMatMat ?  

        TODO : if MatrixSparse => x or y 'eigen flag' is ignored  

        """
        return _gstlearn.MatrixFactory_prodMatMat(x, y, transposeX, transposeY)

    @staticmethod
    def createMatrixSquare(x, nrow):
        r"""

        MatrixFactory::createMatrixSquare
        Create a Matrix similar to the input one with a given row number  

        Returns
        -------
        Pointer to the newly created AMatrix matrix  

        Parameters
        ----------
        * `x` :  
            First AMatrix matrix  
        * `nrow` :  
            Number of rows  

        TODO : use typeinfo  

        """
        return _gstlearn.MatrixFactory_createMatrixSquare(x, nrow)

    @staticmethod
    def createReduce(*args, **kwargs):
        r"""

        MatrixFactory::createReduce
        Create a submatrix from an input matrix by specifying the list of rows and
        columns to be extracted or excluded  

        Parameters
        ----------
        * `x` :  
            Input matrix  
        * `selRows` :  
            List of selected rows  
        * `selCols` :  
            List of selected columns  
        * `flagKeepRows` :  
            True if the selected rows must be kept (they must be excluded otherwise)  
        * `flagKeepCols` :  
            True if the selected columns must be kept (they must be excluded otherwise)  

        Returns
        -------  

        remark: If a list if not defined, the whole set of rows (resp. columns) is
            considered)  

        remark: (this assumes that flagKeep is True)  

        TODO : use typeinfo  

        """
        return _gstlearn.MatrixFactory_createReduce(*args, **kwargs)

    @staticmethod
    def createReduceOne(x, selRow=-1, selCol=-1, flagKeepRow=True, flagKeepCol=True):
        r"""

        MatrixFactory::createReduceOne
        Create a submatrix from an input matrix by specifying the row and or column to
        be extracted or excluded  

        Parameters
        ----------
        * `x` :  
            Input matrix  
        * `selRow` :  
            Rank of the selected row  
        * `selCol` :  
            Rank of the selected column  
        * `flagKeepRow` :  
            True if the selected row must be kept (it must be excluded otherwise)  
        * `flagKeepCol` :  
            True if the selected column must be kept (it must be excluded otherwise)  

        Returns
        -------  

        remark: If a rank is negative, the whole set of rows (resp. columns) is
            considered)  

        remark: (this assumes that flagKeep is True)  

        """
        return _gstlearn.MatrixFactory_createReduceOne(x, selRow, selCol, flagKeepRow, flagKeepCol)

    @staticmethod
    def createGlue(a1, a2, flagShiftRow, flagShiftCol):
        r"""

        MatrixFactory::createGlue
        Concatenate two matrices  

        Returns
        -------
        Pointer on the newly created concatenated matrix (or NULL)  

        Parameters
        ----------
        * `a1` :  
            Pointer to the first matrix  
        * `a2` :  
            Pointer to the second matrix  
        * `flagShiftRow` :  
            Concatenate by Row  
        * `flagShiftCol` :  
            Concatenate by Column  

        """
        return _gstlearn.MatrixFactory_createGlue(a1, a2, flagShiftRow, flagShiftCol)

    def __init__(self):
        r"""


        C++ includes: MatrixFactory.hpp

        """
        _gstlearn.MatrixFactory_swiginit(self, _gstlearn.new_MatrixFactory())
    __swig_destroy__ = _gstlearn.delete_MatrixFactory

# Register MatrixFactory in _gstlearn:
_gstlearn.MatrixFactory_swigregister(MatrixFactory)
class MatrixInt(AStringable, ICloneable):
    r"""


    Rectangular matrices are stored by columns  

    C++ includes: MatrixInt.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MatrixInt::MatrixInt
        """
        _gstlearn.MatrixInt_swiginit(self, _gstlearn.new_MatrixInt(*args))
    __swig_destroy__ = _gstlearn.delete_MatrixInt

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.MatrixInt_clone(self)

    def toString(self, strfmt=None):
        r"""

        MatrixInt::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.MatrixInt_toString(self, strfmt)

    @staticmethod
    def createFromVI(X, nrow, ncol, byCol=False):
        r"""

        MatrixInt::createFromVI
        """
        return _gstlearn.MatrixInt_createFromVI(X, nrow, ncol, byCol)

    @staticmethod
    def createFromVVI(X):
        r"""

        MatrixInt::createFromVVI
        Converts a VectorVectorInt into a MatrixInt Note: the input argument is stored
        by row (if coming from [] specification)  

        Parameters
        ----------
        * `X` :  
            Input VectorVectorInt argument  

        Returns
        -------
        The returned rectangular matrix  

        remark: : the matrix is transposed implicitly while reading  

        """
        return _gstlearn.MatrixInt_createFromVVI(X)

    def reset(self, nrows, ncols):
        r"""

        MatrixInt::reset
        """
        return _gstlearn.MatrixInt_reset(self, nrows, ncols)

    def resetFromArray(self, nrows, ncols, tab, byCol=True):
        r"""

        MatrixInt::resetFromArray
        """
        return _gstlearn.MatrixInt_resetFromArray(self, nrows, ncols, tab, byCol)

    def getValue(self, *args):
        r"""

        MatrixInt::getValue
        """
        return _gstlearn.MatrixInt_getValue(self, *args)

    def setValueByRank(self, rank, value):
        r"""

        MatrixInt::setValueByRank
        """
        return _gstlearn.MatrixInt_setValueByRank(self, rank, value)

    def setValue(self, irow, icol, value):
        r"""

        MatrixInt::setValue
        """
        return _gstlearn.MatrixInt_setValue(self, irow, icol, value)

    def getMatrixSize(self):
        r"""

        MatrixInt::getMatrixSize
        """
        return _gstlearn.MatrixInt_getMatrixSize(self)

    def size(self):
        r"""

        MatrixInt::size
        """
        return _gstlearn.MatrixInt_size(self)

    def getValues(self):
        r"""

        MatrixInt::getValues
        """
        return _gstlearn.MatrixInt_getValues(self)

    def getValuesPerRow(self, irow):
        r"""

        MatrixInt::getValuesPerRow
        """
        return _gstlearn.MatrixInt_getValuesPerRow(self, irow)

    def getValuesPerColumn(self, icol):
        r"""

        MatrixInt::getValuesPerColumn
        """
        return _gstlearn.MatrixInt_getValuesPerColumn(self, icol)

    def getMatrix(self):
        r"""

        MatrixInt::getMatrix
        """
        return _gstlearn.MatrixInt_getMatrix(self)

    def setValues(self, values, byCol=True):
        r"""

        MatrixInt::setValues
        Filling the matrix with an array of values Note that this array is ALWAYS
        dimensioned to the total number of elements in the matrix. Kept for
        compatibility with old code where matrix contents was stored as a int* array  

        Parameters
        ----------
        * `values` :  
            Input array (Dimension: nrow * ncol)  
        * `byCol` :  
            true for Column major; false for Row Major  

        """
        return _gstlearn.MatrixInt_setValues(self, values, byCol)

    def setValuesOldStyle(self, values, byCol=True):
        r"""

        MatrixInt::setValuesOldStyle
        """
        return _gstlearn.MatrixInt_setValuesOldStyle(self, values, byCol)

    def transposeInPlace(self):
        r"""

        MatrixInt::transposeInPlace
        """
        return _gstlearn.MatrixInt_transposeInPlace(self)

    def empty(self):
        r"""

        MatrixInt::empty
        """
        return _gstlearn.MatrixInt_empty(self)

    def fill(self, value):
        r"""

        MatrixInt::fill
        """
        return _gstlearn.MatrixInt_fill(self, value)

    def getNCols(self):
        r"""

        MatrixInt::getNCols
        """
        return _gstlearn.MatrixInt_getNCols(self)

    def setNCols(self, cols):
        r"""

        MatrixInt::setNCols
        """
        return _gstlearn.MatrixInt_setNCols(self, cols)

    def getNRows(self):
        r"""

        MatrixInt::getNRows
        """
        return _gstlearn.MatrixInt_getNRows(self)

    def setNRows(self, rows):
        r"""

        MatrixInt::setNRows
        """
        return _gstlearn.MatrixInt_setNRows(self, rows)

    def __call__(self, *args):
        return _gstlearn.MatrixInt___call__(self, *args)

    def __repr__(self):
        return _gstlearn.MatrixInt___repr__(self)

# Register MatrixInt in _gstlearn:
_gstlearn.MatrixInt_swigregister(MatrixInt)
class Table(MatrixDense, ASerializable):
    r"""


    Stores an array of values as a Table, i.e. a MatrixDense where rows and columns
    can be optionally decorated  

    C++ includes: Table.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Table::Table
        """
        _gstlearn.Table_swiginit(self, _gstlearn.new_Table(*args))
    __swig_destroy__ = _gstlearn.delete_Table

    def toTL(self):
        return _gstlearn.Table_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.Table_clone(self)

    def reset(self, nrows, ncols):
        r"""

        Table::reset
        Cloneable interface.  

        """
        return _gstlearn.Table_reset(self, nrows, ncols)

    def toString(self, strfmt=None):
        r"""

        Table::toString
        Print the contents of the statistics  

        """
        return _gstlearn.Table_toString(self, strfmt)

    @staticmethod
    def create(nrow=0, ncol=0):
        r"""

        Table::create
        """
        return _gstlearn.Table_create(nrow, ncol)

    @staticmethod
    def createFromNames(rownames, colnames):
        r"""

        Table::createFromNames
        """
        return _gstlearn.Table_createFromNames(rownames, colnames)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        Table::createFromNF
        """
        return _gstlearn.Table_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromTable(table):
        r"""

        Table::createFromTable
        """
        return _gstlearn.Table_createFromTable(table)

    def getRange(self, icol):
        r"""

        Table::getRange
        """
        return _gstlearn.Table_getRange(self, icol)

    def getAllRange(self):
        r"""

        Table::getAllRange
        """
        return _gstlearn.Table_getAllRange(self)

    def plot(self, isimu):
        r"""

        Table::plot
        Plot the contents of the statistics  

        """
        return _gstlearn.Table_plot(self, isimu)

    def setColumnNames(self, colNames):
        r"""

        Table::setColumnNames
        """
        return _gstlearn.Table_setColumnNames(self, colNames)

    def setColumnName(self, icol, name):
        r"""

        Table::setColumnName
        """
        return _gstlearn.Table_setColumnName(self, icol, name)

    def setRowNames(self, rowNames):
        r"""

        Table::setRowNames
        """
        return _gstlearn.Table_setRowNames(self, rowNames)

    def setRowName(self, irow, name):
        r"""

        Table::setRowName
        """
        return _gstlearn.Table_setRowName(self, irow, name)

    def getColumnNames(self):
        r"""

        Table::getColumnNames
        """
        return _gstlearn.Table_getColumnNames(self)

    def getRowNames(self):
        r"""

        Table::getRowNames
        """
        return _gstlearn.Table_getRowNames(self)

    def getColumnName(self, icol):
        r"""

        Table::getColumnName
        """
        return _gstlearn.Table_getColumnName(self, icol)

    def getRowName(self, irow):
        r"""

        Table::getRowName
        """
        return _gstlearn.Table_getRowName(self, irow)

    def getTitle(self):
        r"""

        Table::getTitle
        """
        return _gstlearn.Table_getTitle(self)

    def setTitle(self, title):
        r"""

        Table::setTitle
        """
        return _gstlearn.Table_setTitle(self, title)

    def setSkipDescription(self, skipDescription):
        r"""

        Table::setSkipDescription
        """
        return _gstlearn.Table_setSkipDescription(self, skipDescription)

    def setSkipTitle(self, skipTitle):
        r"""

        Table::setSkipTitle
        """
        return _gstlearn.Table_setSkipTitle(self, skipTitle)

    def __repr__(self):
        return _gstlearn.Table___repr__(self)

# Register Table in _gstlearn:
_gstlearn.Table_swigregister(Table)
class ISkinFunctions(object):
    r"""


    C++ includes: ISkinFunctions.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ISkinFunctions

    def isAlreadyFilled(self, arg2):
        r"""

        ISkinFunctions::isAlreadyFilled
        """
        return _gstlearn.ISkinFunctions_isAlreadyFilled(self, arg2)

    def isToBeFilled(self, arg2):
        r"""

        ISkinFunctions::isToBeFilled
        """
        return _gstlearn.ISkinFunctions_isToBeFilled(self, arg2)

    def getWeight(self, arg2, arg3):
        r"""

        ISkinFunctions::getWeight
        """
        return _gstlearn.ISkinFunctions_getWeight(self, arg2, arg3)

# Register ISkinFunctions in _gstlearn:
_gstlearn.ISkinFunctions_swigregister(ISkinFunctions)
class Skin(object):
    r"""


    C++ includes: Skin.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Skin::Skin
        """
        _gstlearn.Skin_swiginit(self, _gstlearn.new_Skin(*args))
    __swig_destroy__ = _gstlearn.delete_Skin

    def gridShift(self, lec, dir):
        r"""

        Skin::gridShift
        Returns the shifted node of a skin  

        Returns
        -------
        The absolute sample address  

        Parameters
        ----------
        * `lec` :  
            Absolute grid index of the input grid node  
        * `dir` :  
            Rank of the direction  

        """
        return _gstlearn.Skin_gridShift(self, lec, dir)

    def init(self, verbose=False):
        r"""

        Skin::init
        Initialize the skin  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.Skin_init(self, verbose)

    def remains(self, verbose=False):
        r"""

        Skin::remains
        Returns the number of cells still to be processed  

        Returns
        -------
        Returns the number of cells still to be processed  

        """
        return _gstlearn.Skin_remains(self, verbose)

    def getNext(self, rank, ipos):
        r"""

        Skin::getNext
        Find the next cell at random within the skin  

        Parameters
        ----------
        * `rank` :  
            Location of the cell in the skin  
        * `ipos` :  
            Cell location  

        """
        return _gstlearn.Skin_getNext(self, rank, ipos)

    def unstack(self, rank0, ipos0):
        r"""

        Skin::unstack
        Suppress the current cell from the skin  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `rank0` :  
            Rank of the current cell in the skin  
        * `ipos0` :  
            Cell location  

        """
        return _gstlearn.Skin_unstack(self, rank0, ipos0)

    def skinPrint(self):
        r"""

        Skin::skinPrint
        Print the computing information concerning the skin algorithm  

        """
        return _gstlearn.Skin_skinPrint(self)

# Register Skin in _gstlearn:
_gstlearn.Skin_swigregister(Skin)
class AMesh(AStringable, ASerializable):
    r"""


    C++ includes: AMesh.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AMesh

    def toString(self, strfmt=None):
        r"""

        AMesh::toString
        Interface to AStringable.  

        """
        return _gstlearn.AMesh_toString(self, strfmt)

    def getNApexPerMesh(self):
        r"""

        AMesh::getNApexPerMesh
        Interface for AMesh.  

        Returns the number of apex per mesh  

        """
        return _gstlearn.AMesh_getNApexPerMesh(self)

    def getNApices(self):
        r"""

        AMesh::getNApices
        Returns the number of apices  

        """
        return _gstlearn.AMesh_getNApices(self)

    def getNMeshes(self):
        r"""

        AMesh::getNMeshes
        Returns the number of meshes  

        """
        return _gstlearn.AMesh_getNMeshes(self)

    def getApex(self, imesh, rank):
        r"""

        AMesh::getApex
        Returns the rank of apex 'rank' for mesh 'imesh'  

        """
        return _gstlearn.AMesh_getApex(self, imesh, rank)

    def getCoor(self, imesh, rank, idim):
        r"""

        AMesh::getCoor
        Returns coordinate 'idim' of apex 'rank' of mesh 'imesh'  

        """
        return _gstlearn.AMesh_getCoor(self, imesh, rank, idim)

    def getCoordinatesPerMeshInPlace(self, imesh, rank, coords):
        r"""

        AMesh::getCoordinatesPerMeshInPlace
        Returns coordinate 'idim' of apex 'rank' of mesh 'imesh'  

        """
        return _gstlearn.AMesh_getCoordinatesPerMeshInPlace(self, imesh, rank, coords)

    def getApexCoor(self, i, idim):
        r"""

        AMesh::getApexCoor
        Returns coordinate 'idim' of apex 'i'  

        """
        return _gstlearn.AMesh_getApexCoor(self, i, idim)

    def getApexCoordinatesInPlace(self, i, coords):
        r"""

        AMesh::getApexCoordinatesInPlace
        Returns coordinates of apex 'i'  

        """
        return _gstlearn.AMesh_getApexCoordinatesInPlace(self, i, coords)

    def getMeshSize(self, imesh):
        r"""

        AMesh::getMeshSize
        Returns the mesh size  

        """
        return _gstlearn.AMesh_getMeshSize(self, imesh)

    def resetProjFromDb(self, m, db, rankZ=-1, verbose=False):
        r"""

        AMesh::resetProjFromDb
        Initialize the Sparse Matrix for projecting the Db on a Mesh  

        Returns the Sparse Matrix used to project a Db onto the Meshing  

        Parameters
        ----------
        * `m` :  
            Projection matrix to be initialized  
        * `db` :  
            Db structure  
        * `rankZ` :  
            Rank of the Z-locator to be tested (see remarks)  
        * `verbose` :  
            Verbose flag  

        remark: If rankZ>=0, a sample is only considered if the value  

        remark: of the corresponding variable is defined  

        """
        return _gstlearn.AMesh_resetProjFromDb(self, m, db, rankZ, verbose)

    def getVariety(self):
        r"""

        AMesh::getVariety
        Returns the space variety  

        """
        return _gstlearn.AMesh_getVariety(self)

    def getEmbeddedNDim(self):
        r"""

        AMesh::getEmbeddedNDim
        """
        return _gstlearn.AMesh_getEmbeddedNDim(self)

    def getEmbeddedCoorPerMesh(self, imesh, ic, coords):
        r"""

        AMesh::getEmbeddedCoorPerMesh
        Fill the coordinates of a corner of a mesh in embedded space  

        Parameters
        ----------
        * `imesh` :  
            Mesh rank  
        * `ic` :  
            Corner index  
        * `coords` :  
            Array of coordinates  

        """
        return _gstlearn.AMesh_getEmbeddedCoorPerMesh(self, imesh, ic, coords)

    def getEmbeddedCoorPerApex(self, iapex, coords):
        r"""

        AMesh::getEmbeddedCoorPerApex
        Fill the coordinates of an apex in embedded space  

        Parameters
        ----------
        * `iapex` :  
            Apex index  
        * `coords` :  
            Array of coordinates  

        """
        return _gstlearn.AMesh_getEmbeddedCoorPerApex(self, iapex, coords)

    def getBarycenterInPlace(self, imesh, coord):
        r"""

        AMesh::getBarycenterInPlace
        """
        return _gstlearn.AMesh_getBarycenterInPlace(self, imesh, coord)

    def createProjMatrix(self, db, rankZ=-1, verbose=False):
        r"""

        AMesh::createProjMatrix
        Returns the Sparse Matrix for projecting the Mesh to a Db  

        """
        return _gstlearn.AMesh_createProjMatrix(self, db, rankZ, verbose)

    def getNDim(self):
        r"""

        AMesh::getNDim
        Returns the space dimension  

        """
        return _gstlearn.AMesh_getNDim(self)

    def getExtendMin(self, idim):
        r"""

        AMesh::getExtendMin
        Returns the minimum of the Bounding box for a given space dimension  

        """
        return _gstlearn.AMesh_getExtendMin(self, idim)

    def getExtendMax(self, idim):
        r"""

        AMesh::getExtendMax
        Returns the maximum of the Bounding box for a given space dimension  

        """
        return _gstlearn.AMesh_getExtendMax(self, idim)

    def getExtrema(self, idim):
        r"""

        AMesh::getExtrema
        Returns the Vector of Extrema of the Bounding Box  

        """
        return _gstlearn.AMesh_getExtrema(self, idim)

    def getElements(self, apices, meshes):
        r"""

        AMesh::getElements
        Returns the list of apexes and meshes  

        Extract the elements of the meshing  

        Parameters
        ----------
        * `apices` :  
            Pointer on the array of Apices  
        * `meshes` :  
            Pointer on the array of Meshes  

        """
        return _gstlearn.AMesh_getElements(self, apices, meshes)

    def isCompatibleDb(self, db):
        r"""

        AMesh::isCompatibleDb
        Checks that the Db is compatible with the Meshing  

        Returns
        -------
        1 if Db and Meshing are incompatible; 0 otherwise  

        Parameters
        ----------
        * `db` :  
            Db structure  

        """
        return _gstlearn.AMesh_isCompatibleDb(self, db)

    def getMeshSizes(self):
        r"""

        AMesh::getMeshSizes
        """
        return _gstlearn.AMesh_getMeshSizes(self)

    def printMesh(self, imesh0):
        r"""

        AMesh::printMesh
        Print the list of meshes and apices  

        """
        return _gstlearn.AMesh_printMesh(self, imesh0)

    def printMeshes(self, level=0, nline_max=-1):
        r"""

        AMesh::printMeshes
        """
        return _gstlearn.AMesh_printMeshes(self, level, nline_max)

    def getCoordinatesPerApex(self, idim):
        r"""

        AMesh::getCoordinatesPerApex
        Returns Vector of Apex coordinates for space index  

        """
        return _gstlearn.AMesh_getCoordinatesPerApex(self, idim)

    def getMeshByApexPair(self, apex1, apex2):
        r"""

        AMesh::getMeshByApexPair
        Returns the list of indices of Meshes sharing the same Apex  

        """
        return _gstlearn.AMesh_getMeshByApexPair(self, apex1, apex2)

    def getApexCoordinates(self, iapex):
        r"""

        AMesh::getApexCoordinates
        Returns the coordinates of an Apex  

        """
        return _gstlearn.AMesh_getApexCoordinates(self, iapex)

    def getCoordinatesPerMesh(self, *args):
        r"""

        AMesh::getCoordinatesPerMesh
        """
        return _gstlearn.AMesh_getCoordinatesPerMesh(self, *args)

    def getEmbeddedCoordinatesPerMesh(self, imesh=0):
        r"""

        AMesh::getEmbeddedCoordinatesPerMesh
        Returns the array of coordinates of all apices of any mesh in embedded space Its
        dimensions are: ncorner * ndim  

        Parameters
        ----------
        * `imesh` :  
            Mesh rank  

        Returns
        -------  

        """
        return _gstlearn.AMesh_getEmbeddedCoordinatesPerMesh(self, imesh)

    def getEmbeddedCoordinatesPerMeshInPlace(self, imesh, vec):
        r"""

        AMesh::getEmbeddedCoordinatesPerMeshInPlace
        Fill the array of coordinates of all apices of a mesh in embedded space Storage
        [ndim, ncorner]  

        Parameters
        ----------
        * `imesh` :  
            Mesh rank  
        * `vec` :  
            Returned array  

        """
        return _gstlearn.AMesh_getEmbeddedCoordinatesPerMeshInPlace(self, imesh, vec)

    def getEmbeddedCoordinatesPerApex(self):
        r"""

        AMesh::getEmbeddedCoordinatesPerApex
        Returns the coordinates of the Mesh apices expressed in the embedded space The
        returned vector is organized by coordinate  

        Returns
        -------  

        """
        return _gstlearn.AMesh_getEmbeddedCoordinatesPerApex(self)

    def getDistances(self, *args, **kwargs):
        r"""

        AMesh::getDistances
        """
        return _gstlearn.AMesh_getDistances(self, *args, **kwargs)

    def getAllCoordinates(self):
        r"""

        AMesh::getAllCoordinates
        Returns the coordinates of all meshes:  

        *   the first dimension if the space dimension  
        *   the second dimension is the number of apices  

            Returns:  

        """
        return _gstlearn.AMesh_getAllCoordinates(self)

    def getAllApices(self):
        r"""

        AMesh::getAllApices
        Returns the information about all apices:  

        *   the first dimension is the number of meshes (nrow)  
        *   the second dimension if the space dimension (ncol)  

            Returns:  

        """
        return _gstlearn.AMesh_getAllApices(self)

    def getAllMeshes(self):
        r"""

        AMesh::getAllMeshes
        Returns the information of all meshes:  

        *   the first dimension is the number of apices (nrow)  
        *   the second dimension if the space dimension (ncol)  

            Returns:  

        """
        return _gstlearn.AMesh_getAllMeshes(self)

    def getCenterCoordinate(self, imesh, idim):
        r"""

        AMesh::getCenterCoordinate
        Returns the coordinates of the Center of Gravity of a Mesh  

        Parameters
        ----------
        * `imesh` :  
            Rank of the Mesh  
        * `idim` :  
            Index of the space dimension  

        Returns
        -------  

        """
        return _gstlearn.AMesh_getCenterCoordinate(self, imesh, idim)

    def getAllCenterCoordinates(self):
        r"""

        AMesh::getAllCenterCoordinates
        """
        return _gstlearn.AMesh_getAllCenterCoordinates(self)

    def getNeighborhoodPerMesh(self):
        r"""

        AMesh::getNeighborhoodPerMesh
        Returns the list of neighboring meshes This is a complex structure which stands
        as a vector of vectors of integers  

        *   the first dimension is the number of apices  
        *   for each apex, the second vector gives the indices of the neighboring meshes  

            Returns:  

        """
        return _gstlearn.AMesh_getNeighborhoodPerMesh(self)

    def getNeighborhoodPerApex(self):
        r"""

        AMesh::getNeighborhoodPerApex
        Returns the list of neighboring apices This is a complex structure which stands
        as a vector of vectors of integers  

        *   the first dimension is the number of apices  
        *   for each apex, the second vector gives the indices of the neighboring apices  

            Returns:  

        """
        return _gstlearn.AMesh_getNeighborhoodPerApex(self)

    @staticmethod
    def dumpNeighborhood(Vmesh, nline_max=1):
        r"""

        AMesh::dumpNeighborhood
        """
        return _gstlearn.AMesh_dumpNeighborhood(Vmesh, nline_max)

    def __repr__(self):
        return _gstlearn.AMesh___repr__(self)

# Register AMesh in _gstlearn:
_gstlearn.AMesh_swigregister(AMesh)
class MeshEStandard(AMesh):
    r"""


    Standard Meshing defined in the Euclidean space  

    C++ includes: MeshEStandard.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MeshEStandard::MeshEStandard
        """
        _gstlearn.MeshEStandard_swiginit(self, _gstlearn.new_MeshEStandard(*args))
    __swig_destroy__ = _gstlearn.delete_MeshEStandard

    def toString(self, strfmt=None):
        r"""

        MeshEStandard::toString
        Interface to AStringable.  

        Print the contents of the meshing  

        Parameters
        ----------
        * `strfmt` :  
            Format for printout  

        """
        return _gstlearn.MeshEStandard_toString(self, strfmt)

    def getNApices(self):
        r"""

        MeshEStandard::getNApices
        Interface for AMesh.  

        Returns the number of Apices  

        Returns
        -------
        Number of apices  

        """
        return _gstlearn.MeshEStandard_getNApices(self)

    def getNMeshes(self):
        r"""

        MeshEStandard::getNMeshes
        Returns the number of Meshes  

        Returns
        -------
        Number of meshes  

        """
        return _gstlearn.MeshEStandard_getNMeshes(self)

    def getApex(self, imesh, rank):
        r"""

        MeshEStandard::getApex
        Returns the rank of the Apex 'rank' of the Mesh 'imesh'  

        Returns
        -------
        The rank of the target apex  

        Parameters
        ----------
        * `imesh` :  
            Rank of Mesh (from 0 to _nMeshes-1))  
        * `rank` :  
            Rank of Apex within a Mesh (from 0 to _nApexPerMesh)  

        """
        return _gstlearn.MeshEStandard_getApex(self, imesh, rank)

    def getCoor(self, imesh, rank, idim):
        r"""

        MeshEStandard::getCoor
        Returns the coordinate 'idim' of the Apex 'rank' of the Mesh 'imesh'  

        Returns
        -------
        The coordinate of the target apex  

        Parameters
        ----------
        * `imesh` :  
            Rank of the Mesh (from 0 to _nMeshes-1))  
        * `rank` :  
            Rank of Apex within a Mesh (from 0 to _nApexPerMesh-1)  
        * `idim` :  
            Rank of the coordinate (from 0 to _nDim-1)  

        """
        return _gstlearn.MeshEStandard_getCoor(self, imesh, rank, idim)

    def getApexCoor(self, i, idim):
        r"""

        MeshEStandard::getApexCoor
        Returns coordinate 'idim' of apex 'i'  

        """
        return _gstlearn.MeshEStandard_getApexCoor(self, i, idim)

    def getMeshSize(self, imesh):
        r"""

        MeshEStandard::getMeshSize
        Returns the size of the Mesh 'imesh'  

        Returns
        -------
        mesh dimension  

        Parameters
        ----------
        * `imesh` :  
            Rank of the Mesh (from 0 to _nMeshes-1))  

        """
        return _gstlearn.MeshEStandard_getMeshSize(self, imesh)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        MeshEStandard::createFromNF
        Create a MeshEStandard by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (MeshEStandard format)  
        * `verbose` :  
            Verbose  

        """
        return _gstlearn.MeshEStandard_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromExternal(apices, meshes, verbose=False):
        r"""

        MeshEStandard::createFromExternal
        """
        return _gstlearn.MeshEStandard_createFromExternal(apices, meshes, verbose)

    def getMeshList(self):
        r"""

        MeshEStandard::getMeshList
        """
        return _gstlearn.MeshEStandard_getMeshList(self)

    def getPointList(self, byCol=True):
        r"""

        MeshEStandard::getPointList
        Returns the list of mesh vertex information This List is organized as a single
        Vector of Double It is dimensioned to Nrows=getNApices() and Ncols=getNDim()  

        Parameters
        ----------
        * `byCol` :  
            true if the values must be sorted by column  

        Returns
        -------  

        """
        return _gstlearn.MeshEStandard_getPointList(self, byCol)

    def reset(self, *args):
        r"""

        MeshEStandard::reset
        Create the meshing (from mesh information)  

        Parameters
        ----------
        * `ndim` :  
            Space Dimension  
        * `napexpermesh` :  
            Number of apices per mesh  
        * `apices` :  
            Vector of Apex information  
        * `meshes` :  
            Vector of mesh indices  
        * `byCol` :  
            true for Column major; false for Row Major  
        * `verbose` :  
            Verbose flag  

        remark: The argument 'byCol' concerns 'apices' and 'meshes'  

        """
        return _gstlearn.MeshEStandard_reset(self, *args)

    def resetFromTurbo(self, turbo, verbose=False):
        r"""

        MeshEStandard::resetFromTurbo
        """
        return _gstlearn.MeshEStandard_resetFromTurbo(self, turbo, verbose)

    def getApices(self):
        r"""

        MeshEStandard::getApices
        """
        return _gstlearn.MeshEStandard_getApices(self)

    def getMeshes(self):
        r"""

        MeshEStandard::getMeshes
        """
        return _gstlearn.MeshEStandard_getMeshes(self)

    def __repr__(self):
        return _gstlearn.MeshEStandard___repr__(self)

# Register MeshEStandard in _gstlearn:
_gstlearn.MeshEStandard_swigregister(MeshEStandard)
class MeshETurbo(AMesh):
    r"""


    Meshing defined as a Turbo based on a Regular Grid It actually avoids storing
    all the meshing information and produces faster methods  

    C++ includes: MeshETurbo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MeshETurbo::MeshETurbo
        """
        _gstlearn.MeshETurbo_swiginit(self, _gstlearn.new_MeshETurbo(*args))
    __swig_destroy__ = _gstlearn.delete_MeshETurbo

    def toString(self, strfmt=None):
        r"""

        MeshETurbo::toString
        Interface to AStringable.  

        Print the contents of the meshing  

        Parameters
        ----------
        * `strfmt` :  
            Format for printout  

        """
        return _gstlearn.MeshETurbo_toString(self, strfmt)

    def getNApices(self):
        r"""

        MeshETurbo::getNApices
        Interface to AMesh.  

        Returns the total number of apices of the whole grid (not accounting for
        possible mask on meshes)  

        Returns
        -------  

        """
        return _gstlearn.MeshETurbo_getNApices(self)

    def getNMeshes(self):
        r"""

        MeshETurbo::getNMeshes
        Actual number of (active) meshes  

        Returns
        -------  

        """
        return _gstlearn.MeshETurbo_getNMeshes(self)

    def getApex(self, imesh, rank):
        r"""

        MeshETurbo::getApex
        Returns the Apex 'rank' of the Mesh 'imesh'  

        Returns
        -------
        The rank of the target apex  

        Parameters
        ----------
        * `imesh` :  
            Rank of active Mesh (starting from 0)  
        * `rank` :  
            Rank of Apex within a Mesh (from 0 to _nApexPerMesh-1)  

        """
        return _gstlearn.MeshETurbo_getApex(self, imesh, rank)

    def getCoor(self, imesh, rank, idim):
        r"""

        MeshETurbo::getCoor
        Returns coordinate 'idim' of apex 'rank' of mesh 'imesh'  

        """
        return _gstlearn.MeshETurbo_getCoor(self, imesh, rank, idim)

    def getCoordinatesPerMeshInPlace(self, imesh, rank, coords):
        r"""

        MeshETurbo::getCoordinatesPerMeshInPlace
        Returns coordinate 'idim' of apex 'rank' of mesh 'imesh'  

        """
        return _gstlearn.MeshETurbo_getCoordinatesPerMeshInPlace(self, imesh, rank, coords)

    def getApexCoor(self, i, idim):
        r"""

        MeshETurbo::getApexCoor
        Returns coordinate 'idim' of apex 'i'  

        """
        return _gstlearn.MeshETurbo_getApexCoor(self, i, idim)

    def getApexCoordinatesInPlace(self, i, coords):
        r"""

        MeshETurbo::getApexCoordinatesInPlace
        Returns coordinates of apex 'i'  

        """
        return _gstlearn.MeshETurbo_getApexCoordinatesInPlace(self, i, coords)

    def getMeshSize(self, imesh):
        r"""

        MeshETurbo::getMeshSize
        Returns the mesh size  

        """
        return _gstlearn.MeshETurbo_getMeshSize(self, imesh)

    def resetProjFromDb(self, m, db, rankZ=-1, verbose=False):
        r"""

        MeshETurbo::resetProjFromDb
        Returns the Sparse Matrix used to project a Db onto the Meshing  

        Parameters
        ----------
        * `m` :  
            Projection matrix to be initialized  
        * `db` :  
            Db structure  
        * `rankZ` :  
            Rank of the Z-locator to be tested (see remarks)  
        * `verbose` :  
            Verbose flag  

        remark: If rankZ>=0, a sample is only considered if:  

            *   the value of the corresponding variable is defined  
            *   the sample is covered by the grid of the Turbo Meshing  

        """
        return _gstlearn.MeshETurbo_resetProjFromDb(self, m, db, rankZ, verbose)

    def setPolarized(self, flag):
        r"""

        MeshETurbo::setPolarized
        """
        return _gstlearn.MeshETurbo_setPolarized(self, flag)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        MeshETurbo::create
        """
        return _gstlearn.MeshETurbo_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        MeshETurbo::createFromNF
        Create a MeshETurbo by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (MeshEStandard format)  
        * `verbose` :  
            Verbose  

        """
        return _gstlearn.MeshETurbo_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromGrid(dbgrid, flag_polarized=False, verbose=False, mode=1):
        r"""

        MeshETurbo::createFromGrid
        """
        return _gstlearn.MeshETurbo_createFromGrid(dbgrid, flag_polarized, verbose, mode)

    @staticmethod
    def createFromGridInfo(grid, flag_polarized=False, verbose=False, mode=1):
        r"""

        MeshETurbo::createFromGridInfo
        """
        return _gstlearn.MeshETurbo_createFromGridInfo(grid, flag_polarized, verbose, mode)

    @staticmethod
    def createFromCova(cova, field, ratio, nbExt=0, isPolarized=False, useSel=True, nxmax=300, verbose=False):
        r"""

        MeshETurbo::createFromCova
        """
        return _gstlearn.MeshETurbo_createFromCova(cova, field, ratio, nbExt, isPolarized, useSel, nxmax, verbose)

    def initFromExtend(self, *args, **kwargs):
        r"""

        MeshETurbo::initFromExtend
        Create the meshing  

        Parameters
        ----------
        * `extendmin` :  
            Minimum of the dilated rotated bounding box  
        * `extendmax` :  
            Minimum of the dilated rotated bounding box  
        * `cellsize` :  
            Array giving the cell size  
        * `rotmat` :  
            Rotation matrix (optional)  
        * `flag_polarized` :  
            Switching ON/OFF the polarization  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.MeshETurbo_initFromExtend(self, *args, **kwargs)

    def initFromGridByMatrix(self, *args, **kwargs):
        r"""

        MeshETurbo::initFromGridByMatrix
        """
        return _gstlearn.MeshETurbo_initFromGridByMatrix(self, *args, **kwargs)

    def initFromGridByAngles(self, *args, **kwargs):
        r"""

        MeshETurbo::initFromGridByAngles
        """
        return _gstlearn.MeshETurbo_initFromGridByAngles(self, *args, **kwargs)

    def initFromCova(self, cova, field, ratio, nbExt=0, isPolarized=False, useSel=True, nxmax=300, verbose=False):
        r"""

        MeshETurbo::initFromCova
        """
        return _gstlearn.MeshETurbo_initFromCova(self, cova, field, ratio, nbExt, isPolarized, useSel, nxmax, verbose)

    def getGrid(self):
        r"""

        MeshETurbo::getGrid
        """
        return _gstlearn.MeshETurbo_getGrid(self)

    def getGridIndirect(self):
        r"""

        MeshETurbo::getGridIndirect
        """
        return _gstlearn.MeshETurbo_getGridIndirect(self)

    def getMeshIndirect(self):
        r"""

        MeshETurbo::getMeshIndirect
        """
        return _gstlearn.MeshETurbo_getMeshIndirect(self)

    def getApexIndicesInPlace(self, i, indg):
        r"""

        MeshETurbo::getApexIndicesInPlace
        """
        return _gstlearn.MeshETurbo_getApexIndicesInPlace(self, i, indg)

    def getMeshFromCoordinates(self, coor, indices, lambdas):
        r"""

        MeshETurbo::getMeshFromCoordinates
        Given the coordinates of a point, return the corresponding mesh index and
        updates the apex indices.  

        Parameters
        ----------
        * `coor` :  
            Input coordinates  
        * `indices` :  
            Returned vector of apex indices  
        * `lambdas` :  
            Returned vector of weights (barycenter coordinates)  

        Returns
        -------
        Rank of the mesh (-1 if point does not belong to the meshing)  

        """
        return _gstlearn.MeshETurbo_getMeshFromCoordinates(self, coor, indices, lambdas)

    def __repr__(self):
        return _gstlearn.MeshETurbo___repr__(self)

# Register MeshETurbo in _gstlearn:
_gstlearn.MeshETurbo_swigregister(MeshETurbo)

def isTurbo(meshes):
    r"""


    Check if a series of Meshes (included in 'meshes') are Turbo.  

    Parameters
    ----------
    * `meshes` :  

    Returns
    -------
    True if ALL meshes are TURBO  

    """
    return _gstlearn.isTurbo(meshes)
class MeshSpherical(AMesh):
    r"""


    Meshing defined in the Spherical Space  

    C++ includes: MeshSpherical.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MeshSpherical::MeshSpherical
        """
        _gstlearn.MeshSpherical_swiginit(self, _gstlearn.new_MeshSpherical(*args))
    __swig_destroy__ = _gstlearn.delete_MeshSpherical

    def toString(self, strfmt=None):
        r"""

        MeshSpherical::toString
        Interface to AStringable.  

        Print the contents of the meshing  

        Parameters
        ----------
        * `strfmt` :  
            Format for printout  

        """
        return _gstlearn.MeshSpherical_toString(self, strfmt)

    def getNApices(self):
        r"""

        MeshSpherical::getNApices
        Interface to AMesh.  

        Returns the number of Apices  

        Returns
        -------
        Number of apices  

        """
        return _gstlearn.MeshSpherical_getNApices(self)

    def getNMeshes(self):
        r"""

        MeshSpherical::getNMeshes
        Returns the number of Meshes  

        Returns
        -------
        Number of meshes  

        """
        return _gstlearn.MeshSpherical_getNMeshes(self)

    def getMeshSize(self, imesh):
        r"""

        MeshSpherical::getMeshSize
        Returns the size of the Mesh 'imesh'  

        Returns
        -------
        mesh dimension  

        Parameters
        ----------
        * `imesh` :  
            Rank of the Mesh (from 0 to _nMeshes-1))  

        """
        return _gstlearn.MeshSpherical_getMeshSize(self, imesh)

    def getApex(self, imesh, rank):
        r"""

        MeshSpherical::getApex
        Returns the rank of the Apex 'rank' of the Mesh 'imesh'  

        Returns
        -------
        The rank of the target apex  

        Parameters
        ----------
        * `imesh` :  
            Rank of the Mesh (from 0 to _nMeshes-1))  
        * `rank` :  
            Rank of the Apex within a Mesh (from 0 to _nApices-1)  

        """
        return _gstlearn.MeshSpherical_getApex(self, imesh, rank)

    def getCoor(self, imesh, rank, idim):
        r"""

        MeshSpherical::getCoor
        Returns the coordinate 'ic' of the Apex 'rank' of the Mesh 'imesh'  

        Returns
        -------
        The coordinate of the target apex  

        Parameters
        ----------
        * `imesh` :  
            Rank of the Mesh (from 0 to _nMeshes-1))  
        * `rank` :  
            Rank of the Apex within a Mesh (from 0 to _nApices-1)  
        * `idim` :  
            Rank of the coordinate (from 0 to _ndimh-1)  

        """
        return _gstlearn.MeshSpherical_getCoor(self, imesh, rank, idim)

    def getApexCoor(self, i, idim):
        r"""

        MeshSpherical::getApexCoor
        Returns coordinate 'idim' of apex 'i'  

        """
        return _gstlearn.MeshSpherical_getApexCoor(self, i, idim)

    def getEmbeddedNDim(self):
        r"""

        MeshSpherical::getEmbeddedNDim
        """
        return _gstlearn.MeshSpherical_getEmbeddedNDim(self)

    def getEmbeddedCoorPerMesh(self, imesh, ic, coords):
        r"""

        MeshSpherical::getEmbeddedCoorPerMesh
        Fill the coordinates of a corner of a mesh in embedded space  

        Parameters
        ----------
        * `imesh` :  
            Mesh rank  
        * `ic` :  
            Corner index  
        * `coords` :  
            Array of coordinates  

        """
        return _gstlearn.MeshSpherical_getEmbeddedCoorPerMesh(self, imesh, ic, coords)

    def getEmbeddedCoorPerApex(self, iapex, coords):
        r"""

        MeshSpherical::getEmbeddedCoorPerApex
        Fill the coordinates of an apex in embedded space  

        Parameters
        ----------
        * `iapex` :  
            Apex index  
        * `coords` :  
            Array of coordinates  

        """
        return _gstlearn.MeshSpherical_getEmbeddedCoorPerApex(self, iapex, coords)

    def getBarycenterInPlace(self, imesh, coord):
        r"""

        MeshSpherical::getBarycenterInPlace
        """
        return _gstlearn.MeshSpherical_getBarycenterInPlace(self, imesh, coord)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        MeshSpherical::createFromNF
        Create a MeshSpherical by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (MeshEStandard format)  
        * `verbose` :  
            Verbose  

        """
        return _gstlearn.MeshSpherical_createFromNF(NFFilename, verbose)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        MeshSpherical::create
        """
        return _gstlearn.MeshSpherical_create(*args, **kwargs)

    def reset(self, ndim, napexpermesh, apices, meshes, byCol, verbose=False):
        r"""

        MeshSpherical::reset
        Create the meshing (from mesh information)  

        Parameters
        ----------
        * `ndim` :  
            Space Dimension  
        * `napexpermesh` :  
            Number of apices per mesh  
        * `apices` :  
            Vector of Apex information  
        * `meshes` :  
            Vector of mesh indices  
        * `byCol` :  
            true for Column major; false for Row Major  
        * `verbose` :  
            Verbose flag  

        remark: The argument 'byCol' concerns 'apices' and 'meshes'  

        """
        return _gstlearn.MeshSpherical_reset(self, ndim, napexpermesh, apices, meshes, byCol, verbose)

    def getVariety(self):
        r"""

        MeshSpherical::getVariety
        Returns the space variety  

        """
        return _gstlearn.MeshSpherical_getVariety(self)

    def getApices(self):
        r"""

        MeshSpherical::getApices
        """
        return _gstlearn.MeshSpherical_getApices(self)

    def getMeshes(self):
        r"""

        MeshSpherical::getMeshes
        """
        return _gstlearn.MeshSpherical_getMeshes(self)

    def getMeshesAsVVI(self):
        r"""

        MeshSpherical::getMeshesAsVVI
        """
        return _gstlearn.MeshSpherical_getMeshesAsVVI(self)

    def __repr__(self):
        return _gstlearn.MeshSpherical___repr__(self)

# Register MeshSpherical in _gstlearn:
_gstlearn.MeshSpherical_swigregister(MeshSpherical)
class MeshSphericalExt(MeshSpherical):
    r"""


    Meshing defined in the Euclidean space  

    C++ includes: MeshSphericalExt.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        MeshSphericalExt::MeshSphericalExt
        """
        _gstlearn.MeshSphericalExt_swiginit(self, _gstlearn.new_MeshSphericalExt(*args))
    __swig_destroy__ = _gstlearn.delete_MeshSphericalExt

    def resetFromDb(self, *args, **kwargs):
        r"""

        MeshSphericalExt::resetFromDb
        Create the meshing  

        Parameters
        ----------
        * `dbin` :  
            Pointer to the input Db (optional)  
        * `dbout` :  
            Pointer to the output Db (optional)  
        * `triswitch` :  
            Construction switch  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.MeshSphericalExt_resetFromDb(self, *args, **kwargs)

    @staticmethod
    def spde_mesh_load(*args, **kwargs):
        r"""

        MeshSphericalExt::spde_mesh_load
        Load the AMesh structure  

        Returns
        -------
        Pointer on the newly allocated AMesh  

        Parameters
        ----------
        * `dbin` :  
            Db structure for the conditioning data  
        * `dbout` :  
            Db structure of the grid  
        * `gext` :  
            Array of domain dilation  
        * `triswitch` :  
            Triswitch option  
        * `verbose` :  
            Verbose option  

        """
        return _gstlearn.MeshSphericalExt_spde_mesh_load(*args, **kwargs)

    def __repr__(self):
        return _gstlearn.MeshSphericalExt___repr__(self)

# Register MeshSphericalExt in _gstlearn:
_gstlearn.MeshSphericalExt_swigregister(MeshSphericalExt)
class APolynomial(AStringable, ICloneable):
    r"""


    C++ includes: APolynomial.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_APolynomial

    def toString(self, strfmt=None):
        r"""

        APolynomial::toString
        Interface for AStringable.  

        """
        return _gstlearn.APolynomial_toString(self, strfmt)

    def init(self, coeffs):
        r"""

        APolynomial::init
        """
        return _gstlearn.APolynomial_init(self, coeffs)

    def eval(self, x):
        r"""

        APolynomial::eval
        """
        return _gstlearn.APolynomial_eval(self, x)

    def getCoeffs(self):
        r"""

        APolynomial::getCoeffs
        """
        return _gstlearn.APolynomial_getCoeffs(self)

    def setCoeffs(self, coeffs):
        r"""

        APolynomial::setCoeffs
        """
        return _gstlearn.APolynomial_setCoeffs(self, coeffs)

    def getDegree(self):
        r"""

        APolynomial::getDegree
        """
        return _gstlearn.APolynomial_getDegree(self)

    def fit(self, f, _from=0., to=1., tol=1.e-5):
        r"""

        APolynomial::fit
        """
        return _gstlearn.APolynomial_fit(self, f, _from, to, tol)

    def __repr__(self):
        return _gstlearn.APolynomial___repr__(self)

# Register APolynomial in _gstlearn:
_gstlearn.APolynomial_swigregister(APolynomial)
class ClassicalPolynomial(APolynomial):
    r"""


    C++ includes: ClassicalPolynomial.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ClassicalPolynomial::ClassicalPolynomial
        """
        _gstlearn.ClassicalPolynomial_swiginit(self, _gstlearn.new_ClassicalPolynomial(*args))
    __swig_destroy__ = _gstlearn.delete_ClassicalPolynomial

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ClassicalPolynomial_clone(self)

    def eval(self, x):
        r"""

        ClassicalPolynomial::eval
        ICloneable interface.  

        """
        return _gstlearn.ClassicalPolynomial_eval(self, x)

    def __repr__(self):
        return _gstlearn.ClassicalPolynomial___repr__(self)

# Register ClassicalPolynomial in _gstlearn:
_gstlearn.ClassicalPolynomial_swigregister(ClassicalPolynomial)

def hermitePolynomials(*args):
    r"""


    Returns the vector of Hermite Polynomials selected by ranks  

    Parameters
    ----------
    * `y` :  
        Target variable  
    * `r` :  
        Change of support coefficient  
    * `ifacs` :  
        Vector of ranks (staring from 0)  

    Returns
    -------
    The vector of Hi(y) where 'i' is in 'ifacs'  

    """
    return _gstlearn.hermitePolynomials(*args)

def hermiteCoefIndicator(yc, nbpoly):
    r"""


    Parameters
    ----------
    * `yc` :  
        Cutoff Value  
    * `nbpoly` :  
        Number of Hermite polynomials  

    Returns
    -------
    The vector of coefficients of the Indicator  

    """
    return _gstlearn.hermiteCoefIndicator(yc, nbpoly)

def hermiteCoefMetal(yc, phi):
    r"""


    Parameters
    ----------
    * `yc` :  
        Cutoff Value  
    * `phi` :  
        Coefficients of Hermite polynomial  

    Returns
    -------
    The vector of coefficients of the Metal Quantity  

    """
    return _gstlearn.hermiteCoefMetal(yc, phi)

def hermiteCoefLower(y, nbpoly):
    r"""


    Returns the vector of Hermite coefficients of the gaussian floored at 'y'  

    Parameters
    ----------
    * `y` :  
        Floor value  
    * `nbpoly` :  
        Number of Polynomial functions  

    Returns
    -------
    Hermite Coefficients  

    """
    return _gstlearn.hermiteCoefLower(y, nbpoly)

def hermiteIndicatorLower(y, nbpoly):
    r"""


    """
    return _gstlearn.hermiteIndicatorLower(y, nbpoly)

def hermiteIncompleteIntegral(yc, nbpoly):
    r"""


    Parameters
    ----------
    * `yc` :  
        Cutoff Value  
    * `nbpoly` :  
        Number of Hermite polynomials  

    Returns
    -------
    The matrix of Incomplete Integral (Dimension: nbpoly * nbpoly)  

    """
    return _gstlearn.hermiteIncompleteIntegral(yc, nbpoly)

def hermiteLognormal(mean, sigma, nbpoly):
    r"""


    Hermite coefficient for a lognormal transform mean * exp(sigma * Y + 1/2 *
    sigma^2)  

    Parameters
    ----------
    * `mean` :  
        Mean value  
    * `sigma` :  
        Standard deviation  
    * `nbpoly` :  
        Number of Hermite polynomials  

    Returns
    -------
    The array of coefficients  

    """
    return _gstlearn.hermiteLognormal(mean, sigma, nbpoly)

def hermiteSeries(an, hn):
    r"""


    Evaluate the Hermite expansion  

    Parameters
    ----------
    * `an` :  
        Series of coefficients of the Hermite polynomials  
    * `hn` :  
        Hermite polynomial values  

    Returns
    -------
    The result of the expansion  

    """
    return _gstlearn.hermiteSeries(an, hn)

def hermiteIndicator(yc, krigest, krigstd):
    r"""


    Parameters
    ----------
    * `yc` :  
        Cutoff Value  
    * `krigest` :  
        Estimation  
    * `krigstd` :  
        Standard deviation of estimation error  

    Returns
    -------
    The indicator above Cutoff  

    """
    return _gstlearn.hermiteIndicator(yc, krigest, krigstd)

def hermiteIndicatorElement(yc, krigest, krigstd):
    r"""


    """
    return _gstlearn.hermiteIndicatorElement(yc, krigest, krigstd)

def hermiteIndicatorStd(yc, krigest, krigstd):
    r"""


    """
    return _gstlearn.hermiteIndicatorStd(yc, krigest, krigstd)

def hermiteIndicatorStdElement(yc, krigest, krigstd):
    r"""


    """
    return _gstlearn.hermiteIndicatorStdElement(yc, krigest, krigstd)

def hermiteMetal(yc, krigest, krigstd, phi):
    r"""


    Parameters
    ----------
    * `yc` :  
        Cutoff Value  
    * `krigest` :  
        Estimation  
    * `krigstd` :  
        Standard deviation of estimation error  
    * `phi` :  
        Hermite coefficients  

    Returns
    -------
    The Metal  

    """
    return _gstlearn.hermiteMetal(yc, krigest, krigstd, phi)

def hermiteMetalElement(yc, krigest, krigstd, phi):
    r"""


    """
    return _gstlearn.hermiteMetalElement(yc, krigest, krigstd, phi)

def hermiteMetalStd(yc, krigest, krigstd, phi):
    r"""


    """
    return _gstlearn.hermiteMetalStd(yc, krigest, krigstd, phi)

def hermiteMetalStdElement(yc, krigest, krigstd, phi):
    r"""


    """
    return _gstlearn.hermiteMetalStdElement(yc, krigest, krigstd, phi)

def hermiteCondExp(krigest, krigstd, phi):
    r"""


    Calculate the Conditional Expectation: E[Z | Z1=z1, Z2=z2, ..., Zn=zn] = int
    Phi(y_kk + s_k u) g(u) du  

    Parameters
    ----------
    * `krigest` :  
        Vector of Kriging estimates  
    * `krigstd` :  
        Vector of Kriging standard deviations  
    * `phi` :  
        Array of Hermite coefficients  

    Returns
    -------
    Conditional Expectation  

    """
    return _gstlearn.hermiteCondExp(krigest, krigstd, phi)

def hermiteCondExpElement(krigest, krigstd, phi):
    r"""


    """
    return _gstlearn.hermiteCondExpElement(krigest, krigstd, phi)

def hermiteCondStd(krigest, krigstd, phi):
    r"""


    Vector of conditional variances (same dimension as krigest and krigstd)  

    Parameters
    ----------
    * `krigest` :  
        Vector of Kriging estimate  
    * `krigstd` :  
        Vector of Kriging standard deviations  
    * `phi` :  
        Array of Hermite coefficients  

    Returns
    -------  

    """
    return _gstlearn.hermiteCondStd(krigest, krigstd, phi)

def hermiteCondStdElement(krigest, krigstd, phi):
    r"""


    """
    return _gstlearn.hermiteCondStdElement(krigest, krigstd, phi)
NBSIMU_DEF = _gstlearn.NBSIMU_DEF

def integralGaussHermite(yc, r, psi):
    r"""


    Calculate: int phi(r*y + u * sqrt(1-r^2)) g(u) du  

    Parameters
    ----------
    * `yc` :  
        Cutoff value  
    * `r` :  
        Change of support coefficient  
    * `psi` :  
        Vector of Hermite coefficients  

    Returns
    -------
    Vector of returned values for all Hermite coefficients  

    """
    return _gstlearn.integralGaussHermite(yc, r, psi)

def normalizeResults(*args):
    r"""


    """
    return _gstlearn.normalizeResults(*args)

def MCCondExp(krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCCondExp(krigest, krigstd, psi, nbsimu)

def MCCondExpElement(krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCCondExpElement(krigest, krigstd, psi, nbsimu)

def MCCondStd(krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCCondStd(krigest, krigstd, psi, nbsimu)

def MCCondStdElement(krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCCondStdElement(krigest, krigstd, psi, nbsimu)

def MCIndicator(yc, krigest, krigstd, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCIndicator(yc, krigest, krigstd, nbsimu)

def MCIndicatorElement(yc, krigest, krigstd, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCIndicatorElement(yc, krigest, krigstd, nbsimu)

def MCIndicatorStd(yc, krigest, krigstd, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCIndicatorStd(yc, krigest, krigstd, nbsimu)

def MCIndicatorStdElement(yc, krigest, krigstd, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCIndicatorStdElement(yc, krigest, krigstd, nbsimu)

def MCMetal(yc, krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCMetal(yc, krigest, krigstd, psi, nbsimu)

def MCMetalElement(yc, krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCMetalElement(yc, krigest, krigstd, psi, nbsimu)

def MCMetalStd(yc, krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCMetalStd(yc, krigest, krigstd, psi, nbsimu)

def MCMetalStdElement(yc, krigest, krigstd, psi, nbsimu=1000):
    r"""


    """
    return _gstlearn.MCMetalStdElement(yc, krigest, krigstd, psi, nbsimu)
class Chebychev(APolynomial):
    r"""


    TODO : Dependency to csparse to be removed.  

    C++ includes: Chebychev.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        r"""

        Chebychev::Chebychev
        """
        _gstlearn.Chebychev_swiginit(self, _gstlearn.new_Chebychev())
    __swig_destroy__ = _gstlearn.delete_Chebychev

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.Chebychev_clone(self)

    def eval(self, x):
        r"""

        Chebychev::eval
        """
        return _gstlearn.Chebychev_eval(self, x)

    def fit(self, f, a=0., b=1., tol=1.e-5):
        r"""

        Chebychev::fit
        """
        return _gstlearn.Chebychev_fit(self, f, a, b, tol)

    def init(self, ncMax=10001, nDisc=100, a=0., b=1., verbose=False):
        r"""

        Chebychev::init
        """
        return _gstlearn.Chebychev_init(self, ncMax, nDisc, a, b, verbose)

    @staticmethod
    def createFromCoeffs(coeffs):
        r"""

        Chebychev::createFromCoeffs
        """
        return _gstlearn.Chebychev_createFromCoeffs(coeffs)

    def setCoeffs(self, coeffs):
        r"""

        Chebychev::setCoeffs
        """
        return _gstlearn.Chebychev_setCoeffs(self, coeffs)

    def getNcMax(self):
        r"""

        Chebychev::getNcMax
        """
        return _gstlearn.Chebychev_getNcMax(self)

    def getNDisc(self):
        r"""

        Chebychev::getNDisc
        """
        return _gstlearn.Chebychev_getNDisc(self)

    def getA(self):
        r"""

        Chebychev::getA
        """
        return _gstlearn.Chebychev_getA(self)

    def getB(self):
        r"""

        Chebychev::getB
        """
        return _gstlearn.Chebychev_getB(self)

    def getVerbose(self):
        r"""

        Chebychev::getVerbose
        """
        return _gstlearn.Chebychev_getVerbose(self)

    def setA(self, a):
        r"""

        Chebychev::setA
        """
        return _gstlearn.Chebychev_setA(self, a)

    def setB(self, b):
        r"""

        Chebychev::setB
        """
        return _gstlearn.Chebychev_setB(self, b)

    def setNcMax(self, ncMax):
        r"""

        Chebychev::setNcMax
        """
        return _gstlearn.Chebychev_setNcMax(self, ncMax)

    def setNDisc(self, nDisc):
        r"""

        Chebychev::setNDisc
        """
        return _gstlearn.Chebychev_setNDisc(self, nDisc)

    def setVerbose(self, verbose):
        r"""

        Chebychev::setVerbose
        """
        return _gstlearn.Chebychev_setVerbose(self, verbose)

    def fit2(self, f, a=0., b=1., tol=1.e-5):
        r"""

        Chebychev::fit2
        """
        return _gstlearn.Chebychev_fit2(self, f, a, b, tol)

    def __repr__(self):
        return _gstlearn.Chebychev___repr__(self)

# Register Chebychev in _gstlearn:
_gstlearn.Chebychev_swigregister(Chebychev)
class CGParam(object):
    r"""


    C++ includes: CGParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        CGParam::CGParam
        """
        _gstlearn.CGParam_swiginit(self, _gstlearn.new_CGParam(*args))
    __swig_destroy__ = _gstlearn.delete_CGParam

    def setEps(self, eps):
        r"""

        CGParam::setEps
        """
        return _gstlearn.CGParam_setEps(self, eps)

    def setNIterMax(self, nIterMax):
        r"""

        CGParam::setNIterMax
        """
        return _gstlearn.CGParam_setNIterMax(self, nIterMax)

    def setX0(self, x0):
        r"""

        CGParam::setX0
        """
        return _gstlearn.CGParam_setX0(self, x0)

    def setPrecond(self, precond, status):
        r"""

        CGParam::setPrecond
        Define the Pre-Conditioner facility  

        Parameters
        ----------
        * `precond` :  
            Pointer to a ALinearOp operator  
        * `status` :  
            Status of this Pre-conditioner  

            *   0 : not defined and therefore not used  
            *   -1 : Pre-conditioner is the Q_{-1}  
            *   1 : Pre-conditioner is the Q  

        remark: When 'precond' argument is not provided, 'status' is forced to 0  

        """
        return _gstlearn.CGParam_setPrecond(self, precond, status)

    def setPrecondStatus(self, precondStatus):
        r"""

        CGParam::setPrecondStatus
        """
        return _gstlearn.CGParam_setPrecondStatus(self, precondStatus)

    def getEps(self):
        r"""

        CGParam::getEps
        """
        return _gstlearn.CGParam_getEps(self)

    def getNIterMax(self):
        r"""

        CGParam::getNIterMax
        """
        return _gstlearn.CGParam_getNIterMax(self)

    def getPrecond(self):
        r"""

        CGParam::getPrecond
        """
        return _gstlearn.CGParam_getPrecond(self)

    def getX0(self, *args):
        r"""

        CGParam::getX0
        """
        return _gstlearn.CGParam_getX0(self, *args)

    def getPrecondStatus(self):
        r"""

        CGParam::getPrecondStatus
        """
        return _gstlearn.CGParam_getPrecondStatus(self)

# Register CGParam in _gstlearn:
_gstlearn.CGParam_swigregister(CGParam)
class LogStats(object):
    r"""


    C++ includes: LogStats.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        LogStats::LogStats
        """
        _gstlearn.LogStats_swiginit(self, _gstlearn.new_LogStats(*args))
    __swig_destroy__ = _gstlearn.delete_LogStats

    def incrementStatsDirect(self, time):
        r"""

        LogStats::incrementStatsDirect
        """
        return _gstlearn.LogStats_incrementStatsDirect(self, time)

    def incrementStatsInverseCG(self, niter, time):
        r"""

        LogStats::incrementStatsInverseCG
        """
        return _gstlearn.LogStats_incrementStatsInverseCG(self, niter, time)

    def incrementStatsInverseChol(self, time):
        r"""

        LogStats::incrementStatsInverseChol
        """
        return _gstlearn.LogStats_incrementStatsInverseChol(self, time)

    def incrementStatsInversePoly(self, time):
        r"""

        LogStats::incrementStatsInversePoly
        """
        return _gstlearn.LogStats_incrementStatsInversePoly(self, time)

    def incrementStatsSimulate(self, time):
        r"""

        LogStats::incrementStatsSimulate
        """
        return _gstlearn.LogStats_incrementStatsSimulate(self, time)

    def incrementStatsCholesky(self, time):
        r"""

        LogStats::incrementStatsCholesky
        """
        return _gstlearn.LogStats_incrementStatsCholesky(self, time)

    def statsShow(self):
        r"""

        LogStats::statsShow
        Trigger the printout of the statistics  

        """
        return _gstlearn.LogStats_statsShow(self)

    def mustShowStats(self, mustPrint):
        r"""

        LogStats::mustShowStats
        """
        return _gstlearn.LogStats_mustShowStats(self, mustPrint)

    def isMustPrint(self):
        r"""

        LogStats::isMustPrint
        """
        return _gstlearn.LogStats_isMustPrint(self)

# Register LogStats in _gstlearn:
_gstlearn.LogStats_swigregister(LogStats)
class ALinearOpCGSolver(object):
    r"""


    C++ includes: LinearOpCGSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ALinearOpCGSolver

    def solve(self, rhs, out):
        r"""

        ALinearOpCGSolver::solve
        """
        return _gstlearn.ALinearOpCGSolver_solve(self, rhs, out)

    def setMaxIterations(self, n):
        r"""

        ALinearOpCGSolver::setMaxIterations
        """
        return _gstlearn.ALinearOpCGSolver_setMaxIterations(self, n)

    def setTolerance(self, tol):
        r"""

        ALinearOpCGSolver::setTolerance
        """
        return _gstlearn.ALinearOpCGSolver_setTolerance(self, tol)

    def getIterations(self):
        r"""

        ALinearOpCGSolver::getIterations
        """
        return _gstlearn.ALinearOpCGSolver_getIterations(self)

    def getError(self):
        r"""

        ALinearOpCGSolver::getError
        """
        return _gstlearn.ALinearOpCGSolver_getError(self)

# Register ALinearOpCGSolver in _gstlearn:
_gstlearn.ALinearOpCGSolver_swigregister(ALinearOpCGSolver)
class ALinearOpMulti(object):
    r"""


    C++ includes: ALinearOpMulti.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ALinearOpMulti

    def initLk(self, inv, outv):
        r"""

        ALinearOpMulti::initLk
        """
        return _gstlearn.ALinearOpMulti_initLk(self, inv, outv)

    def sizes(self):
        r"""

        ALinearOpMulti::sizes
        """
        return _gstlearn.ALinearOpMulti_sizes(self)

    def size(self, arg2):
        r"""

        ALinearOpMulti::size
        """
        return _gstlearn.ALinearOpMulti_size(self, arg2)

    def setNIterMax(self, nitermax):
        r"""

        ALinearOpMulti::setNIterMax
        """
        return _gstlearn.ALinearOpMulti_setNIterMax(self, nitermax)

    def setNIterRestart(self, niterrestart):
        r"""

        ALinearOpMulti::setNIterRestart
        """
        return _gstlearn.ALinearOpMulti_setNIterRestart(self, niterrestart)

    def setEps(self, eps):
        r"""

        ALinearOpMulti::setEps
        """
        return _gstlearn.ALinearOpMulti_setEps(self, eps)

    def setPrecond(self, precond, status):
        r"""

        ALinearOpMulti::setPrecond
        Define the Pre-Conditioner facility  

        Parameters
        ----------
        * `precond` :  
            Pointer to a ALinearOp operator  
        * `status` :  
            Status of this Pre-conditioner  

            *   0 : not defined and therefore not used  
            *   -1 : Pre-conditioner is the Q_{-1}  
            *   1 : Pre-conditioner is the Q  

        remark: When 'precond' argument is not provided, 'status' is forced to 0  

        """
        return _gstlearn.ALinearOpMulti_setPrecond(self, precond, status)

    def getLogStats(self):
        r"""

        ALinearOpMulti::getLogStats
        """
        return _gstlearn.ALinearOpMulti_getLogStats(self)

    def prepare(self):
        r"""

        ALinearOpMulti::prepare
        This method intends to resize the different working arrays. It is considered as
        const in order to avoid breaking constness of calling function  

        """
        return _gstlearn.ALinearOpMulti_prepare(self)

    def setUserInitialValue(self, b):
        r"""

        ALinearOpMulti::setUserInitialValue
        """
        return _gstlearn.ALinearOpMulti_setUserInitialValue(self, b)
    _temp = property(_gstlearn.ALinearOpMulti__temp_get, _gstlearn.ALinearOpMulti__temp_set)
    _p = property(_gstlearn.ALinearOpMulti__p_get, _gstlearn.ALinearOpMulti__p_set)
    _z = property(_gstlearn.ALinearOpMulti__z_get, _gstlearn.ALinearOpMulti__z_set)
    _nb = property(_gstlearn.ALinearOpMulti__nb_get, _gstlearn.ALinearOpMulti__nb_set)

# Register ALinearOpMulti in _gstlearn:
_gstlearn.ALinearOpMulti_swigregister(ALinearOpMulti)
class ScaleOp(ALinearOp):
    r"""


    C++ includes: ScaleOp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, n, scale=1.):
        r"""

        ScaleOp::ScaleOp
        """
        _gstlearn.ScaleOp_swiginit(self, _gstlearn.new_ScaleOp(n, scale))
    __swig_destroy__ = _gstlearn.delete_ScaleOp

    def getSize(self):
        r"""

        ScaleOp::getSize
        """
        return _gstlearn.ScaleOp_getSize(self)

# Register ScaleOp in _gstlearn:
_gstlearn.ScaleOp_swigregister(ScaleOp)
class AShiftOp(ICloneable, ALinearOp):
    r"""


    Shift Operator for performing the basic tasks of SPDE.  

    C++ includes: AShiftOp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def prodLambda(self, x, y, power):
        r"""

        AShiftOp::prodLambda
        """
        return _gstlearn.AShiftOp_prodLambda(self, x, y, power)
    __swig_destroy__ = _gstlearn.delete_AShiftOp

    def getMaxEigenValue(self):
        r"""

        AShiftOp::getMaxEigenValue
        """
        return _gstlearn.AShiftOp_getMaxEigenValue(self)

    def normalizeLambdaBySills(self, arg2):
        r"""

        AShiftOp::normalizeLambdaBySills
        """
        return _gstlearn.AShiftOp_normalizeLambdaBySills(self, arg2)

    def getLambdas(self):
        r"""

        AShiftOp::getLambdas
        """
        return _gstlearn.AShiftOp_getLambdas(self)

    def getLambda(self, iapex):
        r"""

        AShiftOp::getLambda
        """
        return _gstlearn.AShiftOp_getLambda(self, iapex)

    @staticmethod
    def cloneAndCast(*args):
        r"""

        AShiftOp::cloneAndCast
        """
        return _gstlearn.AShiftOp_cloneAndCast(*args)

    def getSize(self):
        r"""

        AShiftOp::getSize
        """
        return _gstlearn.AShiftOp_getSize(self)

# Register AShiftOp in _gstlearn:
_gstlearn.AShiftOp_swigregister(AShiftOp)
class ShiftOpStencil(AShiftOp):
    r"""


    This is an implementation of ShiftOp dedicated to case where:  

    *   the target is a regular grid  
    *   the meshing is elaborated as a TurboMeshing  
    *   the covariance is stationary  

    The different members are: _relativeShifts For each vector, gives the vector of
    shifts, with respect to the target node (in relative indices) _absoluteShifts
    Vector of shifts to calculate where the weights should apply calculated on the
    global target grid. This can only be used if the grid has no selection _weights
    Vector of weights (only significative ones are kept) _isInside Vector telling if
    each node of the grid is located on its edge and should be bypassed for matrix
    calculations, or not  

    C++ includes: ShiftOpStencil.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        ShiftOpStencil::ShiftOpStencil
        """
        _gstlearn.ShiftOpStencil_swiginit(self, _gstlearn.new_ShiftOpStencil(*args))
    __swig_destroy__ = _gstlearn.delete_ShiftOpStencil

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShiftOpStencil_clone(self)

    def normalizeLambdaBySills(self, mesh):
        r"""

        ShiftOpStencil::normalizeLambdaBySills
        ICloneable interface.  

        """
        return _gstlearn.ShiftOpStencil_normalizeLambdaBySills(self, mesh)

    def multiplyByValueAndAddDiagonal(self, v1=1., v2=0.):
        r"""

        ShiftOpStencil::multiplyByValueAndAddDiagonal
        """
        return _gstlearn.ShiftOpStencil_multiplyByValueAndAddDiagonal(self, v1, v2)

    def resetModif(self):
        r"""

        ShiftOpStencil::resetModif
        """
        return _gstlearn.ShiftOpStencil_resetModif(self)

    def getMaxEigenValue(self):
        r"""

        ShiftOpStencil::getMaxEigenValue
        """
        return _gstlearn.ShiftOpStencil_getMaxEigenValue(self)

    def getLambda(self, iapex):
        r"""

        ShiftOpStencil::getLambda
        """
        return _gstlearn.ShiftOpStencil_getLambda(self, iapex)

# Register ShiftOpStencil in _gstlearn:
_gstlearn.ShiftOpStencil_swigregister(ShiftOpStencil)
class ShiftOpMatrix(AShiftOp):
    r"""


    C++ includes: ShiftOpMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        ShiftOpMatrix::ShiftOpMatrix
        """
        _gstlearn.ShiftOpMatrix_swiginit(self, _gstlearn.new_ShiftOpMatrix(*args))
    __swig_destroy__ = _gstlearn.delete_ShiftOpMatrix

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ShiftOpMatrix_clone(self)

    def normalizeLambdaBySills(self, mesh):
        r"""

        ShiftOpMatrix::normalizeLambdaBySills
        ICloneable interface.  

        """
        return _gstlearn.ShiftOpMatrix_normalizeLambdaBySills(self, mesh)

    @staticmethod
    def create(amesh, cova, dbout=None, verbose=False):
        r"""

        ShiftOpMatrix::create
        """
        return _gstlearn.ShiftOpMatrix_create(amesh, cova, dbout, verbose)

    @staticmethod
    def createFromSparse(S, TildeC, Lambda, cova, verbose=False):
        r"""

        ShiftOpMatrix::createFromSparse
        """
        return _gstlearn.ShiftOpMatrix_createFromSparse(S, TildeC, Lambda, cova, verbose)

    def initFromMesh(self, amesh, cova, dbout=None, flagAdvection=False, verbose=False):
        r"""

        ShiftOpMatrix::initFromMesh
        Parameters
        ----------
        * `amesh` :  
            Meshing description (New format)  
        * `cova` :  
            Pointer to the CovAniso structure  
        * `dbout` :  
            Pointer to the Db structure  
        * `flagAdvection` :  
            When TRUE, S is replaced by G  
        * `verbose` :  
            Verbose flag  

        Returns
        -------
        Error return code  

        """
        return _gstlearn.ShiftOpMatrix_initFromMesh(self, amesh, cova, dbout, flagAdvection, verbose)

    def initGradFromMesh(self, amesh, cova, verbose=False, tol=1.e-10):
        r"""

        ShiftOpMatrix::initGradFromMesh
        Initialize the environment for calculation of derivatives of S  

        Parameters
        ----------
        * `amesh` :  
            Meshing description (New format)  
        * `cova` :  
            Pointer to the CovAniso structure  
        * `verbose` :  
            Verbose flag  
        * `tol` :  
            Smallest value below which the value is not stored in sparse matrix  

        Returns
        -------
        Error return code  

        """
        return _gstlearn.ShiftOpMatrix_initGradFromMesh(self, amesh, cova, verbose, tol)

    def initFromCS(self, S, TildeC, Lambda, cova, verbose=False):
        r"""

        ShiftOpMatrix::initFromCS
        Parameters
        ----------
        * `S` :  
            Sparse matrix describing the S information  
        * `TildeC` :  
            Diagonal array containing TildeC  
        * `Lambda` :  
            Normalization vector  
        * `cova` :  
            Pointer to the CovAniso structure  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.ShiftOpMatrix_initFromCS(self, S, TildeC, Lambda, cova, verbose)

    def getNDim(self):
        r"""

        ShiftOpMatrix::getNDim
        """
        return _gstlearn.ShiftOpMatrix_getNDim(self)

    def getNCovAnisoGradParam(self):
        r"""

        ShiftOpMatrix::getNCovAnisoGradParam
        """
        return _gstlearn.ShiftOpMatrix_getNCovAnisoGradParam(self)

    def prodTildeC(self, x, y, power):
        r"""

        ShiftOpMatrix::prodTildeC
        Perform the operation: y = x * C^power  

        Parameters
        ----------
        * `x` :  
            Input vector  
        * `y` :  
            Output vector  
        * `power` :  
            Value of the exponent  

        remark: 'C' is a member (_TildeC) that stands as a vector  

        remark: Specific coding has been realized for the cases  

        remark: where 'power' is equal to 1, -1, 0.5 and -0.5  

        """
        return _gstlearn.ShiftOpMatrix_prodTildeC(self, x, y, power)

    def prodLambdaOnSqrtTildeC(self, inv, outv, puis=2):
        r"""

        ShiftOpMatrix::prodLambdaOnSqrtTildeC
        """
        return _gstlearn.ShiftOpMatrix_prodLambdaOnSqrtTildeC(self, inv, outv, puis)

    def getMaxEigenValue(self):
        r"""

        ShiftOpMatrix::getMaxEigenValue
        """
        return _gstlearn.ShiftOpMatrix_getMaxEigenValue(self)

    def getS(self):
        r"""

        ShiftOpMatrix::getS
        """
        return _gstlearn.ShiftOpMatrix_getS(self)

    def getTildeCGrad(self, iapex, igparam):
        r"""

        ShiftOpMatrix::getTildeCGrad
        """
        return _gstlearn.ShiftOpMatrix_getTildeCGrad(self, iapex, igparam)

    def getSGrad(self, iapex, igparam):
        r"""

        ShiftOpMatrix::getSGrad
        """
        return _gstlearn.ShiftOpMatrix_getSGrad(self, iapex, igparam)

    def getTildeC(self):
        r"""

        ShiftOpMatrix::getTildeC
        """
        return _gstlearn.ShiftOpMatrix_getTildeC(self)

    def getLambdaGrads(self, idim):
        r"""

        ShiftOpMatrix::getLambdaGrads
        """
        return _gstlearn.ShiftOpMatrix_getLambdaGrads(self, idim)

    def getLambdaGrad(self, idim, iapex):
        r"""

        ShiftOpMatrix::getLambdaGrad
        """
        return _gstlearn.ShiftOpMatrix_getLambdaGrad(self, idim, iapex)

    def getSGradAddress(self, iapex, igparam):
        r"""

        ShiftOpMatrix::getSGradAddress
        Returns the internal address for a given vertex and a given parameter It returns
        -1 if the address is ivalid  

        Parameters
        ----------
        * `iapex` :  
            Rank of the target apex  
        * `igparam` :  
            Rank of the target parameter  

        Returns
        -------  

        """
        return _gstlearn.ShiftOpMatrix_getSGradAddress(self, iapex, igparam)

    def getLambdaGradSize(self):
        r"""

        ShiftOpMatrix::getLambdaGradSize
        """
        return _gstlearn.ShiftOpMatrix_getLambdaGradSize(self)

# Register ShiftOpMatrix in _gstlearn:
_gstlearn.ShiftOpMatrix_swigregister(ShiftOpMatrix)
class PrecisionOp(ASimulable):
    r"""


    C++ includes: PrecisionOp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        PrecisionOp::PrecisionOp
        """
        _gstlearn.PrecisionOp_swiginit(self, _gstlearn.new_PrecisionOp(*args))
    __swig_destroy__ = _gstlearn.delete_PrecisionOp

    def getRangeEigenVal(self, ndiscr=100):
        r"""

        PrecisionOp::getRangeEigenVal
        """
        return _gstlearn.PrecisionOp_getRangeEigenVal(self, ndiscr)

    @staticmethod
    def createFromShiftOp(shiftop=None, cova=None, verbose=False):
        r"""

        PrecisionOp::createFromShiftOp
        """
        return _gstlearn.PrecisionOp_createFromShiftOp(shiftop, cova, verbose)

    @staticmethod
    def create(mesh, cova, stencil=False, verbose=False):
        r"""

        PrecisionOp::create
        """
        return _gstlearn.PrecisionOp_create(mesh, cova, stencil, verbose)

    def reset(self, shiftop, cova=None, verbose=False):
        r"""

        PrecisionOp::reset
        """
        return _gstlearn.PrecisionOp_reset(self, shiftop, cova, verbose)

    def getLogDeterminant(self, nMC=1):
        r"""

        PrecisionOp::getLogDeterminant
        Compute the Logarithm of the Determinant  

        Parameters
        ----------
        * `nMC` :  
            Number of Monte-Carlo simulations  

        Returns
        -------
        The computed value or TEST if problem  

        """
        return _gstlearn.PrecisionOp_getLogDeterminant(self, nMC)

    def computeCov(self, imesh):
        r"""

        PrecisionOp::computeCov
        """
        return _gstlearn.PrecisionOp_computeCov(self, imesh)

    def simulateOne(self):
        r"""

        PrecisionOp::simulateOne
        """
        return _gstlearn.PrecisionOp_simulateOne(self)

    def getSize(self):
        r"""

        PrecisionOp::getSize
        """
        return _gstlearn.PrecisionOp_getSize(self)

    def getTraining(self):
        r"""

        PrecisionOp::getTraining
        """
        return _gstlearn.PrecisionOp_getTraining(self)

    def setTraining(self, tr):
        r"""

        PrecisionOp::setTraining
        """
        return _gstlearn.PrecisionOp_setTraining(self, tr)

    def getShiftOp(self):
        r"""

        PrecisionOp::getShiftOp
        """
        return _gstlearn.PrecisionOp_getShiftOp(self)

    def getPolyCoeffs(self, power):
        r"""

        PrecisionOp::getPolyCoeffs
        """
        return _gstlearn.PrecisionOp_getPolyCoeffs(self, power)

    def setPolynomialFromPoly(self, polynomial):
        r"""

        PrecisionOp::setPolynomialFromPoly
        """
        return _gstlearn.PrecisionOp_setPolynomialFromPoly(self, polynomial)

    def isCovaDefined(self):
        r"""

        PrecisionOp::isCovaDefined
        """
        return _gstlearn.PrecisionOp_isCovaDefined(self)

    def getCoeffs(self):
        r"""

        PrecisionOp::getCoeffs
        """
        return _gstlearn.PrecisionOp_getCoeffs(self)

    def extractDiag(self):
        r"""

        PrecisionOp::extractDiag
        """
        return _gstlearn.PrecisionOp_extractDiag(self)

# Register PrecisionOp in _gstlearn:
_gstlearn.PrecisionOp_swigregister(PrecisionOp)
class PrecisionOpMatrix(PrecisionOp):
    r"""


    This class is just a specialization of PrecisionOp when the shift Operator is
    built with sparse matrices and therefore algebra can be performed with Cholesky.
    It allows to return the precision matrix as a Sparse Matrix.  

    C++ includes: PrecisionOpMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        PrecisionOpMatrix::PrecisionOpMatrix
        """
        _gstlearn.PrecisionOpMatrix_swiginit(self, _gstlearn.new_PrecisionOpMatrix(*args))
    __swig_destroy__ = _gstlearn.delete_PrecisionOpMatrix

    def getLogDeterminant(self, nMC=1):
        r"""

        PrecisionOpMatrix::getLogDeterminant
        Compute the Logarithm of the Determinant  

        Parameters
        ----------
        * `nMC` :  
            Number of Monte-Carlo simulations  

        Returns
        -------
        The computed value or TEST if problem  

        """
        return _gstlearn.PrecisionOpMatrix_getLogDeterminant(self, nMC)

    def extractDiag(self):
        r"""

        PrecisionOpMatrix::extractDiag
        """
        return _gstlearn.PrecisionOpMatrix_extractDiag(self)

    def getQ(self):
        r"""

        PrecisionOpMatrix::getQ
        """
        return _gstlearn.PrecisionOpMatrix_getQ(self)

    def getS(self):
        r"""

        PrecisionOpMatrix::getS
        """
        return _gstlearn.PrecisionOpMatrix_getS(self)

# Register PrecisionOpMatrix in _gstlearn:
_gstlearn.PrecisionOpMatrix_swigregister(PrecisionOpMatrix)
class ASPDEOp(ALinearOp):
    r"""


    C++ includes: SPDEOp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, popKriging=None, projInKriging=None, invNoise=None, popSimu=None, projInSimu=None, projOutKriging=None, projOutSimu=None, noiseToDelete=False):
        r"""

        ASPDEOp::ASPDEOp
        """
        _gstlearn.ASPDEOp_swiginit(self, _gstlearn.new_ASPDEOp(popKriging, projInKriging, invNoise, popSimu, projInSimu, projOutKriging, projOutSimu, noiseToDelete))
    __swig_destroy__ = _gstlearn.delete_ASPDEOp

    def stdev(self, dat, nMC=1, seed=134343):
        r"""

        ASPDEOp::stdev
        Computing Standard deviation of the estimation error using MonteCarlo on
        conditional simulations.  

        Parameters
        ----------
        * `dat` :  
            Vector of Data  
        * `nMC` :  
            Number of Monte-Carlo simulations  
        * `seed` :  
            Random seed for the Monte-Carlo simulations  

        Returns
        -------
        VectorDouble  

        """
        return _gstlearn.ASPDEOp_stdev(self, dat, nMC, seed)

    def getSize(self):
        r"""

        ASPDEOp::getSize
        """
        return _gstlearn.ASPDEOp_getSize(self)

    def getSizeSimu(self):
        r"""

        ASPDEOp::getSizeSimu
        """
        return _gstlearn.ASPDEOp_getSizeSimu(self)

    def getIterations(self):
        r"""

        ASPDEOp::getIterations
        """
        return _gstlearn.ASPDEOp_getIterations(self)

    def getError(self):
        r"""

        ASPDEOp::getError
        """
        return _gstlearn.ASPDEOp_getError(self)

    def setMaxIterations(self, n):
        r"""

        ASPDEOp::setMaxIterations
        """
        return _gstlearn.ASPDEOp_setMaxIterations(self, n)

    def setTolerance(self, tol):
        r"""

        ASPDEOp::setTolerance
        """
        return _gstlearn.ASPDEOp_setTolerance(self, tol)

    def kriging(self, dat):
        r"""

        ASPDEOp::kriging
        """
        return _gstlearn.ASPDEOp_kriging(self, dat)

    def krigingWithGuess(self, dat, guess):
        r"""

        ASPDEOp::krigingWithGuess
        """
        return _gstlearn.ASPDEOp_krigingWithGuess(self, dat, guess)

    def computeDriftCoeffs(self, Z, driftMat, verbose=False):
        r"""

        ASPDEOp::computeDriftCoeffs
        """
        return _gstlearn.ASPDEOp_computeDriftCoeffs(self, Z, driftMat, verbose)

    def simCond(self, dat):
        r"""

        ASPDEOp::simCond
        """
        return _gstlearn.ASPDEOp_simCond(self, dat)

    def simNonCond(self):
        r"""

        ASPDEOp::simNonCond
        """
        return _gstlearn.ASPDEOp_simNonCond(self)

    def getQKriging(self):
        r"""

        ASPDEOp::getQKriging
        """
        return _gstlearn.ASPDEOp_getQKriging(self)

    def getProjKriging(self):
        r"""

        ASPDEOp::getProjKriging
        """
        return _gstlearn.ASPDEOp_getProjKriging(self)

    def getInvNoise(self):
        r"""

        ASPDEOp::getInvNoise
        """
        return _gstlearn.ASPDEOp_getInvNoise(self)

    def getQSimu(self):
        r"""

        ASPDEOp::getQSimu
        """
        return _gstlearn.ASPDEOp_getQSimu(self)

    def getProjInSimu(self):
        r"""

        ASPDEOp::getProjInSimu
        """
        return _gstlearn.ASPDEOp_getProjInSimu(self)

# Register ASPDEOp in _gstlearn:
_gstlearn.ASPDEOp_swigregister(ASPDEOp)
class SPDEOp(ASPDEOp, ALinearOp):
    r"""


    C++ includes: SPDEOp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, popKriging=None, projInKriging=None, invNoise=None, popSimu=None, projInSimu=None, projOutKriging=None, projOutSimu=None, noiseToDelete=False):
        r"""

        SPDEOp::SPDEOp
        """
        _gstlearn.SPDEOp_swiginit(self, _gstlearn.new_SPDEOp(popKriging, projInKriging, invNoise, popSimu, projInSimu, projOutKriging, projOutSimu, noiseToDelete))
    __swig_destroy__ = _gstlearn.delete_SPDEOp

# Register SPDEOp in _gstlearn:
_gstlearn.SPDEOp_swigregister(SPDEOp)
class SPDEOpMatrix(SPDEOp):
    r"""


    C++ includes: SPDEOpMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pop=None, A=None, invNoise=None, projOut=None):
        r"""

        SPDEOpMatrix::SPDEOpMatrix
        """
        _gstlearn.SPDEOpMatrix_swiginit(self, _gstlearn.new_SPDEOpMatrix(pop, A, invNoise, projOut))
    __swig_destroy__ = _gstlearn.delete_SPDEOpMatrix

    def computeLogDetOp(self, nbsimu):
        r"""

        SPDEOpMatrix::computeLogDetOp
        """
        return _gstlearn.SPDEOpMatrix_computeLogDetOp(self, nbsimu)

    def stdev(self, dat, nMC, seed):
        r"""

        SPDEOpMatrix::stdev
        Computing Standard deviation of the estimation error using partial_invert of a
        Sparse Cholesky matrix.  

        Parameters
        ----------
        * `dat` :  
            Vector of Data  
        * `nMC` :  
            Number of Monte-Carlo simulations (unused)  
        * `seed` :  
            Random seed for the Monte-Carlo simulations (unused)  

        Returns
        -------
        VectorDouble  

        """
        return _gstlearn.SPDEOpMatrix_stdev(self, dat, nMC, seed)

# Register SPDEOpMatrix in _gstlearn:
_gstlearn.SPDEOpMatrix_swigregister(SPDEOpMatrix)
TO_ndim = _gstlearn.TO_ndim
TO_ncorner = _gstlearn.TO_ncorner
TO_npercell = _gstlearn.TO_npercell
class TripletND(object):
    r"""


    C++ includes: TurboOptimizer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = property(_gstlearn.TripletND_rows_get, _gstlearn.TripletND_rows_set)
    cols = property(_gstlearn.TripletND_cols_get, _gstlearn.TripletND_cols_set)
    values = property(_gstlearn.TripletND_values_get, _gstlearn.TripletND_values_set)

    def __init__(self):
        r"""


        C++ includes: TurboOptimizer.hpp

        """
        _gstlearn.TripletND_swiginit(self, _gstlearn.new_TripletND())
    __swig_destroy__ = _gstlearn.delete_TripletND

# Register TripletND in _gstlearn:
_gstlearn.TripletND_swigregister(TripletND)
class TurboOptimizer(object):
    r"""


    Turbo Optimizer for a specific 2-D environment,.  

    with an isotropic Matrn Model  

    C++ includes: TurboOptimizer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        TurboOptimizer::TurboOptimizer
        """
        _gstlearn.TurboOptimizer_swiginit(self, _gstlearn.new_TurboOptimizer(*args))
    __swig_destroy__ = _gstlearn.delete_TurboOptimizer

    def setGrid(self, nx=2, ny=2, dx=1., dy=1., x0=0., y0=0.):
        r"""

        TurboOptimizer::setGrid
        Definition of the 2-D non rotated Grid  

        Parameters
        ----------
        * `nx` :  
            Number of nodes along X  
        * `ny` :  
            Number of nodes along Y  
        * `dx` :  
            Mesh of the grid along X  
        * `dy` :  
            Mesh of the grid along Y  
        * `x0` :  
            Origin of the grid along X  
        * `y0` :  
            Origin of the grid along Y  

        """
        return _gstlearn.TurboOptimizer_setGrid(self, nx, ny, dx, dy, x0, y0)

    def setModelByRange(self, range=1., sill=1., param=1):
        r"""

        TurboOptimizer::setModelByRange
        Definition of the Model (single isotropic Matrn structure) by range  

        Parameters
        ----------
        * `range` :  
            Range of the structure  
        * `sill` :  
            Sill of the structure  
        * `param` :  
            Matrn parameter (third parameter)  

        """
        return _gstlearn.TurboOptimizer_setModelByRange(self, range, sill, param)

    def setModelByScale(self, scale=1., sill=1., param=1):
        r"""

        TurboOptimizer::setModelByScale
        Definition of the Model (single isotropic Matrn structure) by scale  

        Parameters
        ----------
        * `scale` :  
            Scale of the structure  
        * `sill` :  
            Sill of the structure  
        * `param` :  
            Matrn parameter (third parameter)  

        """
        return _gstlearn.TurboOptimizer_setModelByScale(self, scale, sill, param)

    def setEnviron(self, flagOne=1):
        r"""

        TurboOptimizer::setEnviron
        Generic method to set all the remaining terms of the class  

        Parameters
        ----------
        * `flagOne` :  
            Starting value for numbering of rows and columns in TripletND  

        """
        return _gstlearn.TurboOptimizer_setEnviron(self, flagOne)

    def run(self, verbose=False):
        r"""

        TurboOptimizer::run
        This function is compulsory as it performs the calculations and allows retrieval
        of the matrices  

        Parameters
        ----------
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.TurboOptimizer_run(self, verbose)

    def getBlin(self):
        r"""

        TurboOptimizer::getBlin
        Allows retrieving the vector Blin  

        Returns
        -------
        The Blin vector  

        """
        return _gstlearn.TurboOptimizer_getBlin(self)

    def getTildeC(self):
        r"""

        TurboOptimizer::getTildeC
        Allows retrieving the vector TildeC  

        Returns
        -------
        The TildeC vector  

        """
        return _gstlearn.TurboOptimizer_getTildeC(self)

    def getLambda(self):
        r"""

        TurboOptimizer::getLambda
        Allows retrieving the vector Lambda  

        Returns
        -------
        The Lambda vector  

        """
        return _gstlearn.TurboOptimizer_getLambda(self)

    def getS(self):
        r"""

        TurboOptimizer::getS
        Allows retrieving the S sparse matrix  

        Returns
        -------
        The returned matrix stored as TripletNDs  

        """
        return _gstlearn.TurboOptimizer_getS(self)

    def getQ(self):
        r"""

        TurboOptimizer::getQ
        Allows retrieving the Q sparse matrix  

        Returns
        -------
        The returned matrix stored as Triplets  

        """
        return _gstlearn.TurboOptimizer_getQ(self)

    def interpolate(self, x, y):
        r"""

        TurboOptimizer::interpolate
        Returns the weights for interpolating points on the meshing  

        Parameters
        ----------
        * `x` :  
            Vector of X-coordinates for the target points  
        * `y` :  
            Vector of Y-coordinates for the target points  

        Returns
        -------
        The triplet structure giving the interpolation weights  

        note: : The triplets contain:  

        note: : - rows: the index of the target point  

        note: : - cols: the index of the node of the grid  

        note: : - values: the corresponding weight  

        """
        return _gstlearn.TurboOptimizer_interpolate(self, x, y)

    def interpolate_rows(self, x, y):
        r"""

        TurboOptimizer::interpolate_rows
        """
        return _gstlearn.TurboOptimizer_interpolate_rows(self, x, y)

    def interpolate_cols(self, x, y):
        r"""

        TurboOptimizer::interpolate_cols
        """
        return _gstlearn.TurboOptimizer_interpolate_cols(self, x, y)

    def interpolate_values(self, x, y):
        r"""

        TurboOptimizer::interpolate_values
        """
        return _gstlearn.TurboOptimizer_interpolate_values(self, x, y)

    def getQ_rows(self):
        r"""

        TurboOptimizer::getQ_rows
        """
        return _gstlearn.TurboOptimizer_getQ_rows(self)

    def getQ_cols(self):
        r"""

        TurboOptimizer::getQ_cols
        """
        return _gstlearn.TurboOptimizer_getQ_cols(self)

    def getQ_values(self):
        r"""

        TurboOptimizer::getQ_values
        """
        return _gstlearn.TurboOptimizer_getQ_values(self)

    def printClass(self):
        r"""

        TurboOptimizer::printClass
        Display the parameters of the Method (Grid and Model parameters)  

        """
        return _gstlearn.TurboOptimizer_printClass(self)

    def printMeshes(self):
        r"""

        TurboOptimizer::printMeshes
        Print the elements of the Internal Meshing  

        """
        return _gstlearn.TurboOptimizer_printMeshes(self)

    def printS(self, nper_batch=5, row_begin=0, row_end=0, col_begin=0, col_end=0):
        r"""

        TurboOptimizer::printS
        """
        return _gstlearn.TurboOptimizer_printS(self, nper_batch, row_begin, row_end, col_begin, col_end)

    def printQ(self, nper_batch=5, row_begin=0, row_end=0, col_begin=0, col_end=0):
        r"""

        TurboOptimizer::printQ
        """
        return _gstlearn.TurboOptimizer_printQ(self, nper_batch, row_begin, row_end, col_begin, col_end)

    def getHalf(self):
        r"""

        TurboOptimizer::getHalf
        """
        return _gstlearn.TurboOptimizer_getHalf(self)

    def getCenter(self):
        r"""

        TurboOptimizer::getCenter
        """
        return _gstlearn.TurboOptimizer_getCenter(self)

    def getNxred(self):
        r"""

        TurboOptimizer::getNxred
        """
        return _gstlearn.TurboOptimizer_getNxred(self)

    def getPoncif(self):
        r"""

        TurboOptimizer::getPoncif
        """
        return _gstlearn.TurboOptimizer_getPoncif(self)

    def getTildeCT(self):
        r"""

        TurboOptimizer::getTildeCT
        """
        return _gstlearn.TurboOptimizer_getTildeCT(self)

    def getLambdaT(self):
        r"""

        TurboOptimizer::getLambdaT
        """
        return _gstlearn.TurboOptimizer_getLambdaT(self)

    def getQT(self):
        r"""

        TurboOptimizer::getQT
        """
        return _gstlearn.TurboOptimizer_getQT(self)

    def getST(self):
        r"""

        TurboOptimizer::getST
        """
        return _gstlearn.TurboOptimizer_getST(self)

# Register TurboOptimizer in _gstlearn:
_gstlearn.TurboOptimizer_swigregister(TurboOptimizer)
class IProj(object):
    r"""


    C++ includes: IProj.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        IProj::IProj
        """
        if self.__class__ == IProj:
            _self = None
        else:
            _self = self
        _gstlearn.IProj_swiginit(self, _gstlearn.new_IProj(_self, ))
    __swig_destroy__ = _gstlearn.delete_IProj

    def point2mesh(self, inv, outv):
        r"""

        IProj::point2mesh
        """
        return _gstlearn.IProj_point2mesh(self, inv, outv)

    def mesh2point(self, inv, outv):
        r"""

        IProj::mesh2point
        """
        return _gstlearn.IProj_mesh2point(self, inv, outv)

    def getNApex(self):
        r"""

        IProj::getNApex
        """
        return _gstlearn.IProj_getNApex(self)

    def getNPoint(self):
        r"""

        IProj::getNPoint
        """
        return _gstlearn.IProj_getNPoint(self)
    def __disown__(self):
        self.this.disown()
        _gstlearn.disown_IProj(self)
        return weakref.proxy(self)

# Register IProj in _gstlearn:
_gstlearn.IProj_swigregister(IProj)
class ProjZero(IProj):
    r"""


    C++ includes: ProjZero.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        ProjZero::ProjZero
        """
        _gstlearn.ProjZero_swiginit(self, _gstlearn.new_ProjZero(*args))
    __swig_destroy__ = _gstlearn.delete_ProjZero

    def getNApex(self):
        r"""

        ProjZero::getNApex
        """
        return _gstlearn.ProjZero_getNApex(self)

    def getNPoint(self):
        r"""

        ProjZero::getNPoint
        """
        return _gstlearn.ProjZero_getNPoint(self)

# Register ProjZero in _gstlearn:
_gstlearn.ProjZero_swigregister(ProjZero)
class ProjComposition(IProj):
    r"""


    C++ includes: ProjComposition.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, projs):
        r"""

        ProjComposition::ProjComposition
        """
        _gstlearn.ProjComposition_swiginit(self, _gstlearn.new_ProjComposition(projs))
    __swig_destroy__ = _gstlearn.delete_ProjComposition

    def getNApex(self):
        r"""

        ProjComposition::getNApex
        """
        return _gstlearn.ProjComposition_getNApex(self)

    def getNPoint(self):
        r"""

        ProjComposition::getNPoint
        """
        return _gstlearn.ProjComposition_getNPoint(self)

# Register ProjComposition in _gstlearn:
_gstlearn.ProjComposition_swigregister(ProjComposition)
class ProjMatrix(IProj, MatrixSparse):
    r"""


    C++ includes: ProjMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ProjMatrix::ProjMatrix
        """
        _gstlearn.ProjMatrix_swiginit(self, _gstlearn.new_ProjMatrix(*args))
    __swig_destroy__ = _gstlearn.delete_ProjMatrix

    def toTL(self):
        return _gstlearn.ProjMatrix_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ProjMatrix_clone(self)

    def toString(self, strfmt=None):
        r"""

        ProjMatrix::toString
        Cloneable interface.  

        Interface for AStringable  

        """
        return _gstlearn.ProjMatrix_toString(self, strfmt)

    def getNApex(self):
        r"""

        ProjMatrix::getNApex
        """
        return _gstlearn.ProjMatrix_getNApex(self)

    def getNPoint(self):
        r"""

        ProjMatrix::getNPoint
        """
        return _gstlearn.ProjMatrix_getNPoint(self)

    @staticmethod
    def create(db, a_mesh, rankZ=-1, verbose=False):
        r"""

        ProjMatrix::create
        """
        return _gstlearn.ProjMatrix_create(db, a_mesh, rankZ, verbose)

    def resetFromMeshAndDb(self, db, a_mesh, rankZ=-1, verbose=False):
        r"""

        ProjMatrix::resetFromMeshAndDb
        """
        return _gstlearn.ProjMatrix_resetFromMeshAndDb(self, db, a_mesh, rankZ, verbose)

    def dumpVerticesUsed(self, npmax=-1):
        r"""

        ProjMatrix::dumpVerticesUsed
        """
        return _gstlearn.ProjMatrix_dumpVerticesUsed(self, npmax)

    def __repr__(self):
        return _gstlearn.ProjMatrix___repr__(self)

# Register ProjMatrix in _gstlearn:
_gstlearn.ProjMatrix_swigregister(ProjMatrix)
class ProjMulti(IProj, AStringable):
    r"""


    C++ includes: ProjMulti.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, projs, silent=False):
        r"""

        ProjMulti::ProjMulti
        """
        _gstlearn.ProjMulti_swiginit(self, _gstlearn.new_ProjMulti(projs, silent))

    def toString(self, strfmt=None):
        r"""

        ProjMulti::toString
        AStringable Interface.  

        """
        return _gstlearn.ProjMulti_toString(self, strfmt)

    def getNApex(self):
        r"""

        ProjMulti::getNApex
        """
        return _gstlearn.ProjMulti_getNApex(self)

    def getNPoint(self):
        r"""

        ProjMulti::getNPoint
        """
        return _gstlearn.ProjMulti_getNPoint(self)

    def getNVariable(self):
        r"""

        ProjMulti::getNVariable
        """
        return _gstlearn.ProjMulti_getNVariable(self)

    def getNLatent(self):
        r"""

        ProjMulti::getNLatent
        """
        return _gstlearn.ProjMulti_getNLatent(self)
    __swig_destroy__ = _gstlearn.delete_ProjMulti

    def empty(self):
        r"""

        ProjMulti::empty
        """
        return _gstlearn.ProjMulti_empty(self)

    def __repr__(self):
        return _gstlearn.ProjMulti___repr__(self)

# Register ProjMulti in _gstlearn:
_gstlearn.ProjMulti_swigregister(ProjMulti)
class ProjMultiMatrix(ProjMulti):
    r"""


    C++ includes: ProjMultiMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, proj, toClean=False, silent=False):
        r"""

        ProjMultiMatrix::ProjMultiMatrix
        """
        _gstlearn.ProjMultiMatrix_swiginit(self, _gstlearn.new_ProjMultiMatrix(proj, toClean, silent))
    __swig_destroy__ = _gstlearn.delete_ProjMultiMatrix

    @staticmethod
    def create(vectproj, nvariable):
        r"""

        ProjMultiMatrix::create
        """
        return _gstlearn.ProjMultiMatrix_create(vectproj, nvariable)

    @staticmethod
    def createFromDbAndMeshes(db, meshes, ncov, nvar, checkOnZVariable=True, verbose=False):
        r"""

        ProjMultiMatrix::createFromDbAndMeshes
        Construct the Projection Matrix starting from 'db' and 'meshes'.  

        Parameters
        ----------
        * `db` :  
            Target Db structure  
        * `meshes` :  
            List of target meshes  
        * `ncov` :  
            Number of covariances (nugget excluded)  
        * `nvar` :  
            Number of variables (see notes)  
        * `checkOnZVariable` :  
            Check if a sample should be considered or not  
        * `verbose` :  
            Verbose flag  

        Returns
        -------
        ProjMultiMatrix  

        note: Argument 'nvar' is provided as it cannot be derived from 'db' (when 'db'
            refers to the output file for example, where no Z-variable is available)  

        note: When Z-variable is defined, you can still bypass checking the validity of
            a sample (its Z-value is not NA) if 'checkOnZVariable' is False.  

        """
        return _gstlearn.ProjMultiMatrix_createFromDbAndMeshes(db, meshes, ncov, nvar, checkOnZVariable, verbose)

    def getProj(self):
        r"""

        ProjMultiMatrix::getProj
        """
        return _gstlearn.ProjMultiMatrix_getProj(self)

    def __repr__(self):
        return _gstlearn.ProjMultiMatrix___repr__(self)

# Register ProjMultiMatrix in _gstlearn:
_gstlearn.ProjMultiMatrix_swigregister(ProjMultiMatrix)
class PrecisionOpMulti(AStringable, ASimulable):
    r"""


    Class to store objects for SPDE  

    C++ includes: PrecisionOpMulti.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""

        PrecisionOpMulti::PrecisionOpMulti
        """
        _gstlearn.PrecisionOpMulti_swiginit(self, _gstlearn.new_PrecisionOpMulti(*args, **kwargs))
    __swig_destroy__ = _gstlearn.delete_PrecisionOpMulti

    def getSize(self):
        r"""

        PrecisionOpMulti::getSize
        """
        return _gstlearn.PrecisionOpMulti_getSize(self)

    def toString(self, strfmt=None):
        r"""

        PrecisionOpMulti::toString
        AStringable Interface.  

        """
        return _gstlearn.PrecisionOpMulti_toString(self, strfmt)

    def computeLogDetQ(self, nMC=1):
        r"""

        PrecisionOpMulti::computeLogDetQ
        """
        return _gstlearn.PrecisionOpMulti_computeLogDetQ(self, nMC)

    def __repr__(self):
        return _gstlearn.PrecisionOpMulti___repr__(self)

# Register PrecisionOpMulti in _gstlearn:
_gstlearn.PrecisionOpMulti_swigregister(PrecisionOpMulti)
class PrecisionOpMultiMatrix(PrecisionOpMulti):
    r"""


    Class for the precision matrix of the latent field in SPDE (matricial form)  

    C++ includes: PrecisionOpMultiMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""

        PrecisionOpMultiMatrix::PrecisionOpMultiMatrix
        """
        _gstlearn.PrecisionOpMultiMatrix_swiginit(self, _gstlearn.new_PrecisionOpMultiMatrix(*args, **kwargs))
    __swig_destroy__ = _gstlearn.delete_PrecisionOpMultiMatrix

    def getQ(self):
        r"""

        PrecisionOpMultiMatrix::getQ
        """
        return _gstlearn.PrecisionOpMultiMatrix_getQ(self)

    def __repr__(self):
        return _gstlearn.PrecisionOpMultiMatrix___repr__(self)

# Register PrecisionOpMultiMatrix in _gstlearn:
_gstlearn.PrecisionOpMultiMatrix_swigregister(PrecisionOpMultiMatrix)
class PrecisionOpMultiConditional(ALinearOpMulti):
    r"""


    Class to store objects for SPDE  

    C++ includes: PrecisionOpMultiConditional.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        PrecisionOpMultiConditional::PrecisionOpMultiConditional
        """
        _gstlearn.PrecisionOpMultiConditional_swiginit(self, _gstlearn.new_PrecisionOpMultiConditional())
    __swig_destroy__ = _gstlearn.delete_PrecisionOpMultiConditional

    def makeReady(self):
        r"""

        PrecisionOpMultiConditional::makeReady
        Interface for PrecisionOpMultiConditional.  

        """
        return _gstlearn.PrecisionOpMultiConditional_makeReady(self)

    def push_back(self, pmatElem, projDataElem=None):
        r"""

        PrecisionOpMultiConditional::push_back
        """
        return _gstlearn.PrecisionOpMultiConditional_push_back(self, pmatElem, projDataElem)

    def computeLogDetOp(self, nbsimu=1):
        r"""

        PrecisionOpMultiConditional::computeLogDetOp
        """
        return _gstlearn.PrecisionOpMultiConditional_computeLogDetOp(self, nbsimu)

    def sizes(self):
        r"""

        PrecisionOpMultiConditional::sizes
        Interface for ALinearOpMulti.  

        """
        return _gstlearn.PrecisionOpMultiConditional_sizes(self)

    def size(self, i):
        r"""

        PrecisionOpMultiConditional::size
        """
        return _gstlearn.PrecisionOpMultiConditional_size(self, i)

    def getAllVarianceData(self):
        r"""

        PrecisionOpMultiConditional::getAllVarianceData
        """
        return _gstlearn.PrecisionOpMultiConditional_getAllVarianceData(self)

    def getVarianceData(self, iech):
        r"""

        PrecisionOpMultiConditional::getVarianceData
        """
        return _gstlearn.PrecisionOpMultiConditional_getVarianceData(self, iech)

    def setVarianceData(self, nugg):
        r"""

        PrecisionOpMultiConditional::setVarianceData
        """
        return _gstlearn.PrecisionOpMultiConditional_setVarianceData(self, nugg)

    def setVarianceDataVector(self, nugg):
        r"""

        PrecisionOpMultiConditional::setVarianceDataVector
        """
        return _gstlearn.PrecisionOpMultiConditional_setVarianceDataVector(self, nugg)

    def computeRangeEigenVal(self):
        r"""

        PrecisionOpMultiConditional::computeRangeEigenVal
        """
        return _gstlearn.PrecisionOpMultiConditional_computeRangeEigenVal(self)

    def rangeEigenValQ(self):
        r"""

        PrecisionOpMultiConditional::rangeEigenValQ
        """
        return _gstlearn.PrecisionOpMultiConditional_rangeEigenValQ(self)

    def getMaxEigenValProj(self):
        r"""

        PrecisionOpMultiConditional::getMaxEigenValProj
        """
        return _gstlearn.PrecisionOpMultiConditional_getMaxEigenValProj(self)

    def computeLogDetNoise(self):
        r"""

        PrecisionOpMultiConditional::computeLogDetNoise
        """
        return _gstlearn.PrecisionOpMultiConditional_computeLogDetNoise(self)

    def computeLogDetQ(self, nMC=1):
        r"""

        PrecisionOpMultiConditional::computeLogDetQ
        """
        return _gstlearn.PrecisionOpMultiConditional_computeLogDetQ(self, nMC)

    def computeTotalLogDet(self, nMC=1, seed=13132):
        r"""

        PrecisionOpMultiConditional::computeTotalLogDet
        """
        return _gstlearn.PrecisionOpMultiConditional_computeTotalLogDet(self, nMC, seed)

    def preparePoly(self, logPoly):
        r"""

        PrecisionOpMultiConditional::preparePoly
        """
        return _gstlearn.PrecisionOpMultiConditional_preparePoly(self, logPoly)

    def getProjMatrix(self, i=0):
        r"""

        PrecisionOpMultiConditional::getProjMatrix
        """
        return _gstlearn.PrecisionOpMultiConditional_getProjMatrix(self, i)

    def getMultiPrecisionOp(self, i=0):
        r"""

        PrecisionOpMultiConditional::getMultiPrecisionOp
        """
        return _gstlearn.PrecisionOpMultiConditional_getMultiPrecisionOp(self, i)

    def mustShowStats(self, status):
        r"""

        PrecisionOpMultiConditional::mustShowStats
        """
        return _gstlearn.PrecisionOpMultiConditional_mustShowStats(self, status)

    def computeCoeffs(self, Y, X):
        r"""

        PrecisionOpMultiConditional::computeCoeffs
        """
        return _gstlearn.PrecisionOpMultiConditional_computeCoeffs(self, Y, X)

# Register PrecisionOpMultiConditional in _gstlearn:
_gstlearn.PrecisionOpMultiConditional_swigregister(PrecisionOpMultiConditional)
class ProjConvolution(IProj):
    r"""


    Projection matrix for vertical convolution  

    C++ includes: ProjConvolution.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""

        ProjConvolution::ProjConvolution
        """
        _gstlearn.ProjConvolution_swiginit(self, _gstlearn.new_ProjConvolution(*args, **kwargs))
    __swig_destroy__ = _gstlearn.delete_ProjConvolution

    def getNApex(self):
        r"""

        ProjConvolution::getNApex
        """
        return _gstlearn.ProjConvolution_getNApex(self)

    def getNPoint(self):
        r"""

        ProjConvolution::getNPoint
        """
        return _gstlearn.ProjConvolution_getNPoint(self)

    def getResolutionGrid(self):
        r"""

        ProjConvolution::getResolutionGrid
        """
        return _gstlearn.ProjConvolution_getResolutionGrid(self)

    def getAProjHoriz(self):
        r"""

        ProjConvolution::getAProjHoriz
        TODO : return a shared pointer ?  

        """
        return _gstlearn.ProjConvolution_getAProjHoriz(self)

    def getConvolution(self):
        r"""

        ProjConvolution::getConvolution
        """
        return _gstlearn.ProjConvolution_getConvolution(self)

    def getShiftVector(self):
        r"""

        ProjConvolution::getShiftVector
        """
        return _gstlearn.ProjConvolution_getShiftVector(self)

# Register ProjConvolution in _gstlearn:
_gstlearn.ProjConvolution_swigregister(ProjConvolution)
class IOptimCost(object):
    r"""


    C++ includes: IOptimCost.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_IOptimCost

    def calculateGradient(self, indic, sval, normgrad):
        r"""

        IOptimCost::calculateGradient
        """
        return _gstlearn.IOptimCost_calculateGradient(self, indic, sval, normgrad)

# Register IOptimCost in _gstlearn:
_gstlearn.IOptimCost_swigregister(IOptimCost)
class OptimCostBinary(IOptimCost):
    r"""


    C++ includes: OptimCostBinary.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        OptimCostBinary::OptimCostBinary
        """
        _gstlearn.OptimCostBinary_swiginit(self, _gstlearn.new_OptimCostBinary(*args))
    __swig_destroy__ = _gstlearn.delete_OptimCostBinary

    def reset(self, *args, **kwargs):
        r"""

        OptimCostBinary::reset
        Initialize the Binary Cost Operator  

        Parameters
        ----------
        * `pmat` :  
            The precision matrix to be optimized  
        * `projdata` :  
            The Projection operator between Data and Meshing  
        * `projseis` :  
            The Projection operator between Seismic and Meshing  
        * `propseis` :  
            Array of facies proportions  
        * `varseis` :  
            Array of variance attached to the seismic  

        """
        return _gstlearn.OptimCostBinary_reset(self, *args, **kwargs)

    def minimize(self, indic, verbose=False, maxiter=100, eps=5.e-4):
        r"""

        OptimCostBinary::minimize
        Perform the minimization  

        Returns
        -------
        The array of facies proportions (Dimension: nvertex)  

        Parameters
        ----------
        * `indic` :  
            Array containing the Facies indicators (see remarks) (Dimension: npoint)  
        * `verbose` :  
            Verbose flag  
        * `maxiter` :  
            Maximum number of iterations for Optimization algo.  
        * `eps` :  
            Tolerance for Optimization algorithm  

        remark: The argument 'indic' should contain 0 or 1 for active constraints  

        remark: The inactive constraints should be set to TEST.  

        """
        return _gstlearn.OptimCostBinary_minimize(self, indic, verbose, maxiter, eps)

    def calculateGradient(self, indic, _lambda, out):
        r"""

        OptimCostBinary::calculateGradient
        Calculate the Gradient  

        Parameters
        ----------
        * `indic` :  
            Array containing the Facies indicators (see remarks) (Dimension: npoint)  
        * `lambda` :  
            Array of input values  
        * `out` :  
            Array of output gradients  

        """
        return _gstlearn.OptimCostBinary_calculateGradient(self, indic, _lambda, out)

    def setMeanProportion(self, meanprop):
        r"""

        OptimCostBinary::setMeanProportion
        Set the Mean proportion for the indicator  

        Parameters
        ----------
        * `meanprop` :  
            Value of the mean proportion (raw scale)  

        """
        return _gstlearn.OptimCostBinary_setMeanProportion(self, meanprop)

    @staticmethod
    def setPreCondParams(chebncmax=10001, chebtol=5.e-3):
        r"""

        OptimCostBinary::setPreCondParams
        Set the constant parameters for internal Pre-Conditioner  

        """
        return _gstlearn.OptimCostBinary_setPreCondParams(chebncmax, chebtol)

    def isInitialized(self):
        r"""

        OptimCostBinary::isInitialized
        """
        return _gstlearn.OptimCostBinary_isInitialized(self)

    def getNPoint(self):
        r"""

        OptimCostBinary::getNPoint
        Returns the Number of Data Points  

        """
        return _gstlearn.OptimCostBinary_getNPoint(self)

    def getNVertex(self):
        r"""

        OptimCostBinary::getNVertex
        Returns the Number of Meshing Vertices  

        """
        return _gstlearn.OptimCostBinary_getNVertex(self)

    def toggleSeismic(self, status):
        r"""

        OptimCostBinary::toggleSeismic
        Toggle the use of the Seismic constraint  

        Parameters
        ----------
        * `status` :  
            Status assigned to the Seismic Constraints  

        remark: When the Seismic is not defined (i.e. 'projSeis not defined)  

        remark: this function is useless  

        """
        return _gstlearn.OptimCostBinary_toggleSeismic(self, status)

# Register OptimCostBinary in _gstlearn:
_gstlearn.OptimCostBinary_swigregister(OptimCostBinary)
class OptimCostColored(OptimCostBinary):
    r"""


    C++ includes: OptimCostColored.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        OptimCostColored::OptimCostColored
        """
        _gstlearn.OptimCostColored_swiginit(self, _gstlearn.new_OptimCostColored(*args))
    __swig_destroy__ = _gstlearn.delete_OptimCostColored

    def reset(self, *args, **kwargs):
        r"""

        OptimCostColored::reset
        Initialize the Hessian Operator  

        Parameters
        ----------
        * `nprop` :  
            Number of different proportions (or facies)  
        * `pmat` :  
            The precision matrix to be optimized  
        * `projdata` :  
            The Projection operator between Data and Meshing  
        * `projseis` :  
            The Projection operator between Seismic and Meshing  
        * `propseis` :  
            Array of facies proportions  
        * `varseis` :  
            Array of variance attached to the seismic  

        """
        return _gstlearn.OptimCostColored_reset(self, *args, **kwargs)

    def minimize(self, *args, **kwargs):
        r"""

        OptimCostColored::minimize
        Perform the minimization  

        Returns
        -------
        Array of facies proportions (Dimension: [nprop][nvertex]  

        Parameters
        ----------
        * `facies` :  
            Array containing the Facies values (see remarks) (Dimension: npoint)  
        * `splits` :  
            Array giving the facies split (Dimension: [nfacies-1][nfacies])  
        * `meanprops` :  
            Array of mean of proportions (Dimension: nfacies)  
        * `verbose` :  
            Verbose flag  
        * `maxiter` :  
            Maximum number of iterations for Optimization algorithm  
        * `eps` :  
            Tolerance for Optimization algorithm  

        remark: Argument 'facies' should contain values ranging from 1 to _nprop  

        """
        return _gstlearn.OptimCostColored_minimize(self, *args, **kwargs)

    def initSplit(self, nfacies, verbose=False):
        r"""

        OptimCostColored::initSplit
        Provides the list of regrouped facies during Optimizaition  

        Parameters
        ----------
        * `nfacies` :  
            Number of facies  
        * `verbose` :  
            Verbose flag  

        Returns
        -------
        For each level, Vector of regrouped facies  

        """
        return _gstlearn.OptimCostColored_initSplit(self, nfacies, verbose)

    def printSplits(self, *args, **kwargs):
        r"""

        OptimCostColored::printSplits
        Internal function to print the Splits  

        """
        return _gstlearn.OptimCostColored_printSplits(self, *args, **kwargs)

    def setMeanProps(self, meanProps):
        r"""

        OptimCostColored::setMeanProps
        """
        return _gstlearn.OptimCostColored_setMeanProps(self, meanProps)

    def setSplits(self, splits):
        r"""

        OptimCostColored::setSplits
        """
        return _gstlearn.OptimCostColored_setSplits(self, splits)

# Register OptimCostColored in _gstlearn:
_gstlearn.OptimCostColored_swigregister(OptimCostColored)
class MatrixSymmetricSim(ASimulable):
    r"""


    Square Symmetric matrices  

    C++ includes: MatrixSymmetricSim.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m, inverse=True):
        r"""

        MatrixSymmetricSim::MatrixSymmetricSim
        """
        _gstlearn.MatrixSymmetricSim_swiginit(self, _gstlearn.new_MatrixSymmetricSim(m, inverse))
    __swig_destroy__ = _gstlearn.delete_MatrixSymmetricSim

    def getMatrix(self):
        r"""

        MatrixSymmetricSim::getMatrix
        """
        return _gstlearn.MatrixSymmetricSim_getMatrix(self)

    def getSize(self):
        r"""

        MatrixSymmetricSim::getSize
        """
        return _gstlearn.MatrixSymmetricSim_getSize(self)

    def isEmpty(self):
        r"""

        MatrixSymmetricSim::isEmpty
        """
        return _gstlearn.MatrixSymmetricSim_isEmpty(self)

    def computeLogDet(self, nMC=1):
        r"""

        MatrixSymmetricSim::computeLogDet
        """
        return _gstlearn.MatrixSymmetricSim_computeLogDet(self, nMC)

    def toTL(self):
        return _gstlearn.MatrixSymmetricSim_toTL(self)

# Register MatrixSymmetricSim in _gstlearn:
_gstlearn.MatrixSymmetricSim_swigregister(MatrixSymmetricSim)
class ACholesky(ASimulable):
    r"""


    C++ includes: ACholesky.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ACholesky

    def getSize(self):
        r"""

        ACholesky::getSize
        """
        return _gstlearn.ACholesky_getSize(self)

    def getMatrix(self):
        r"""

        ACholesky::getMatrix
        """
        return _gstlearn.ACholesky_getMatrix(self)

    def solve(self, vecin, vecout):
        r"""

        ACholesky::solve
        """
        return _gstlearn.ACholesky_solve(self, vecin, vecout)

    def InvLtX(self, whitenoise, vecout):
        r"""

        ACholesky::InvLtX
        """
        return _gstlearn.ACholesky_InvLtX(self, whitenoise, vecout)

    def InvLX(self, whitenoise, vecout):
        r"""

        ACholesky::InvLX
        """
        return _gstlearn.ACholesky_InvLX(self, whitenoise, vecout)

    def solveMatrix(self, b, x):
        r"""

        ACholesky::solveMatrix
        """
        return _gstlearn.ACholesky_solveMatrix(self, b, x)

    def isReady(self):
        r"""

        ACholesky::isReady
        """
        return _gstlearn.ACholesky_isReady(self)

    def invLtX(self, vecin):
        r"""

        ACholesky::invLtX
        """
        return _gstlearn.ACholesky_invLtX(self, vecin)

    def LtX(self, *args):
        r"""

        ACholesky::LtX
        """
        return _gstlearn.ACholesky_LtX(self, *args)

    def LX(self, *args):
        r"""

        ACholesky::LX
        """
        return _gstlearn.ACholesky_LX(self, *args)

    def invLX(self, vecin):
        r"""

        ACholesky::invLX
        """
        return _gstlearn.ACholesky_invLX(self, vecin)

    def solveX(self, vecin):
        r"""

        ACholesky::solveX
        """
        return _gstlearn.ACholesky_solveX(self, vecin)

    def computeLogDeterminant(self):
        r"""

        ACholesky::computeLogDeterminant
        """
        return _gstlearn.ACholesky_computeLogDeterminant(self)

    def addSolveX(self, vecin, vecout):
        r"""

        ACholesky::addSolveX
        """
        return _gstlearn.ACholesky_addSolveX(self, vecin, vecout)

    def addInvLtX(self, vecin, vecout):
        r"""

        ACholesky::addInvLtX
        """
        return _gstlearn.ACholesky_addInvLtX(self, vecin, vecout)

    def addLtX(self, vecin, vecout):
        r"""

        ACholesky::addLtX
        """
        return _gstlearn.ACholesky_addLtX(self, vecin, vecout)

    def addLX(self, vecin, vecout):
        r"""

        ACholesky::addLX
        """
        return _gstlearn.ACholesky_addLX(self, vecin, vecout)

    def addInvLX(self, vecin, vecout):
        r"""

        ACholesky::addInvLX
        """
        return _gstlearn.ACholesky_addInvLX(self, vecin, vecout)

# Register ACholesky in _gstlearn:
_gstlearn.ACholesky_swigregister(ACholesky)
class CholeskyDense(ACholesky):
    r"""


    C++ includes: CholeskyDense.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        CholeskyDense::CholeskyDense
        """
        _gstlearn.CholeskyDense_swiginit(self, _gstlearn.new_CholeskyDense(*args))
    __swig_destroy__ = _gstlearn.delete_CholeskyDense

    def setMatrix(self, mat):
        r"""

        CholeskyDense::setMatrix
        """
        return _gstlearn.CholeskyDense_setMatrix(self, mat)

    def computeLogDeterminant(self):
        r"""

        CholeskyDense::computeLogDeterminant
        """
        return _gstlearn.CholeskyDense_computeLogDeterminant(self)

    def getLowerTriangle(self, *args):
        r"""

        CholeskyDense::getLowerTriangle
        """
        return _gstlearn.CholeskyDense_getLowerTriangle(self, *args)

    def getUpperTriangleInverse(self, *args):
        r"""

        CholeskyDense::getUpperTriangleInverse
        """
        return _gstlearn.CholeskyDense_getUpperTriangleInverse(self, *args)

    def solveMatInPlace(self, mat, res):
        r"""

        CholeskyDense::solveMatInPlace
        """
        return _gstlearn.CholeskyDense_solveMatInPlace(self, mat, res)

    def addSolveX(self, vecin, vecout):
        r"""

        CholeskyDense::addSolveX
        """
        return _gstlearn.CholeskyDense_addSolveX(self, vecin, vecout)

    def addInvLtX(self, vecin, vecout):
        r"""

        CholeskyDense::addInvLtX
        """
        return _gstlearn.CholeskyDense_addInvLtX(self, vecin, vecout)

    def addLtX(self, vecin, vecout):
        r"""

        CholeskyDense::addLtX
        """
        return _gstlearn.CholeskyDense_addLtX(self, vecin, vecout)

    def addLX(self, vecin, vecout):
        r"""

        CholeskyDense::addLX
        """
        return _gstlearn.CholeskyDense_addLX(self, vecin, vecout)

    def addInvLX(self, vecin, vecout):
        r"""

        CholeskyDense::addInvLX
        """
        return _gstlearn.CholeskyDense_addInvLX(self, vecin, vecout)

    def matProductInPlace(self, mode, a, x):
        r"""

        CholeskyDense::matProductInPlace
        Performs the product between a triangular and a square matrix TL is the lower
        triangular matrix and X is a square matrix  

        Parameters
        ----------
        * `mode` :  
            Type of calculations: 0 : X=TU%*A 1 : X=TL%*A 2 : X=A%*TU 3 : X=A%*TL 4 :
            X=t(A)%*TU 5 : X=t(A)%*TL  
        * `a` :  
            Input matrix  
        * `x` :  
            Resulting matrix (resized if necessary)  

        remark: The dimensions of 'a' and 'x' must match  

        remark: Anyhow 'x' is resized to the same dimension as 'a'  

        """
        return _gstlearn.CholeskyDense_matProductInPlace(self, mode, a, x)

    def normMatInPlace(self, mode, neq, a, b):
        r"""

        CholeskyDense::normMatInPlace
        Performs the product B = TL * A * TU or TU * A * TL where TL,TU is a triangular
        matrix and A a square symmetric matrix  

        Parameters
        ----------
        * `mode` :  
            0: TL * A * TU; 1: TU * A * TL  
        * `neq` :  
            number of equations in the system  
        * `a` :  
            Square symmetric matrix (optional)  
        * `b` :  
            Square output matrix (resized if needed)  

        remark: The value of 'neq' could be derived from the input matrix 'a'  

        remark: but this matrix is optional, hence the presence of argument 'neq'  

        """
        return _gstlearn.CholeskyDense_normMatInPlace(self, mode, neq, a, b)

    def clear(self):
        r"""

        CholeskyDense::clear
        """
        return _gstlearn.CholeskyDense_clear(self)

    def empty(self):
        r"""

        CholeskyDense::empty
        """
        return _gstlearn.CholeskyDense_empty(self)

# Register CholeskyDense in _gstlearn:
_gstlearn.CholeskyDense_swigregister(CholeskyDense)
class CholeskySparse(ACholesky):
    r"""


    C++ includes: CholeskySparse.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        CholeskySparse::CholeskySparse
        """
        _gstlearn.CholeskySparse_swiginit(self, _gstlearn.new_CholeskySparse(*args))
    __swig_destroy__ = _gstlearn.delete_CholeskySparse

    def setMatrix(self, mat):
        r"""

        CholeskySparse::setMatrix
        """
        return _gstlearn.CholeskySparse_setMatrix(self, mat)

    def stdev(self, vcur, flagStDev=False):
        r"""

        CholeskySparse::stdev
        Perform the calculation of the Standard Deviation of Estimation Error  

        Parameters
        ----------
        * `vcur` :  
            Output array  
        * `flagStDev` :  
            FALSE for a variance calculation, True for StDev.  

        """
        return _gstlearn.CholeskySparse_stdev(self, vcur, flagStDev)

    def computeLogDeterminant(self):
        r"""

        CholeskySparse::computeLogDeterminant
        """
        return _gstlearn.CholeskySparse_computeLogDeterminant(self)

    def addSolveX(self, vecin, vecout):
        r"""

        CholeskySparse::addSolveX
        """
        return _gstlearn.CholeskySparse_addSolveX(self, vecin, vecout)

    def addInvLtX(self, vecin, vecout):
        r"""

        CholeskySparse::addInvLtX
        """
        return _gstlearn.CholeskySparse_addInvLtX(self, vecin, vecout)

    def addLtX(self, vecin, vecout):
        r"""

        CholeskySparse::addLtX
        """
        return _gstlearn.CholeskySparse_addLtX(self, vecin, vecout)

    def addLX(self, vecin, vecout):
        r"""

        CholeskySparse::addLX
        """
        return _gstlearn.CholeskySparse_addLX(self, vecin, vecout)

    def addInvLX(self, vecin, vecout):
        r"""

        CholeskySparse::addInvLX
        """
        return _gstlearn.CholeskySparse_addInvLX(self, vecin, vecout)

# Register CholeskySparse in _gstlearn:
_gstlearn.CholeskySparse_swigregister(CholeskySparse)
class ANeigh(ASpaceObject, ASerializable, ICloneable):
    r"""


    Class to define the a subset of an input Data Base ('Db') called a Neighborhood.
    This Neighborhood feature is invoked when the geostatistical processing cannot
    handle the whole data set (usually due to core limitations) and requires a fine
    selection of the most suitable part of the data set.  

    Several implementations can be defined, such as:  

    *   Unique Neighborhood: all active samples are selected (see NeighUnique)  
    *   Moving Neighborhood: the sub-population essentially selects the samples
        close enough to the target. This sub-population evolves with the location of
        the target, hence the name of this Neighborhood feature (see NeighMoving).  
    *   Bench Neighborhood: the sub-population selects all samples located in the
        same 'bench' as the target. A bench is a portion of the space characterized
        sliced along the highest dimension of the space (e.g. horizontal bench for
        3D space) (see NeighBench).  
    *   Cell Neighborhood: the sub-population selects all samples belonging to the
        same 'cell' as the target. Obviously this feature is only valid if the
        target data base is defined as a Grid (see NeighCell).  
    *   Image Neighborhood: the sub-population selects a pattern of constant
        dimensions centered on the target. This Neighborhood is only valid when the
        target and the input data base are matching grids (usually they are the same
        file) (see NeighImage).  

    Several other topics are considered as belonging to the Neighborhood selection
    procedure, such as:  

    *   Possibility to add some information, collected from the Target File, in the
        Neighborhood calculated from the input data file: this is the Colocation
        option  
    *   Possibility to exclude the target (or samples sharing some characteristics
        with the Target). This is the cross-validation option.  

    C++ includes: ANeigh.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_ANeigh

    def isConsistent(self, space):
        r"""

        ANeigh::isConsistent
        ASpaceObject Interface.  

        """
        return _gstlearn.ANeigh_isConsistent(self, space)

    def attach(self, dbin, dbout):
        r"""

        ANeigh::attach
        Interface for ANeigh.  

        """
        return _gstlearn.ANeigh_attach(self, dbin, dbout)

    def getNeigh(self, iech_out, ranks):
        r"""

        ANeigh::getNeigh
        """
        return _gstlearn.ANeigh_getNeigh(self, iech_out, ranks)

    def getNSampleMax(self, db):
        r"""

        ANeigh::getNSampleMax
        """
        return _gstlearn.ANeigh_getNSampleMax(self, db)

    def hasChanged(self, iech_out):
        r"""

        ANeigh::hasChanged
        """
        return _gstlearn.ANeigh_hasChanged(self, iech_out)

    def summary(self, iech_out):
        r"""

        ANeigh::summary
        """
        return _gstlearn.ANeigh_summary(self, iech_out)

    def getType(self):
        r"""

        ANeigh::getType
        """
        return _gstlearn.ANeigh_getType(self)

    def getFlagContinuous(self):
        r"""

        ANeigh::getFlagContinuous
        """
        return _gstlearn.ANeigh_getFlagContinuous(self)

    def displayDebug(self, ranks):
        r"""

        ANeigh::displayDebug
        """
        return _gstlearn.ANeigh_displayDebug(self, ranks)

    def select(self, iech_out, ranks):
        r"""

        ANeigh::select
        Generic function for performing neighborhood selection. This function ALWAYS
        modifies (and resizes) the returned array 'ranks'  

        Parameters
        ----------
        * `iech_out` :  
            Rank of the target point (in 'dbout')  
        * `ranks` :  
            Input / Output vector of neighboring sample ranks  

        """
        return _gstlearn.ANeigh_select(self, iech_out, ranks)

    def isUnchanged(self):
        r"""

        ANeigh::isUnchanged
        """
        return _gstlearn.ANeigh_isUnchanged(self)

    def setIsChanged(self, status=False):
        r"""

        ANeigh::setIsChanged
        """
        return _gstlearn.ANeigh_setIsChanged(self, status)

    def reset(self):
        r"""

        ANeigh::reset
        """
        return _gstlearn.ANeigh_reset(self)

    def getFlagXvalid(self):
        r"""

        ANeigh::getFlagXvalid
        """
        return _gstlearn.ANeigh_getFlagXvalid(self)

    def getFlagKFold(self):
        r"""

        ANeigh::getFlagKFold
        """
        return _gstlearn.ANeigh_getFlagKFold(self)

    def setFlagXvalid(self, flagXvalid):
        r"""

        ANeigh::setFlagXvalid
        """
        return _gstlearn.ANeigh_setFlagXvalid(self, flagXvalid)

    def setFlagKFold(self, flagKFold):
        r"""

        ANeigh::setFlagKFold
        """
        return _gstlearn.ANeigh_setFlagKFold(self, flagKFold)

    def setFlagSimu(self, flagSimu):
        r"""

        ANeigh::setFlagSimu
        """
        return _gstlearn.ANeigh_setFlagSimu(self, flagSimu)

    def setBallSearch(self, status, leaf_size=10):
        r"""

        ANeigh::setBallSearch
        """
        return _gstlearn.ANeigh_setBallSearch(self, status, leaf_size)

    def attachBall(self, dist_function=None):
        r"""

        ANeigh::attachBall
        """
        return _gstlearn.ANeigh_attachBall(self, dist_function)

    def __repr__(self):
        return _gstlearn.ANeigh___repr__(self)

# Register ANeigh in _gstlearn:
_gstlearn.ANeigh_swigregister(ANeigh)
class NeighUnique(ANeigh):
    r"""


    Unique Neighborhood definition.  

    The Neighborhood is usually meant to select a sub-population from the input Data
    Base, containing the active samples close to the target.  

    The Unique Neighborhood selects all the active samples. Nevertheless, it offers
    the possibility to suppress any sample which would be too close to (or coincide
    with) the target: this is the cross-validation option.  

    C++ includes: NeighUnique.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NeighUnique::NeighUnique
        """
        _gstlearn.NeighUnique_swiginit(self, _gstlearn.new_NeighUnique(*args))
    __swig_destroy__ = _gstlearn.delete_NeighUnique

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.NeighUnique_clone(self)

    def getNeigh(self, iech_out, ranks):
        r"""

        NeighUnique::getNeigh
        Interface for ANeigh.  

        Select the neighborhood  

        Parameters
        ----------
        * `iech_out` :  
            Valid Rank of the sample in the output Db  
        * `ranks` :  
            Vector of sample ranks in neighborhood (empty when error)  

        """
        return _gstlearn.NeighUnique_getNeigh(self, iech_out, ranks)

    def getNSampleMax(self, db):
        r"""

        NeighUnique::getNSampleMax
        Given a Db, returns the maximum number of samples per NeighUniqueborhood  

        Parameters
        ----------
        * `db` :  
            Pointer to the target Db  

        Returns
        -------  

        """
        return _gstlearn.NeighUnique_getNSampleMax(self, db)

    def hasChanged(self, iech_out):
        r"""

        NeighUnique::hasChanged
        """
        return _gstlearn.NeighUnique_hasChanged(self, iech_out)

    def getType(self):
        r"""

        NeighUnique::getType
        """
        return _gstlearn.NeighUnique_getType(self)

    def toString(self, strfmt=None):
        r"""

        NeighUnique::toString
        Interface for AStringable.  

        """
        return _gstlearn.NeighUnique_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        NeighUnique::create
        """
        return _gstlearn.NeighUnique_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        NeighUnique::createFromNF
        Create a NeighUniqueborhood by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.NeighUnique_createFromNF(NFFilename, verbose)

    def __repr__(self):
        return _gstlearn.NeighUnique___repr__(self)

# Register NeighUnique in _gstlearn:
_gstlearn.NeighUnique_swigregister(NeighUnique)
class NeighImage(ANeigh):
    r"""


    Image Neighborhood definition.  

    The Neighborhood is usually meant to select a sub-population from the input Data
    Base, containing the active samples close to the target.  

    This Neighborhood is only defined in the case when the Data and the Target
    belong to the same grid. This neighborhood is defined as a rectangular set of
    pixels, located around the target. This rectangle is given by its half-extension
    in each space dimension (called 'radius') As the number of pixels grows fast
    with the space dimension, it is offered to sample them by specifying a skipping
    factor, so as to retain only 1 / (1 + skip) of them.  

    C++ includes: NeighImage.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NeighImage::NeighImage
        """
        _gstlearn.NeighImage_swiginit(self, _gstlearn.new_NeighImage(*args))
    __swig_destroy__ = _gstlearn.delete_NeighImage

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.NeighImage_clone(self)

    def getNeigh(self, iech_out, ranks):
        r"""

        NeighImage::getNeigh
        Interface for ANeigh.  

        Select the neighborhood  

        Parameters
        ----------
        * `iech_out` :  
            Valid Rank of the sample in the output Db  
        * `ranks` :  
            Vector of sample ranks in neighborhood (empty when error)  

        """
        return _gstlearn.NeighImage_getNeigh(self, iech_out, ranks)

    def getNSampleMax(self, db):
        r"""

        NeighImage::getNSampleMax
        Given a Db, returns the maximum number of samples per NeighImageborhood  

        Parameters
        ----------
        * `db` :  
            Pointer to the target Db  

        Returns
        -------  

        """
        return _gstlearn.NeighImage_getNSampleMax(self, db)

    def hasChanged(self, iech_out):
        r"""

        NeighImage::hasChanged
        """
        return _gstlearn.NeighImage_hasChanged(self, iech_out)

    def getType(self):
        r"""

        NeighImage::getType
        """
        return _gstlearn.NeighImage_getType(self)

    def toString(self, strfmt=None):
        r"""

        NeighImage::toString
        Interface for AStringable.  

        """
        return _gstlearn.NeighImage_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        NeighImage::create
        """
        return _gstlearn.NeighImage_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        NeighImage::createFromNF
        Create a NeighImageborhood by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.NeighImage_createFromNF(NFFilename, verbose)

    def getSkip(self):
        r"""

        NeighImage::getSkip
        """
        return _gstlearn.NeighImage_getSkip(self)

    def getImageRadius(self, *args):
        r"""

        NeighImage::getImageRadius
        """
        return _gstlearn.NeighImage_getImageRadius(self, *args)

    def setImageRadius(self, imageRadius):
        r"""

        NeighImage::setImageRadius
        """
        return _gstlearn.NeighImage_setImageRadius(self, imageRadius)

    def setSkip(self, skip):
        r"""

        NeighImage::setSkip
        """
        return _gstlearn.NeighImage_setSkip(self, skip)

    def buildImageGrid(self, dbgrid, seed):
        r"""

        NeighImage::buildImageGrid
        Create a subgrid containing the minimum pattern for Image Neighborhood. The
        output subgrid is "parallel" to the input 'dbgrid'.  

        Parameters
        ----------
        * `dbgrid` :  
            Input DbGrid  
        * `seed` :  
            Seed used for random number generation  

        Returns
        -------
        Pointer to the newly created DbGrid  

        remark: When a sample is skipped ('using 'skip' Neighborhood parameter) the
            value of the corresponding variable is set to 'TEST'.  

        remark: The center point can never be skipped.  

        """
        return _gstlearn.NeighImage_buildImageGrid(self, dbgrid, seed)

    def __repr__(self):
        return _gstlearn.NeighImage___repr__(self)

# Register NeighImage in _gstlearn:
_gstlearn.NeighImage_swigregister(NeighImage)
class NeighMoving(ANeigh):
    r"""


    Moving Neighborhood definition.  

    The Neighborhood is usually meant to select a sub-population from the input Data
    Base, containing the active samples close to the target.  

    The Moving Neighborhood selects these active samples based on a series of
    criteria (the corresponding parameters are given between parentheses), such as:  

    *   the selected samples should belong to a circle (ellipse) centered on the
        target sample (circle radius, ellipse orientation and extensions)  
    *   the minimum and maximum number of selected samples  
    *   the previous circle can be subdivided into angular sectors: the selected
        samples are taken regularly per sector (maximum number of samples per
        sector)  

    The neighborhood also offers the possibility to suppress any sample which would
    be too close to (or coincide with) the target: this is the cross-validation
    option.  

    C++ includes: NeighMoving.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NeighMoving::NeighMoving
        """
        _gstlearn.NeighMoving_swiginit(self, _gstlearn.new_NeighMoving(*args))
    __swig_destroy__ = _gstlearn.delete_NeighMoving

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.NeighMoving_clone(self)

    def attach(self, dbin, dbout=None):
        r"""

        NeighMoving::attach
        Interface for ANeigh.  

        Initialize the neighborhood search  

        Parameters
        ----------
        * `dbin` :  
            input Db structure  
        * `dbout` :  
            output Db structure (optional)  

        """
        return _gstlearn.NeighMoving_attach(self, dbin, dbout)

    def getNeigh(self, iech_out, ranks):
        r"""

        NeighMoving::getNeigh
        Select the neighborhood  

        Parameters
        ----------
        * `iech_out` :  
            Valid Rank of the sample in the output Db  
        * `ranks` :  
            Vector of sample ranks in neighborhood (empty when error)  

        """
        return _gstlearn.NeighMoving_getNeigh(self, iech_out, ranks)

    def hasChanged(self, iech_out):
        r"""

        NeighMoving::hasChanged
        """
        return _gstlearn.NeighMoving_hasChanged(self, iech_out)

    def summary(self, iech_out):
        r"""

        NeighMoving::summary
        Returns the main Neighborhood Parameters for a given target as a vector:  

        *   0 : Number of active samples  
        *   1 : Minimum distance  
        *   2 : Maximum distance  
        *   3 : Number of non-empty sectors  
        *   4 : Number of consecutive empty sectors  

        Parameters
        ----------
        * `iech_out` :  
            Valid Rank of the sample in the output Db  

        """
        return _gstlearn.NeighMoving_summary(self, iech_out)

    def getNSampleMax(self, db):
        r"""

        NeighMoving::getNSampleMax
        Given a Db, returns the maximum number of samples per NeighMovingborhood  

        Parameters
        ----------
        * `db` :  
            Pointer to the target Db  

        Returns
        -------  

        """
        return _gstlearn.NeighMoving_getNSampleMax(self, db)

    def getType(self):
        r"""

        NeighMoving::getType
        """
        return _gstlearn.NeighMoving_getType(self)

    def getFlagContinuous(self):
        r"""

        NeighMoving::getFlagContinuous
        """
        return _gstlearn.NeighMoving_getFlagContinuous(self)

    def toString(self, strfmt=None):
        r"""

        NeighMoving::toString
        Interface for AStringable.  

        """
        return _gstlearn.NeighMoving_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        NeighMoving::create
        """
        return _gstlearn.NeighMoving_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        NeighMoving::createFromNF
        Create a NeighMovingborhood by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.NeighMoving_createFromNF(NFFilename, verbose)

    def addBiTargetCheck(self, abpc):
        r"""

        NeighMoving::addBiTargetCheck
        """
        return _gstlearn.NeighMoving_addBiTargetCheck(self, abpc)

    def getFlagSector(self):
        r"""

        NeighMoving::getFlagSector
        """
        return _gstlearn.NeighMoving_getFlagSector(self)

    def getNMaxi(self):
        r"""

        NeighMoving::getNMaxi
        """
        return _gstlearn.NeighMoving_getNMaxi(self)

    def getNMini(self):
        r"""

        NeighMoving::getNMini
        """
        return _gstlearn.NeighMoving_getNMini(self)

    def getNSect(self):
        r"""

        NeighMoving::getNSect
        """
        return _gstlearn.NeighMoving_getNSect(self)

    def getNSMax(self):
        r"""

        NeighMoving::getNSMax
        """
        return _gstlearn.NeighMoving_getNSMax(self)

    def getDistCont(self):
        r"""

        NeighMoving::getDistCont
        """
        return _gstlearn.NeighMoving_getDistCont(self)

    def getBiPtDist(self):
        r"""

        NeighMoving::getBiPtDist
        """
        return _gstlearn.NeighMoving_getBiPtDist(self)

    def getFlagAniso(self):
        r"""

        NeighMoving::getFlagAniso
        """
        return _gstlearn.NeighMoving_getFlagAniso(self)

    def getFlagRotation(self):
        r"""

        NeighMoving::getFlagRotation
        """
        return _gstlearn.NeighMoving_getFlagRotation(self)

    def getRadius(self):
        r"""

        NeighMoving::getRadius
        """
        return _gstlearn.NeighMoving_getRadius(self)

    def getAnisoRotMats(self):
        r"""

        NeighMoving::getAnisoRotMats
        """
        return _gstlearn.NeighMoving_getAnisoRotMats(self)

    def getAnisoCoeffs(self):
        r"""

        NeighMoving::getAnisoCoeffs
        """
        return _gstlearn.NeighMoving_getAnisoCoeffs(self)

    def getAnisoCoeff(self, i):
        r"""

        NeighMoving::getAnisoCoeff
        """
        return _gstlearn.NeighMoving_getAnisoCoeff(self, i)

    def getBipts(self, *args):
        r"""

        NeighMoving::getBipts
        """
        return _gstlearn.NeighMoving_getBipts(self, *args)

    def setNMaxi(self, nmaxi):
        r"""

        NeighMoving::setNMaxi
        """
        return _gstlearn.NeighMoving_setNMaxi(self, nmaxi)

    def setNMini(self, nmini):
        r"""

        NeighMoving::setNMini
        """
        return _gstlearn.NeighMoving_setNMini(self, nmini)

    def setNSect(self, nsect):
        r"""

        NeighMoving::setNSect
        """
        return _gstlearn.NeighMoving_setNSect(self, nsect)

    def setNSMax(self, nsmax):
        r"""

        NeighMoving::setNSMax
        """
        return _gstlearn.NeighMoving_setNSMax(self, nsmax)

    def setDistCont(self, distCont):
        r"""

        NeighMoving::setDistCont
        """
        return _gstlearn.NeighMoving_setDistCont(self, distCont)

    def getEllipsoid(self, target, count=360):
        r"""

        NeighMoving::getEllipsoid
        """
        return _gstlearn.NeighMoving_getEllipsoid(self, target, count)

    def getSectors(self, target):
        r"""

        NeighMoving::getSectors
        Generate the end-points of the sectors. By default, the extension is set to
        radius  

        Parameters
        ----------
        * `target` :  
            Coordinates of the Target  

        Returns
        -------  

        """
        return _gstlearn.NeighMoving_getSectors(self, target)

    def getZoomLimits(self, target, percent=20):
        r"""

        NeighMoving::getZoomLimits
        """
        return _gstlearn.NeighMoving_getZoomLimits(self, target, percent)

    def __repr__(self):
        return _gstlearn.NeighMoving___repr__(self)

# Register NeighMoving in _gstlearn:
_gstlearn.NeighMoving_swigregister(NeighMoving)
class NeighBench(ANeigh):
    r"""


    Neighborhood definition by Bench.  

    The Neighborhood is usually meant to select a sub-population from the input Data
    Base, containing the active samples close to the target.  

    The selected samples belong to the same 'bench' as the target: the distance
    (according to the last space coordinate, e.g. the elevation in the 3-D case)
    between a selected sample and the target is smaller than the bench width.  

    The neighborhood also offers the possibility to suppress any sample which would
    be too close to (or coincide with) the target: this is the cross-validation
    option.  

    C++ includes: NeighBench.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NeighBench::NeighBench
        """
        _gstlearn.NeighBench_swiginit(self, _gstlearn.new_NeighBench(*args))
    __swig_destroy__ = _gstlearn.delete_NeighBench

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.NeighBench_clone(self)

    def attach(self, dbin, dbout=None):
        r"""

        NeighBench::attach
        Interface for ANeigh.  

        """
        return _gstlearn.NeighBench_attach(self, dbin, dbout)

    def getNeigh(self, iech_out, ranks):
        r"""

        NeighBench::getNeigh
        Select the neighborhood  

        Parameters
        ----------
        * `iech_out` :  
            Valid Rank of the sample in the output Db  
        * `ranks` :  
            Vector of sample ranks in neighborhood (empty when error)  

        """
        return _gstlearn.NeighBench_getNeigh(self, iech_out, ranks)

    def hasChanged(self, iech_out):
        r"""

        NeighBench::hasChanged
        """
        return _gstlearn.NeighBench_hasChanged(self, iech_out)

    def getNSampleMax(self, db):
        r"""

        NeighBench::getNSampleMax
        Given a Db, returns the maximum number of samples per NeighBenchborhood  

        Parameters
        ----------
        * `db` :  
            Pointer to the target Db  

        Returns
        -------  

        """
        return _gstlearn.NeighBench_getNSampleMax(self, db)

    def getType(self):
        r"""

        NeighBench::getType
        """
        return _gstlearn.NeighBench_getType(self)

    def toString(self, strfmt=None):
        r"""

        NeighBench::toString
        Interface for AStringable.  

        """
        return _gstlearn.NeighBench_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        NeighBench::create
        """
        return _gstlearn.NeighBench_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        NeighBench::createFromNF
        Create a Neighborhood by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.NeighBench_createFromNF(NFFilename, verbose)

    def getWidth(self):
        r"""

        NeighBench::getWidth
        """
        return _gstlearn.NeighBench_getWidth(self)

    def __repr__(self):
        return _gstlearn.NeighBench___repr__(self)

# Register NeighBench in _gstlearn:
_gstlearn.NeighBench_swigregister(NeighBench)
class NeighCell(ANeigh):
    r"""


    Neighborhood definition by Cell.  

    The Neighborhood is usually meant to select a sub-population from the input Data
    Base, containing the active samples close to the target.  

    The selected samples belong to the same 'cell' as the target. This obviously
    requires that the target belongs to a Grid.  

    The neighborhood also offers the possibility to suppress any sample which would
    be too close to (or coincide with) the target: this is the cross-validation
    option.  

    C++ includes: NeighCell.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NeighCell::NeighCell
        """
        _gstlearn.NeighCell_swiginit(self, _gstlearn.new_NeighCell(*args))
    __swig_destroy__ = _gstlearn.delete_NeighCell

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.NeighCell_clone(self)

    def attach(self, dbin, dbout=None):
        r"""

        NeighCell::attach
        Interface for ANeigh.  

        """
        return _gstlearn.NeighCell_attach(self, dbin, dbout)

    def getNeigh(self, iech_out, ranks):
        r"""

        NeighCell::getNeigh
        Select the neighborhood  

        Parameters
        ----------
        * `iech_out` :  
            Valid Rank of the sample in the output Db  
        * `ranks` :  
            Vector of sample ranks in neighborhood (empty when error)  

        """
        return _gstlearn.NeighCell_getNeigh(self, iech_out, ranks)

    def hasChanged(self, iech_out):
        r"""

        NeighCell::hasChanged
        """
        return _gstlearn.NeighCell_hasChanged(self, iech_out)

    def getNSampleMax(self, db):
        r"""

        NeighCell::getNSampleMax
        """
        return _gstlearn.NeighCell_getNSampleMax(self, db)

    def getType(self):
        r"""

        NeighCell::getType
        """
        return _gstlearn.NeighCell_getType(self)

    def toString(self, strfmt=None):
        r"""

        NeighCell::toString
        Interface for AStringable.  

        """
        return _gstlearn.NeighCell_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        NeighCell::create
        """
        return _gstlearn.NeighCell_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        NeighCell::createFromNF
        Create a Neighborhood by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose flag  

        Returns
        -------  

        """
        return _gstlearn.NeighCell_createFromNF(NFFilename, verbose)

    def getNMini(self):
        r"""

        NeighCell::getNMini
        """
        return _gstlearn.NeighCell_getNMini(self)

    def __repr__(self):
        return _gstlearn.NeighCell___repr__(self)

# Register NeighCell in _gstlearn:
_gstlearn.NeighCell_swigregister(NeighCell)
class AVario(AStringable, ICloneable):
    r"""


    C++ includes: AVario.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AVario

    @staticmethod
    def getCalculType(calcul_name):
        r"""

        AVario::getCalculType
        Convert the Calculation Name into a Calculation Type (ECalcVario)  

        Returns
        -------
        The corresponding ECalcVario enum  

        """
        return _gstlearn.AVario_getCalculType(calcul_name)

    def getCalcul(self):
        r"""

        AVario::getCalcul
        """
        return _gstlearn.AVario_getCalcul(self)

    def setCalcul(self, calcul):
        r"""

        AVario::setCalcul
        """
        return _gstlearn.AVario_setCalcul(self, calcul)

    def setCalculByName(self, calcul_name):
        r"""

        AVario::setCalculByName
        """
        return _gstlearn.AVario_setCalculByName(self, calcul_name)

    def __repr__(self):
        return _gstlearn.AVario___repr__(self)

# Register AVario in _gstlearn:
_gstlearn.AVario_swigregister(AVario)
class VarioParam(AStringable, ICloneable):
    r"""


    Class containing the definition of the criteria for calculating the Spatial (and
    Temporal) Characteristics from samples contained in a Db.  

    These criteria consist in:  

    *   some criteria based on the **dates**: this information will is used for
        calculating the Temporal Characteristics  
    *   a collection of definitions of **Calculation Directions** for Spatial
        Characteristics. For more information on a Direction definition, please
        refer to DirParam.hpp  

    Note that this class also stores a pointer to any Faults definition, if to be
    used during the calculation of the Spatial Characteristics.  

    C++ includes: VarioParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VarioParam::VarioParam
        """
        _gstlearn.VarioParam_swiginit(self, _gstlearn.new_VarioParam(*args))
    __swig_destroy__ = _gstlearn.delete_VarioParam

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.VarioParam_clone(self)

    def toString(self, strfmt=None):
        r"""

        VarioParam::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.VarioParam_toString(self, strfmt)

    @staticmethod
    def createOmniDirection(*args, **kwargs):
        r"""

        VarioParam::createOmniDirection
        Shortcuts.  

        Create one Calculation Direction corresponding to the Omni-direction calculation
        For details, see DirParam::createOmniDirection documentation  

        Parameters
        ----------
        * `nlag` :  
            Number of lags  
        * `dlag` :  
            Lag value  
        * `toldis` :  
            Tolerance on distance  
        * `opt_code` :  
            Option for usage of the code  
        * `idate` :  
            Reference date  
        * `bench` :  
            Bench value  
        * `cylrad` :  
            Value of radius of the Cylinder search  
        * `tolcode` :  
            Tolerance on the code  
        * `breaks` :  
            Definition of the irregular intervals  
        * `scale` :  
            Scaling factor  
        * `dates` :  
            Range of dates  
        * `space` :  
            Pointer to the space definition  

        Returns
        -------  

        """
        return _gstlearn.VarioParam_createOmniDirection(*args, **kwargs)

    @staticmethod
    def createMultiple(*args, **kwargs):
        r"""

        VarioParam::createMultiple
        """
        return _gstlearn.VarioParam_createMultiple(*args, **kwargs)

    @staticmethod
    def createMultipleFromGrid(*args, **kwargs):
        r"""

        VarioParam::createMultipleFromGrid
        Automatically create several calculation directions from Grid information: For
        details, see DirParam::createMultipleFromGrid documentation  

        Parameters
        ----------
        * `dbgrid` :  
            a DbGrid structure  
        * `nlag` :  
            Number of lags  
        * `scale` :  
            Scaling factor  
        * `dates` :  
            Range of dates  
        * `space` :  
            Pointer to the Space definition  
        * `ndimax` :  
            Maximum dimension (see note)  

        Returns
        -------
        A pointer to the newly created VarioParam object  

        note: This method creates as many calculation direction as space dimension  

        note: However, this number can be truncated to 'ndimax' (when defined)  

        """
        return _gstlearn.VarioParam_createMultipleFromGrid(*args, **kwargs)

    @staticmethod
    def createFromSpaceDimension(*args, **kwargs):
        r"""

        VarioParam::createFromSpaceDimension
        Automatically create a set of calculation directions for a given Space
        Direction:  

        *   one calculation direction per space direction  
        *   the same parameters are used for each direction, such as:  

            Parameters:  
            * `nlag` :  
                Number of lags  
            * `dlag` :  
                Value of the lag  
            * `toldis` :  
                Tolerance on distancecomputeFromDb  
            * `tolang` :  
                Tolerance on angle  
            * `scale` :  
                Scaling factor  
            * `dates` :  
                Range of dates  
            * `space` :  
                Pointer to the Space definition  

            Returns:  

        """
        return _gstlearn.VarioParam_createFromSpaceDimension(*args, **kwargs)

    @staticmethod
    def createSeveral2D(*args, **kwargs):
        r"""

        VarioParam::createSeveral2D
        """
        return _gstlearn.VarioParam_createSeveral2D(*args, **kwargs)

    def addDir(self, dirparam):
        r"""

        VarioParam::addDir
        """
        return _gstlearn.VarioParam_addDir(self, dirparam)

    def addMultiDirs(self, dirparams):
        r"""

        VarioParam::addMultiDirs
        """
        return _gstlearn.VarioParam_addMultiDirs(self, dirparams)

    def delDir(self, rank):
        r"""

        VarioParam::delDir
        """
        return _gstlearn.VarioParam_delDir(self, rank)

    def delAllDirs(self):
        r"""

        VarioParam::delAllDirs
        """
        return _gstlearn.VarioParam_delAllDirs(self)

    def getSpace(self):
        r"""

        VarioParam::getSpace
        """
        return _gstlearn.VarioParam_getSpace(self)

    def getScale(self):
        r"""

        VarioParam::getScale
        """
        return _gstlearn.VarioParam_getScale(self)

    def getNDate(self):
        r"""

        VarioParam::getNDate
        """
        return _gstlearn.VarioParam_getNDate(self)

    def getNDir(self):
        r"""

        VarioParam::getNDir
        """
        return _gstlearn.VarioParam_getNDir(self)

    def getDates(self):
        r"""

        VarioParam::getDates
        """
        return _gstlearn.VarioParam_getDates(self)

    def getDate(self, idate, icas):
        r"""

        VarioParam::getDate
        """
        return _gstlearn.VarioParam_getDate(self, idate, icas)

    def getNLag(self, idir):
        r"""

        VarioParam::getNLag
        """
        return _gstlearn.VarioParam_getNLag(self, idir)

    def getCodirs(self, idir=0):
        r"""

        VarioParam::getCodirs
        """
        return _gstlearn.VarioParam_getCodirs(self, idir)

    def getDirParams(self):
        r"""

        VarioParam::getDirParams
        """
        return _gstlearn.VarioParam_getDirParams(self)

    def getDirParam(self, idir):
        r"""

        VarioParam::getDirParam
        """
        return _gstlearn.VarioParam_getDirParam(self, idir)

    def getNDim(self):
        r"""

        VarioParam::getNDim
        """
        return _gstlearn.VarioParam_getNDim(self)

    def isDefinedForGrid(self):
        r"""

        VarioParam::isDefinedForGrid
        """
        return _gstlearn.VarioParam_isDefinedForGrid(self)

    def hasDate(self):
        r"""

        VarioParam::hasDate
        """
        return _gstlearn.VarioParam_hasDate(self)

    def isDateUsed(self, db1, db2=None):
        r"""

        VarioParam::isDateUsed
        Check if dates are involved in the variogram calculation  

        Returns
        -------
        1 if dates are used; 0 otherwise  

        Parameters
        ----------
        * `db1` :  
            First Db structure  
        * `db2` :  
            Second Db structure  

        """
        return _gstlearn.VarioParam_isDateUsed(self, db1, db2)

    def setScale(self, scale):
        r"""

        VarioParam::setScale
        """
        return _gstlearn.VarioParam_setScale(self, scale)

    def setDates(self, dates):
        r"""

        VarioParam::setDates
        """
        return _gstlearn.VarioParam_setDates(self, dates)

    def setDPas(self, idir, db):
        r"""

        VarioParam::setDPas
        """
        return _gstlearn.VarioParam_setDPas(self, idir, db)

    def setGrincr(self, idir, grincr):
        r"""

        VarioParam::setGrincr
        """
        return _gstlearn.VarioParam_setGrincr(self, idir, grincr)

    def toStringMain(self, strfmt=None):
        r"""

        VarioParam::toStringMain
        """
        return _gstlearn.VarioParam_toStringMain(self, strfmt)

    def getFaults(self):
        r"""

        VarioParam::getFaults
        """
        return _gstlearn.VarioParam_getFaults(self)

    def hasFaults(self):
        r"""

        VarioParam::hasFaults
        """
        return _gstlearn.VarioParam_hasFaults(self)

    def addFaults(self, faults):
        r"""

        VarioParam::addFaults
        """
        return _gstlearn.VarioParam_addFaults(self, faults)

    def __repr__(self):
        return _gstlearn.VarioParam___repr__(self)

# Register VarioParam in _gstlearn:
_gstlearn.VarioParam_swigregister(VarioParam)

def buildDbFromVarioParam(db, varioparam):
    r"""


    Establish a new Db containing the pairs of the Variogram  

    Returns
    -------
    Pointer to the newly created Db  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `varioparam` :  
        VarioParam structure  

    """
    return _gstlearn.buildDbFromVarioParam(db, varioparam)
class Vario_Order(object):
    r"""


    C++ includes: Vario.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nalloc = property(_gstlearn.Vario_Order_nalloc_get, _gstlearn.Vario_Order_nalloc_set)
    npair = property(_gstlearn.Vario_Order_npair_get, _gstlearn.Vario_Order_npair_set)
    size_aux = property(_gstlearn.Vario_Order_size_aux_get, _gstlearn.Vario_Order_size_aux_set)
    flag_dist = property(_gstlearn.Vario_Order_flag_dist_get, _gstlearn.Vario_Order_flag_dist_set)
    tab_iech = property(_gstlearn.Vario_Order_tab_iech_get, _gstlearn.Vario_Order_tab_iech_set)
    tab_jech = property(_gstlearn.Vario_Order_tab_jech_get, _gstlearn.Vario_Order_tab_jech_set)
    tab_ipas = property(_gstlearn.Vario_Order_tab_ipas_get, _gstlearn.Vario_Order_tab_ipas_set)
    tab_sort = property(_gstlearn.Vario_Order_tab_sort_get, _gstlearn.Vario_Order_tab_sort_set)
    tab_aux_iech = property(_gstlearn.Vario_Order_tab_aux_iech_get, _gstlearn.Vario_Order_tab_aux_iech_set)
    tab_aux_jech = property(_gstlearn.Vario_Order_tab_aux_jech_get, _gstlearn.Vario_Order_tab_aux_jech_set)
    tab_dist = property(_gstlearn.Vario_Order_tab_dist_get, _gstlearn.Vario_Order_tab_dist_set)

    def __init__(self):
        r"""


        C++ includes: Vario.hpp

        """
        _gstlearn.Vario_Order_swiginit(self, _gstlearn.new_Vario_Order())
    __swig_destroy__ = _gstlearn.delete_Vario_Order

# Register Vario_Order in _gstlearn:
_gstlearn.Vario_Order_swigregister(Vario_Order)
class Vario(AVario, ASerializable):
    r"""


    Class containing the Spatial Characteristics as calculated experimentally from
    the data (contained in a Db).  

    The experimental Spatial Characteristics is usually referred to as the
    experimental **variogram**. However, note that it can rather calculate other
    results such as a Covariance or a Madogram. All these quantities can be
    regrouped by considering them as **two-points** statistics. For a complete list
    of calculation methods, please refer to ECalcVario.hpp.  

    This class is composed of two parts:  

    *   the first part describes the rule when comparing two samples from the Db.
        They are defined by:
        -   the definition of the **Geometry**: e.g. definition of calculation
            direction, tolerances. For more information, please refer to
            VarioParam.hpp  
        -   the definition of the calculations **Options**: e.g. calculation method.  
        -   some additional **Conditions** used during calculations: e.g. usage of
            *Faults*. For more information, please refer to ABiTargetCheck.hpp.  
    *   the second part are the results of the calculations  

    **Results**  

    All the Spatial Characteristics are calculated:  

    *   from the sample values of active samples contained in a Db,  
    *   for all the variables (defined with the locator ELoc.Z): in the multivariate
        case, simple and cross-variograms are calculated  
    *   for a series of distance lags.  

    They are always expressed as a table with one row per distance lag and three
    columns containing:  

    *   the number of pairs  
    *   the average value of the distance  
    *   the average value of the two-points statistics  

    Note that:  

    *   the lags for which no pair is found are skipped.  
    *   some methods correspond to an **even** function (values are equal whether
        the distance between the two end-points is counted positively or negatively:
        then only one-sided results are stored. For **odd**, the results of both
        sides are stored.  
    *   for a number of lags equal to *N*, the number of rows is {N+1} when the
        function is even and {2N+1} when the function is odd.  
    *   in the multivariate case (NV variables), the number of rows is multiplied by
        NV*(NV+1)/2. In order to avoid any indexing problem, the user should use the
        assessors provided in order to access to the information relative to the
        target pair of variables.  

    C++ includes: Vario.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Vario::Vario
        """
        _gstlearn.Vario_swiginit(self, _gstlearn.new_Vario(*args))
    __swig_destroy__ = _gstlearn.delete_Vario

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.Vario_clone(self)

    def toTL(self):
        return _gstlearn.Vario_toTL(self)

    def toString(self, strfmt=None):
        r"""

        Vario::toString
        AStringable Interface.  

        """
        return _gstlearn.Vario_toString(self, strfmt)

    def _getIVAR(self, db, iech, ivar):
        r"""

        Vario::_getIVAR
        AVario Interface.  

        Calculate the data value (possibly after removing the global trend)  

        Returns
        -------
        The data value (or the residual)  

        Parameters
        ----------
        * `db` :  
            Db descriptor  
        * `iech` :  
            Rank of the sample  
        * `ivar` :  
            Rank of the variable  

        remark: The trend removal only applies on the first variable  

        remark: Therefore, if applied on any variable rank other than 0,  

        remark: TEST is returned  

        """
        return _gstlearn.Vario__getIVAR(self, db, iech, ivar)

    def _setResult(self, iech1, iech2, nvar, ilag, ivar, jvar, orient, ww, dist, value):
        r"""

        Vario::_setResult
        Internal function for setting a variogram value  

        Parameters
        ----------
        * `iech1` :  
            Rank of the first sample  
        * `iech2` :  
            Rank of the second sample  
        * `nvar` :  
            Number of variables  
        * `ilag` :  
            Rank of the variogram lag  
        * `ivar` :  
            Index of the first variable  
        * `jvar` :  
            Index of the second variable  
        * `orient` :  
            Orientation  
        * `ww` :  
            Weight  
        * `dist` :  
            Distance  
        * `value` :  
            Variogram value  

        """
        return _gstlearn.Vario__setResult(self, iech1, iech2, nvar, ilag, ivar, jvar, orient, ww, dist, value)

    @staticmethod
    def create(varioparam):
        r"""

        Vario::create
        """
        return _gstlearn.Vario_create(varioparam)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        Vario::createFromNF
        """
        return _gstlearn.Vario_createFromNF(NFFilename, verbose)

    @staticmethod
    def createRegularizeFromModel(model, varioparam, ext, ndisc, angles, asCov=False):
        r"""

        Vario::createRegularizeFromModel
        """
        return _gstlearn.Vario_createRegularizeFromModel(model, varioparam, ext, ndisc, angles, asCov)

    @staticmethod
    def createTransformZToY(varioZ, anam):
        r"""

        Vario::createTransformZToY
        """
        return _gstlearn.Vario_createTransformZToY(varioZ, anam)

    @staticmethod
    def createTransformYToZ(varioY, anam):
        r"""

        Vario::createTransformYToZ
        """
        return _gstlearn.Vario_createTransformYToZ(varioY, anam)

    @staticmethod
    def createReduce(varioIn, varcols, dircols, asSymmetric=False):
        r"""

        Vario::createReduce
        """
        return _gstlearn.Vario_createReduce(varioIn, varcols, dircols, asSymmetric)

    @staticmethod
    def computeFromDb(*args, **kwargs):
        r"""

        Vario::computeFromDb
        """
        return _gstlearn.Vario_computeFromDb(*args, **kwargs)

    def resetReduce(self, varcols, dircols, asSymmetric=False):
        r"""

        Vario::resetReduce
        Reduce the current variogram by keeping a subset of variables and/or directions  

        Parameters
        ----------
        * `varcols` :  
            Vector of variable ranks (starting from 0)  
        * `dircols` :  
            Vector of direction ranks (starting from 0)  
        * `asSymmetric` :  
            Turn the result into as Symmetrical function (i.e. variogram)  

        """
        return _gstlearn.Vario_resetReduce(self, varcols, dircols, asSymmetric)

    def getFlagAsym(self):
        r"""

        Vario::getFlagAsym
        """
        return _gstlearn.Vario_getFlagAsym(self)

    def drawOnlyPositiveX(self, ivar, jvar):
        r"""

        Vario::drawOnlyPositiveX
        """
        return _gstlearn.Vario_drawOnlyPositiveX(self, ivar, jvar)

    def drawOnlyPositiveY(self, ivar, jvar):
        r"""

        Vario::drawOnlyPositiveY
        """
        return _gstlearn.Vario_drawOnlyPositiveY(self, ivar, jvar)

    def getNVar(self):
        r"""

        Vario::getNVar
        """
        return _gstlearn.Vario_getNVar(self)

    def getMeans(self):
        r"""

        Vario::getMeans
        """
        return _gstlearn.Vario_getMeans(self)

    def getMean(self, ivar):
        r"""

        Vario::getMean
        """
        return _gstlearn.Vario_getMean(self, ivar)

    def getVar(self, ivar, jvar):
        r"""

        Vario::getVar
        """
        return _gstlearn.Vario_getVar(self, ivar, jvar)

    def getVarMatrix(self):
        r"""

        Vario::getVarMatrix
        """
        return _gstlearn.Vario_getVarMatrix(self)

    def getVarIndex(self, ijvar):
        r"""

        Vario::getVarIndex
        """
        return _gstlearn.Vario_getVarIndex(self, ijvar)

    def getVars(self):
        r"""

        Vario::getVars
        """
        return _gstlearn.Vario_getVars(self)

    def setMeans(self, means):
        r"""

        Vario::setMeans
        """
        return _gstlearn.Vario_setMeans(self, means)

    def setMean(self, mean, ivar=0):
        r"""

        Vario::setMean
        """
        return _gstlearn.Vario_setMean(self, mean, ivar)

    def setVar(self, value, ivar=0, jvar=0):
        r"""

        Vario::setVar
        """
        return _gstlearn.Vario_setVar(self, value, ivar, jvar)

    def setVars(self, vars):
        r"""

        Vario::setVars
        """
        return _gstlearn.Vario_setVars(self, vars)

    def setVarIndex(self, ijvar, value):
        r"""

        Vario::setVarIndex
        """
        return _gstlearn.Vario_setVarIndex(self, ijvar, value)

    def setDb(self, db):
        r"""

        Vario::setDb
        """
        return _gstlearn.Vario_setDb(self, db)

    def getDirSize(self, idir):
        r"""

        Vario::getDirSize
        Returns the Dimension of internal arrays after the number of variables has been
        defined  

        Parameters
        ----------
        * `idir` :  
            Target direction  

        Returns
        -------  

        """
        return _gstlearn.Vario_getDirSize(self, idir)

    def getGgByIndex(self, idir=0, i=0):
        r"""

        Vario::getGgByIndex
        """
        return _gstlearn.Vario_getGgByIndex(self, idir, i)

    def getHhByIndex(self, idir=0, i=0):
        r"""

        Vario::getHhByIndex
        """
        return _gstlearn.Vario_getHhByIndex(self, idir, i)

    def getSwByIndex(self, idir=0, i=0):
        r"""

        Vario::getSwByIndex
        """
        return _gstlearn.Vario_getSwByIndex(self, idir, i)

    def getUtilizeByIndex(self, idir=0, i=0):
        r"""

        Vario::getUtilizeByIndex
        """
        return _gstlearn.Vario_getUtilizeByIndex(self, idir, i)

    def getGg(self, idir=0, ivar=0, jvar=0, ilag=0, asCov=False, flagNormalized=False):
        r"""

        Vario::getGg
        """
        return _gstlearn.Vario_getGg(self, idir, ivar, jvar, ilag, asCov, flagNormalized)

    def getHh(self, idir=0, ivar=0, jvar=0, ilag=0):
        r"""

        Vario::getHh
        """
        return _gstlearn.Vario_getHh(self, idir, ivar, jvar, ilag)

    def getSw(self, idir=0, ivar=0, jvar=0, ilag=0):
        r"""

        Vario::getSw
        """
        return _gstlearn.Vario_getSw(self, idir, ivar, jvar, ilag)

    def getUtilize(self, idir=0, ivar=0, jvar=0, ilag=0):
        r"""

        Vario::getUtilize
        """
        return _gstlearn.Vario_getUtilize(self, idir, ivar, jvar, ilag)

    def getVec(self, idir=0, ivar=0, jvar=0):
        r"""

        Vario::getVec
        Returns a triple array of values: 0-Weight; 1-Distance; 2-Variogram  

        Parameters
        ----------
        * `idir` :  
            Target Direction  
        * `ivar` :  
            Target first variable  
        * `jvar` :  
            Target second variable  

        Returns
        -------  

        """
        return _gstlearn.Vario_getVec(self, idir, ivar, jvar)

    def getGgVec(self, idir=0, ivar=0, jvar=0, asCov=False, flagNormalized=False, compress=True):
        r"""

        Vario::getGgVec
        Returns the vector of variogram values for a given pair of variables in a given
        direction  

        Parameters
        ----------
        * `idir` :  
            Direction  
        * `ivar` :  
            First variable  
        * `jvar` :  
            Second variable  
        * `asCov` :  
            True if result should be provided as Covariance, False for Variogram  
        * `flagNorm` :  
            If the result should be provided as a Normalized covariance / Variogram  
        * `compress` :  
            When true, suppress lags where 'sw' <= 0  

        Returns
        -------
        The vector of 'gg'  

        """
        return _gstlearn.Vario_getGgVec(self, idir, ivar, jvar, asCov, flagNormalized, compress)

    def getHhVec(self, idir=0, ivar=0, jvar=0, compress=True):
        r"""

        Vario::getHhVec
        Returns the vector of distances for a given pair of variables in a given
        direction  

        Parameters
        ----------
        * `idir` :  
            Direction  
        * `ivar` :  
            First variable  
        * `jvar` :  
            Second variable  
        * `compress` :  
            When true, suppress lags where 'sw' <= 0  

        Returns
        -------
        The vector of 'hh'  

        """
        return _gstlearn.Vario_getHhVec(self, idir, ivar, jvar, compress)

    def getSwVec(self, idir=0, ivar=0, jvar=0, compress=True):
        r"""

        Vario::getSwVec
        Returns the vector of weights for a given pair of variables in a given direction  

        Parameters
        ----------
        * `idir` :  
            Direction  
        * `ivar` :  
            First variable  
        * `jvar` :  
            Second variable  
        * `compress` :  
            When true, suppress lags where 'sw' <= 0  

        Returns
        -------
        The vector of 'sw'  

        """
        return _gstlearn.Vario_getSwVec(self, idir, ivar, jvar, compress)

    def getUtilizeVec(self, idir=0, ivar=0, jvar=0, compress=True):
        r"""

        Vario::getUtilizeVec
        Returns the vector of utilization flags for a given pair of variables in a given
        direction  

        Parameters
        ----------
        * `idir` :  
            Direction  
        * `ivar` :  
            First variable  
        * `jvar` :  
            Second variable  
        * `compress` :  
            When true, suppress lags where 'sw' <= 0  

        Returns
        -------
        The vector of 'utilize'  

        """
        return _gstlearn.Vario_getUtilizeVec(self, idir, ivar, jvar, compress)

    def setSwVec(self, idir, ivar, jvar, sw):
        r"""

        Vario::setSwVec
        """
        return _gstlearn.Vario_setSwVec(self, idir, ivar, jvar, sw)

    def setHhVec(self, idir, ivar, jvar, hh):
        r"""

        Vario::setHhVec
        """
        return _gstlearn.Vario_setHhVec(self, idir, ivar, jvar, hh)

    def setGgVec(self, idir, ivar, jvar, gg):
        r"""

        Vario::setGgVec
        """
        return _gstlearn.Vario_setGgVec(self, idir, ivar, jvar, gg)

    def getGgs(self, *args, **kwargs):
        r"""

        Vario::getGgs
        """
        return _gstlearn.Vario_getGgs(self, *args, **kwargs)

    def setGgs(self, idir, ivar, jvar, ilag, values):
        r"""

        Vario::setGgs
        """
        return _gstlearn.Vario_setGgs(self, idir, ivar, jvar, ilag, values)

    def getAllGg(self, idir=0):
        r"""

        Vario::getAllGg
        """
        return _gstlearn.Vario_getAllGg(self, idir)

    def getAllHh(self, idir=0):
        r"""

        Vario::getAllHh
        """
        return _gstlearn.Vario_getAllHh(self, idir)

    def getAllSw(self, idir=0):
        r"""

        Vario::getAllSw
        """
        return _gstlearn.Vario_getAllSw(self, idir)

    def getAllUtilize(self, idir=0):
        r"""

        Vario::getAllUtilize
        """
        return _gstlearn.Vario_getAllUtilize(self, idir)

    def setGgByIndex(self, idir, i, gg, flagCheck=True):
        r"""

        Vario::setGgByIndex
        """
        return _gstlearn.Vario_setGgByIndex(self, idir, i, gg, flagCheck)

    def setHhByIndex(self, idir, i, hh, flagCheck=True):
        r"""

        Vario::setHhByIndex
        """
        return _gstlearn.Vario_setHhByIndex(self, idir, i, hh, flagCheck)

    def setSwByIndex(self, idir, i, sw, flagCheck=True):
        r"""

        Vario::setSwByIndex
        """
        return _gstlearn.Vario_setSwByIndex(self, idir, i, sw, flagCheck)

    def setUtilizeByIndex(self, idir, i, utilize, flagCheck=True):
        r"""

        Vario::setUtilizeByIndex
        """
        return _gstlearn.Vario_setUtilizeByIndex(self, idir, i, utilize, flagCheck)

    def setSw(self, idir, ivar, jvar, ilag, sw, flagCheck=True):
        r"""

        Vario::setSw
        """
        return _gstlearn.Vario_setSw(self, idir, ivar, jvar, ilag, sw, flagCheck)

    def setHh(self, idir, ivar, jvar, ilag, hh, flagCheck=True):
        r"""

        Vario::setHh
        """
        return _gstlearn.Vario_setHh(self, idir, ivar, jvar, ilag, hh, flagCheck)

    def setGg(self, idir, ivar, jvar, ilag, gg, flagCheck=True):
        r"""

        Vario::setGg
        """
        return _gstlearn.Vario_setGg(self, idir, ivar, jvar, ilag, gg, flagCheck)

    def setUtilize(self, idir, ivar, jvar, ilag, utilize, flagCheck=True):
        r"""

        Vario::setUtilize
        """
        return _gstlearn.Vario_setUtilize(self, idir, ivar, jvar, ilag, utilize, flagCheck)

    def updateSwByIndex(self, idir, i, sw, flagCheck=True):
        r"""

        Vario::updateSwByIndex
        """
        return _gstlearn.Vario_updateSwByIndex(self, idir, i, sw, flagCheck)

    def updateHhByIndex(self, idir, i, hh, flagCheck=True):
        r"""

        Vario::updateHhByIndex
        """
        return _gstlearn.Vario_updateHhByIndex(self, idir, i, hh, flagCheck)

    def updateGgByIndex(self, idir, i, gg, flagCheck=True):
        r"""

        Vario::updateGgByIndex
        """
        return _gstlearn.Vario_updateGgByIndex(self, idir, i, gg, flagCheck)

    def getCenter(self, ivar=0, jvar=0, idir=0):
        r"""

        Vario::getCenter
        """
        return _gstlearn.Vario_getCenter(self, ivar, jvar, idir)

    def getNext(self, ivar=0, jvar=0, idir=0, shift=1):
        r"""

        Vario::getNext
        """
        return _gstlearn.Vario_getNext(self, ivar, jvar, idir, shift)

    def internalVariableResize(self):
        r"""

        Vario::internalVariableResize
        """
        return _gstlearn.Vario_internalVariableResize(self)

    def internalDirectionResize(self, ndir=0, flagDirs=True):
        r"""

        Vario::internalDirectionResize
        """
        return _gstlearn.Vario_internalDirectionResize(self, ndir, flagDirs)

    def getHmax(self, ivar=-1, jvar=-1, idir=-1):
        r"""

        Vario::getHmax
        """
        return _gstlearn.Vario_getHmax(self, ivar, jvar, idir)

    def getHRange(self, ivar=-1, jvar=-1, idir=-1):
        r"""

        Vario::getHRange
        Returns a vector with Minimum-Maximum of the Hh array  

        Parameters
        ----------
        * `ivar` :  
            Target variable (or -1)  
        * `jvar` :  
            Target variable (or -1)  
        * `idir` :  
            Target Direction (or -1)  

        Returns
        -------  

        """
        return _gstlearn.Vario_getHRange(self, ivar, jvar, idir)

    def getGmax(self, ivar=-1, jvar=-1, idir=-1, flagAbs=False, flagSill=False):
        r"""

        Vario::getGmax
        """
        return _gstlearn.Vario_getGmax(self, ivar, jvar, idir, flagAbs, flagSill)

    def getGRange(self, ivar=-1, jvar=-1, idir=-1, flagSill=False):
        r"""

        Vario::getGRange
        """
        return _gstlearn.Vario_getGRange(self, ivar, jvar, idir, flagSill)

    def patchCenter(self, idir, nech, rho):
        r"""

        Vario::patchCenter
        """
        return _gstlearn.Vario_patchCenter(self, idir, nech, rho)

    def fill(self, idir, sw, gg, hh):
        r"""

        Vario::fill
        """
        return _gstlearn.Vario_fill(self, idir, sw, gg, hh)

    def getDirAddress(self, idir, ivar, jvar, ilag, flag_abs=False, sens=0, flagCheck=True):
        r"""

        Vario::getDirAddress
        """
        return _gstlearn.Vario_getDirAddress(self, idir, ivar, jvar, ilag, flag_abs, sens, flagCheck)

    def getVarAddress(self, ivar, jvar):
        r"""

        Vario::getVarAddress
        """
        return _gstlearn.Vario_getVarAddress(self, ivar, jvar)

    def getNLagTotal(self, idir):
        r"""

        Vario::getNLagTotal
        """
        return _gstlearn.Vario_getNLagTotal(self, idir)

    def compute(self, *args, **kwargs):
        r"""

        Vario::compute
        """
        return _gstlearn.Vario_compute(self, *args, **kwargs)

    def computeIndic(self, *args, **kwargs):
        r"""

        Vario::computeIndic
        """
        return _gstlearn.Vario_computeIndic(self, *args, **kwargs)

    def computeGeometry(self, db, vorder, npair):
        r"""

        Vario::computeGeometry
        Calculate the geometry for a given direction  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db description  
        * `vorder` :  
            Vario_Order structure  
        * `npair` :  
            Number of pairs  

        """
        return _gstlearn.Vario_computeGeometry(self, db, vorder, npair)

    def computeVarioVect(self, db, ncomp):
        r"""

        Vario::computeVarioVect
        Evaluate the experimental covariance for directional variables  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db descriptor  
        * `ncomp` :  
            Number of components  

        """
        return _gstlearn.Vario_computeVarioVect(self, db, ncomp)

    def computeGeometryMLayers(self, db, seltab, vorder):
        r"""

        Vario::computeGeometryMLayers
        Determine the samples used for a variogram in multilayers framework  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db description  
        * `seltab` :  
            Number of sample definition (0, 1 or 2)  
        * `vorder` :  
            Vario_Order structure  

        """
        return _gstlearn.Vario_computeGeometryMLayers(self, db, seltab, vorder)

    def regularizeFromModel(self, *args, **kwargs):
        r"""

        Vario::regularizeFromModel
        Calculate the regularized model as an experimental variogram  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `model` :  
            Model structure  
        * `ext` :  
            Vector of Block extension  
        * `ndisc` :  
            Vector of discretization counts  
        * `angles` :  
            Vector of rotation angles (optional)  
        * `mode` :  
            CovCalcMode structure  
        * `asCov` :  
            When true; produces a covariance  

        """
        return _gstlearn.Vario_regularizeFromModel(self, *args, **kwargs)

    def regularizeFromDbGrid(self, model, db, mode=None):
        r"""

        Vario::regularizeFromDbGrid
        Calculate the regularized model as an experimental variogram  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `model` :  
            Model structure  
        * `db` :  
            Db discretization structure  
        * `mode` :  
            CovCalcMode structure  

        """
        return _gstlearn.Vario_regularizeFromDbGrid(self, model, db, mode)

    def getExtension(self, ivar, jvar, idir0, flag_norm, flag_vars, distmin, distmax, varmin, varmax, flag_hneg, flag_gneg, c0, hmin, hmax, gmin, gmax):
        r"""

        Vario::getExtension
        Calculate the variogram extension for a pair of variables  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `idir0` :  
            Rank of the direction (-1 for all)  
        * `flag_norm` :  
            1 if the variogram must be normalized by variance  
        * `flag_vars` :  
            1 if the global statistics must be taken into account  
        * `distmin` :  
            Minimum along the distance axis  
        * `distmax` :  
            Maximum along the distance axis  
        * `varmin` :  
            Minimum along the variogram (or covariance) axis  
        * `varmax` :  
            Maximum along the variogram (or covariance) axis  
        * `flag_hneg` :  
            1 if the distance scale can be negative  
        * `flag_gneg` :  
            1 if the variogram scale can be negative  
        * `c0` :  
            Value of the variogram at the origin  
        * `hmin` :  
            Minimum distance  
        * `hmax` :  
            Maximum distance  
        * `gmin` :  
            Minimum variogram value  
        * `gmax` :  
            Maximum variogram value  

        """
        return _gstlearn.Vario_getExtension(self, ivar, jvar, idir0, flag_norm, flag_vars, distmin, distmax, varmin, varmax, flag_hneg, flag_gneg, c0, hmin, hmax, gmin, gmax)

    def sampleModel(self, model, mode=None):
        r"""

        Vario::sampleModel
        Calculates variogram values by sampling a model  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `model` :  
            Model structure  
        * `mode` :  
            CovCalcMode structure  

        """
        return _gstlearn.Vario_sampleModel(self, model, mode)

    def getDirParam(self, idir):
        r"""

        Vario::getDirParam
        """
        return _gstlearn.Vario_getDirParam(self, idir)

    def getNDir(self):
        r"""

        Vario::getNDir
        """
        return _gstlearn.Vario_getNDir(self)

    def hasDate(self):
        r"""

        Vario::hasDate
        """
        return _gstlearn.Vario_hasDate(self)

    def getDates(self, *args):
        r"""

        Vario::getDates
        """
        return _gstlearn.Vario_getDates(self, *args)

    def getNDate(self):
        r"""

        Vario::getNDate
        """
        return _gstlearn.Vario_getNDate(self)

    def getScale(self):
        r"""

        Vario::getScale
        """
        return _gstlearn.Vario_getScale(self)

    def getSpace(self):
        r"""

        Vario::getSpace
        """
        return _gstlearn.Vario_getSpace(self)

    def setScale(self, scale):
        r"""

        Vario::setScale
        """
        return _gstlearn.Vario_setScale(self, scale)

    def addDirs(self, dirparam):
        r"""

        Vario::addDirs
        """
        return _gstlearn.Vario_addDirs(self, dirparam)

    def getNLag(self, idir):
        r"""

        Vario::getNLag
        """
        return _gstlearn.Vario_getNLag(self, idir)

    def getDPas(self, idir):
        r"""

        Vario::getDPas
        """
        return _gstlearn.Vario_getDPas(self, idir)

    def getNDim(self, *args):
        r"""

        Vario::getNDim
        """
        return _gstlearn.Vario_getNDim(self, *args)

    def getCodirs(self, idir):
        r"""

        Vario::getCodirs
        """
        return _gstlearn.Vario_getCodirs(self, idir)

    def getCodir(self, idir, idim):
        r"""

        Vario::getCodir
        """
        return _gstlearn.Vario_getCodir(self, idir, idim)

    def getMaximumDistance(self, *args):
        r"""

        Vario::getMaximumDistance
        """
        return _gstlearn.Vario_getMaximumDistance(self, *args)

    def getIdate(self, idir):
        r"""

        Vario::getIdate
        """
        return _gstlearn.Vario_getIdate(self, idir)

    def getGrincrs(self, idir):
        r"""

        Vario::getGrincrs
        """
        return _gstlearn.Vario_getGrincrs(self, idir)

    def getGrincr(self, idir, idim):
        r"""

        Vario::getGrincr
        """
        return _gstlearn.Vario_getGrincr(self, idir, idim)

    def isDefinedForGrid(self):
        r"""

        Vario::isDefinedForGrid
        """
        return _gstlearn.Vario_isDefinedForGrid(self)

    def setNVar(self, nvar):
        r"""

        Vario::setNVar
        """
        return _gstlearn.Vario_setNVar(self, nvar)

    def setCalculByName(self, calcul_name):
        r"""

        Vario::setCalculByName
        """
        return _gstlearn.Vario_setCalculByName(self, calcul_name)

    def setVariableNames(self, variableNames):
        r"""

        Vario::setVariableNames
        """
        return _gstlearn.Vario_setVariableNames(self, variableNames)

    def setVariableName(self, ivar, variableName):
        r"""

        Vario::setVariableName
        """
        return _gstlearn.Vario_setVariableName(self, ivar, variableName)

    def prepare(self, *args, **kwargs):
        r"""

        Vario::prepare
        """
        return _gstlearn.Vario_prepare(self, *args, **kwargs)

    def getVarioParam(self):
        r"""

        Vario::getVarioParam
        """
        return _gstlearn.Vario_getVarioParam(self)

    def getNBiPtsPerDir(self):
        r"""

        Vario::getNBiPtsPerDir
        """
        return _gstlearn.Vario_getNBiPtsPerDir(self)

    def getBipts(self, idir, rank):
        r"""

        Vario::getBipts
        """
        return _gstlearn.Vario_getBipts(self, idir, rank)

    def keepPair(self, idir, T1, T2, dist):
        r"""

        Vario::keepPair
        """
        return _gstlearn.Vario_keepPair(self, idir, T1, T2, dist)

    def getRankFromDirAndDate(self, idir, idate):
        r"""

        Vario::getRankFromDirAndDate
        Ask for the rank of the 'vardir' structure, given direction and date  

        Returns
        -------
        Absolute rank (or -1 for error)  

        Parameters
        ----------
        * `idir` :  
            Rank for the direction (starting from 0)  
        * `idate` :  
            Rank for the Date (starting from 0)  

        remark: An error occurs if 'idir' is negative or larger than 'ndir'  

        remark: or if 'idate' is negative or larger than 'ndate'  

        """
        return _gstlearn.Vario_getRankFromDirAndDate(self, idir, idate)

    def getVariableNames(self):
        r"""

        Vario::getVariableNames
        """
        return _gstlearn.Vario_getVariableNames(self)

    def getVariableName(self, ivar):
        r"""

        Vario::getVariableName
        """
        return _gstlearn.Vario_getVariableName(self, ivar)

    def transformCut(self, nh, ycut):
        r"""

        Vario::transformCut
        Update the experimental variogram of the completed variable starting from the
        experimental variogram of the truncated variable This only functions in the
        monovariate case  

        Parameters
        ----------
        * `nh` :  
            Number of Hermite polynomials  
        * `ycut` :  
            Truncation (lowest) value  

        Returns
        -------
        Error return code  

        """
        return _gstlearn.Vario_transformCut(self, nh, ycut)

    def transformZToY(self, anam):
        r"""

        Vario::transformZToY
        Transform the experimental variogram from raw to gaussian space  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `anam` :  
            Point Hermite anamorphosis  

        """
        return _gstlearn.Vario_transformZToY(self, anam)

    def transformYToZ(self, anam):
        r"""

        Vario::transformYToZ
        Calculate the experimental variogram of the Raw starting from the Model of the
        Gaussian variable  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `anam` :  
            Point anamorphosis  

        """
        return _gstlearn.Vario_transformYToZ(self, anam)

    def isLagCorrect(self, idir, k):
        r"""

        Vario::isLagCorrect
        """
        return _gstlearn.Vario_isLagCorrect(self, idir, k)

    def getC00(self, idir, ivar, jvar):
        r"""

        Vario::getC00
        """
        return _gstlearn.Vario_getC00(self, idir, ivar, jvar)

    def computeWeightPerDirection(self):
        r"""

        Vario::computeWeightPerDirection
        """
        return _gstlearn.Vario_computeWeightPerDirection(self)

    def getTotalLagsPerDirection(self):
        r"""

        Vario::getTotalLagsPerDirection
        """
        return _gstlearn.Vario_getTotalLagsPerDirection(self)

    def computeWeightsFromVario(self, wmode):
        r"""

        Vario::computeWeightsFromVario
        """
        return _gstlearn.Vario_computeWeightsFromVario(self, wmode)

    def __repr__(self):
        return _gstlearn.Vario___repr__(self)

# Register Vario in _gstlearn:
_gstlearn.Vario_swigregister(Vario)

def vario_order_manage(mode, flag_dist, size_aux, vorder):
    r"""


    Manage the Variogram Order structure  

    Returns
    -------
    Pointer to the Vario_Order structure  

    Parameters
    ----------
    * `mode` :  
        Usage:  

        *   1 : to initialize  
        *   0 : to clean the geometry  
        *   -1 : to delete  
    * `flag_dist` :  
        1 if distances are stored; 0 otherwise  
    * `size_aux` :  
        Size (in bytes) of the auxiliary array  
    * `vorder` :  
        Vario_Order structure  

    """
    return _gstlearn.vario_order_manage(mode, flag_dist, size_aux, vorder)

def vario_order_final(vorder, npair):
    r"""


    Resize the array and sort it  

    Returns
    -------
    Pointer to the Vario_Order structure  

    Parameters
    ----------
    * `vorder` :  
        Vario_Order structure  
    * `npair` :  
        Final number of pairs  

    """
    return _gstlearn.vario_order_final(vorder, npair)

def vario_order_print(vorder, idir_target, ipas_target, verbose):
    r"""


    Print the Vario_Order structure  

    Parameters
    ----------
    * `vorder` :  
        Vario_Order structure  
    * `idir_target` :  
        Rank of the target direction (starting from 0) or -1  
    * `ipas_target` :  
        Rank of the target lag (starting from 0) or -1  
    * `verbose` :  
        1 for a complete printout  

    """
    return _gstlearn.vario_order_print(vorder, idir_target, ipas_target, verbose)

def vario_order_get_bounds(vorder, idir, ilag, ifirst, ilast):
    r"""


    Returns the first and last indices matching a target lag  

    Parameters
    ----------
    * `vorder` :  
        Vario_Order structure  
    * `idir` :  
        Rank of the target direction  
    * `ilag` :  
        Rank of the target lag  
    * `ifirst` :  
        Rank of the first sample of the lag (included)  
    * `ilast` :  
        Rank of the last sample of the lag (excluded)  

    """
    return _gstlearn.vario_order_get_bounds(vorder, idir, ilag, ifirst, ilast)

def vario_order_get_indices(vorder, ipair, iech, jech, dist):
    r"""


    Returns the two samples for a given (ordered) pair  

    Parameters
    ----------
    * `vorder` :  
        Vario_Order structure  
    * `ipair` :  
        Rank of the sorted pair  
    * `iech` :  
        Rank of the first sample  
    * `jech` :  
        Rank of the second sample  
    * `dist` :  
        Calculated distance or TEST (if flag_dist == 0)  

    """
    return _gstlearn.vario_order_get_indices(vorder, ipair, iech, jech, dist)

def vario_order_get_auxiliary(vorder, ipair, aux_iech, aux_jech):
    r"""


    Returns the two auxiliary arrays for a given (ordered) pair  

    Parameters
    ----------
    * `vorder` :  
        Vario_Order structure  
    * `ipair` :  
        Rank of the sorted pair  
    * `aux_iech` :  
        Array to auxiliary information for sample 'iech'  
    * `aux_jech` :  
        Array to auxiliary information for sample 'jech'  

    """
    return _gstlearn.vario_order_get_auxiliary(vorder, ipair, aux_iech, aux_jech)

def vario_order_add(vorder, iech, jech, aux_iech, aux_jech, ilag, idir, dist):
    r"""


    Add a record to the Variogram Order structure  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `vorder` :  
        Vario_Order structure  
    * `iech` :  
        Rank of the first sample  
    * `jech` :  
        Rank of the second sample  
    * `aux_iech` :  
        Auxiliary array for sample 'iech' (or NULL)  
    * `aux_jech` :  
        Auxiliary array for sample 'jech' (or NULL)  
    * `ilag` :  
        Rank of the lag  
    * `idir` :  
        Rank of the direction (or 0)  
    * `dist` :  
        Calculated distance (only stored if flag_dist == 1)  

    """
    return _gstlearn.vario_order_add(vorder, iech, jech, aux_iech, aux_jech, ilag, idir, dist)
class DirParam(ASpaceObject):
    r"""


    Class containing the definition of a **Direction** used for the calculation of
    the experimental Spatial Characteristics as calculated experimentally from the
    data (contained in a Db). This class corresponds to one item of the list of
    criteria stored in VarioParam and use for the calculation of Vario.  

    The **Direction** consists in a series of rules (some are optional) for
    comparing two active samples of the Db:  

    *   their distance must be assigned to a lag: i.e. the distance must correspond
        to a multiple of the lag (**lag**), up to a tolerance (**tolerance**)
        expressed as a percentage of the lag. The rank of this multiple must be
        smaller than the number of lags (**nlag**).  
    *   the lag definition can be replaced by a series of intervals (**breaks**):
        the pair is selected if the distance belongs to one of these intervals.  
    *   the orientation of the segment joining the two points must be assigned to
        the current direction characterized by its angle (expressed by its direction
        coefficients **codir**), up to a tolerance on angle (**tolangle**) given in
        degrees.  
    *   the distance between the two points (measured along the axis perpendicular
        to the direction) must be smaller than a maximum cylinder distance
        (**cylrad**).  
    *   the distance between the two points (measured along the highest space
        dimension) must be smaller than a bench height (**bench**)  
    *   the difference between the code values (locator ELoc::CODE) defined at both
        samples must be either smaller or larger than the tolerance on the code
        (**tolcode**).  
    *   the two saples must share the same data (ELoc::DATE)  

    In the case, the Db correspond to a grid, the lag is defined as an increment on
    the grid meshes (**grincr**)  

    C++ includes: DirParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DirParam::DirParam
        """
        _gstlearn.DirParam_swiginit(self, _gstlearn.new_DirParam(*args))
    __swig_destroy__ = _gstlearn.delete_DirParam

    @staticmethod
    def create(*args, **kwargs):
        r"""

        DirParam::create
        """
        return _gstlearn.DirParam_create(*args, **kwargs)

    @staticmethod
    def createOmniDirection(*args, **kwargs):
        r"""

        DirParam::createOmniDirection
        """
        return _gstlearn.DirParam_createOmniDirection(*args, **kwargs)

    @staticmethod
    def createFromGrid(*args, **kwargs):
        r"""

        DirParam::createFromGrid
        """
        return _gstlearn.DirParam_createFromGrid(*args, **kwargs)

    @staticmethod
    def createMultiple(*args, **kwargs):
        r"""

        DirParam::createMultiple
        """
        return _gstlearn.DirParam_createMultiple(*args, **kwargs)

    @staticmethod
    def createSeveral2D(*args, **kwargs):
        r"""

        DirParam::createSeveral2D
        """
        return _gstlearn.DirParam_createSeveral2D(*args, **kwargs)

    @staticmethod
    def createMultipleInSpace(*args, **kwargs):
        r"""

        DirParam::createMultipleInSpace
        Create a set of calculation directions based on the Space definition  

        *   one direction per space axis  
        *   the other parameters are applied to each direction, such as:  

            Parameters:  
            * `nlag` :  
                Number of lags  
            * `dlag` :  
                Dimension for the lag  
            * `space` :  
                Pointer to the Space definition  

            Returns:  

            remark: : the angular tolerance is set equal to 0  

        """
        return _gstlearn.DirParam_createMultipleInSpace(*args, **kwargs)

    def toString(self, strfmt=None):
        r"""

        DirParam::toString
        AStringable Interface.  

        """
        return _gstlearn.DirParam_toString(self, strfmt)

    def isConsistent(self, space):
        r"""

        DirParam::isConsistent
        ASpaceObject Interface.  

        """
        return _gstlearn.DirParam_isConsistent(self, space)

    def getBench(self):
        r"""

        DirParam::getBench
        """
        return _gstlearn.DirParam_getBench(self)

    def getBreaks(self):
        r"""

        DirParam::getBreaks
        """
        return _gstlearn.DirParam_getBreaks(self)

    def getBreak(self, i):
        r"""

        DirParam::getBreak
        """
        return _gstlearn.DirParam_getBreak(self, i)

    def getCodirs(self):
        r"""

        DirParam::getCodirs
        """
        return _gstlearn.DirParam_getCodirs(self)

    def getCodir(self, i):
        r"""

        DirParam::getCodir
        """
        return _gstlearn.DirParam_getCodir(self, i)

    def getCylRad(self):
        r"""

        DirParam::getCylRad
        """
        return _gstlearn.DirParam_getCylRad(self)

    def getDPas(self):
        r"""

        DirParam::getDPas
        """
        return _gstlearn.DirParam_getDPas(self)

    def getLag(self):
        r"""

        DirParam::getLag
        """
        return _gstlearn.DirParam_getLag(self)

    def getIdate(self):
        r"""

        DirParam::getIdate
        """
        return _gstlearn.DirParam_getIdate(self)

    def getNLag(self):
        r"""

        DirParam::getNLag
        """
        return _gstlearn.DirParam_getNLag(self)

    def getOptionCode(self):
        r"""

        DirParam::getOptionCode
        """
        return _gstlearn.DirParam_getOptionCode(self)

    def getTolAngle(self):
        r"""

        DirParam::getTolAngle
        """
        return _gstlearn.DirParam_getTolAngle(self)

    def getTolCode(self):
        r"""

        DirParam::getTolCode
        """
        return _gstlearn.DirParam_getTolCode(self)

    def getTolDist(self):
        r"""

        DirParam::getTolDist
        """
        return _gstlearn.DirParam_getTolDist(self)

    def getGrincrs(self):
        r"""

        DirParam::getGrincrs
        """
        return _gstlearn.DirParam_getGrincrs(self)

    def getGrincr(self, i):
        r"""

        DirParam::getGrincr
        """
        return _gstlearn.DirParam_getGrincr(self, i)

    def getMaximumDistance(self):
        r"""

        DirParam::getMaximumDistance
        """
        return _gstlearn.DirParam_getMaximumDistance(self)

    def getNBreak(self):
        r"""

        DirParam::getNBreak
        """
        return _gstlearn.DirParam_getNBreak(self)

    def getFlagRegular(self):
        r"""

        DirParam::getFlagRegular
        """
        return _gstlearn.DirParam_getFlagRegular(self)

    def setNLag(self, nlag):
        r"""

        DirParam::setNLag
        """
        return _gstlearn.DirParam_setNLag(self, nlag)

    def setOptionCode(self, option_code):
        r"""

        DirParam::setOptionCode
        """
        return _gstlearn.DirParam_setOptionCode(self, option_code)

    def setIdate(self, idate):
        r"""

        DirParam::setIdate
        """
        return _gstlearn.DirParam_setIdate(self, idate)

    def setDLag(self, dlag):
        r"""

        DirParam::setDLag
        """
        return _gstlearn.DirParam_setDLag(self, dlag)

    def setDPas(self, *args):
        r"""

        DirParam::setDPas
        Set the value of the lag as computed from the Db (Grid organized)  

        Parameters
        ----------
        * `db` :  
            Db structure  

        """
        return _gstlearn.DirParam_setDPas(self, *args)

    def setBench(self, bench):
        r"""

        DirParam::setBench
        """
        return _gstlearn.DirParam_setBench(self, bench)

    def setCylRad(self, cylrad):
        r"""

        DirParam::setCylRad
        """
        return _gstlearn.DirParam_setCylRad(self, cylrad)

    def setTolDist(self, toldist):
        r"""

        DirParam::setTolDist
        """
        return _gstlearn.DirParam_setTolDist(self, toldist)

    def setTolAngle(self, tolang):
        r"""

        DirParam::setTolAngle
        """
        return _gstlearn.DirParam_setTolAngle(self, tolang)

    def setTolCode(self, tolcode):
        r"""

        DirParam::setTolCode
        """
        return _gstlearn.DirParam_setTolCode(self, tolcode)

    def setBreaks(self, breaks):
        r"""

        DirParam::setBreaks
        """
        return _gstlearn.DirParam_setBreaks(self, breaks)

    def setCodir(self, codir):
        r"""

        DirParam::setCodir
        """
        return _gstlearn.DirParam_setCodir(self, codir)

    def setGrincr(self, grincr):
        r"""

        DirParam::setGrincr
        """
        return _gstlearn.DirParam_setGrincr(self, grincr)

    def isLagValid(self, ilag, flagAsym=False, flagCheck=True):
        r"""

        DirParam::isLagValid
        """
        return _gstlearn.DirParam_isLagValid(self, ilag, flagAsym, flagCheck)

    def isDimensionValid(self, idim):
        r"""

        DirParam::isDimensionValid
        """
        return _gstlearn.DirParam_isDimensionValid(self, idim)

    def isDefinedForGrid(self):
        r"""

        DirParam::isDefinedForGrid
        """
        return _gstlearn.DirParam_isDefinedForGrid(self)

    def getLagRank(self, dist):
        r"""

        DirParam::getLagRank
        Return the rank of the lag  

        Returns
        -------
        Rank of the lag or ITEST  

        Parameters
        ----------
        * `dist` :  
            Distance  

        """
        return _gstlearn.DirParam_getLagRank(self, dist)

    def __repr__(self):
        return _gstlearn.DirParam___repr__(self)

# Register DirParam in _gstlearn:
_gstlearn.DirParam_swigregister(DirParam)
class VMap(AVario):
    r"""


    Class containing the Variogram Map which uses an DbGrid provided by the user
    This function simply calculate and add the results as new field in this DbGrid.  

    C++ includes: VMap.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VMap::VMap
        """
        _gstlearn.VMap_swiginit(self, _gstlearn.new_VMap(*args))
    __swig_destroy__ = _gstlearn.delete_VMap

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.VMap_clone(self)

    def toTL(self):
        return _gstlearn.VMap_toTL(self)

    def toString(self, strfmt=None):
        r"""

        VMap::toString
        AStringable Interface.  

        """
        return _gstlearn.VMap_toString(self, strfmt)

    def _getIVAR(self, db, iech, ivar):
        r"""

        VMap::_getIVAR
        AVario Interface.  

        """
        return _gstlearn.VMap__getIVAR(self, db, iech, ivar)

    def _setResult(self, iech1, iech2, nvar, ilag, ivar, jvar, orient, ww, dist, value):
        r"""

        VMap::_setResult
        Internal function for setting a VMAP value  

        Parameters
        ----------
        * `iech1` :  
            Rank of the first sample  
        * `iech2` :  
            Rank of the second sample  
        * `nvar` :  
            Number of variables  
        * `ilag` :  
            Rank of the variogram lag  
        * `ivar` :  
            Index of the first variable  
        * `jvar` :  
            Index of the second variable  
        * `orient` :  
            Orientation  
        * `ww` :  
            Weight  
        * `dist` :  
            Distance  
        * `value` :  
            Variogram value  

        """
        return _gstlearn.VMap__setResult(self, iech1, iech2, nvar, ilag, ivar, jvar, orient, ww, dist, value)

    def compute(self, *args, **kwargs):
        r"""

        VMap::compute
        Calculate the variogram map  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db containing the data  
        * `calcul_type` :  
            Type of calculation (ECalcVario)  
        * `radius` :  
            Dilation radius (smooth resulting maps) only on points  
        * `flag_FFT` :  
            Use FFT method (only valid on grid)  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.VMap_compute(self, *args, **kwargs)

    def __repr__(self):
        return _gstlearn.VMap___repr__(self)

# Register VMap in _gstlearn:
_gstlearn.VMap_swigregister(VMap)

def db_vmap(*args, **kwargs):
    r"""


    Calculate the variogram map (integrated function)  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db containing the data  
    * `calcul_type` :  
        Type of calculation (ECalcVario)  
    * `nxx` :  
        Vector of (Half-) number of nodes for Vmap (def:20)  
    * `dxx` :  
        Vector of mesh for Vmap (see details)  
    * `radius` :  
        Dilation radius (mooth resulting maps) only on points  
    * `flag_FFT` :  
        Use FFT method (only valid on grid)  
    * `namconv` :  
        Naming convention  

    remark: For calculating the default values:  

    remark: - for nx: it is set to 20 in all directions  

    remark: - for dx:  

    remark: . If 'Db' is a grid, the mesh of the grid is used  

    remark: - Otherwise, the mesh is set to the field extension / nx  

    """
    return _gstlearn.db_vmap(*args, **kwargs)
class VCloud(AVario):
    r"""


    Class containing the Variogram Cloud which uses an DbGrid provided by the user
    This function simply calculate and add the results as new field in this DbGrid.  

    C++ includes: VCloud.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        VCloud::VCloud
        """
        _gstlearn.VCloud_swiginit(self, _gstlearn.new_VCloud(*args))
    __swig_destroy__ = _gstlearn.delete_VCloud

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.VCloud_clone(self)

    def toTL(self):
        return _gstlearn.VCloud_toTL(self)

    def toString(self, strfmt=None):
        r"""

        VCloud::toString
        AStringable Interface.  

        """
        return _gstlearn.VCloud_toString(self, strfmt)

    def _getIVAR(self, db, iech, ivar):
        r"""

        VCloud::_getIVAR
        AVCloud Interface.  

        """
        return _gstlearn.VCloud__getIVAR(self, db, iech, ivar)

    def _setResult(self, iech1, iech2, nvar, ilag, ivar, jvar, orient, ww, dist, value):
        r"""

        VCloud::_setResult
        Internal function for setting a VCloud value  

        Parameters
        ----------
        * `iech1` :  
            Rank of the first sample  
        * `iech2` :  
            Rank of the second sample  
        * `nvar` :  
            Number of variables  
        * `ilag` :  
            Rank of the variogram lag  
        * `ivar` :  
            Index of the first variable  
        * `jvar` :  
            Index of the second variable  
        * `orient` :  
            Orientation  
        * `ww` :  
            Weight  
        * `dist` :  
            Distance  
        * `value` :  
            Variogram value  

        """
        return _gstlearn.VCloud__setResult(self, iech1, iech2, nvar, ilag, ivar, jvar, orient, ww, dist, value)

    def compute(self, *args, **kwargs):
        r"""

        VCloud::compute
        Evaluate the experimental variogram cloud on irregular data This method creates
        one variable per direction of 'dirparam'  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db descriptor  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.VCloud_compute(self, *args, **kwargs)

    def selectFromPolygon(self, db, polygon, idir=0):
        r"""

        VCloud::selectFromPolygon
        Check the samples which are involved in the pairs which are located within the
        polygon  

        Parameters
        ----------
        * `db` :  
            Db descriptor  
        * `polygon` :  
            Polygons structure  
        * `idir` :  
            Rank of the direction of itnerest  

        """
        return _gstlearn.VCloud_selectFromPolygon(self, db, polygon, idir)

    def __repr__(self):
        return _gstlearn.VCloud___repr__(self)

# Register VCloud in _gstlearn:
_gstlearn.VCloud_swigregister(VCloud)

def db_vcloud(*args, **kwargs):
    r"""


    Evaluate the experimental variogram cloud  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db descriptor  
    * `varioparam` :  
        VarioParam structure  
    * `lagmax` :  
        Maximum distance  
    * `varmax` :  
        Maximum Variance value (see remarks)  
    * `lagnb` :  
        Number of discretization steps along distance axis  
    * `varnb` :  
        Number of discretization steps along variance axis  
    * `namconv` :  
        Naming convention  

    remark: If 'lagmax' is not provided, it is set to the diagonal of the area
        covered by the active samples within 'db'.  

    remark: If 'varmax' is not defined, it is set to 3 times the experimental
        variance of the first variable (Z_locator)  

    """
    return _gstlearn.db_vcloud(*args, **kwargs)
class ParamInfo(AStringable):
    r"""


    Definition of the generic parameter.  

    Parameters
    ----------
    * `_name` :  
        Name assigned to the parameter  
    * `_value` :  
        Value (initial) assigned to the parameter  
    * `_currentValue` :  
        Value currently assigned to the parameter  
    * `_absoluteBounds` :  
        Absolute bounds within which the parameter may vary  
    * `_userBounds` :  
        Current bounds for the parameter  
    * `_isFixed` :  
        True if the parameter value may not vary (in the non linear optimization)  
    * `_description` :  
        String describing the role of this parameter  
    * `_address` :  
        Address of the parameter in the optimization vector (ListParams)  

    C++ includes: ParamInfo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ParamInfo::ParamInfo
        """
        _gstlearn.ParamInfo_swiginit(self, _gstlearn.new_ParamInfo(*args))
    __swig_destroy__ = _gstlearn.delete_ParamInfo

    def getValue(self):
        r"""

        ParamInfo::getValue
        """
        return _gstlearn.ParamInfo_getValue(self)

    def getAbsoluteMinValue(self):
        r"""

        ParamInfo::getAbsoluteMinValue
        """
        return _gstlearn.ParamInfo_getAbsoluteMinValue(self)

    def getAbsoluteMaxValue(self):
        r"""

        ParamInfo::getAbsoluteMaxValue
        """
        return _gstlearn.ParamInfo_getAbsoluteMaxValue(self)

    def setMinValue(self, value):
        r"""

        ParamInfo::setMinValue
        """
        return _gstlearn.ParamInfo_setMinValue(self, value)

    def setMaxValue(self, value):
        r"""

        ParamInfo::setMaxValue
        """
        return _gstlearn.ParamInfo_setMaxValue(self, value)

    def decreaseMax(self, value):
        r"""

        ParamInfo::decreaseMax
        """
        return _gstlearn.ParamInfo_decreaseMax(self, value)

    def increaseMin(self, value):
        r"""

        ParamInfo::increaseMin
        """
        return _gstlearn.ParamInfo_increaseMin(self, value)

    def setValue(self, value):
        r"""

        ParamInfo::setValue
        """
        return _gstlearn.ParamInfo_setValue(self, value)

    def getName(self):
        r"""

        ParamInfo::getName
        """
        return _gstlearn.ParamInfo_getName(self)

    def getUserMin(self):
        r"""

        ParamInfo::getUserMin
        """
        return _gstlearn.ParamInfo_getUserMin(self)

    def getUserMax(self):
        r"""

        ParamInfo::getUserMax
        """
        return _gstlearn.ParamInfo_getUserMax(self)

    def setFixed(self, isFixed):
        r"""

        ParamInfo::setFixed
        """
        return _gstlearn.ParamInfo_setFixed(self, isFixed)

    def isFixed(self):
        r"""

        ParamInfo::isFixed
        """
        return _gstlearn.ParamInfo_isFixed(self)

    def setAddress(self, addr):
        r"""

        ParamInfo::setAddress
        """
        return _gstlearn.ParamInfo_setAddress(self, addr)

    def getAddress(self):
        r"""

        ParamInfo::getAddress
        """
        return _gstlearn.ParamInfo_getAddress(self)

    def toString(self, strfmt=None):
        r"""

        ParamInfo::toString
        """
        return _gstlearn.ParamInfo_toString(self, strfmt)

    def __repr__(self):
        return _gstlearn.ParamInfo___repr__(self)

# Register ParamInfo in _gstlearn:
_gstlearn.ParamInfo_swigregister(ParamInfo)
class ListParams(AStringable):
    r"""


    C++ includes: ListParams.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        r"""

        ListParams::ListParams
        """
        _gstlearn.ListParams_swiginit(self, _gstlearn.new_ListParams())
    __swig_destroy__ = _gstlearn.delete_ListParams

    def toString(self, strfmt=None):
        r"""

        ListParams::toString
        """
        return _gstlearn.ListParams_toString(self, strfmt)

    def addParam(self, param):
        r"""

        ListParams::addParam
        """
        return _gstlearn.ListParams_addParam(self, param)

    def addParams(self, params):
        r"""

        ListParams::addParams
        """
        return _gstlearn.ListParams_addParams(self, params)

    def clear(self):
        r"""

        ListParams::clear
        """
        return _gstlearn.ListParams_clear(self)

    def getValue(self, index):
        r"""

        ListParams::getValue
        """
        return _gstlearn.ListParams_getValue(self, index)

    def setValue(self, index, value):
        r"""

        ListParams::setValue
        """
        return _gstlearn.ListParams_setValue(self, index, value)

    def getOptimizableValues(self):
        r"""

        ListParams::getOptimizableValues
        """
        return _gstlearn.ListParams_getOptimizableValues(self)

    def setValues(self, values):
        r"""

        ListParams::setValues
        """
        return _gstlearn.ListParams_setValues(self, values)

    def getMinValues(self):
        r"""

        ListParams::getMinValues
        """
        return _gstlearn.ListParams_getMinValues(self)

    def getMaxValues(self):
        r"""

        ListParams::getMaxValues
        """
        return _gstlearn.ListParams_getMaxValues(self)

    def makeDispatchIndexFromDispatch(self):
        r"""

        ListParams::makeDispatchIndexFromDispatch
        """
        return _gstlearn.ListParams_makeDispatchIndexFromDispatch(self)

    def getOptimizableValue(self, index):
        r"""

        ListParams::getOptimizableValue
        """
        return _gstlearn.ListParams_getOptimizableValue(self, index)

    def getNOptimizableParams(self):
        r"""

        ListParams::getNOptimizableParams
        """
        return _gstlearn.ListParams_getNOptimizableParams(self)

    def getNParams(self):
        r"""

        ListParams::getNParams
        """
        return _gstlearn.ListParams_getNParams(self)

    def updateDispatch(self):
        r"""

        ListParams::updateDispatch
        """
        return _gstlearn.ListParams_updateDispatch(self)

    def getDispatch(self):
        r"""

        ListParams::getDispatch
        """
        return _gstlearn.ListParams_getDispatch(self)

    def getDispatchIndex(self):
        r"""

        ListParams::getDispatchIndex
        """
        return _gstlearn.ListParams_getDispatchIndex(self)

    def __repr__(self):
        return _gstlearn.ListParams___repr__(self)

# Register ListParams in _gstlearn:
_gstlearn.ListParams_swigregister(ListParams)
class ModelGeneric(ICloneable):
    r"""


    Class containing the Model Information describing the formal Spatial (or
    Temporal) Characteristics of the (set of) random variable(s) under study.  

    The Model is essentially a container with two main contents:  

    *   the **covariance** part: see ACov.hpp for more information  
    *   the **drift** part: see DriftList.hpp for more information  

    The additional member **CovContext** only serves in carrying the following
    information:  

    *   the number of variables: if more than 1, the Model becomes multivariate  
    *   the field extension: this information is needed to get a *stationary*
        version to any covariance  
    *   the experimental mean vector and the variance-covariance matrix (used to
        calibrate the Model)  

    C++ includes: ModelGeneric.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        ModelGeneric::ModelGeneric
        """
        _gstlearn.ModelGeneric_swiginit(self, _gstlearn.new_ModelGeneric(*args))
    __swig_destroy__ = _gstlearn.delete_ModelGeneric

    def getCov(self):
        r"""

        ModelGeneric::getCov
        """
        return _gstlearn.ModelGeneric_getCov(self)

    def getContext(self):
        r"""

        ModelGeneric::getContext
        """
        return _gstlearn.ModelGeneric_getContext(self)

    def getDriftList(self):
        r"""

        ModelGeneric::getDriftList
        """
        return _gstlearn.ModelGeneric_getDriftList(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ModelGeneric_clone(self)

    def _getCovModify(self):
        r"""

        ModelGeneric::_getCovModify
        ICloneable interface.  

        """
        return _gstlearn.ModelGeneric__getCovModify(self)

    def _getContextModify(self):
        r"""

        ModelGeneric::_getContextModify
        """
        return _gstlearn.ModelGeneric__getContextModify(self)

    def _getDriftListModify(self):
        r"""

        ModelGeneric::_getDriftListModify
        """
        return _gstlearn.ModelGeneric__getDriftListModify(self)

    def getGradients(self):
        r"""

        ModelGeneric::getGradients
        """
        return _gstlearn.ModelGeneric_getGradients(self)

    def setField(self, field):
        r"""

        ModelGeneric::setField
        Call the method CovContext::setField of the object CovContext.  

        """
        return _gstlearn.ModelGeneric_setField(self, field)

    def isValid(self):
        r"""

        ModelGeneric::isValid
        """
        return _gstlearn.ModelGeneric_isValid(self)

    def setCov(self, cova):
        r"""

        ModelGeneric::setCov
        """
        return _gstlearn.ModelGeneric_setCov(self, cova)

    def setDriftList(self, driftlist):
        r"""

        ModelGeneric::setDriftList
        Add a list of Drifts. This operation cleans any previously stored drift function  

        Parameters
        ----------
        * `driftlist` :  
            List of Drifts to be added  

        remark: This method deletes any pre-existing drift functions  

        """
        return _gstlearn.ModelGeneric_setDriftList(self, driftlist)

    def setDriftIRF(self, order=0, nfex=0):
        r"""

        ModelGeneric::setDriftIRF
        Define the list of drift functions for:  

        *   a given degree of the IRF  
        *   a given number of external drifts  

            Parameters:  
            * `order` :  
                Order of the IRF  
            * `nfex` :  
                Number of External Drifts  

            remark: This method deletes any pre-existing drift functions and replaces
                them by the new definition  

            remark: This replacement is performed accounting for information stored in
                'model', such as:  
        *   the space dimension  
        *   the number of variables  

        """
        return _gstlearn.ModelGeneric_setDriftIRF(self, order, nfex)

    def addDrift(self, drift):
        r"""

        ModelGeneric::addDrift
        """
        return _gstlearn.ModelGeneric_addDrift(self, drift)

    def setDrifts(self, driftSymbols):
        r"""

        ModelGeneric::setDrifts
        """
        return _gstlearn.ModelGeneric_setDrifts(self, driftSymbols)

    def initParams(self, vars, href=1.):
        r"""

        ModelGeneric::initParams
        """
        return _gstlearn.ModelGeneric_initParams(self, vars, href)

    def generateListParams(self):
        r"""

        ModelGeneric::generateListParams
        """
        return _gstlearn.ModelGeneric_generateListParams(self)

    @staticmethod
    def createListParams(lp):
        r"""

        ModelGeneric::createListParams
        """
        return _gstlearn.ModelGeneric_createListParams(lp)

    def updateModel(self):
        r"""

        ModelGeneric::updateModel
        """
        return _gstlearn.ModelGeneric_updateModel(self)

    def computeLogLikelihood(self, db, verbose=False):
        r"""

        ModelGeneric::computeLogLikelihood
        Compute the log-likelihood (based on covariance)  

        Parameters
        ----------
        * `db` :  
            Db structure where variable are loaded from  
        * `verbose` :  
            Verbose flag  

        remark: The calculation considers all the active samples.  

        remark: It can work in multivariate case with or without drift conditions
            (linked or not)  

        remark: The algorithm is stopped (with a message) in the heterotopic case //
            TODO; improve for heterotopic case  

        """
        return _gstlearn.ModelGeneric_computeLogLikelihood(self, db, verbose)

    def fitNew(self, *args, **kwargs):
        r"""

        ModelGeneric::fitNew
        """
        return _gstlearn.ModelGeneric_fitNew(self, *args, **kwargs)

# Register ModelGeneric in _gstlearn:
_gstlearn.ModelGeneric_swigregister(ModelGeneric)

def computeCovMatSVCLHSInPlace(cov, Sigma, F1, type=1, idx=0):
    r"""


    """
    return _gstlearn.computeCovMatSVCLHSInPlace(cov, Sigma, F1, type, idx)

def computeCovMatSVCRHSInPlace(cov, Sigma, F1, F2, type1=1, idx1=0, type2=1, idx2=0):
    r"""


    """
    return _gstlearn.computeCovMatSVCRHSInPlace(cov, Sigma, F1, F2, type1, idx1, type2, idx2)

def computeDriftMatSVCRHSInPlace(mat, F, type=1, idx=0, flagCenteredFactors=True):
    r"""


    """
    return _gstlearn.computeDriftMatSVCRHSInPlace(mat, F, type, idx, flagCenteredFactors)
class ModelCovList(ModelGeneric):
    r"""


    Class containing the ModelCovList Information describing the formal Spatial (or
    Temporal) Characteristics of the (set of) random variable(s) under study.  

    The ModelCovList is essentially a container with two main contents:  

    *   the **covariance** part: see CovList.hpp for more information  

    C++ includes: ModelCovList.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        ModelCovList::ModelCovList
        """
        _gstlearn.ModelCovList_swiginit(self, _gstlearn.new_ModelCovList(*args))
    __swig_destroy__ = _gstlearn.delete_ModelCovList

    def getCovList(self):
        r"""

        ModelCovList::getCovList
        """
        return _gstlearn.ModelCovList_getCovList(self)

    def getCovListModify(self):
        r"""

        ModelCovList::getCovListModify
        """
        return _gstlearn.ModelCovList_getCovListModify(self)

    def setCovList(self, covs):
        r"""

        ModelCovList::setCovList
        """
        return _gstlearn.ModelCovList_setCovList(self, covs)

    def addCov(self, cov):
        r"""

        ModelCovList::addCov
        """
        return _gstlearn.ModelCovList_addCov(self, cov)

    def getCovBase(self, icov):
        r"""

        ModelCovList::getCovBase
        """
        return _gstlearn.ModelCovList_getCovBase(self, icov)

    def fitSills(self, *args, **kwargs):
        r"""

        ModelCovList::fitSills
        """
        return _gstlearn.ModelCovList_fitSills(self, *args, **kwargs)

# Register ModelCovList in _gstlearn:
_gstlearn.ModelCovList_swigregister(ModelCovList)
class Model(AStringable, ASerializable, ModelCovList):
    r"""


    Class containing the Model Information describing the formal Spatial (or
    Temporal) Characteristics of the (set of) random variable(s) under study.  

    The Model is essentially a container with two main contents:  

    *   the **covariance** part: see ACov.hpp for more information  
    *   the **drift** part: see DriftList.hpp for more information  

    The additional member **CovContext** only serves in carrying the following
    information:  

    *   the number of variables: if more than 1, the Model becomes multivariate  
    *   the field extension: this information is needed to get a *stationary*
        version to any covariance  
    *   the experimental mean vector and the variance-covariance matrix (used to
        calibrate the Model)  

    C++ includes: Model.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Model::Model
        """
        _gstlearn.Model_swiginit(self, _gstlearn.new_Model(*args))
    __swig_destroy__ = _gstlearn.delete_Model

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.Model_clone(self)

    def toString(self, strfmt=None):
        r"""

        Model::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.Model_toString(self, strfmt)

    def castInCovAnisoListConst(self, icov=-1):
        r"""

        Model::castInCovAnisoListConst
        This internal function tries to cast the member '_cova' into a pointer to
        CovAnisoList and checks the validity of the argument 'icov' which gives the rank
        within this list  

        Parameters
        ----------
        * `icov` :  
            Rank of the CovAniso (to be checked if >= 0)  

        Returns
        -------
        'nullptr' if not valid cast (the error message is printed internally)  

        """
        return _gstlearn.Model_castInCovAnisoListConst(self, icov)

    def castInCovLMCTaperingConst(self):
        r"""

        Model::castInCovLMCTaperingConst
        """
        return _gstlearn.Model_castInCovLMCTaperingConst(self)

    def castInCovLMGradientConst(self):
        r"""

        Model::castInCovLMGradientConst
        """
        return _gstlearn.Model_castInCovLMGradientConst(self)

    def castInCovLMCAnamorphosisConst(self):
        r"""

        Model::castInCovLMCAnamorphosisConst
        """
        return _gstlearn.Model_castInCovLMCAnamorphosisConst(self)

    def _castInCovAnisoList(self, icov=-1):
        r"""

        Model::_castInCovAnisoList
        """
        return _gstlearn.Model__castInCovAnisoList(self, icov)

    def _castInCovLMCTapering(self):
        r"""

        Model::_castInCovLMCTapering
        """
        return _gstlearn.Model__castInCovLMCTapering(self)

    def _castInCovLMGradient(self):
        r"""

        Model::_castInCovLMGradient
        """
        return _gstlearn.Model__castInCovLMGradient(self)

    def _castInCovLMCAnamorphosis(self):
        r"""

        Model::_castInCovLMCAnamorphosis
        """
        return _gstlearn.Model__castInCovLMCAnamorphosis(self)

    def resetFromDb(self, db):
        r"""

        Model::resetFromDb
        """
        return _gstlearn.Model_resetFromDb(self, db)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        Model::create
        """
        return _gstlearn.Model_create(*args, **kwargs)

    @staticmethod
    def createFromEnvironment(nvar, ndim=2):
        r"""

        Model::createFromEnvironment
        """
        return _gstlearn.Model_createFromEnvironment(nvar, ndim)

    @staticmethod
    def createNugget(nvar, ndim=2, sill=1.):
        r"""

        Model::createNugget
        """
        return _gstlearn.Model_createNugget(nvar, ndim, sill)

    @staticmethod
    def createFromParam(*args, **kwargs):
        r"""

        Model::createFromParam
        """
        return _gstlearn.Model_createFromParam(*args, **kwargs)

    @staticmethod
    def createFromParamOldStyle(*args, **kwargs):
        r"""

        Model::createFromParamOldStyle
        """
        return _gstlearn.Model_createFromParamOldStyle(*args, **kwargs)

    @staticmethod
    def createFromDb(db):
        r"""

        Model::createFromDb
        """
        return _gstlearn.Model_createFromDb(db)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        Model::createFromNF
        """
        return _gstlearn.Model_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromVario(*args, **kwargs):
        r"""

        Model::createFromVario
        """
        return _gstlearn.Model_createFromVario(*args, **kwargs)

    @staticmethod
    def createFillRandom(*args, **kwargs):
        r"""

        Model::createFillRandom
        """
        return _gstlearn.Model_createFillRandom(*args, **kwargs)

    def setCovAnisoList(self, covalist):
        r"""

        Model::setCovAnisoList
        Add a list of Covariances. This operation cleans any previously stored
        covariance  

        Parameters
        ----------
        * `covalist` :  
            List of Covariances to be added  

        """
        return _gstlearn.Model_setCovAnisoList(self, covalist)

    def addCovAniso(self, cov):
        r"""

        Model::addCovAniso
        """
        return _gstlearn.Model_addCovAniso(self, cov)

    def addCovFromParam(self, *args, **kwargs):
        r"""

        Model::addCovFromParam
        """
        return _gstlearn.Model_addCovFromParam(self, *args, **kwargs)

    def addCovFromParamOldStyle(self, *args, **kwargs):
        r"""

        Model::addCovFromParamOldStyle
        """
        return _gstlearn.Model_addCovFromParamOldStyle(self, *args, **kwargs)

    def setAnam(self, *args, **kwargs):
        r"""

        Model::setAnam
        Defining an Anamorphosis information for the Model (in fact, this is added to
        CovAnisoList part and transforms it from CovAnisoList to CovLMCAnamorphosis  

        Parameters
        ----------
        * `anam` :  
            Pointer to the anamorphosis  
        * `strcnt` :  
            Array of covariance description used for IR case  

        Returns
        -------  

        """
        return _gstlearn.Model_setAnam(self, *args, **kwargs)

    def unsetAnam(self):
        r"""

        Model::unsetAnam
        """
        return _gstlearn.Model_unsetAnam(self)

    def isFlagGradient(self):
        r"""

        Model::isFlagGradient
        """
        return _gstlearn.Model_isFlagGradient(self)

    def isFlagGradientNumerical(self):
        r"""

        Model::isFlagGradientNumerical
        """
        return _gstlearn.Model_isFlagGradientNumerical(self)

    def isFlagGradientFunctional(self):
        r"""

        Model::isFlagGradientFunctional
        """
        return _gstlearn.Model_isFlagGradientFunctional(self)

    def switchToGradient(self):
        r"""

        Model::switchToGradient
        Switch to a Model dedicated to Gradients (transforms it from CovAnisoList to
        CovLMGradient)  

        """
        return _gstlearn.Model_switchToGradient(self)

    def getCovAnisoList(self):
        r"""

        Model::getCovAnisoList
        TODO : to be removed (encapsulation of CovAnisoList)  

        """
        return _gstlearn.Model_getCovAnisoList(self)

    def getCovAnisoListModify(self):
        r"""

        Model::getCovAnisoListModify
        """
        return _gstlearn.Model_getCovAnisoListModify(self)

    def evalCovFromIncr(self, *args, **kwargs):
        r"""

        Model::evalCovFromIncr
        """
        return _gstlearn.Model_evalCovFromIncr(self, *args, **kwargs)

    def duplicate(self):
        r"""

        Model::duplicate
        """
        return _gstlearn.Model_duplicate(self)

    def createReduce(self, validVars):
        r"""

        Model::createReduce
        """
        return _gstlearn.Model_createReduce(self, validVars)

    def getNVar(self):
        r"""

        Model::getNVar
        """
        return _gstlearn.Model_getNVar(self)

    def fitFromCovIndices(self, *args, **kwargs):
        r"""

        Model::fitFromCovIndices
        Automatic Fitting procedure  

        Parameters
        ----------
        * `vario` :  
            Experimental variogram to be fitted  
        * `types` :  
            Vector of ECov integer values  
        * `constraints` :  
            Set of Constraints  
        * `optvar` :  
            Set of options  
        * `mauto` :  
            Special parameters for Automatic fitting procedure  
        * `verbose` :  
            Verbose option  

        Returns
        -------
        0 if no error, 1 otherwise  

        TODO : What to do with that ?  

        """
        return _gstlearn.Model_fitFromCovIndices(self, *args, **kwargs)

    def fit(self, *args, **kwargs):
        r"""

        Model::fit
        Automatic Fitting procedure from an experimental Variogram  

        Parameters
        ----------
        * `vario` :  
            Experimental variogram to be fitted  
        * `types` :  
            Vector of ECov (see remarks)  
        * `constraints` :  
            Set of Constraints  
        * `optvar` :  
            Set of options  
        * `mauto` :  
            Special parameters for Automatic fitting procedure (instance of
            Option_AutoFit), for exemple wmode (type of weighting function)  
        * `verbose` :  
            Verbose option  

        remark: If no list of specific basic structure is specified, the automatic
            fitting is performed using a single spherical structure by default.  

        Returns
        -------
        0 if no error, 1 otherwise  

        TODO : What to do with that ?  

        """
        return _gstlearn.Model_fit(self, *args, **kwargs)

    def fitFromVMap(self, *args, **kwargs):
        r"""

        Model::fitFromVMap
        Automatic Fitting procedure from A Variogram Map stored on a DbGrid  

        Parameters
        ----------
        * `dbmap` :  
            DbGrid containing the Variogram Map  
        * `types` :  
            Vector of ECov  
        * `constraints` :  
            Set of Constraints  
        * `optvar` :  
            Set of options  
        * `mauto` :  
            Special parameters for Automatic fitting procedure (instance of
            Option_AutoFit), for exemple wmode (type of weighting function)  
        * `verbose` :  
            Verbose option  

        Returns
        -------
        0 if no error, 1 otherwise  

        """
        return _gstlearn.Model_fitFromVMap(self, *args, **kwargs)

    def stabilize(self, percent, verbose=False):
        r"""

        Model::stabilize
        Stabilize the model (in the monovariate case)  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `percent` :  
            Percentage of nugget effect added  
        * `verbose` :  
            true for a verbose output  

        remark: If the model only contains GAUSSIAN structures, add  

        remark: a NUGGET EFFECT structure with a sill equal to a percentage  

        remark: of the total sill of the GAUSSIAN component(s)  

        remark: This function does not do anything in the multivariate case  

        """
        return _gstlearn.Model_stabilize(self, percent, verbose)

    def standardize(self, verbose=False):
        r"""

        Model::standardize
        Normalize the model  

        Parameters
        ----------
        * `verbose` :  
            true for a verbose output  

        """
        return _gstlearn.Model_standardize(self, verbose)

    @staticmethod
    def gofDisplay(*args, **kwargs):
        r"""

        Model::gofDisplay
        """
        return _gstlearn.Model_gofDisplay(*args, **kwargs)

    @staticmethod
    def initCovList(covranks):
        r"""

        Model::initCovList
        """
        return _gstlearn.Model_initCovList(covranks)

    def isValid(self):
        r"""

        Model::isValid
        """
        return _gstlearn.Model_isValid(self)

    def __repr__(self):
        return _gstlearn.Model___repr__(self)

# Register Model in _gstlearn:
_gstlearn.Model_swigregister(Model)
class ModelOptimParam(AStringable):
    r"""


    This class defines the options and parameters used during the Variogram Fitting.
    All the parameters described hereafter are either available in the construction,
    or can be set using a specific get() function.  

    *   auth_aniso: When True, the inference looks for an anisotropic fit.  
    *   auth_rotation: When True, the inference looks for a possible rotation  
    *   lock_samerot: When True, the inference locks the same anisotropy for all
        basic structures  
    *   lock_rot2d: When True, the anisotropy is restricted to a rotation around
        Z-axis only  
    *   lock_no3D: When True, the inference parameters are limited to the 2-D space.  
    *   lock_iso2d: When True, the inference looks for a 2-D isotropic model  
    *   flag_goulard: This very efficient algorithm can be used for inferring the
        sill matrix for each basic structure. This option can be switched OFF on
        purpose (and replaced by the FOXLEG algorithm).  
    *   flag_instrinsic: When True, fit a Model which includes at least one
        Intrinsic basic Structure  
    *   wmode: Weighting option (see comments on the setWMode() function)  
    *   maxiter: Maximum number of iterations  
    *   tolred: Define the relative criterion used for stopping the iterations  

    C++ includes: ModelOptimParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ModelOptimParam::ModelOptimParam
        """
        _gstlearn.ModelOptimParam_swiginit(self, _gstlearn.new_ModelOptimParam(*args))
    __swig_destroy__ = _gstlearn.delete_ModelOptimParam

    def toString(self, strfmt=None):
        r"""

        ModelOptimParam::toString
        """
        return _gstlearn.ModelOptimParam_toString(self, strfmt)

    @staticmethod
    def create(auth_aniso=True, auth_rotation=True, lock_samerot=False, lock_rot2d=False, lock_no3d=False, lock_iso2d=False, flag_goulard=True, flag_intrinsic=False, wmode=2, maxiter=1000, tolred=1.e-10):
        r"""

        ModelOptimParam::create
        """
        return _gstlearn.ModelOptimParam_create(auth_aniso, auth_rotation, lock_samerot, lock_rot2d, lock_no3d, lock_iso2d, flag_goulard, flag_intrinsic, wmode, maxiter, tolred)

    def getAuthAniso(self):
        r"""

        ModelOptimParam::getAuthAniso
        """
        return _gstlearn.ModelOptimParam_getAuthAniso(self)

    def setAuthAniso(self, authAniso):
        r"""

        ModelOptimParam::setAuthAniso
        """
        return _gstlearn.ModelOptimParam_setAuthAniso(self, authAniso)

    def getAuthRotation(self):
        r"""

        ModelOptimParam::getAuthRotation
        """
        return _gstlearn.ModelOptimParam_getAuthRotation(self)

    def setAuthRotation(self, authRotation):
        r"""

        ModelOptimParam::setAuthRotation
        """
        return _gstlearn.ModelOptimParam_setAuthRotation(self, authRotation)

    def getFlagGoulard(self):
        r"""

        ModelOptimParam::getFlagGoulard
        """
        return _gstlearn.ModelOptimParam_getFlagGoulard(self)

    def setFlagGoulard(self, flagGoulard):
        r"""

        ModelOptimParam::setFlagGoulard
        """
        return _gstlearn.ModelOptimParam_setFlagGoulard(self, flagGoulard)

    def getLockIso2d(self):
        r"""

        ModelOptimParam::getLockIso2d
        """
        return _gstlearn.ModelOptimParam_getLockIso2d(self)

    def setLockIso2d(self, lockIso2d):
        r"""

        ModelOptimParam::setLockIso2d
        """
        return _gstlearn.ModelOptimParam_setLockIso2d(self, lockIso2d)

    def getLockNo3d(self):
        r"""

        ModelOptimParam::getLockNo3d
        """
        return _gstlearn.ModelOptimParam_getLockNo3d(self)

    def setLockNo3d(self, lockNo3d):
        r"""

        ModelOptimParam::setLockNo3d
        """
        return _gstlearn.ModelOptimParam_setLockNo3d(self, lockNo3d)

    def getLockRot2d(self):
        r"""

        ModelOptimParam::getLockRot2d
        """
        return _gstlearn.ModelOptimParam_getLockRot2d(self)

    def setLockRot2d(self, lockRot2d):
        r"""

        ModelOptimParam::setLockRot2d
        """
        return _gstlearn.ModelOptimParam_setLockRot2d(self, lockRot2d)

    def getLockSamerot(self):
        r"""

        ModelOptimParam::getLockSamerot
        """
        return _gstlearn.ModelOptimParam_getLockSamerot(self)

    def setLockSamerot(self, lockSamerot):
        r"""

        ModelOptimParam::setLockSamerot
        """
        return _gstlearn.ModelOptimParam_setLockSamerot(self, lockSamerot)

    def getFlagIntrinsic(self):
        r"""

        ModelOptimParam::getFlagIntrinsic
        """
        return _gstlearn.ModelOptimParam_getFlagIntrinsic(self)

    def setFlagIntrinsic(self, flagIntrinsic):
        r"""

        ModelOptimParam::setFlagIntrinsic
        """
        return _gstlearn.ModelOptimParam_setFlagIntrinsic(self, flagIntrinsic)

    def getWmode(self):
        r"""

        ModelOptimParam::getWmode
        Set the type of the weighting function used in the fitting procedure. This
        function is defined in the case of several directional experimental variograms,
        calculated in a multivariate case: 0: The weight is constant 1: The weight is
        proportional to the number of pairs 2: The weight is proportional to the number
        of pairs and inverse proportional to the distance 3: The weight is inverse
        proportional to the number of lags for each direction  

        Parameters
        ----------
        * `wmode` :  
            type of weighting function (0, 1, 2 or 3, see above)  

        note: The default value for wmode is 2  

        """
        return _gstlearn.ModelOptimParam_getWmode(self)

    def setWmode(self, wmode):
        r"""

        ModelOptimParam::setWmode
        """
        return _gstlearn.ModelOptimParam_setWmode(self, wmode)

    def getMaxiter(self):
        r"""

        ModelOptimParam::getMaxiter
        """
        return _gstlearn.ModelOptimParam_getMaxiter(self)

    def setMaxiter(self, maxiter):
        r"""

        ModelOptimParam::setMaxiter
        """
        return _gstlearn.ModelOptimParam_setMaxiter(self, maxiter)

    def getTolred(self):
        r"""

        ModelOptimParam::getTolred
        """
        return _gstlearn.ModelOptimParam_getTolred(self)

    def setTolred(self, tolred):
        r"""

        ModelOptimParam::setTolred
        """
        return _gstlearn.ModelOptimParam_setTolred(self, tolred)

    def __repr__(self):
        return _gstlearn.ModelOptimParam___repr__(self)

# Register ModelOptimParam in _gstlearn:
_gstlearn.ModelOptimParam_swigregister(ModelOptimParam)
class Option_AutoFit(AStringable):
    r"""


    This class defines the options and parameters used during the Variogram Fitting.
    All the parameters described hereafter are either available in the construction,
    or can be set using a specific get() function.  

    *   verbose: Ask for a verbose option during the Automatic Model fitting  
    *   wmode: Weighting option (see comments on the setWMode() function)  
    *   maxiter: Maximum number of iterations  
    *   tolstop: Define an absolute criterion used for stopping the iterations  
    *   tolred: Define the relative criterion used for stopping the iterations  
    *   epsdelta: Define the tolerance used for the search  
    *   tolsigma: Percentage of the variance below which a basic structure is
        discarded  
    *   initdelta: Initial radius of the trusting area  

    C++ includes: Option_AutoFit.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Option_AutoFit::Option_AutoFit
        """
        _gstlearn.Option_AutoFit_swiginit(self, _gstlearn.new_Option_AutoFit(*args))
    __swig_destroy__ = _gstlearn.delete_Option_AutoFit

    def toString(self, strfmt=None):
        r"""

        Option_AutoFit::toString
        """
        return _gstlearn.Option_AutoFit_toString(self, strfmt)

    def getEpsdelta(self):
        r"""

        Option_AutoFit::getEpsdelta
        """
        return _gstlearn.Option_AutoFit_getEpsdelta(self)

    def getInitdelta(self):
        r"""

        Option_AutoFit::getInitdelta
        """
        return _gstlearn.Option_AutoFit_getInitdelta(self)

    def getMaxiter(self):
        r"""

        Option_AutoFit::getMaxiter
        """
        return _gstlearn.Option_AutoFit_getMaxiter(self)

    def getTolred(self):
        r"""

        Option_AutoFit::getTolred
        """
        return _gstlearn.Option_AutoFit_getTolred(self)

    def getTolsigma(self):
        r"""

        Option_AutoFit::getTolsigma
        """
        return _gstlearn.Option_AutoFit_getTolsigma(self)

    def getTolstop(self):
        r"""

        Option_AutoFit::getTolstop
        """
        return _gstlearn.Option_AutoFit_getTolstop(self)

    def getVerbose(self):
        r"""

        Option_AutoFit::getVerbose
        """
        return _gstlearn.Option_AutoFit_getVerbose(self)

    def getWmode(self):
        r"""

        Option_AutoFit::getWmode
        """
        return _gstlearn.Option_AutoFit_getWmode(self)

    def setEpsdelta(self, epsdelta):
        r"""

        Option_AutoFit::setEpsdelta
        """
        return _gstlearn.Option_AutoFit_setEpsdelta(self, epsdelta)

    def setInitdelta(self, initdelta):
        r"""

        Option_AutoFit::setInitdelta
        """
        return _gstlearn.Option_AutoFit_setInitdelta(self, initdelta)

    def setMaxiter(self, maxiter):
        r"""

        Option_AutoFit::setMaxiter
        """
        return _gstlearn.Option_AutoFit_setMaxiter(self, maxiter)

    def setTolred(self, tolred):
        r"""

        Option_AutoFit::setTolred
        """
        return _gstlearn.Option_AutoFit_setTolred(self, tolred)

    def setTolsigma(self, tolsigma):
        r"""

        Option_AutoFit::setTolsigma
        """
        return _gstlearn.Option_AutoFit_setTolsigma(self, tolsigma)

    def setTolstop(self, tolstop):
        r"""

        Option_AutoFit::setTolstop
        """
        return _gstlearn.Option_AutoFit_setTolstop(self, tolstop)

    def setVerbose(self, verbose):
        r"""

        Option_AutoFit::setVerbose
        """
        return _gstlearn.Option_AutoFit_setVerbose(self, verbose)

    def setWmode(self, wmode):
        r"""

        Option_AutoFit::setWmode
        Set the type of the weighting function used in the fitting procedure. This
        function is defined in the case of several directional experimental variograms,
        calculated in a multivariate case: 0: The weight is constant 1: The weight is
        proportional to the number of pairs 2: The weight is proportional to the number
        of pairs and inverse proportional to the distance 3: The weight is inverse
        proportional to the number of lags for each direction  

        Parameters
        ----------
        * `wmode` :  
            type of weighting function (0, 1, 2 or 3, see above)  

        note: The default value for wmode is 2  

        """
        return _gstlearn.Option_AutoFit_setWmode(self, wmode)

    def __repr__(self):
        return _gstlearn.Option_AutoFit___repr__(self)

# Register Option_AutoFit in _gstlearn:
_gstlearn.Option_AutoFit_swigregister(Option_AutoFit)
class Option_VarioFit(AStringable):
    r"""


    This class defines the options and parameters used during the Variogram Fitting.
    All the parameters described hereafter are either available in the construction,
    or can be set using a specific get() function.  

    *   flag_noreduce: in the different iterations, some structures can be discarded
        if their importance is considered as too small. The current option forbids
        this simplification, which ensures that all the basic structures are kept
        and their number remains unchanged.  
    *   flag_goulard_used: This very efficient algorithm can be used for inferring
        the sill matrix for each basic structure. This option can be switched OFF on
        purpose (and replaced by the FOXLEG algorithm).  
    *   auth_aniso: When True, the inference looks for an anisotropic fit.  
    *   auth_rotation: When True, the inference looks for a possible rotation  
    *   lock_samerot: When True, the inference locks the same anisotropy for all
        basic structures  
    *   lock_rot2d: When True, the anisotropy is restricted to a rotation around
        Z-axis only  
    *   lock_no3D: When True, the inference parameters are limited to the 2-D space.  
    *   lock_iso2d: When True, the inference looks for a 2-D isotropic model  
    *   keep_instr: When True, at least ONE basic structure must be kept in the
        Model  
    *   flag_instrinsic: When True, fit a Model which includes at least one
        Intrinsic basic Structure  

    C++ includes: Option_VarioFit.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Option_VarioFit::Option_VarioFit
        """
        _gstlearn.Option_VarioFit_swiginit(self, _gstlearn.new_Option_VarioFit(*args))
    __swig_destroy__ = _gstlearn.delete_Option_VarioFit

    def toString(self, strfmt=None):
        r"""

        Option_VarioFit::toString
        """
        return _gstlearn.Option_VarioFit_toString(self, strfmt)

    def getAuthAniso(self):
        r"""

        Option_VarioFit::getAuthAniso
        """
        return _gstlearn.Option_VarioFit_getAuthAniso(self)

    def setAuthAniso(self, authAniso):
        r"""

        Option_VarioFit::setAuthAniso
        """
        return _gstlearn.Option_VarioFit_setAuthAniso(self, authAniso)

    def getAuthRotation(self):
        r"""

        Option_VarioFit::getAuthRotation
        """
        return _gstlearn.Option_VarioFit_getAuthRotation(self)

    def setAuthRotation(self, authRotation):
        r"""

        Option_VarioFit::setAuthRotation
        """
        return _gstlearn.Option_VarioFit_setAuthRotation(self, authRotation)

    def getFlagGoulardUsed(self):
        r"""

        Option_VarioFit::getFlagGoulardUsed
        """
        return _gstlearn.Option_VarioFit_getFlagGoulardUsed(self)

    def setFlagGoulardUsed(self, flagGoulardUsed):
        r"""

        Option_VarioFit::setFlagGoulardUsed
        """
        return _gstlearn.Option_VarioFit_setFlagGoulardUsed(self, flagGoulardUsed)

    def getFlagNoreduce(self):
        r"""

        Option_VarioFit::getFlagNoreduce
        """
        return _gstlearn.Option_VarioFit_getFlagNoreduce(self)

    def setFlagNoreduce(self, flagNoreduce):
        r"""

        Option_VarioFit::setFlagNoreduce
        """
        return _gstlearn.Option_VarioFit_setFlagNoreduce(self, flagNoreduce)

    def getKeepIntstr(self):
        r"""

        Option_VarioFit::getKeepIntstr
        """
        return _gstlearn.Option_VarioFit_getKeepIntstr(self)

    def setKeepIntstr(self, keepIntstr):
        r"""

        Option_VarioFit::setKeepIntstr
        """
        return _gstlearn.Option_VarioFit_setKeepIntstr(self, keepIntstr)

    def getLockIso2d(self):
        r"""

        Option_VarioFit::getLockIso2d
        """
        return _gstlearn.Option_VarioFit_getLockIso2d(self)

    def setLockIso2d(self, lockIso2d):
        r"""

        Option_VarioFit::setLockIso2d
        """
        return _gstlearn.Option_VarioFit_setLockIso2d(self, lockIso2d)

    def getLockNo3d(self):
        r"""

        Option_VarioFit::getLockNo3d
        """
        return _gstlearn.Option_VarioFit_getLockNo3d(self)

    def setLockNo3d(self, lockNo3d):
        r"""

        Option_VarioFit::setLockNo3d
        """
        return _gstlearn.Option_VarioFit_setLockNo3d(self, lockNo3d)

    def getLockRot2d(self):
        r"""

        Option_VarioFit::getLockRot2d
        """
        return _gstlearn.Option_VarioFit_getLockRot2d(self)

    def setLockRot2d(self, lockRot2d):
        r"""

        Option_VarioFit::setLockRot2d
        """
        return _gstlearn.Option_VarioFit_setLockRot2d(self, lockRot2d)

    def getLockSamerot(self):
        r"""

        Option_VarioFit::getLockSamerot
        """
        return _gstlearn.Option_VarioFit_getLockSamerot(self)

    def setLockSamerot(self, lockSamerot):
        r"""

        Option_VarioFit::setLockSamerot
        """
        return _gstlearn.Option_VarioFit_setLockSamerot(self, lockSamerot)

    def getFlagIntrinsic(self):
        r"""

        Option_VarioFit::getFlagIntrinsic
        """
        return _gstlearn.Option_VarioFit_getFlagIntrinsic(self)

    def setFlagIntrinsic(self, flagIntrinsic):
        r"""

        Option_VarioFit::setFlagIntrinsic
        """
        return _gstlearn.Option_VarioFit_setFlagIntrinsic(self, flagIntrinsic)

    def __repr__(self):
        return _gstlearn.Option_VarioFit___repr__(self)

# Register Option_VarioFit in _gstlearn:
_gstlearn.Option_VarioFit_swigregister(Option_VarioFit)
class Constraints(AStringable):
    r"""


    C++ includes: Constraints.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Constraints::Constraints
        """
        _gstlearn.Constraints_swiginit(self, _gstlearn.new_Constraints(*args))
    __swig_destroy__ = _gstlearn.delete_Constraints

    def toString(self, strfmt=None):
        r"""

        Constraints::toString
        """
        return _gstlearn.Constraints_toString(self, strfmt)

    def addItem(self, item):
        r"""

        Constraints::addItem
        """
        return _gstlearn.Constraints_addItem(self, item)

    def addItemFromParamId(self, *args, **kwargs):
        r"""

        Constraints::addItemFromParamId
        """
        return _gstlearn.Constraints_addItemFromParamId(self, *args, **kwargs)

    def isDefined(self):
        r"""

        Constraints::isDefined
        """
        return _gstlearn.Constraints_isDefined(self)

    def isDefinedForSill(self):
        r"""

        Constraints::isDefinedForSill
        """
        return _gstlearn.Constraints_isDefinedForSill(self)

    def getNConsItem(self):
        r"""

        Constraints::getNConsItem
        """
        return _gstlearn.Constraints_getNConsItem(self)

    def getConsItems(self, *args):
        r"""

        Constraints::getConsItems
        """
        return _gstlearn.Constraints_getConsItems(self, *args)

    def modifyConstraintsForSill(self):
        r"""

        Constraints::modifyConstraintsForSill
        """
        return _gstlearn.Constraints_modifyConstraintsForSill(self)

    def getConstantSillValue(self):
        r"""

        Constraints::getConstantSillValue
        """
        return _gstlearn.Constraints_getConstantSillValue(self)

    def getConstantSills(self, *args):
        r"""

        Constraints::getConstantSills
        """
        return _gstlearn.Constraints_getConstantSills(self, *args)

    def setConstantSillValue(self, value):
        r"""

        Constraints::setConstantSillValue
        """
        return _gstlearn.Constraints_setConstantSillValue(self, value)

    def setConstantSills(self, constantSills):
        r"""

        Constraints::setConstantSills
        """
        return _gstlearn.Constraints_setConstantSills(self, constantSills)

    def expandConstantSill(self, nvar):
        r"""

        Constraints::expandConstantSill
        """
        return _gstlearn.Constraints_expandConstantSill(self, nvar)

    def isConstraintSillDefined(self):
        r"""

        Constraints::isConstraintSillDefined
        """
        return _gstlearn.Constraints_isConstraintSillDefined(self)

    def setValue(self, item, value):
        r"""

        Constraints::setValue
        """
        return _gstlearn.Constraints_setValue(self, item, value)

    def __repr__(self):
        return _gstlearn.Constraints___repr__(self)

# Register Constraints in _gstlearn:
_gstlearn.Constraints_swigregister(Constraints)

def constraints_get(constraints, icase, igrf, icov, icons, v1, v2):
    r"""


    Return the constraint value (if defined) or TEST  

    Returns
    -------
    Returned value or TEST  

    Parameters
    ----------
    * `constraints` :  
        Constraints structure  
    * `icase` :  
        Parameter type (EConsType)  
    * `igrf` :  
        Rank of the Gaussian Random Function  
    * `icov` :  
        Rank of the structure (starting from 0)  
    * `icons` :  
        Type of the constraint (EConsElem)  
    * `iv1` :  
        Rank of the first variable  
    * `iv2` :  
        Rank of the second variable  

    """
    return _gstlearn.constraints_get(constraints, icase, igrf, icov, icons, v1, v2)

def constraints_print(constraints):
    r"""


    Print the Auto Fitting Constraints Structure  

    Parameters
    ----------
    * `constraints` :  
        Constraints structure  

    """
    return _gstlearn.constraints_print(constraints)

def modify_constraints_on_sill(constraints):
    r"""


    If a constraint concerns a sill, take its square root as it corresponds to a
    constraints on AIC (not on a sill directly) due to the fact that it will be
    processed in FOXLEG (not in GOULARD) This transform only makes sense for
    MONOVARIATE case (the test should have been performed beforehand)  

    Returns
    -------
    Error code (if the sill constraint is negative)  

    Parameters
    ----------
    * `constraints` :  
        Constraints structure  

    """
    return _gstlearn.modify_constraints_on_sill(constraints)

def add_unit_sill_constraints(constraints):
    r"""


    Add constraints (all equal to 1) to the Option_AutoFit structure  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `constraints` :  
        Constraints structure  

    """
    return _gstlearn.add_unit_sill_constraints(constraints)
class ConsItem(AStringable, ICloneable):
    r"""


    This class is used:  

    *   to define the constraints for the Model Automatic Fitting (authAssign true)  
    *   to define the non-stationary parameters of a Model  

    C++ includes: ConsItem.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ConsItem::ConsItem
        """
        _gstlearn.ConsItem_swiginit(self, _gstlearn.new_ConsItem(*args))
    __swig_destroy__ = _gstlearn.delete_ConsItem

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ConsItem_clone(self)

    def toString(self, strfmt=None):
        r"""

        ConsItem::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.ConsItem_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        ConsItem::create
        """
        return _gstlearn.ConsItem_create(*args, **kwargs)

    @staticmethod
    def createFromParamId(*args, **kwargs):
        r"""

        ConsItem::createFromParamId
        """
        return _gstlearn.ConsItem_createFromParamId(*args, **kwargs)

    def getType(self):
        r"""

        ConsItem::getType
        """
        return _gstlearn.ConsItem_getType(self)

    def getIGrf(self):
        r"""

        ConsItem::getIGrf
        """
        return _gstlearn.ConsItem_getIGrf(self)

    def getICov(self):
        r"""

        ConsItem::getICov
        """
        return _gstlearn.ConsItem_getICov(self)

    def getIV1(self):
        r"""

        ConsItem::getIV1
        """
        return _gstlearn.ConsItem_getIV1(self)

    def getIV2(self):
        r"""

        ConsItem::getIV2
        """
        return _gstlearn.ConsItem_getIV2(self)

    def setValue(self, value):
        r"""

        ConsItem::setValue
        """
        return _gstlearn.ConsItem_setValue(self, value)

    def setIcase(self, type):
        r"""

        ConsItem::setIcase
        """
        return _gstlearn.ConsItem_setIcase(self, type)

    def getIcase(self):
        r"""

        ConsItem::getIcase
        """
        return _gstlearn.ConsItem_getIcase(self)

    def getValue(self):
        r"""

        ConsItem::getValue
        """
        return _gstlearn.ConsItem_getValue(self)

    def matchIGrf(self, igrf0):
        r"""

        ConsItem::matchIGrf
        """
        return _gstlearn.ConsItem_matchIGrf(self, igrf0)

    def matchICov(self, icov0):
        r"""

        ConsItem::matchICov
        """
        return _gstlearn.ConsItem_matchICov(self, icov0)

    def matchType(self, type0):
        r"""

        ConsItem::matchType
        """
        return _gstlearn.ConsItem_matchType(self, type0)

    def matchIV1(self, iv10):
        r"""

        ConsItem::matchIV1
        """
        return _gstlearn.ConsItem_matchIV1(self, iv10)

    def matchIV2(self, iv20):
        r"""

        ConsItem::matchIV2
        """
        return _gstlearn.ConsItem_matchIV2(self, iv20)

    def getParamId(self):
        r"""

        ConsItem::getParamId
        """
        return _gstlearn.ConsItem_getParamId(self)

    @staticmethod
    def define(*args, **kwargs):
        r"""

        ConsItem::define
        This function creates a constraints on a parameter This constraint will be used
        subsequently during the variogram fitting  

        Parameters
        ----------
        * `elem` :  
            The type of item on which the constraints applies (EConsElem.hpp)  
        * `icov` :  
            The rank of the covariance  
        * `iv1` :  
            The rank of the first variable  
        * `iv2` :  
            The rank of the second variable  
        * `type` :  
            The type of constraints (EConsType.hpp)  
        * `value` :  
            The value assigned to the constraint  

        remark: Do not forget to delete object after usage  

        Returns
        -------  

        """
        return _gstlearn.ConsItem_define(*args, **kwargs)

    def __repr__(self):
        return _gstlearn.ConsItem___repr__(self)

# Register ConsItem in _gstlearn:
_gstlearn.ConsItem_swigregister(ConsItem)
class CovParamId(AStringable, ICloneable):
    r"""


    This class is used:  

    *   to define the constraints for the Model Automatic Fitting (authAssign true)  
    *   to define the non-stationary parameters of a Model  

    C++ includes: CovParamId.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovParamId::CovParamId
        """
        _gstlearn.CovParamId_swiginit(self, _gstlearn.new_CovParamId(*args))
    __swig_destroy__ = _gstlearn.delete_CovParamId

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovParamId_clone(self)

    def toString(self, strfmt=None):
        r"""

        CovParamId::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.CovParamId_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        CovParamId::create
        """
        return _gstlearn.CovParamId_create(*args, **kwargs)

    def init(self, igrf, icov, type, iv1, iv2):
        r"""

        CovParamId::init
        """
        return _gstlearn.CovParamId_init(self, igrf, icov, type, iv1, iv2)

    def getType(self):
        r"""

        CovParamId::getType
        """
        return _gstlearn.CovParamId_getType(self)

    def getIGrf(self):
        r"""

        CovParamId::getIGrf
        """
        return _gstlearn.CovParamId_getIGrf(self)

    def getICov(self):
        r"""

        CovParamId::getICov
        """
        return _gstlearn.CovParamId_getICov(self)

    def getIV1(self):
        r"""

        CovParamId::getIV1
        """
        return _gstlearn.CovParamId_getIV1(self)

    def getIV2(self):
        r"""

        CovParamId::getIV2
        """
        return _gstlearn.CovParamId_getIV2(self)

    def setType(self, type):
        r"""

        CovParamId::setType
        """
        return _gstlearn.CovParamId_setType(self, type)

    def matchIGrf(self, igrf0):
        r"""

        CovParamId::matchIGrf
        """
        return _gstlearn.CovParamId_matchIGrf(self, igrf0)

    def matchICov(self, icov0):
        r"""

        CovParamId::matchICov
        """
        return _gstlearn.CovParamId_matchICov(self, icov0)

    def matchType(self, type0):
        r"""

        CovParamId::matchType
        """
        return _gstlearn.CovParamId_matchType(self, type0)

    def matchIV1(self, iv10):
        r"""

        CovParamId::matchIV1
        """
        return _gstlearn.CovParamId_matchIV1(self, iv10)

    def matchIV2(self, iv20):
        r"""

        CovParamId::matchIV2
        """
        return _gstlearn.CovParamId_matchIV2(self, iv20)

    def __repr__(self):
        return _gstlearn.CovParamId___repr__(self)

# Register CovParamId in _gstlearn:
_gstlearn.CovParamId_swigregister(CovParamId)
class ParamId(AStringable, ICloneable):
    r"""


    This class is used:  

    *   to define the constraints for the Model Automatic Fitting (authAssign true)  
    *   to define the non-stationary parameters of a Model  

    C++ includes: ParamId.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ParamId::ParamId
        """
        _gstlearn.ParamId_swiginit(self, _gstlearn.new_ParamId(*args))
    __swig_destroy__ = _gstlearn.delete_ParamId

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.ParamId_clone(self)

    def toString(self, strfmt=None):
        r"""

        ParamId::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.ParamId_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        ParamId::create
        """
        return _gstlearn.ParamId_create(*args, **kwargs)

    def init(self, type, iv1, iv2):
        r"""

        ParamId::init
        """
        return _gstlearn.ParamId_init(self, type, iv1, iv2)

    def getType(self):
        r"""

        ParamId::getType
        """
        return _gstlearn.ParamId_getType(self)

    def getIV1(self):
        r"""

        ParamId::getIV1
        """
        return _gstlearn.ParamId_getIV1(self)

    def getIV2(self):
        r"""

        ParamId::getIV2
        """
        return _gstlearn.ParamId_getIV2(self)

    def setType(self, type):
        r"""

        ParamId::setType
        """
        return _gstlearn.ParamId_setType(self, type)

    def matchType(self, type0):
        r"""

        ParamId::matchType
        """
        return _gstlearn.ParamId_matchType(self, type0)

    def matchIV1(self, iv10):
        r"""

        ParamId::matchIV1
        """
        return _gstlearn.ParamId_matchIV1(self, iv10)

    def matchIV2(self, iv20):
        r"""

        ParamId::matchIV2
        """
        return _gstlearn.ParamId_matchIV2(self, iv20)

    def __repr__(self):
        return _gstlearn.ParamId___repr__(self)

# Register ParamId in _gstlearn:
_gstlearn.ParamId_swigregister(ParamId)
class ParamIdHash(object):
    r"""


    C++ includes: ParamId.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, p):
        return _gstlearn.ParamIdHash___call__(self, p)

    def __init__(self):
        r"""


        C++ includes: ParamId.hpp

        """
        _gstlearn.ParamIdHash_swiginit(self, _gstlearn.new_ParamIdHash())
    __swig_destroy__ = _gstlearn.delete_ParamIdHash

# Register ParamIdHash in _gstlearn:
_gstlearn.ParamIdHash_swigregister(ParamIdHash)
class ParamIdEqual(object):
    r"""


    C++ includes: ParamId.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, lhs, rhs):
        return _gstlearn.ParamIdEqual___call__(self, lhs, rhs)

    def __init__(self):
        r"""


        C++ includes: ParamId.hpp

        """
        _gstlearn.ParamIdEqual_swiginit(self, _gstlearn.new_ParamIdEqual())
    __swig_destroy__ = _gstlearn.delete_ParamIdEqual

# Register ParamIdEqual in _gstlearn:
_gstlearn.ParamIdEqual_swigregister(ParamIdEqual)
class TabNoStat(AStringable, ICloneable):
    r"""


    C++ includes: TabNoStat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        TabNoStat::TabNoStat
        """
        _gstlearn.TabNoStat_swiginit(self, _gstlearn.new_TabNoStat(*args))
    __swig_destroy__ = _gstlearn.delete_TabNoStat

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.TabNoStat_clone(self)

    def isNoStat(self):
        r"""

        TabNoStat::isNoStat
        """
        return _gstlearn.TabNoStat_isNoStat(self)

    def informMeshByMesh(self, *args):
        r"""

        TabNoStat::informMeshByMesh
        """
        return _gstlearn.TabNoStat_informMeshByMesh(self, *args)

    def informMeshByApex(self, *args):
        r"""

        TabNoStat::informMeshByApex
        """
        return _gstlearn.TabNoStat_informMeshByApex(self, *args)

    def informDbIn(self, *args):
        r"""

        TabNoStat::informDbIn
        """
        return _gstlearn.TabNoStat_informDbIn(self, *args)

    def informDbOut(self, *args):
        r"""

        TabNoStat::informDbOut
        """
        return _gstlearn.TabNoStat_informDbOut(self, *args)

    def size(self):
        r"""

        TabNoStat::size
        """
        return _gstlearn.TabNoStat_size(self)

    def empty(self):
        r"""

        TabNoStat::empty
        """
        return _gstlearn.TabNoStat_empty(self)

    def updateDescription(self):
        r"""

        TabNoStat::updateDescription
        """
        return _gstlearn.TabNoStat_updateDescription(self)

    def getTable(self):
        r"""

        TabNoStat::getTable
        """
        return _gstlearn.TabNoStat_getTable(self)

    def isValid(self, econs):
        r"""

        TabNoStat::isValid
        """
        return _gstlearn.TabNoStat_isValid(self, econs)

    def addElem(self, nostat, econs, iv1=0, iv2=0):
        r"""

        TabNoStat::addElem
        """
        return _gstlearn.TabNoStat_addElem(self, nostat, econs, iv1, iv2)

    def removeElem(self, econs, iv1=0, iv2=0):
        r"""

        TabNoStat::removeElem
        """
        return _gstlearn.TabNoStat_removeElem(self, econs, iv1, iv2)

    def clear(self):
        r"""

        TabNoStat::clear
        """
        return _gstlearn.TabNoStat_clear(self)

    def setDbNoStatRef(self, *args):
        r"""

        TabNoStat::setDbNoStatRef
        """
        return _gstlearn.TabNoStat_setDbNoStatRef(self, *args)

    def getDbNoStatRef(self):
        r"""

        TabNoStat::getDbNoStatRef
        """
        return _gstlearn.TabNoStat_getDbNoStatRef(self)

    def getDbNoStatRefRaw(self):
        r"""

        TabNoStat::getDbNoStatRefRaw
        """
        return _gstlearn.TabNoStat_getDbNoStatRefRaw(self)

    def informCoords(self, coords, econs, iv1, iv2, result):
        r"""

        TabNoStat::informCoords
        """
        return _gstlearn.TabNoStat_informCoords(self, coords, econs, iv1, iv2, result)

    def toString(self, strfmt=None):
        r"""

        TabNoStat::toString
        """
        return _gstlearn.TabNoStat_toString(self, strfmt)

    def toStringInside(self, strfmt=None, i=0):
        r"""

        TabNoStat::toStringInside
        """
        return _gstlearn.TabNoStat_toStringInside(self, strfmt, i)

    def isElemDefined(self, econs, iv1=0, iv2=0):
        r"""

        TabNoStat::isElemDefined
        """
        return _gstlearn.TabNoStat_isElemDefined(self, econs, iv1, iv2)

    def getElem(self, econs, iv1=0, iv2=0):
        r"""

        TabNoStat::getElem
        """
        return _gstlearn.TabNoStat_getElem(self, econs, iv1, iv2)

    def __repr__(self):
        return _gstlearn.TabNoStat___repr__(self)

# Register TabNoStat in _gstlearn:
_gstlearn.TabNoStat_swigregister(TabNoStat)
class TabNoStatCovAniso(TabNoStat):
    r"""


    C++ includes: TabNoStatCovAniso.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.TabNoStatCovAniso_clone(self)

    def __init__(self, *args):
        r"""

        TabNoStatCovAniso::TabNoStatCovAniso
        """
        _gstlearn.TabNoStatCovAniso_swiginit(self, _gstlearn.new_TabNoStatCovAniso(*args))
    __swig_destroy__ = _gstlearn.delete_TabNoStatCovAniso

    def getNAngles(self):
        r"""

        TabNoStatCovAniso::getNAngles
        """
        return _gstlearn.TabNoStatCovAniso_getNAngles(self)

    def getNRanges(self):
        r"""

        TabNoStatCovAniso::getNRanges
        """
        return _gstlearn.TabNoStatCovAniso_getNRanges(self)

    def getNScales(self):
        r"""

        TabNoStatCovAniso::getNScales
        """
        return _gstlearn.TabNoStatCovAniso_getNScales(self)

    def isParam(self):
        r"""

        TabNoStatCovAniso::isParam
        """
        return _gstlearn.TabNoStatCovAniso_isParam(self)

    def isDefinedForTensor(self):
        r"""

        TabNoStatCovAniso::isDefinedForTensor
        """
        return _gstlearn.TabNoStatCovAniso_isDefinedForTensor(self)

    def isDefinedForAnisotropy(self):
        r"""

        TabNoStatCovAniso::isDefinedForAnisotropy
        Look if a Non-stationary parameter for Anisotropy is defined either by Tensor or
        by (angle/range/scale)  

        Returns
        -------  

        """
        return _gstlearn.TabNoStatCovAniso_isDefinedForAnisotropy(self)

    def isDefinedForRotation(self):
        r"""

        TabNoStatCovAniso::isDefinedForRotation
        """
        return _gstlearn.TabNoStatCovAniso_isDefinedForRotation(self)

    def addElem(self, nostat, econs, iv1=0, iv2=0):
        r"""

        TabNoStatCovAniso::addElem
        """
        return _gstlearn.TabNoStatCovAniso_addElem(self, nostat, econs, iv1, iv2)

    def removeElem(self, econs, iv1=0, iv2=0):
        r"""

        TabNoStatCovAniso::removeElem
        """
        return _gstlearn.TabNoStatCovAniso_removeElem(self, econs, iv1, iv2)

    def __repr__(self):
        return _gstlearn.TabNoStatCovAniso___repr__(self)

# Register TabNoStatCovAniso in _gstlearn:
_gstlearn.TabNoStatCovAniso_swigregister(TabNoStatCovAniso)
class TabNoStatSills(TabNoStat):
    r"""


    C++ includes: TabNoStatSills.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        TabNoStatSills::TabNoStatSills
        """
        _gstlearn.TabNoStatSills_swiginit(self, _gstlearn.new_TabNoStatSills(*args))
    __swig_destroy__ = _gstlearn.delete_TabNoStatSills

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.TabNoStatSills_clone(self)

    def isDefinedForVariance(self):
        r"""

        TabNoStatSills::isDefinedForVariance
        """
        return _gstlearn.TabNoStatSills_isDefinedForVariance(self)

    def getNSills(self):
        r"""

        TabNoStatSills::getNSills
        """
        return _gstlearn.TabNoStatSills_getNSills(self)

    def toString(self, strfmt=None):
        r"""

        TabNoStatSills::toString
        """
        return _gstlearn.TabNoStatSills_toString(self, strfmt)

    def toStringInside(self, strfmt=None, i=0):
        r"""

        TabNoStatSills::toStringInside
        """
        return _gstlearn.TabNoStatSills_toStringInside(self, strfmt, i)

    def __repr__(self):
        return _gstlearn.TabNoStatSills___repr__(self)

# Register TabNoStatSills in _gstlearn:
_gstlearn.TabNoStatSills_swigregister(TabNoStatSills)
class ANoStat(AStringable):
    r"""


    C++ includes: ANoStat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def getValueOnDbOut(self, iech):
        r"""

        ANoStat::getValueOnDbOut
        """
        return _gstlearn.ANoStat_getValueOnDbOut(self, iech)

    def getValueOnDbIn(self, iech):
        r"""

        ANoStat::getValueOnDbIn
        """
        return _gstlearn.ANoStat_getValueOnDbIn(self, iech)

    def getValueOnDb(self, iech, icas):
        r"""

        ANoStat::getValueOnDb
        """
        return _gstlearn.ANoStat_getValueOnDb(self, iech, icas)

    def getValuesOnDb(self, icas1, iech1, val1, icas2, iech2, val2):
        r"""

        ANoStat::getValuesOnDb
        """
        return _gstlearn.ANoStat_getValuesOnDb(self, icas1, iech1, val1, icas2, iech2, val2)

    def getValueOnMeshByMesh(self, imesh):
        r"""

        ANoStat::getValueOnMeshByMesh
        """
        return _gstlearn.ANoStat_getValueOnMeshByMesh(self, imesh)

    def getValueOnMeshByApex(self, iapex):
        r"""

        ANoStat::getValueOnMeshByApex
        """
        return _gstlearn.ANoStat_getValueOnMeshByApex(self, iapex)

    def getValueOnMesh(self, iapex, center=False):
        r"""

        ANoStat::getValueOnMesh
        """
        return _gstlearn.ANoStat_getValueOnMesh(self, iapex, center)

    def informField(self, coords, tab, verbose=False):
        r"""

        ANoStat::informField
        """
        return _gstlearn.ANoStat_informField(self, coords, tab, verbose)

    def informMeshByMesh(self, amesh, verbose=False):
        r"""

        ANoStat::informMeshByMesh
        """
        return _gstlearn.ANoStat_informMeshByMesh(self, amesh, verbose)

    def informMeshByApex(self, amesh, verbose=False):
        r"""

        ANoStat::informMeshByApex
        """
        return _gstlearn.ANoStat_informMeshByApex(self, amesh, verbose)

    def informDbIn(self, dbin, verbose=False):
        r"""

        ANoStat::informDbIn
        """
        return _gstlearn.ANoStat_informDbIn(self, dbin, verbose)

    def informDbOout(self, dbout, verbose=False):
        r"""

        ANoStat::informDbOout
        """
        return _gstlearn.ANoStat_informDbOout(self, dbout, verbose)

    def toString(self, strfmt=None):
        r"""

        ANoStat::toString
        """
        return _gstlearn.ANoStat_toString(self, strfmt)
    __swig_destroy__ = _gstlearn.delete_ANoStat

    def __repr__(self):
        return _gstlearn.ANoStat___repr__(self)

# Register ANoStat in _gstlearn:
_gstlearn.ANoStat_swigregister(ANoStat)
class NoStatArray(ANoStat):
    r"""


    C++ includes: NoStatArray.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        NoStatArray::NoStatArray
        """
        _gstlearn.NoStatArray_swiginit(self, _gstlearn.new_NoStatArray(*args))
    __swig_destroy__ = _gstlearn.delete_NoStatArray

    def toString(self, strfmt=None):
        r"""

        NoStatArray::toString
        """
        return _gstlearn.NoStatArray_toString(self, strfmt)

    def __repr__(self):
        return _gstlearn.NoStatArray___repr__(self)

# Register NoStatArray in _gstlearn:
_gstlearn.NoStatArray_swigregister(NoStatArray)
class NoStatFunctional(ANoStat):
    r"""


    This class concerns the non-stationarity defined as a function (hence its name).  

    C++ includes: NoStatFunctional.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, func):
        r"""

        NoStatFunctional::NoStatFunctional
        """
        _gstlearn.NoStatFunctional_swiginit(self, _gstlearn.new_NoStatFunctional(func))
    __swig_destroy__ = _gstlearn.delete_NoStatFunctional

    def toString(self, strfmt=None):
        r"""

        NoStatFunctional::toString
        """
        return _gstlearn.NoStatFunctional_toString(self, strfmt)

    def __repr__(self):
        return _gstlearn.NoStatFunctional___repr__(self)

# Register NoStatFunctional in _gstlearn:
_gstlearn.NoStatFunctional_swigregister(NoStatFunctional)
class ACov(ICloneable, AStringable):
    r"""


    Class containing the Covariance part of the Model.  

    It is the uppermost class of the Covariance Tree and is conceived as simple as
    possible on purpose (in order to let the user defined its own version if
    necessary): it must simply be able to return its value between two end-point
    (see eval method).  

    It is mainly implemented in CovAniso.hpp or CovAnisoList.hpp  

    C++ includes: ACov.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        ACov::ACov
        """
        if self.__class__ == ACov:
            _self = None
        else:
            _self = self
        _gstlearn.ACov_swiginit(self, _gstlearn.new_ACov(_self, *args))
    __swig_destroy__ = _gstlearn.delete_ACov

    def getNVar(self):
        r"""

        ACov::getNVar
        ACov Interface.  

        """
        return _gstlearn.ACov_getNVar(self)

    def isIndexable(self):
        r"""

        ACov::isIndexable
        """
        return _gstlearn.ACov_isIndexable(self)

    def isNoStat(self):
        r"""

        ACov::isNoStat
        """
        return _gstlearn.ACov_isNoStat(self)

    def getContext(self):
        r"""

        ACov::getContext
        """
        return _gstlearn.ACov_getContext(self)

    def setContext(self, ctxt):
        r"""

        ACov::setContext
        """
        return _gstlearn.ACov_setContext(self, ctxt)

    def updateFromContext(self):
        r"""

        ACov::updateFromContext
        """
        return _gstlearn.ACov_updateFromContext(self)

    def copyCovContext(self, ctxt):
        r"""

        ACov::copyCovContext
        """
        return _gstlearn.ACov_copyCovContext(self, ctxt)

    def initFromContext(self):
        r"""

        ACov::initFromContext
        """
        return _gstlearn.ACov_initFromContext(self)

    def getContextCopy(self):
        r"""

        ACov::getContextCopy
        """
        return _gstlearn.ACov_getContextCopy(self)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        ACov::eval0
        Calculate the covariance between two variables for 0-distance (stationary case)  

        """
        return _gstlearn.ACov_eval0(self, ivar, jvar, mode)

    def evalCov(self, p1, p2, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalCov
        Calculate the covariance between two variables and two points (general case)  

        """
        return _gstlearn.ACov_evalCov(self, p1, p2, ivar, jvar, mode)

    def evalCovGrad(self, p1, p2, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalCovGrad
        """
        return _gstlearn.ACov_evalCovGrad(self, p1, p2, ivar, jvar, mode)

    def evalCovOnSphere(self, alpha, degree=50, flagScaleDistance=False, mode=None):
        r"""

        ACov::evalCovOnSphere
        """
        return _gstlearn.ACov_evalCovOnSphere(self, alpha, degree, flagScaleDistance, mode)

    def evalSpectrumOnSphere(self, n, flagNormDistance=False, flagCumul=False):
        r"""

        ACov::evalSpectrumOnSphere
        """
        return _gstlearn.ACov_evalSpectrumOnSphere(self, n, flagNormDistance, flagCumul)

    def evalSpectrum(self, freq, ivar, jvar):
        r"""

        ACov::evalSpectrum
        """
        return _gstlearn.ACov_evalSpectrum(self, freq, ivar, jvar)

    def attachNoStatDb(self, db):
        r"""

        ACov::attachNoStatDb
        """
        return _gstlearn.ACov_attachNoStatDb(self, db)

    def getSpace(self):
        r"""

        ACov::getSpace
        """
        return _gstlearn.ACov_getSpace(self)

    def isConsistent(self, space):
        r"""

        ACov::isConsistent
        """
        return _gstlearn.ACov_isConsistent(self, space)

    def isOptimEnabled(self):
        r"""

        ACov::isOptimEnabled
        Functions linked to Optimization during Covariance calculations.  

        """
        return _gstlearn.ACov_isOptimEnabled(self)

    def optimizationPreProcess(self, mode, ps):
        r"""

        ACov::optimizationPreProcess
        """
        return _gstlearn.ACov_optimizationPreProcess(self, mode, ps)

    def optimizationLoadInPlace(self, iech, mode, rank):
        r"""

        ACov::optimizationLoadInPlace
        """
        return _gstlearn.ACov_optimizationLoadInPlace(self, iech, mode, rank)

    def optimizationPostProcess(self):
        r"""

        ACov::optimizationPostProcess
        """
        return _gstlearn.ACov_optimizationPostProcess(self)

    def optimizationSetTarget(self, pt):
        r"""

        ACov::optimizationSetTarget
        """
        return _gstlearn.ACov_optimizationSetTarget(self, pt)

    def eval(self, vec_p1, vec_p2, ivar=0, jvar=0, mode=None):
        r"""

        ACov::eval
        Functions for evaluating Covariances.  

        """
        return _gstlearn.ACov_eval(self, vec_p1, vec_p2, ivar, jvar, mode)

    def eval0Mat(self, mode=None):
        r"""

        ACov::eval0Mat
        """
        return _gstlearn.ACov_eval0Mat(self, mode)

    def evalCovMat0(self, *args, **kwargs):
        r"""

        ACov::evalCovMat0
        Functions for evaluating Covariance Matrices either in place or not.  

        """
        return _gstlearn.ACov_evalCovMat0(self, *args, **kwargs)

    def evalCovMat(self, *args, **kwargs):
        r"""

        ACov::evalCovMat
        Establish the covariance matrix between two Dbs Takes into account selection and
        heterotopy  

        Returns
        -------
        Dense matrix containing the covariance matrix  

        Parameters
        ----------
        * `db1` :  
            First Db  
        * `db2` :  
            Second Db (= db1 if absent)  
        * `ivar0` :  
            Rank of the first variable (-1 for all variables)  
        * `jvar0` :  
            Rank of the second variable (-1 for all variables)  
        * `nbgh1` :  
            Vector of indices of active samples in db1 (optional)  
        * `nbgh2` :  
            Vector of indices of active samples in db2 (optional)  
        * `mode` :  
            CovCalcMode structure  
        * `cleanOptim` :  
            When True, clean optimization internal when ended  

        remark: If a Db does not contain any Z-variable defined, the covariance  

        remark: cannot treat possible heterotopy and therefore uses all samples  

        remark: The returned matrix if dimension to nrows * ncols where  

        remark: each term is the product of the number of active samples  

        remark: by the number of samples where the variable is defined  

        note: 'dbin' and 'dbout' cannot be made 'const' as they can be updated  

        note: due to the presence of 'nostat'  

        """
        return _gstlearn.ACov_evalCovMat(self, *args, **kwargs)

    def evalCovMatSym(self, *args, **kwargs):
        r"""

        ACov::evalCovMatSym
        Establish the covariance matrix within a Db Takes into account selection and
        heterotopy This method takes advantage of calculating covariance between a Db
        and itself  

        Returns
        -------
        Dense matrix containing the covariance matrix  

        Parameters
        ----------
        * `db1` :  
            First Db  
        * `ivar0` :  
            Rank of the first variable (-1 for all variables)  
        * `nbgh1` :  
            Vector of indices of active samples in db1 (optional)  
        * `mode` :  
            CovCalcMode structure  
        * `cleanOptim` :  
            When True, clean optimization internal arrays at end  

        remark: If a Db does not contain any Z-variable defined, the covariance  

        remark: cannot treat possible heterotopy and therefore uses all samples  

        remark: The returned matrix if dimension to nrows * ncols where  

        remark: each term is the product of the number of active samples  

        remark: by the number of samples where the variable is defined  

        """
        return _gstlearn.ACov_evalCovMatSym(self, *args, **kwargs)

    def evalCovMatSparse(self, *args, **kwargs):
        r"""

        ACov::evalCovMatSparse
        Establish the covariance matrix between two Dbs where samples are selected by
        ranks The output is stored in a Sparse Matrix  

        Returns
        -------
        Sparse matrix containing the covariance matrix  

        Parameters
        ----------
        * `db1` :  
            First Db  
        * `db2` :  
            Second Db  
        * `ivar0` :  
            Rank of the first variable (-1: all variables)  
        * `jvar0` :  
            Rank of the second variable (-1: all variables)  
        * `nbgh1` :  
            Array giving ranks of selected samples (optional)  
        * `nbgh2` :  
            Array giving ranks of selected samples (optional)  
        * `mode` :  
            CovCalcMode structure  
        * `cleanOptim` :  
            When True, clean optimization internal when ended  
        * `eps` :  
            Tolerance for discarding a covariance value  

        remark: The covariance matrix (returned) must be freed by calling routine  

        remark: The covariance matrix is established for the first variable  

        remark: and returned as a covariance  

        remark: As the ranks are used, no test is performed on any selection  

        remark: but only ranks positive or null are considered  

        """
        return _gstlearn.ACov_evalCovMatSparse(self, *args, **kwargs)

    def evalCovMat0InPlace(self, *args, **kwargs):
        r"""

        ACov::evalCovMat0InPlace
        """
        return _gstlearn.ACov_evalCovMat0InPlace(self, *args, **kwargs)

    def evalCovMatInPlace(self, *args, **kwargs):
        r"""

        ACov::evalCovMatInPlace
        """
        return _gstlearn.ACov_evalCovMatInPlace(self, *args, **kwargs)

    def evalCovMatSymInPlace(self, *args, **kwargs):
        r"""

        ACov::evalCovMatSymInPlace
        """
        return _gstlearn.ACov_evalCovMatSymInPlace(self, *args, **kwargs)

    def evalCovMatInPlaceFromIdx(self, *args, **kwargs):
        r"""

        ACov::evalCovMatInPlaceFromIdx
        """
        return _gstlearn.ACov_evalCovMatInPlaceFromIdx(self, *args, **kwargs)

    def evalCovMatSymInPlaceFromIdx(self, mat, db1, index1, mode=None, cleanOptim=True):
        r"""

        ACov::evalCovMatSymInPlaceFromIdx
        """
        return _gstlearn.ACov_evalCovMatSymInPlaceFromIdx(self, mat, db1, index1, mode, cleanOptim)

    def evalCovMatRHSInPlaceFromIdx(self, *args, **kwargs):
        r"""

        ACov::evalCovMatRHSInPlaceFromIdx
        Establish covariance matrix between one Db and one sample of a Target Db  

        Returns
        -------
        Dense matrix containing the covariance matrix  

        Parameters
        ----------
        * `mat` :  
            Matrix (possibly resized)  
        * `db1` :  
            First Db  
        * `db2` :  
            Second Db  
        * `index1` :  
            Vector of vector indices of active samples in db1  
        * `iech2` :  
            Sample rank within db2  
        * `krigopt` :  
            KrigOpt structure  
        * `cleanOptim` :  
            When True, clean optimization internal when ended  

        remark: If a Db does not contain any Z-variable defined, the covariance  

        remark: cannot treat possible heterotopy and therefore uses all samples  

        remark: The returned matrix if dimension to nrows * 1 where  

        remark: each 'nrows' is the number of active samples  

        remark: by the number of samples where the variable is defined  

        note: 'dbin' and 'dbout' cannot be made 'const' as they can be updated  

        note: due to the presence of 'nostat'  

        """
        return _gstlearn.ACov_evalCovMatRHSInPlaceFromIdx(self, *args, **kwargs)

    def eval0CovMatBiPointInPlace(self, mat, mode):
        r"""

        ACov::eval0CovMatBiPointInPlace
        Calculate the Matrix of covariance for zero distance  

        Parameters
        ----------
        * `mat` :  
            Covariance matrix (Dimension: nvar * nvar)  
        * `mode` :  
            Calculation Options  

        remark: : Matrix 'mat' should be dimensioned and initialized beforehand  

        """
        return _gstlearn.ACov_eval0CovMatBiPointInPlace(self, mat, mode)

    def evalIvarIpas(self, *args, **kwargs):
        r"""

        ACov::evalIvarIpas
        Covariance from a given point (center) in a given direction (dir *step)  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `step` :  
            Step value  
        * `dir` :  
            Direction definition  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalIvarIpas(self, *args, **kwargs)

    def evalIvarIpasIncr(self, dincr, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalIvarIpasIncr
        """
        return _gstlearn.ACov_evalIvarIpasIncr(self, dincr, ivar, jvar, mode)

    def evalIvarNlag(self, *args, **kwargs):
        r"""

        ACov::evalIvarNlag
        Covariance vector from a given point (center) in a given direction (dir * steps)
        for a pair of variables and a set of steps  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `vec_step` :  
            Vector of step values  
        * `dir` :  
            Direction definition  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalIvarNlag(self, *args, **kwargs)

    def evalNvarIpas(self, *args, **kwargs):
        r"""

        ACov::evalNvarIpas
        Covariance Matrix from a given point (center) in a given direction (dir * step)
        for a set of variables and a given step  

        Parameters
        ----------
        * `step` :  
            Step value  
        * `dir` :  
            Direction definition  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalNvarIpas(self, *args, **kwargs)

    def evalNvarIpasIncr(self, dincr, mode=None):
        r"""

        ACov::evalNvarIpasIncr
        """
        return _gstlearn.ACov_evalNvarIpasIncr(self, dincr, mode)

    def evalIsoIvarIpas(self, step, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalIsoIvarIpas
        Covariance for a given unit global distance (without anisotropy) for a pair of
        variables and a single step  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `step` :  
            Step value  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        TODO : Not true whatever the space  

        """
        return _gstlearn.ACov_evalIsoIvarIpas(self, step, ivar, jvar, mode)

    def evalIsoIvarNlag(self, vec_step, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalIsoIvarNlag
        Covariance for a given unit global distance (without anisotropy) for a pair of
        variables and a set of steps  

        Parameters
        ----------
        * `ivar` :  
        * `jvar` :  
        * `vec_step` :  
        * `mode` :  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalIsoIvarNlag(self, vec_step, ivar, jvar, mode)

    def evalIsoNvarIpas(self, step, mode=None):
        r"""

        ACov::evalIsoNvarIpas
        Covariance for a given unit global distance (without anisotropy) for a set of
        variables and a single step  

        Parameters
        ----------
        * `step` :  
            Step value  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalIsoNvarIpas(self, step, mode)

    def evalCvv(self, *args, **kwargs):
        r"""

        ACov::evalCvv
        Average covariance over a block  

        Parameters
        ----------
        * `ext` :  
            Vector of Block extensions  
        * `ndisc` :  
            Vector of Block discretization  
        * `angles` :  
            Vector of rotation angles  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalCvv(self, *args, **kwargs)

    def evalCvvShift(self, *args, **kwargs):
        r"""

        ACov::evalCvvShift
        Average covariance between a block and the same block shifted  

        Parameters
        ----------
        * `ext` :  
            Vector of Block extensions  
        * `ndisc` :  
            Vector of Block discretization  
        * `angles` :  
            Vector of rotation angles  
        * `shift` :  
            Shift between the two blocks  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalCvvShift(self, *args, **kwargs)

    def evalCvvM(self, *args, **kwargs):
        r"""

        ACov::evalCvvM
        """
        return _gstlearn.ACov_evalCvvM(self, *args, **kwargs)

    def evalCxv(self, *args):
        r"""

        ACov::evalCxv
        """
        return _gstlearn.ACov_evalCxv(self, *args)

    def evalCxvM(self, *args, **kwargs):
        r"""

        ACov::evalCxvM
        """
        return _gstlearn.ACov_evalCxvM(self, *args, **kwargs)

    def evalPointToDb(self, *args, **kwargs):
        r"""

        ACov::evalPointToDb
        Calculate the Covariance vector between a Point and all the samples of a Db, for
        a pair of variables  

        Parameters
        ----------
        * `values` :  
            Array of returned values (possible resized)  
        * `p1` :  
            Point location  
        * `db2` :  
            Pointer to the second Db  
        * `ivar` :  
            Rank of the first variables  
        * `jvar` :  
            Rank of the second variable  
        * `useSel` :  
            When TRUE, the returned vector is reduced to active samples Otherwise,
            returns TEST for masked samples  
        * `nbgh2` :  
            Vector of indices of active samples in db2 (optional)  
        * `mode` :  
            CovCalcMode structure  

        """
        return _gstlearn.ACov_evalPointToDb(self, *args, **kwargs)

    def evalPointToDbAsSP(self, values, p1s, p2, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalPointToDbAsSP
        """
        return _gstlearn.ACov_evalPointToDbAsSP(self, values, p1s, p2, ivar, jvar, mode)

    def evalAverageDbToDb(self, db1, db2, ivar=0, jvar=0, eps=0., seed=434132, mode=None):
        r"""

        ACov::evalAverageDbToDb
        Calculate the (weighted) average Covariance between samples of two Dbs, for a
        pair of variables  

        Parameters
        ----------
        * `db1` :  
            Pointer to the first Db  
        * `db2` :  
            Pointer to the second Db  
        * `ivar` :  
            Rank of the first variables  
        * `jvar` :  
            Rank of the second variable  
        * `eps` :  
            Epsilon used for randomization in calculation of CVV (optional)  
        * `seed` :  
            Seed for the randomization  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalAverageDbToDb(self, db1, db2, ivar, jvar, eps, seed, mode)

    def evalAverageIncrToIncr(self, d1, d2, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalAverageIncrToIncr
        """
        return _gstlearn.ACov_evalAverageIncrToIncr(self, d1, d2, ivar, jvar, mode)

    def evalAveragePointToDb(self, p1, db2, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evalAveragePointToDb
        Calculate the (weighted) average Covariance between a point and a Db for a pair
        of variables  

        Parameters
        ----------
        * `p1` :  
            Point location  
        * `db2` :  
            Pointer to the second Db  
        * `ivar` :  
            Rank of the first variables  
        * `jvar` :  
            Rank of the second variable  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_evalAveragePointToDb(self, p1, db2, ivar, jvar, mode)

    def extensionVariance(self, *args, **kwargs):
        r"""

        ACov::extensionVariance
        Variance of Extension of a set of points and the block  

        Parameters
        ----------
        * `db` :  
            Reference Data Base  
        * `ext` :  
            Vector giving the extensions of the target block  
        * `ndisc` :  
            Vector giving the discretization  
        * `angles` :  
            Vector for the rotation angles of the block (optional)  
        * `x0` :  
            Optional origin of the Block  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        Returns
        -------  

        """
        return _gstlearn.ACov_extensionVariance(self, *args, **kwargs)

    def samplingDensityVariance(self, *args, **kwargs):
        r"""

        ACov::samplingDensityVariance
        Calculate the Sampling Density Variance  

        Parameters
        ----------
        * `db` :  
            Set of data points  
        * `ext` :  
            Block extension  
        * `ndisc` :  
            Discretization  
        * `angles` :  
            Optional rotation angles for the Block  
        * `x0` :  
            Optional origin of the block  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        Returns
        -------  

        """
        return _gstlearn.ACov_samplingDensityVariance(self, *args, **kwargs)

    def specificVolume(self, *args, **kwargs):
        r"""

        ACov::specificVolume
        Calculate the Specific Volume  

        Parameters
        ----------
        * `db` :  
            Set of data points  
        * `mean` :  
            Value of the Mean  
        * `ext` :  
            Target Block extension  
        * `ndisc` :  
            Vector of discretization  
        * `angles` :  
            Optional rotation angle for block  
        * `x0` :  
            Optional origin of the Block  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        Returns
        -------  

        """
        return _gstlearn.ACov_specificVolume(self, *args, **kwargs)

    def coefficientOfVariation(self, *args, **kwargs):
        r"""

        ACov::coefficientOfVariation
        Calculate the Coefficient of Variation  

        Parameters
        ----------
        * `db` :  
            Set of data points  
        * `volume` :  
            Specific production volume  
        * `mean` :  
            Value of the Mean  
        * `ext` :  
            Target Block extension  
        * `ndisc` :  
            Vector of discretization  
        * `angles` :  
            Optional rotation angle for block  
        * `x0` :  
            Optional origin of the Block  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        Returns
        -------  

        """
        return _gstlearn.ACov_coefficientOfVariation(self, *args, **kwargs)

    def specificVolumeFromCoV(self, *args, **kwargs):
        r"""

        ACov::specificVolumeFromCoV
        Derive the Specific volume for a given CoV  

        Parameters
        ----------
        * `db` :  
            Set of data points  
        * `cov` :  
            Target Coefficient of Variation  
        * `mean` :  
            Value of the Mean  
        * `ext` :  
            Target Block extension  
        * `ndisc` :  
            Vector of discretization  
        * `angles` :  
            Optional rotation angle for block  
        * `x0` :  
            Optional origin of the Block  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        Returns
        -------  

        """
        return _gstlearn.ACov_specificVolumeFromCoV(self, *args, **kwargs)

    def evaluateOneGeneric(self, *args, **kwargs):
        r"""

        ACov::evaluateOneGeneric
        Returns the covariance for an increment This is the generic internal function It
        can be called for stationary or non-stationary case  

        Parameters
        ----------
        * `covint` :  
            Internal structure for non-stationarityAddress for the next term after the
            drift or NULL (for stationary case)  
        * `mode` :  
            CovCalcMode structure  
        * `weight` :  
            Multiplicative weight  
        * `d1` :  
            Distance vector  

        """
        return _gstlearn.ACov_evaluateOneGeneric(self, *args, **kwargs)

    def calculateStDev(self, db1, iech1, db2, iech2, verbose=False, factor=1., mode=None):
        r"""

        ACov::calculateStDev
        Returns the standard deviation at a given increment for a given model between
        two samples of two Dbs  

        Parameters
        ----------
        * `db1` :  
            First Db  
        * `iech1` :  
            Rank in the first Db  
        * `db2` :  
            Second Db  
        * `iech2` :  
            Rank in the second Db  
        * `verbose` :  
            Verbose flag  
        * `factor` :  
            Multiplicative factor for standard deviation  
        * `mode` :  
            CovCalcMode structure  

        """
        return _gstlearn.ACov_calculateStDev(self, db1, iech1, db2, iech2, verbose, factor, mode)

    def evaluateMatInPlace(self, covint, d1, covtab, flag_init=False, weight=1., mode=None):
        r"""

        ACov::evaluateMatInPlace
        Returns the covariances for an increment This is the generic internal function
        It can be called for stationary or non-stationary case  

        Parameters
        ----------
        * `covint` :  
            Internal structure for non-stationarityAddress for the next term after the
            drift or NULL (for stationary case)  
        * `mode` :  
            CovCalcMode structure  
        * `flag_init` :  
            Initialize the array beforehand  
        * `weight` :  
            Multiplicative weight  
        * `d1` :  
            Distance vector  
        * `covtab` :  
            Covariance array  

        """
        return _gstlearn.ACov_evaluateMatInPlace(self, covint, d1, covtab, flag_init, weight, mode)

    def evaluateFromDb(self, db, ivar=0, jvar=0, mode=None):
        r"""

        ACov::evaluateFromDb
        Evaluate the model on a Db  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `mode` :  
            CovCalcMode structure  

        """
        return _gstlearn.ACov_evaluateFromDb(self, db, ivar, jvar, mode)

    def evaluateOneIncr(self, *args, **kwargs):
        r"""

        ACov::evaluateOneIncr
        Calculate the value of the model for a set of distances  

        Returns
        -------
        The model value  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `mode` :  
            CovCalcMode structure  
        * `codir` :  
            Array giving the direction coefficients (optional)  
        * `hh` :  
            Vector of increments  

        """
        return _gstlearn.ACov_evaluateOneIncr(self, *args, **kwargs)

    def sample(self, *args, **kwargs):
        r"""

        ACov::sample
        Calculate the value of the model for a set of distances  

        Returns
        -------
        Array containing the model values  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `codir` :  
            Array giving the direction coefficients (optional)  
        * `h` :  
            Vector of increments  
        * `mode` :  
            CovCalcMode structure  
        * `covint` :  
            Non-stationary parameters  

        """
        return _gstlearn.ACov_sample(self, *args, **kwargs)

    def sampleUnitary(self, *args, **kwargs):
        r"""

        ACov::sampleUnitary
        Returns the value of the normalized covariance (by the variance/covariance
        value) for a given pair of variables  

        Parameters
        ----------
        * `hh` :  
            Vector of distances  
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  
        * `codir` :  
            Direction coefficients  
        * `mode` :  
            CovCalcMode structure  

        Returns
        -------  

        """
        return _gstlearn.ACov_sampleUnitary(self, *args, **kwargs)

    def envelop(self, *args, **kwargs):
        r"""

        ACov::envelop
        """
        return _gstlearn.ACov_envelop(self, *args, **kwargs)

    def buildVmapOnDbGrid(self, *args, **kwargs):
        r"""

        ACov::buildVmapOnDbGrid
        Calculate the variogram map from a Model (presented as Variogram, not
        Covariance)  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `dbgrid` :  
            Grid structure  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.ACov_buildVmapOnDbGrid(self, *args, **kwargs)

    def gofToVario(self, vario, verbose=True):
        r"""

        ACov::gofToVario
        Evaluate the Goodness-of_fit of the Model on the Experimental Variogram It is
        expressed as the average departure between Model and Variogram scaled to the
        variance. As this variance may be poorly calculated (< gmax / 5), it may be
        replaced by the largest value (gmax) divided by 2 (highly non_stationary cases).  

        Parameters
        ----------
        * `vario` :  
            Experimental variogram  
        * `verbose` :  
            Verbose flag  

        Returns
        -------
        Value for the Goodness-of_fit (as percentage of the total sill)  

        """
        return _gstlearn.ACov_gofToVario(self, vario, verbose)

    @staticmethod
    def gofDisplay(*args, **kwargs):
        r"""

        ACov::gofDisplay
        Printout of statement concerning the Quality of the GOF  

        Parameters
        ----------
        * `gof` :  
            Value of the Gof  
        * `byValue` :  
            true: display GOF value; false: print its quality level  
        * `thresholds` :  
            Vector giving the Quality thresholds  

        """
        return _gstlearn.ACov_gofDisplay(*args, **kwargs)

    def manage(self, db1, db2):
        r"""

        ACov::manage
        """
        return _gstlearn.ACov_manage(self, db1, db2)

    def load(self, p, case1):
        r"""

        ACov::load
        """
        return _gstlearn.ACov_load(self, p, case1)

    def updateCovByMesh(self, imesh, aniso=True):
        r"""

        ACov::updateCovByMesh
        """
        return _gstlearn.ACov_updateCovByMesh(self, imesh, aniso)

    def getValue(self, econs, iv1, iv2):
        r"""

        ACov::getValue
        """
        return _gstlearn.ACov_getValue(self, econs, iv1, iv2)

    def makeStationary(self):
        r"""

        ACov::makeStationary
        """
        return _gstlearn.ACov_makeStationary(self)

    def makeElemNoStat(self, *args, **kwargs):
        r"""

        ACov::makeElemNoStat
        """
        return _gstlearn.ACov_makeElemNoStat(self, *args, **kwargs)

    def createNoStatTab(self):
        r"""

        ACov::createNoStatTab
        """
        return _gstlearn.ACov_createNoStatTab(self)

    def informMeshByMesh(self, amesh):
        r"""

        ACov::informMeshByMesh
        """
        return _gstlearn.ACov_informMeshByMesh(self, amesh)

    def informMeshByApex(self, amesh):
        r"""

        ACov::informMeshByApex
        """
        return _gstlearn.ACov_informMeshByApex(self, amesh)

    def informCoords(self, coords, econs, iv1=0, iv2=0):
        r"""

        ACov::informCoords
        """
        return _gstlearn.ACov_informCoords(self, coords, econs, iv1, iv2)

    def informDbIn(self, dbin):
        r"""

        ACov::informDbIn
        """
        return _gstlearn.ACov_informDbIn(self, dbin)

    def informDbOut(self, dbout):
        r"""

        ACov::informDbOut
        """
        return _gstlearn.ACov_informDbOut(self, dbout)

    def updateCovByPoints(self, *args):
        r"""

        ACov::updateCovByPoints
        """
        return _gstlearn.ACov_updateCovByPoints(self, *args)

    def getNDim(self, ispace=-1):
        r"""

        ACov::getNDim
        """
        return _gstlearn.ACov_getNDim(self, ispace)

    def optimizationPreProcessForData(self, db1=None):
        r"""

        ACov::optimizationPreProcessForData
        """
        return _gstlearn.ACov_optimizationPreProcessForData(self, db1)

    def setOptimEnabled(self, enabled):
        r"""

        ACov::setOptimEnabled
        """
        return _gstlearn.ACov_setOptimEnabled(self, enabled)

    def checkAndManageNoStatDb(self, db, namecol):
        r"""

        ACov::checkAndManageNoStatDb
        """
        return _gstlearn.ACov_checkAndManageNoStatDb(self, db, namecol)

    def getDbNoStat(self):
        r"""

        ACov::getDbNoStat
        """
        return _gstlearn.ACov_getDbNoStat(self)

    def getDbNoStatRaw(self):
        r"""

        ACov::getDbNoStatRaw
        """
        return _gstlearn.ACov_getDbNoStatRaw(self)

    def setNoStatDbIfNecessary(self, *args):
        r"""

        ACov::setNoStatDbIfNecessary
        """
        return _gstlearn.ACov_setNoStatDbIfNecessary(self, *args)

    def appendParams(self, listParams, gradFuncs=None):
        r"""

        ACov::appendParams
        """
        return _gstlearn.ACov_appendParams(self, listParams, gradFuncs)

    def updateCov(self):
        r"""

        ACov::updateCov
        """
        return _gstlearn.ACov_updateCov(self)

    def initParams(self, vars, href=1.):
        r"""

        ACov::initParams
        """
        return _gstlearn.ACov_initParams(self, vars, href)

    def _optimizationSetTarget(self, pt):
        return _gstlearn.ACov__optimizationSetTarget(self, pt)

    def _optimizationPreProcess(self, mode, ps):
        return _gstlearn.ACov__optimizationPreProcess(self, mode, ps)

    def _optimizationLoadInPlace(self, iech, mode, rank):
        return _gstlearn.ACov__optimizationLoadInPlace(self, iech, mode, rank)

    def _initFromContext(self):
        return _gstlearn.ACov__initFromContext(self)

    def _isOptimEnabled(self):
        return _gstlearn.ACov__isOptimEnabled(self)

    def _eval(self, p1, p2, ivar=0, jvar=0, mode=None):
        return _gstlearn.ACov__eval(self, p1, p2, ivar, jvar, mode)

    def __repr__(self):
        return _gstlearn.ACov___repr__(self)
    def __disown__(self):
        self.this.disown()
        _gstlearn.disown_ACov(self)
        return weakref.proxy(self)

# Register ACov in _gstlearn:
_gstlearn.ACov_swigregister(ACov)
class CovBase(ACov):
    r"""


    C++ includes: CovBase.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovBase::CovBase
        """
        _gstlearn.CovBase_swiginit(self, _gstlearn.new_CovBase(*args))
    __swig_destroy__ = _gstlearn.delete_CovBase

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovBase_clone(self)

    @staticmethod
    def createParamInfoForCholSill():
        r"""

        CovBase::createParamInfoForCholSill
        """
        return _gstlearn.CovBase_createParamInfoForCholSill()

    def isConsistent(self, space):
        r"""

        CovBase::isConsistent
        """
        return _gstlearn.CovBase_isConsistent(self, space)

    def getNVar(self):
        r"""

        CovBase::getNVar
        ACov Interface.  

        """
        return _gstlearn.CovBase_getNVar(self)

    def isOptimizationInitialized(self, db=None):
        r"""

        CovBase::isOptimizationInitialized
        Checks that the Optimization has already been initiated, by:  

        *   checking that the storage (for Sample Points projected in the Covariance
            rotation system) is already allocated  
        *   checking that the dimension of this storage is correct (only if 'db' is
            provided): in particular, this check is not necessary when freeing this
            storage.  

        """
        return _gstlearn.CovBase_isOptimizationInitialized(self, db)

    def setCholSill(self, ivar, jvar, val):
        r"""

        CovBase::setCholSill
        """
        return _gstlearn.CovBase_setCholSill(self, ivar, jvar, val)

    def setSill(self, *args):
        r"""

        CovBase::setSill
        TODO : Test if sill matrix is positive definite (if not, generate a warning)  

        """
        return _gstlearn.CovBase_setSill(self, *args)

    def initSill(self, value=0.):
        r"""

        CovBase::initSill
        """
        return _gstlearn.CovBase_initSill(self, value)

    def setCor(self, cor):
        r"""

        CovBase::setCor
        """
        return _gstlearn.CovBase_setCor(self, cor)

    def getCor(self):
        r"""

        CovBase::getCor
        """
        return _gstlearn.CovBase_getCor(self)

    def getSill(self, *args):
        r"""

        CovBase::getSill
        """
        return _gstlearn.CovBase_getSill(self, *args)

    def makeSillNoStatDb(self, namecol, ivar=0, jvar=0, db=None):
        r"""

        CovBase::makeSillNoStatDb
        """
        return _gstlearn.CovBase_makeSillNoStatDb(self, namecol, ivar, jvar, db)

    def makeSillStationary(self, ivar=0, jvar=0):
        r"""

        CovBase::makeSillStationary
        """
        return _gstlearn.CovBase_makeSillStationary(self, ivar, jvar)

    def makeSillsStationary(self, silent=False):
        r"""

        CovBase::makeSillsStationary
        """
        return _gstlearn.CovBase_makeSillsStationary(self, silent)

    def makeSillNoStatFunctional(self, func, ivar=0, jvar=0):
        r"""

        CovBase::makeSillNoStatFunctional
        """
        return _gstlearn.CovBase_makeSillNoStatFunctional(self, func, ivar, jvar)

    def getTabNoStatSills(self):
        r"""

        CovBase::getTabNoStatSills
        """
        return _gstlearn.CovBase_getTabNoStatSills(self)

    def getNSills(self):
        r"""

        CovBase::getNSills
        """
        return _gstlearn.CovBase_getNSills(self)

    def isNoStatForVariance(self):
        r"""

        CovBase::isNoStatForVariance
        """
        return _gstlearn.CovBase_isNoStatForVariance(self)

    def informMeshByMesh(self, amesh):
        r"""

        CovBase::informMeshByMesh
        """
        return _gstlearn.CovBase_informMeshByMesh(self, amesh)

    def informMeshByApex(self, amesh):
        r"""

        CovBase::informMeshByApex
        """
        return _gstlearn.CovBase_informMeshByApex(self, amesh)

    def informCoords(self, coords, econs, iv1=0, iv2=0):
        r"""

        CovBase::informCoords
        """
        return _gstlearn.CovBase_informCoords(self, coords, econs, iv1, iv2)

    def informDbIn(self, dbin):
        r"""

        CovBase::informDbIn
        """
        return _gstlearn.CovBase_informDbIn(self, dbin)

    def informDbOut(self, dbout):
        r"""

        CovBase::informDbOut
        """
        return _gstlearn.CovBase_informDbOut(self, dbout)

    def informMeshByMeshForSills(self, amesh):
        r"""

        CovBase::informMeshByMeshForSills
        """
        return _gstlearn.CovBase_informMeshByMeshForSills(self, amesh)

    def informMeshByApexForSills(self, amesh):
        r"""

        CovBase::informMeshByApexForSills
        """
        return _gstlearn.CovBase_informMeshByApexForSills(self, amesh)

    def informDbInForSills(self, dbin):
        r"""

        CovBase::informDbInForSills
        """
        return _gstlearn.CovBase_informDbInForSills(self, dbin)

    def informDbOutForSills(self, dbout):
        r"""

        CovBase::informDbOutForSills
        """
        return _gstlearn.CovBase_informDbOutForSills(self, dbout)

    def updateCovByPoints(self, icas1, iech1, icas2, iech2):
        r"""

        CovBase::updateCovByPoints
        Tell if the use of Optimization is enabled or not.  

        Update the Model according to the Non-stationary parameters  

        Parameters
        ----------
        * `icas1` :  
            Type of first Db: 1 for Input; 2 for Output  
        * `iech1` :  
            Rank of the target within Db1 (or -1)  
        * `icas2` :  
            Type of first Db: 1 for Input; 2 for Output  
        * `iech2` :  
            Rank of the target within Dbout (or -2)  

        """
        return _gstlearn.CovBase_updateCovByPoints(self, icas1, iech1, icas2, iech2)

    def updateCovByMesh(self, imesh, aniso=True):
        r"""

        CovBase::updateCovByMesh
        """
        return _gstlearn.CovBase_updateCovByMesh(self, imesh, aniso)

    def getValue(self, econs, iv1, iv2):
        r"""

        CovBase::getValue
        """
        return _gstlearn.CovBase_getValue(self, econs, iv1, iv2)

    def nostatUpdate(self, covint):
        r"""

        CovBase::nostatUpdate
        Update the Model in the case of Non-stationary parameters This requires the
        knowledge of the two end-points  

        Parameters
        ----------
        * `covint` :  
            Internal structure for non-stationarity or NULL (for stationary case)  

        """
        return _gstlearn.CovBase_nostatUpdate(self, covint)

    def setOptimEnabled(self, flag):
        r"""

        CovBase::setOptimEnabled
        """
        return _gstlearn.CovBase_setOptimEnabled(self, flag)

    def makeElemNoStat(self, *args, **kwargs):
        r"""

        CovBase::makeElemNoStat
        """
        return _gstlearn.CovBase_makeElemNoStat(self, *args, **kwargs)

    def appendParams(self, listParams, gradFuncs=None):
        r"""

        CovBase::appendParams
        """
        return _gstlearn.CovBase_appendParams(self, listParams, gradFuncs)

    def updateCov(self):
        r"""

        CovBase::updateCov
        """
        return _gstlearn.CovBase_updateCov(self)

    def initParams(self, vars, href=1.):
        r"""

        CovBase::initParams
        """
        return _gstlearn.CovBase_initParams(self, vars, href)

    def getParamInfoCholSills(self, ivar, jvar):
        r"""

        CovBase::getParamInfoCholSills
        """
        return _gstlearn.CovBase_getParamInfoCholSills(self, ivar, jvar)

    def __repr__(self):
        return _gstlearn.CovBase___repr__(self)

# Register CovBase in _gstlearn:
_gstlearn.CovBase_swigregister(CovBase)
class CovProportional(CovBase):
    r"""


    C++ includes: CovProportional.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovProportional::CovProportional
        """
        _gstlearn.CovProportional_swiginit(self, _gstlearn.new_CovProportional(*args))
    __swig_destroy__ = _gstlearn.delete_CovProportional

    def setCor(self, cor):
        r"""

        CovProportional::setCor
        """
        return _gstlearn.CovProportional_setCor(self, cor)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovProportional_clone(self)

    def __repr__(self):
        return _gstlearn.CovProportional___repr__(self)

# Register CovProportional in _gstlearn:
_gstlearn.CovProportional_swigregister(CovProportional)
class CorAniso(ACov):
    r"""


    This class describes an **elementary covariance**.  

    This covariance is described through the following list of parameters:  

    *   the covariance **type**: the list of these types is provided in ECov.hpp  
    *   the largest set of parameters for any covariance: **range(s)**, **anisotropy
        angle(s)**, **third parameter**. Some of these parameters do not make sense,
        depending on the covariance type: e.g. the range for nugget effect, the
        third parameter for a spherical structure, ... All these parameters are
        processed and stored as a **tensor** in order to avoid repetitive
        calculations.  

    C++ includes: CorAniso.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CorAniso::CorAniso
        """
        _gstlearn.CorAniso_swiginit(self, _gstlearn.new_CorAniso(*args))
    __swig_destroy__ = _gstlearn.delete_CorAniso

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CorAniso_clone(self)

    def toString(self, strfmt=None):
        r"""

        CorAniso::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.CorAniso_toString(self, strfmt)

    def isConsistent(self, space):
        r"""

        CorAniso::isConsistent
        ASpaceObject Interface.  

        """
        return _gstlearn.CorAniso_isConsistent(self, space)

    def getNVar(self):
        r"""

        CorAniso::getNVar
        ACov Interface.  

        """
        return _gstlearn.CorAniso_getNVar(self)

    def evalCor(self, p1, p2, mode=None, ivar=0, jvar=0):
        r"""

        CorAniso::evalCor
        ACov Interface.  

        """
        return _gstlearn.CorAniso_evalCor(self, p1, p2, mode, ivar, jvar)

    def evalCovOnSphere(self, alpha, degree=50, flagScaleDistance=True, mode=None):
        r"""

        CorAniso::evalCovOnSphere
        """
        return _gstlearn.CorAniso_evalCovOnSphere(self, alpha, degree, flagScaleDistance, mode)

    def evalSpectrumOnSphere(self, n, flagNormDistance=False, flagCumul=False):
        r"""

        CorAniso::evalSpectrumOnSphere
        """
        return _gstlearn.CorAniso_evalSpectrumOnSphere(self, n, flagNormDistance, flagCumul)

    def evalSpectrum(self, freq, ivar=0, jvar=0):
        r"""

        CorAniso::evalSpectrum
        """
        return _gstlearn.CorAniso_evalSpectrum(self, freq, ivar, jvar)

    def getIntegralRange(self, ndisc, hmax):
        r"""

        CorAniso::getIntegralRange
        Calculate the Integral Range in various Space Dimension (1, 2 or 3)  

        Returns
        -------  

        """
        return _gstlearn.CorAniso_getIntegralRange(self, ndisc, hmax)

    def getFormula(self):
        r"""

        CorAniso::getFormula
        """
        return _gstlearn.CorAniso_getFormula(self)

    def getBallRadius(self):
        r"""

        CorAniso::getBallRadius
        """
        return _gstlearn.CorAniso_getBallRadius(self)

    @staticmethod
    def isOptimizationInitialized(p1As, db=None):
        r"""

        CorAniso::isOptimizationInitialized
        Checks that the Optimization has already been initiated, by:  

        *   checking that the storage (for Sample Points projected in the Covariance
            rotation system) is already allocated  
        *   checking that the dimension of this storage is correct (only if 'db' is
            provided): in particular, this check is not necessary when freeing this
            storage.  

        """
        return _gstlearn.CorAniso_isOptimizationInitialized(p1As, db)

    def _optimizationPreProcess(self, mode, ps):
        r"""

        CorAniso::_optimizationPreProcess
        Transform a set of Space Points using the anisotropy tensor The set of resulting
        Space Points are stored as private member of this. Note that ALL samples are
        processed, regardless from the selection  

        Parameters
        ----------
        * `mode` :  
            1 for _p1As and 2 for _p2As  
        * `ps` :  
            Vector of SpacePoints  

        """
        return _gstlearn.CorAniso__optimizationPreProcess(self, mode, ps)

    def _optimizationSetTarget(self, p):
        r"""

        CorAniso::_optimizationSetTarget
        Define the argument 'p' as the current target and project it if needed.  

        Parameters
        ----------
        * `p` :  
            Current space point  

        note: : The target is stored in first position of '_p2As'  

        note: : Its pointer is stored in '_pw2' for quick covariance evaluation.  

        """
        return _gstlearn.CorAniso__optimizationSetTarget(self, p)

    def _optimizationPostProcess(self):
        r"""

        CorAniso::_optimizationPostProcess
        """
        return _gstlearn.CorAniso__optimizationPostProcess(self)

    def isValidForTurningBand(self):
        r"""

        CorAniso::isValidForTurningBand
        """
        return _gstlearn.CorAniso_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CorAniso::simulateTurningBand
        """
        return _gstlearn.CorAniso_simulateTurningBand(self, t0, operTB)

    def isValidForSpectral(self):
        r"""

        CorAniso::isValidForSpectral
        """
        return _gstlearn.CorAniso_isValidForSpectral(self)

    def simulateSpectralOmega(self, nb):
        r"""

        CorAniso::simulateSpectralOmega
        """
        return _gstlearn.CorAniso_simulateSpectralOmega(self, nb)

    @staticmethod
    def createIsotropic(ctxt, type, range, param=1., flagRange=True):
        r"""

        CorAniso::createIsotropic
        """
        return _gstlearn.CorAniso_createIsotropic(ctxt, type, range, param, flagRange)

    @staticmethod
    def createAnisotropic(*args, **kwargs):
        r"""

        CorAniso::createAnisotropic
        """
        return _gstlearn.CorAniso_createAnisotropic(*args, **kwargs)

    @staticmethod
    def createIsotropicMulti(ctxt, type, range, param=1., flagRange=True):
        r"""

        CorAniso::createIsotropicMulti
        """
        return _gstlearn.CorAniso_createIsotropicMulti(ctxt, type, range, param, flagRange)

    @staticmethod
    def createAnisotropicMulti(*args, **kwargs):
        r"""

        CorAniso::createAnisotropicMulti
        """
        return _gstlearn.CorAniso_createAnisotropicMulti(*args, **kwargs)

    def setParam(self, param):
        r"""

        CorAniso::setParam
        """
        return _gstlearn.CorAniso_setParam(self, param)

    def setNoStatFactor(self, noStatFactor):
        r"""

        CorAniso::setNoStatFactor
        """
        return _gstlearn.CorAniso_setNoStatFactor(self, noStatFactor)

    def setRangeIsotropic(self, range):
        r"""

        CorAniso::setRangeIsotropic
        Practical range.  

        """
        return _gstlearn.CorAniso_setRangeIsotropic(self, range)

    def setRange(self, idim, range):
        r"""

        CorAniso::setRange
        """
        return _gstlearn.CorAniso_setRange(self, idim, range)

    def setRanges(self, ranges):
        r"""

        CorAniso::setRanges
        """
        return _gstlearn.CorAniso_setRanges(self, ranges)

    def setScale(self, scale):
        r"""

        CorAniso::setScale
        """
        return _gstlearn.CorAniso_setScale(self, scale)

    def setScaleDim(self, idim, scale):
        r"""

        CorAniso::setScaleDim
        Make the covariance isotropic.  

        """
        return _gstlearn.CorAniso_setScaleDim(self, idim, scale)

    def setScales(self, scales):
        r"""

        CorAniso::setScales
        """
        return _gstlearn.CorAniso_setScales(self, scales)

    def setAnisoRotationMat(self, rot):
        r"""

        CorAniso::setAnisoRotationMat
        """
        return _gstlearn.CorAniso_setAnisoRotationMat(self, rot)

    def setAnisoRotation(self, rot):
        r"""

        CorAniso::setAnisoRotation
        """
        return _gstlearn.CorAniso_setAnisoRotation(self, rot)

    def setAnisoAngles(self, angles):
        r"""

        CorAniso::setAnisoAngles
        """
        return _gstlearn.CorAniso_setAnisoAngles(self, angles)

    def setAnisoAngle(self, idim, angle):
        r"""

        CorAniso::setAnisoAngle
        """
        return _gstlearn.CorAniso_setAnisoAngle(self, idim, angle)

    def setRotationAnglesAndRadius(self, *args, **kwargs):
        r"""

        CorAniso::setRotationAnglesAndRadius
        """
        return _gstlearn.CorAniso_setRotationAnglesAndRadius(self, *args, **kwargs)

    def getRanges(self):
        r"""

        CorAniso::getRanges
        """
        return _gstlearn.CorAniso_getRanges(self)

    def getRange(self, idim):
        r"""

        CorAniso::getRange
        """
        return _gstlearn.CorAniso_getRange(self, idim)

    def getScale(self, idim):
        r"""

        CorAniso::getScale
        """
        return _gstlearn.CorAniso_getScale(self, idim)

    def getAnisoRotation(self):
        r"""

        CorAniso::getAnisoRotation
        """
        return _gstlearn.CorAniso_getAnisoRotation(self)

    def getScales(self):
        r"""

        CorAniso::getScales
        """
        return _gstlearn.CorAniso_getScales(self)

    def setType(self, type):
        r"""

        CorAniso::setType
        """
        return _gstlearn.CorAniso_setType(self, type)

    def getRangeIso(self):
        r"""

        CorAniso::getRangeIso
        This function returns the range in the isotropic case In the anisotropic case,
        it returns the largest range over all directions  

        Returns
        -------  

        """
        return _gstlearn.CorAniso_getRangeIso(self)

    def getScaleIso(self):
        r"""

        CorAniso::getScaleIso
        """
        return _gstlearn.CorAniso_getScaleIso(self)

    def getFlagAniso(self):
        r"""

        CorAniso::getFlagAniso
        """
        return _gstlearn.CorAniso_getFlagAniso(self)

    def getFlagRotation(self):
        r"""

        CorAniso::getFlagRotation
        """
        return _gstlearn.CorAniso_getFlagRotation(self)

    def getAnisoInvMat(self):
        r"""

        CorAniso::getAnisoInvMat
        """
        return _gstlearn.CorAniso_getAnisoInvMat(self)

    def getAnisoCoeffs(self):
        r"""

        CorAniso::getAnisoCoeffs
        """
        return _gstlearn.CorAniso_getAnisoCoeffs(self)

    def getAnisoAngles(self, *args):
        r"""

        CorAniso::getAnisoAngles
        """
        return _gstlearn.CorAniso_getAnisoAngles(self, *args)

    def getAnisoRotMat(self, *args):
        r"""

        CorAniso::getAnisoRotMat
        """
        return _gstlearn.CorAniso_getAnisoRotMat(self, *args)

    def getAnisoCoeff(self, idim):
        r"""

        CorAniso::getAnisoCoeff
        """
        return _gstlearn.CorAniso_getAnisoCoeff(self, idim)

    def getType(self):
        r"""

        CorAniso::getType
        """
        return _gstlearn.CorAniso_getType(self)

    def getParam(self):
        r"""

        CorAniso::getParam
        For compatibility, this function returns 0 if the Covariance has no Third
        Parameter  

        Returns
        -------
        Third parameter  

        """
        return _gstlearn.CorAniso_getParam(self)

    def getScadef(self):
        r"""

        CorAniso::getScadef
        """
        return _gstlearn.CorAniso_getScadef(self)

    def getParMax(self):
        r"""

        CorAniso::getParMax
        """
        return _gstlearn.CorAniso_getParMax(self)

    def getMaxNDim(self):
        r"""

        CorAniso::getMaxNDim
        """
        return _gstlearn.CorAniso_getMaxNDim(self)

    def getMinOrder(self):
        r"""

        CorAniso::getMinOrder
        """
        return _gstlearn.CorAniso_getMinOrder(self)

    def hasInt1D(self):
        r"""

        CorAniso::hasInt1D
        """
        return _gstlearn.CorAniso_hasInt1D(self)

    def hasInt2D(self):
        r"""

        CorAniso::hasInt2D
        """
        return _gstlearn.CorAniso_hasInt2D(self)

    def hasRange(self):
        r"""

        CorAniso::hasRange
        """
        return _gstlearn.CorAniso_hasRange(self)

    def hasParam(self):
        r"""

        CorAniso::hasParam
        """
        return _gstlearn.CorAniso_hasParam(self)

    def getCovName(self):
        r"""

        CorAniso::getCovName
        """
        return _gstlearn.CorAniso_getCovName(self)

    def isIsotropic(self):
        r"""

        CorAniso::isIsotropic
        """
        return _gstlearn.CorAniso_isIsotropic(self)

    def isAsymptotic(self):
        r"""

        CorAniso::isAsymptotic
        """
        return _gstlearn.CorAniso_isAsymptotic(self)

    def hasRotation(self):
        r"""

        CorAniso::hasRotation
        """
        return _gstlearn.CorAniso_hasRotation(self)

    def getAniso(self):
        r"""

        CorAniso::getAniso
        """
        return _gstlearn.CorAniso_getAniso(self)

    def setAniso(self, aniso):
        r"""

        CorAniso::setAniso
        """
        return _gstlearn.CorAniso_setAniso(self, aniso)

    def getCorFunc(self):
        r"""

        CorAniso::getCorFunc
        """
        return _gstlearn.CorAniso_getCorFunc(self)

    def getNGradParam(self):
        r"""

        CorAniso::getNGradParam
        """
        return _gstlearn.CorAniso_getNGradParam(self)

    def hasCovDerivative(self):
        r"""

        CorAniso::hasCovDerivative
        """
        return _gstlearn.CorAniso_hasCovDerivative(self)

    def hasCovOnSphere(self):
        r"""

        CorAniso::hasCovOnSphere
        """
        return _gstlearn.CorAniso_hasCovOnSphere(self)

    def hasSpectrumOnSphere(self):
        r"""

        CorAniso::hasSpectrumOnSphere
        """
        return _gstlearn.CorAniso_hasSpectrumOnSphere(self)

    def hasMarkovCoeffs(self):
        r"""

        CorAniso::hasMarkovCoeffs
        """
        return _gstlearn.CorAniso_hasMarkovCoeffs(self)

    def hasSpectrumOnRn(self):
        r"""

        CorAniso::hasSpectrumOnRn
        """
        return _gstlearn.CorAniso_hasSpectrumOnRn(self)

    def normalizeOnSphere(self, n=50):
        r"""

        CorAniso::normalizeOnSphere
        """
        return _gstlearn.CorAniso_normalizeOnSphere(self, n)

    def makeRangeNoStatDb(self, namecol, idim=0, db=None):
        r"""

        CorAniso::makeRangeNoStatDb
        """
        return _gstlearn.CorAniso_makeRangeNoStatDb(self, namecol, idim, db)

    def makeScaleNoStatDb(self, namecol, idim=0, db=None):
        r"""

        CorAniso::makeScaleNoStatDb
        """
        return _gstlearn.CorAniso_makeScaleNoStatDb(self, namecol, idim, db)

    def makeAngleNoStatDb(self, namecol, idim=0, db=None):
        r"""

        CorAniso::makeAngleNoStatDb
        """
        return _gstlearn.CorAniso_makeAngleNoStatDb(self, namecol, idim, db)

    def makeTensorNoStatDb(self, namecol, idim=0, jdim=0, db=None):
        r"""

        CorAniso::makeTensorNoStatDb
        """
        return _gstlearn.CorAniso_makeTensorNoStatDb(self, namecol, idim, jdim, db)

    def makeParamNoStatDb(self, namecol, db=None):
        r"""

        CorAniso::makeParamNoStatDb
        """
        return _gstlearn.CorAniso_makeParamNoStatDb(self, namecol, db)

    def makeRangeNoStatFunctional(self, func, idim=0):
        r"""

        CorAniso::makeRangeNoStatFunctional
        """
        return _gstlearn.CorAniso_makeRangeNoStatFunctional(self, func, idim)

    def makeScaleNoStatFunctional(self, func, idim=0):
        r"""

        CorAniso::makeScaleNoStatFunctional
        """
        return _gstlearn.CorAniso_makeScaleNoStatFunctional(self, func, idim)

    def makeAngleNoStatFunctional(self, func, idim=0):
        r"""

        CorAniso::makeAngleNoStatFunctional
        """
        return _gstlearn.CorAniso_makeAngleNoStatFunctional(self, func, idim)

    def makeTensorNoStatFunctional(self, func, idim=0, jdim=0):
        r"""

        CorAniso::makeTensorNoStatFunctional
        """
        return _gstlearn.CorAniso_makeTensorNoStatFunctional(self, func, idim, jdim)

    def makeParamNoStatFunctional(self, func):
        r"""

        CorAniso::makeParamNoStatFunctional
        """
        return _gstlearn.CorAniso_makeParamNoStatFunctional(self, func)

    def makeRangeStationary(self, idim=0):
        r"""

        CorAniso::makeRangeStationary
        """
        return _gstlearn.CorAniso_makeRangeStationary(self, idim)

    def makeScaleStationary(self, idim=0):
        r"""

        CorAniso::makeScaleStationary
        """
        return _gstlearn.CorAniso_makeScaleStationary(self, idim)

    def makeAngleStationary(self, idim=0):
        r"""

        CorAniso::makeAngleStationary
        """
        return _gstlearn.CorAniso_makeAngleStationary(self, idim)

    def makeTensorStationary(self, idim, jdim):
        r"""

        CorAniso::makeTensorStationary
        """
        return _gstlearn.CorAniso_makeTensorStationary(self, idim, jdim)

    def makeParamStationary(self):
        r"""

        CorAniso::makeParamStationary
        """
        return _gstlearn.CorAniso_makeParamStationary(self)

    def getTabNoStatCovAniso(self):
        r"""

        CorAniso::getTabNoStatCovAniso
        """
        return _gstlearn.CorAniso_getTabNoStatCovAniso(self)

    def getNAngles(self):
        r"""

        CorAniso::getNAngles
        """
        return _gstlearn.CorAniso_getNAngles(self)

    def getNRanges(self):
        r"""

        CorAniso::getNRanges
        """
        return _gstlearn.CorAniso_getNRanges(self)

    def getNScales(self):
        r"""

        CorAniso::getNScales
        """
        return _gstlearn.CorAniso_getNScales(self)

    def isNoStatForParam(self):
        r"""

        CorAniso::isNoStatForParam
        """
        return _gstlearn.CorAniso_isNoStatForParam(self)

    def isNoStatForTensor(self):
        r"""

        CorAniso::isNoStatForTensor
        """
        return _gstlearn.CorAniso_isNoStatForTensor(self)

    def isNoStatForAnisotropy(self):
        r"""

        CorAniso::isNoStatForAnisotropy
        """
        return _gstlearn.CorAniso_isNoStatForAnisotropy(self)

    def isNoStatForRotation(self):
        r"""

        CorAniso::isNoStatForRotation
        """
        return _gstlearn.CorAniso_isNoStatForRotation(self)

    def evalCovOnSphereVec(self, alpha, degree=50, flagScaleDistance=False, mode=None):
        r"""

        CorAniso::evalCovOnSphereVec
        """
        return _gstlearn.CorAniso_evalCovOnSphereVec(self, alpha, degree, flagScaleDistance, mode)

    def evalCovFFT(self, hmax, N=128, ivar=0, jvar=0):
        r"""

        CorAniso::evalCovFFT
        """
        return _gstlearn.CorAniso_evalCovFFT(self, hmax, N, ivar, jvar)

    def getMarkovCoeffs(self):
        r"""

        CorAniso::getMarkovCoeffs
        """
        return _gstlearn.CorAniso_getMarkovCoeffs(self)

    def setMarkovCoeffs(self, coeffs):
        r"""

        CorAniso::setMarkovCoeffs
        """
        return _gstlearn.CorAniso_setMarkovCoeffs(self, coeffs)

    def setMarkovCoeffsBySquaredPolynomials(self, coeffs1, coeffs2, eps=0):
        r"""

        CorAniso::setMarkovCoeffsBySquaredPolynomials
        """
        return _gstlearn.CorAniso_setMarkovCoeffsBySquaredPolynomials(self, coeffs1, coeffs2, eps)

    def computeMarkovCoeffs(self):
        r"""

        CorAniso::computeMarkovCoeffs
        """
        return _gstlearn.CorAniso_computeMarkovCoeffs(self)

    def getCorrec(self):
        r"""

        CorAniso::getCorrec
        """
        return _gstlearn.CorAniso_getCorrec(self)

    def getFullCorrec(self):
        r"""

        CorAniso::getFullCorrec
        """
        return _gstlearn.CorAniso_getFullCorrec(self)

    def nostatUpdate(self, covint):
        r"""

        CorAniso::nostatUpdate
        Update the Model in the case of Non-stationary parameters This requires the
        knowledge of the two end-points  

        Parameters
        ----------
        * `covint` :  
            Internal structure for non-stationarity or NULL (for stationary case)  

        """
        return _gstlearn.CorAniso_nostatUpdate(self, covint)

    def informMeshByMeshForAnisotropy(self, amesh):
        r"""

        CorAniso::informMeshByMeshForAnisotropy
        """
        return _gstlearn.CorAniso_informMeshByMeshForAnisotropy(self, amesh)

    def informMeshByApexForAnisotropy(self, amesh):
        r"""

        CorAniso::informMeshByApexForAnisotropy
        """
        return _gstlearn.CorAniso_informMeshByApexForAnisotropy(self, amesh)

    def informDbInForAnisotropy(self, dbin):
        r"""

        CorAniso::informDbInForAnisotropy
        """
        return _gstlearn.CorAniso_informDbInForAnisotropy(self, dbin)

    def informDbOutForAnisotropy(self, dbout):
        r"""

        CorAniso::informDbOutForAnisotropy
        """
        return _gstlearn.CorAniso_informDbOutForAnisotropy(self, dbout)

    def updateCovByPoints(self, icas1, iech1, icas2, iech2):
        r"""

        CorAniso::updateCovByPoints
        Tell if the use of Optimization is enabled or not.  

        Update the Model according to the Non-stationary parameters  

        Parameters
        ----------
        * `icas1` :  
            Type of first Db: 1 for Input; 2 for Output  
        * `iech1` :  
            Rank of the target within Db1 (or -1)  
        * `icas2` :  
            Type of first Db: 1 for Input; 2 for Output  
        * `iech2` :  
            Rank of the target within Dbout (or -2)  

        """
        return _gstlearn.CorAniso_updateCovByPoints(self, icas1, iech1, icas2, iech2)

    def updateCovByMesh(self, imesh, aniso=True):
        r"""

        CorAniso::updateCovByMesh
        """
        return _gstlearn.CorAniso_updateCovByMesh(self, imesh, aniso)

    def getValue(self, econs, iv1, iv2):
        r"""

        CorAniso::getValue
        """
        return _gstlearn.CorAniso_getValue(self, econs, iv1, iv2)

    def computeCorrec(self):
        r"""

        CorAniso::computeCorrec
        """
        return _gstlearn.CorAniso_computeCorrec(self)

    def evalCorFromH(self, h, mode):
        r"""

        CorAniso::evalCorFromH
        Calculate the value of the covariance from the distance between bi-points This
        distance has been calculated beforehand (possibly using anisotropy)  

        Parameters
        ----------
        * `h` :  
            Input distance  
        * `mode` :  
            Pointer to CovCalcMode structure (optional)  

        Returns
        -------
        The covariance value  

        """
        return _gstlearn.CorAniso_evalCorFromH(self, h, mode)

    def getDetTensor(self):
        r"""

        CorAniso::getDetTensor
        """
        return _gstlearn.CorAniso_getDetTensor(self)

    def optimizationTransformSP(self, ptin, ptout):
        r"""

        CorAniso::optimizationTransformSP
        Transform a space point using the anisotropy tensor  

        Parameters
        ----------
        * `ptin` :  
            Input Space Point  
        * `ptout` :  
            Output Space Point  

        """
        return _gstlearn.CorAniso_optimizationTransformSP(self, ptin, ptout)

    def optimizationTransformSPNew(self, ptin, ptout):
        r"""

        CorAniso::optimizationTransformSPNew
        """
        return _gstlearn.CorAniso_optimizationTransformSPNew(self, ptin, ptout)

    def toStringParams(self, strfmt=None):
        r"""

        CorAniso::toStringParams
        """
        return _gstlearn.CorAniso_toStringParams(self, strfmt)

    def toStringNoStat(self, strfmt=None, i=0):
        r"""

        CorAniso::toStringNoStat
        """
        return _gstlearn.CorAniso_toStringNoStat(self, strfmt, i)

    def appendParams(self, listParams, gradFuncs=None):
        r"""

        CorAniso::appendParams
        """
        return _gstlearn.CorAniso_appendParams(self, listParams, gradFuncs)

    def evalDerivativeBasis(self, p1, p2, ivar, jvar, mode):
        r"""

        CorAniso::evalDerivativeBasis
        """
        return _gstlearn.CorAniso_evalDerivativeBasis(self, p1, p2, ivar, jvar, mode)

    def updateCov(self):
        r"""

        CorAniso::updateCov
        """
        return _gstlearn.CorAniso_updateCov(self)

    def initParams(self, vars, href=1.):
        r"""

        CorAniso::initParams
        """
        return _gstlearn.CorAniso_initParams(self, vars, href)

    def getParamInfoScale(self, idim):
        r"""

        CorAniso::getParamInfoScale
        """
        return _gstlearn.CorAniso_getParamInfoScale(self, idim)

    def getParamInfoAngle(self, idim):
        r"""

        CorAniso::getParamInfoAngle
        """
        return _gstlearn.CorAniso_getParamInfoAngle(self, idim)

    def getParamInfoScales(self):
        r"""

        CorAniso::getParamInfoScales
        """
        return _gstlearn.CorAniso_getParamInfoScales(self)

    def getParamInfoAngles(self):
        r"""

        CorAniso::getParamInfoAngles
        """
        return _gstlearn.CorAniso_getParamInfoAngles(self)

    def getOptimLockIso2d(self):
        r"""

        CorAniso::getOptimLockIso2d
        """
        return _gstlearn.CorAniso_getOptimLockIso2d(self)

    def setOptimLockIso2d(self, status):
        r"""

        CorAniso::setOptimLockIso2d
        """
        return _gstlearn.CorAniso_setOptimLockIso2d(self, status)

    def getOptimNoAniso(self):
        r"""

        CorAniso::getOptimNoAniso
        """
        return _gstlearn.CorAniso_getOptimNoAniso(self)

    def setOptimNoAniso(self, status):
        r"""

        CorAniso::setOptimNoAniso
        """
        return _gstlearn.CorAniso_setOptimNoAniso(self, status)

    def getDRot(self):
        r"""

        CorAniso::getDRot
        """
        return _gstlearn.CorAniso_getDRot(self)

    def __repr__(self):
        return _gstlearn.CorAniso___repr__(self)

# Register CorAniso in _gstlearn:
_gstlearn.CorAniso_swigregister(CorAniso)
class ACovFunc(AStringable):
    r"""


    C++ includes: ACovFunc.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_ACovFunc

    def toString(self, strfmt=None):
        r"""

        ACovFunc::toString
        AStringable Interface.  

        """
        return _gstlearn.ACovFunc_toString(self, strfmt)

    def getFormula(self):
        r"""

        ACovFunc::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.ACovFunc_getFormula(self)

    def getScadef(self):
        r"""

        ACovFunc::getScadef
        """
        return _gstlearn.ACovFunc_getScadef(self)

    def getParMax(self):
        r"""

        ACovFunc::getParMax
        """
        return _gstlearn.ACovFunc_getParMax(self)

    def hasInt1D(self):
        r"""

        ACovFunc::hasInt1D
        """
        return _gstlearn.ACovFunc_hasInt1D(self)

    def hasInt2D(self):
        r"""

        ACovFunc::hasInt2D
        """
        return _gstlearn.ACovFunc_hasInt2D(self)

    def hasRange(self):
        r"""

        ACovFunc::hasRange
        """
        return _gstlearn.ACovFunc_hasRange(self)

    def hasParam(self):
        r"""

        ACovFunc::hasParam
        """
        return _gstlearn.ACovFunc_hasParam(self)

    def getCovName(self):
        r"""

        ACovFunc::getCovName
        """
        return _gstlearn.ACovFunc_getCovName(self)

    def hasCovDerivative(self):
        r"""

        ACovFunc::hasCovDerivative
        """
        return _gstlearn.ACovFunc_hasCovDerivative(self)

    def hasCovOnRn(self):
        r"""

        ACovFunc::hasCovOnRn
        """
        return _gstlearn.ACovFunc_hasCovOnRn(self)

    def hasCovOnSphere(self):
        r"""

        ACovFunc::hasCovOnSphere
        """
        return _gstlearn.ACovFunc_hasCovOnSphere(self)

    def hasSpectrumOnSphere(self):
        r"""

        ACovFunc::hasSpectrumOnSphere
        """
        return _gstlearn.ACovFunc_hasSpectrumOnSphere(self)

    def hasSpectrumOnRn(self):
        r"""

        ACovFunc::hasSpectrumOnRn
        """
        return _gstlearn.ACovFunc_hasSpectrumOnRn(self)

    def hasMarkovCoeffs(self):
        r"""

        ACovFunc::hasMarkovCoeffs
        """
        return _gstlearn.ACovFunc_hasMarkovCoeffs(self)

    def normalizeOnSphere(self, n=50, scale=1.):
        r"""

        ACovFunc::normalizeOnSphere
        """
        return _gstlearn.ACovFunc_normalizeOnSphere(self, n, scale)

    def isConsistent(self):
        r"""

        ACovFunc::isConsistent
        Test consistency with the current context.  

        TODO : Test irfDegree vs getMinOrder in CovElem because zonal anisotropies  

        """
        return _gstlearn.ACovFunc_isConsistent(self)

    def getMaxNDim(self):
        r"""

        ACovFunc::getMaxNDim
        """
        return _gstlearn.ACovFunc_getMaxNDim(self)

    def getMinOrder(self):
        r"""

        ACovFunc::getMinOrder
        """
        return _gstlearn.ACovFunc_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        ACovFunc::getCompatibleSpaceR
        """
        return _gstlearn.ACovFunc_getCompatibleSpaceR(self)

    def getCompatibleSpaceS(self):
        r"""

        ACovFunc::getCompatibleSpaceS
        """
        return _gstlearn.ACovFunc_getCompatibleSpaceS(self)

    def isValidForTurningBand(self):
        r"""

        ACovFunc::isValidForTurningBand
        """
        return _gstlearn.ACovFunc_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        ACovFunc::simulateTurningBand
        """
        return _gstlearn.ACovFunc_simulateTurningBand(self, t0, operTB)

    def isValidForSpectral(self):
        r"""

        ACovFunc::isValidForSpectral
        """
        return _gstlearn.ACovFunc_isValidForSpectral(self)

    def simulateSpectralOmega(self, nb):
        r"""

        ACovFunc::simulateSpectralOmega
        """
        return _gstlearn.ACovFunc_simulateSpectralOmega(self, nb)

    def setParam(self, param):
        r"""

        ACovFunc::setParam
        TODO : Do not throw in setter. Check range and build the error message here.  

        """
        return _gstlearn.ACovFunc_setParam(self, param)

    def setField(self, field):
        r"""

        ACovFunc::setField
        """
        return _gstlearn.ACovFunc_setField(self, field)

    def setContext(self, ctxt):
        r"""

        ACovFunc::setContext
        """
        return _gstlearn.ACovFunc_setContext(self, ctxt)

    def evalCorFunc(self, h):
        r"""

        ACovFunc::evalCorFunc
        """
        return _gstlearn.ACovFunc_evalCorFunc(self, h)

    def evalCovDerivative(self, degree, h):
        r"""

        ACovFunc::evalCovDerivative
        """
        return _gstlearn.ACovFunc_evalCovDerivative(self, degree, h)

    def evalCovOnSphere(self, alpha, scale=1., degree=50):
        r"""

        ACovFunc::evalCovOnSphere
        """
        return _gstlearn.ACovFunc_evalCovOnSphere(self, alpha, scale, degree)

    def evalSpectrumOnSphere(self, n, scale=1.):
        r"""

        ACovFunc::evalSpectrumOnSphere
        """
        return _gstlearn.ACovFunc_evalSpectrumOnSphere(self, n, scale)

    def evalCovVec(self, vech):
        r"""

        ACovFunc::evalCovVec
        """
        return _gstlearn.ACovFunc_evalCovVec(self, vech)

    def evalCovDerivativeVec(self, degree, vech):
        r"""

        ACovFunc::evalCovDerivativeVec
        """
        return _gstlearn.ACovFunc_evalCovDerivativeVec(self, degree, vech)

    def getType(self):
        r"""

        ACovFunc::getType
        """
        return _gstlearn.ACovFunc_getType(self)

    def getContext(self):
        r"""

        ACovFunc::getContext
        """
        return _gstlearn.ACovFunc_getContext(self)

    def getParam(self):
        r"""

        ACovFunc::getParam
        """
        return _gstlearn.ACovFunc_getParam(self)

    def copyCovContext(self, ctxt):
        r"""

        ACovFunc::copyCovContext
        """
        return _gstlearn.ACovFunc_copyCovContext(self, ctxt)

    def evaluateSpectrum(self, freq):
        r"""

        ACovFunc::evaluateSpectrum
        """
        return _gstlearn.ACovFunc_evaluateSpectrum(self, freq)

    def getMarkovCoeffs(self):
        r"""

        ACovFunc::getMarkovCoeffs
        """
        return _gstlearn.ACovFunc_getMarkovCoeffs(self)

    def setMarkovCoeffs(self, coeffs):
        r"""

        ACovFunc::setMarkovCoeffs
        """
        return _gstlearn.ACovFunc_setMarkovCoeffs(self, coeffs)

    def getCorrec(self):
        r"""

        ACovFunc::getCorrec
        """
        return _gstlearn.ACovFunc_getCorrec(self)

    def setCorrec(self, val):
        r"""

        ACovFunc::setCorrec
        """
        return _gstlearn.ACovFunc_setCorrec(self, val)

    def computeCorrec(self, ndim):
        r"""

        ACovFunc::computeCorrec
        """
        return _gstlearn.ACovFunc_computeCorrec(self, ndim)

    def computeMarkovCoeffs(self, dim):
        r"""

        ACovFunc::computeMarkovCoeffs
        """
        return _gstlearn.ACovFunc_computeMarkovCoeffs(self, dim)

    def evalDerivative(self, h):
        r"""

        ACovFunc::evalDerivative
        """
        return _gstlearn.ACovFunc_evalDerivative(self, h)

    def __repr__(self):
        return _gstlearn.ACovFunc___repr__(self)

# Register ACovFunc in _gstlearn:
_gstlearn.ACovFunc_swigregister(ACovFunc)
class CovList(ACov):
    r"""


    This class describes the **Covariance** as a list of elementary covariances (see
    CovBase.hpp for more details) where the calculation rule is simple: the returned
    value is the **sum** of each elementary (active) covariance function.  

    This class also carry two other important informations:  

    *   a vector giving the status of each elementary covariance item: it may be
        *active* or *filtered*  
    *   a complex structure allowing each parameter (range, sill, anisotropy angle,
        ...) of each of the elementary covariances to be non-stationary (to have a
        value which depends on the location). For more details, see ANoStat.hpp.  

    C++ includes: CovList.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_CovList

    def getNVar(self):
        r"""

        CovList::getNVar
        Interface for ACov.  

        """
        return _gstlearn.CovList_getNVar(self)

    def isIndexable(self):
        r"""

        CovList::isIndexable
        """
        return _gstlearn.CovList_isIndexable(self)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        CovList::eval0
        Calculate the covariance between two variables for 0-distance (stationary case)  

        """
        return _gstlearn.CovList_eval0(self, ivar, jvar, mode)

    def updateCovByPoints(self, icas1, iech1, icas2, iech2):
        r"""

        CovList::updateCovByPoints
        Update the Model according to the Non-stationary parameters  

        Parameters
        ----------
        * `icas1` :  
            Type of first Db: 1 for Input; 2 for Output  
        * `iech1` :  
            Rank of the target within Db1 (or -1)  
        * `icas2` :  
            Type of first Db: 1 for Input; 2 for Output  
        * `iech2` :  
            Rank of the target within Dbout (or -2)  

        """
        return _gstlearn.CovList_updateCovByPoints(self, icas1, iech1, icas2, iech2)

    def toString(self, strfmt=None):
        r"""

        CovList::toString
        Interface for AStringable Interface.  

        """
        return _gstlearn.CovList_toString(self, strfmt)

    def addCov(self, cov):
        r"""

        CovList::addCov
        CovList Interface.  

        """
        return _gstlearn.CovList_addCov(self, cov)

    def addCovList(self, covs):
        r"""

        CovList::addCovList
        """
        return _gstlearn.CovList_addCovList(self, covs)

    def delCov(self, icov):
        r"""

        CovList::delCov
        """
        return _gstlearn.CovList_delCov(self, icov)

    def delAllCov(self):
        r"""

        CovList::delAllCov
        """
        return _gstlearn.CovList_delAllCov(self)

    def setCovFiltered(self, icov, filtered):
        r"""

        CovList::setCovFiltered
        """
        return _gstlearn.CovList_setCovFiltered(self, icov, filtered)

    def getNCov(self):
        r"""

        CovList::getNCov
        """
        return _gstlearn.CovList_getNCov(self)

    def getNCovNuggetExcluded(self):
        r"""

        CovList::getNCovNuggetExcluded
        """
        return _gstlearn.CovList_getNCovNuggetExcluded(self)

    def isFiltered(self, icov):
        r"""

        CovList::isFiltered
        """
        return _gstlearn.CovList_isFiltered(self, icov)

    def getTotalSill(self, ivar=0, jvar=0):
        r"""

        CovList::getTotalSill
        Calculate the total sill of the model for given pair of variables  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        """
        return _gstlearn.CovList_getTotalSill(self, ivar, jvar)

    def getTotalSills(self):
        r"""

        CovList::getTotalSills
        """
        return _gstlearn.CovList_getTotalSills(self)

    def isAllActiveCovList(self):
        r"""

        CovList::isAllActiveCovList
        """
        return _gstlearn.CovList_isAllActiveCovList(self)

    def setOptimEnabled(self, flag):
        r"""

        CovList::setOptimEnabled
        """
        return _gstlearn.CovList_setOptimEnabled(self, flag)

    def getCov(self, icov):
        r"""

        CovList::getCov
        TODO : to be removed (encapsulation)  

        """
        return _gstlearn.CovList_getCov(self, icov)

    def getCovModify(self, icov):
        r"""

        CovList::getCovModify
        """
        return _gstlearn.CovList_getCovModify(self, icov)

    def getCovName(self, icov):
        r"""

        CovList::getCovName
        """
        return _gstlearn.CovList_getCovName(self, icov)

    def getCovType(self, icov):
        r"""

        CovList::getCovType
        """
        return _gstlearn.CovList_getCovType(self, icov)

    def setCov(self, icov, covs):
        r"""

        CovList::setCov
        """
        return _gstlearn.CovList_setCov(self, icov, covs)

    def setSill(self, icov, ivar, jvar, value):
        r"""

        CovList::setSill
        """
        return _gstlearn.CovList_setSill(self, icov, ivar, jvar, value)

    def setSills(self, icov, sills):
        r"""

        CovList::setSills
        """
        return _gstlearn.CovList_setSills(self, icov, sills)

    def getSills(self, icov):
        r"""

        CovList::getSills
        """
        return _gstlearn.CovList_getSills(self, icov)

    def getSill(self, icov, ivar, jvar):
        r"""

        CovList::getSill
        """
        return _gstlearn.CovList_getSill(self, icov, ivar, jvar)

    def _optimizationPreProcess(self, mode, ps):
        r"""

        CovList::_optimizationPreProcess
        Preprocess the input Data. By default, this method only copies the SpacePoints
        In the Anisoptric version, the samples are projected along with the Covariance.  

        Parameters
        ----------
        * `mode` :  
            1 for p1As, 2 for p2As  
        * `ps` :  
            Set of SpacePoints to be copied  

        """
        return _gstlearn.CovList__optimizationPreProcess(self, mode, ps)

    def _optimizationPostProcess(self):
        r"""

        CovList::_optimizationPostProcess
        """
        return _gstlearn.CovList__optimizationPostProcess(self)

    def _optimizationLoadInPlace(self, iech, mode, rank):
        r"""

        CovList::_optimizationLoadInPlace
        Returns the references in 'pt' and set the local pointer '_pw2'.  

        Parameters
        ----------
        * `iech` :  
            Relative index of the target sample (within 'pXAs')  
        * `mode` :  
            1 for _p1As, 2 for _p2As and 3 for _p2A  
        * `rank` :  
            1 for the first point and 2 for the second  

        """
        return _gstlearn.CovList__optimizationLoadInPlace(self, iech, mode, rank)

    def _optimizationSetTarget(self, pt):
        r"""

        CovList::_optimizationSetTarget
        """
        return _gstlearn.CovList__optimizationSetTarget(self, pt)

    def setActiveCovListFromOne(self, keepOnlyCovIdx):
        r"""

        CovList::setActiveCovListFromOne
        """
        return _gstlearn.CovList_setActiveCovListFromOne(self, keepOnlyCovIdx)

    def setActiveCovListFromInterval(self, inddeb, indto):
        r"""

        CovList::setActiveCovListFromInterval
        Set the list of active covariances from an interval  

        Parameters
        ----------
        * `inddeb` :  
            Lower bound of the interval (included)  
        * `indto` :  
            Upper bound of the interval (excluded)  

        """
        return _gstlearn.CovList_setActiveCovListFromInterval(self, inddeb, indto)

    def setActiveCovList(self, activeCovList, allActiveCov):
        r"""

        CovList::setActiveCovList
        """
        return _gstlearn.CovList_setActiveCovList(self, activeCovList, allActiveCov)

    def copyCovContext(self, ctxt):
        r"""

        CovList::copyCovContext
        """
        return _gstlearn.CovList_copyCovContext(self, ctxt)

    def normalize(self, sill=1., ivar=0, jvar=0):
        r"""

        CovList::normalize
        """
        return _gstlearn.CovList_normalize(self, sill, ivar, jvar)

    def makeElemNoStat(self, *args, **kwargs):
        r"""

        CovList::makeElemNoStat
        """
        return _gstlearn.CovList_makeElemNoStat(self, *args, **kwargs)

    def makeSillNoStatDb(self, icov, namecol, ivar=0, jvar=0):
        r"""

        CovList::makeSillNoStatDb
        """
        return _gstlearn.CovList_makeSillNoStatDb(self, icov, namecol, ivar, jvar)

    def makeSillStationary(self, icov, ivar=0, jvar=0):
        r"""

        CovList::makeSillStationary
        """
        return _gstlearn.CovList_makeSillStationary(self, icov, ivar, jvar)

    def makeSillsStationary(self, icov, silent=False):
        r"""

        CovList::makeSillsStationary
        """
        return _gstlearn.CovList_makeSillsStationary(self, icov, silent)

    def makeSillNoStatFunctional(self, icov, func, ivar=0, jvar=0):
        r"""

        CovList::makeSillNoStatFunctional
        """
        return _gstlearn.CovList_makeSillNoStatFunctional(self, icov, func, ivar, jvar)

    def appendParams(self, listParams, gradFuncs=None):
        r"""

        CovList::appendParams
        """
        return _gstlearn.CovList_appendParams(self, listParams, gradFuncs)

    def updateCov(self):
        r"""

        CovList::updateCov
        """
        return _gstlearn.CovList_updateCov(self)

    def initParams(self, vars, href=1.):
        r"""

        CovList::initParams
        """
        return _gstlearn.CovList_initParams(self, vars, href)

    def deleteFitSills(self):
        r"""

        CovList::deleteFitSills
        """
        return _gstlearn.CovList_deleteFitSills(self)

    def setFitSills(self, amopts):
        r"""

        CovList::setFitSills
        """
        return _gstlearn.CovList_setFitSills(self, amopts)

    def getFitSills(self):
        r"""

        CovList::getFitSills
        """
        return _gstlearn.CovList_getFitSills(self)

    def getNitergCum(self):
        r"""

        CovList::getNitergCum
        """
        return _gstlearn.CovList_getNitergCum(self)

    def __repr__(self):
        return _gstlearn.CovList___repr__(self)

# Register CovList in _gstlearn:
_gstlearn.CovList_swigregister(CovList)
class CovAnisoList(CovList):
    r"""


    This class describes the **Covariance** as a list of elementary covariances (see
    CovAniso.hpp for more details) where the calculation rule is simple: the
    returned value is the **sum** of each elementary (active) covariance function.  

    C++ includes: CovAnisoList.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovAnisoList::CovAnisoList
        """
        _gstlearn.CovAnisoList_swiginit(self, _gstlearn.new_CovAnisoList(*args))
    __swig_destroy__ = _gstlearn.delete_CovAnisoList

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovAnisoList_clone(self)

    def isConsistent(self, space):
        r"""

        CovAnisoList::isConsistent
        ICloneable interface.  

        Interface for ASpaceObject  

        TODO : CovAnisoList::isConsistent  

        """
        return _gstlearn.CovAnisoList_isConsistent(self, space)

    def getNVar(self):
        r"""

        CovAnisoList::getNVar
        Interface for ACov.  

        """
        return _gstlearn.CovAnisoList_getNVar(self)

    def isIndexable(self):
        r"""

        CovAnisoList::isIndexable
        """
        return _gstlearn.CovAnisoList_isIndexable(self)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        CovAnisoList::eval0
        Calculate the covariance between two variables for 0-distance (stationary case)  

        """
        return _gstlearn.CovAnisoList_eval0(self, ivar, jvar, mode)

    def toString(self, strfmt=None):
        r"""

        CovAnisoList::toString
        Interface for AStringable Interface.  

        """
        return _gstlearn.CovAnisoList_toString(self, strfmt)

    def addCov(self, cov):
        r"""

        CovAnisoList::addCov
        CovAnisoList Interface.  

        """
        return _gstlearn.CovAnisoList_addCov(self, cov)

    def getAnamHermite(self):
        r"""

        CovAnisoList::getAnamHermite
        """
        return _gstlearn.CovAnisoList_getAnamHermite(self)

    def getCovMode(self):
        r"""

        CovAnisoList::getCovMode
        """
        return _gstlearn.CovAnisoList_getCovMode(self)

    def hasAnam(self):
        r"""

        CovAnisoList::hasAnam
        """
        return _gstlearn.CovAnisoList_hasAnam(self)

    def getAnam(self):
        r"""

        CovAnisoList::getAnam
        """
        return _gstlearn.CovAnisoList_getAnam(self)

    def setActiveFactor(self, arg2):
        r"""

        CovAnisoList::setActiveFactor
        """
        return _gstlearn.CovAnisoList_setActiveFactor(self, arg2)

    def getActiveFactor(self):
        r"""

        CovAnisoList::getActiveFactor
        """
        return _gstlearn.CovAnisoList_getActiveFactor(self)

    def getAnamNClass(self):
        r"""

        CovAnisoList::getAnamNClass
        """
        return _gstlearn.CovAnisoList_getAnamNClass(self)

    def addCovList(self, covs):
        r"""

        CovAnisoList::addCovList
        """
        return _gstlearn.CovAnisoList_addCovList(self, covs)

    def getNCov(self, skipNugget=False):
        r"""

        CovAnisoList::getNCov
        """
        return _gstlearn.CovAnisoList_getNCov(self, skipNugget)

    def hasRange(self):
        r"""

        CovAnisoList::hasRange
        """
        return _gstlearn.CovAnisoList_hasRange(self)

    def isStationary(self):
        r"""

        CovAnisoList::isStationary
        """
        return _gstlearn.CovAnisoList_isStationary(self)

    def getMaximumDistance(self):
        r"""

        CovAnisoList::getMaximumDistance
        Returns the largest range (in any direction in the heterotopic case)  

        Returns
        -------  

        """
        return _gstlearn.CovAnisoList_getMaximumDistance(self)

    def getTotalSill(self, ivar=0, jvar=0):
        r"""

        CovAnisoList::getTotalSill
        Calculate the total sill of the model for given pair of variables Returns TEST
        as soon as one structure has no sill  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        """
        return _gstlearn.CovAnisoList_getTotalSill(self, ivar, jvar)

    def getCovAniso(self, *args):
        r"""

        CovAnisoList::getCovAniso
        """
        return _gstlearn.CovAnisoList_getCovAniso(self, *args)

    def setCov(self, icov, cov):
        r"""

        CovAnisoList::setCov
        """
        return _gstlearn.CovAnisoList_setCov(self, icov, cov)

    def getCovType(self, icov):
        r"""

        CovAnisoList::getCovType
        """
        return _gstlearn.CovAnisoList_getCovType(self, icov)

    def getCovName(self, icov):
        r"""

        CovAnisoList::getCovName
        """
        return _gstlearn.CovAnisoList_getCovName(self, icov)

    def setRangeIsotropic(self, icov, range):
        r"""

        CovAnisoList::setRangeIsotropic
        """
        return _gstlearn.CovAnisoList_setRangeIsotropic(self, icov, range)

    def setType(self, icov, type):
        r"""

        CovAnisoList::setType
        """
        return _gstlearn.CovAnisoList_setType(self, icov, type)

    def setParam(self, icov, value):
        r"""

        CovAnisoList::setParam
        """
        return _gstlearn.CovAnisoList_setParam(self, icov, value)

    def setMarkovCoeffs(self, icov, coeffs):
        r"""

        CovAnisoList::setMarkovCoeffs
        """
        return _gstlearn.CovAnisoList_setMarkovCoeffs(self, icov, coeffs)

    def getParam(self, icov):
        r"""

        CovAnisoList::getParam
        """
        return _gstlearn.CovAnisoList_getParam(self, icov)

    def getRange(self, icov):
        r"""

        CovAnisoList::getRange
        """
        return _gstlearn.CovAnisoList_getRange(self, icov)

    def getRanges(self, icov):
        r"""

        CovAnisoList::getRanges
        """
        return _gstlearn.CovAnisoList_getRanges(self, icov)

    def getAngles(self, icov):
        r"""

        CovAnisoList::getAngles
        """
        return _gstlearn.CovAnisoList_getAngles(self, icov)

    def getNGradParam(self, icov):
        r"""

        CovAnisoList::getNGradParam
        """
        return _gstlearn.CovAnisoList_getNGradParam(self, icov)

    def extractCova(self, icov):
        r"""

        CovAnisoList::extractCova
        """
        return _gstlearn.CovAnisoList_extractCova(self, icov)

    def getCovMinIRFOrder(self):
        r"""

        CovAnisoList::getCovMinIRFOrder
        Returns
        -------
        The Minimum IRF-order induced by the covariances  

        """
        return _gstlearn.CovAnisoList_getCovMinIRFOrder(self)

    def getBallRadius(self):
        r"""

        CovAnisoList::getBallRadius
        Returns the Ball radius (from the first covariance of _covaList)  

        Returns
        -------
        Value of the Ball Radius (if defined, i.e. for Numerical Gradient calculation)  

        """
        return _gstlearn.CovAnisoList_getBallRadius(self)

    def hasExternalCov(self):
        r"""

        CovAnisoList::hasExternalCov
        """
        return _gstlearn.CovAnisoList_hasExternalCov(self)

    def isChangeSupportDefined(self):
        r"""

        CovAnisoList::isChangeSupportDefined
        """
        return _gstlearn.CovAnisoList_isChangeSupportDefined(self)

    def appendParams(self, listParams, gradFuncs=None):
        r"""

        CovAnisoList::appendParams
        """
        return _gstlearn.CovAnisoList_appendParams(self, listParams, gradFuncs)

    def hasNugget(self):
        r"""

        CovAnisoList::hasNugget
        """
        return _gstlearn.CovAnisoList_hasNugget(self)

    def getRankNugget(self):
        r"""

        CovAnisoList::getRankNugget
        """
        return _gstlearn.CovAnisoList_getRankNugget(self)

    def createReduce(self, validVars):
        r"""

        CovAnisoList::createReduce
        """
        return _gstlearn.CovAnisoList_createReduce(self, validVars)

    def makeRangeNoStatDb(self, icov, namecol, idim=0):
        r"""

        CovAnisoList::makeRangeNoStatDb
        """
        return _gstlearn.CovAnisoList_makeRangeNoStatDb(self, icov, namecol, idim)

    def makeScaleNoStatDb(self, icov, namecol, idim=0):
        r"""

        CovAnisoList::makeScaleNoStatDb
        """
        return _gstlearn.CovAnisoList_makeScaleNoStatDb(self, icov, namecol, idim)

    def makeAngleNoStatDb(self, icov, namecol, idim=0):
        r"""

        CovAnisoList::makeAngleNoStatDb
        """
        return _gstlearn.CovAnisoList_makeAngleNoStatDb(self, icov, namecol, idim)

    def makeTensorNoStatDb(self, icov, namecol, idim=0, jdim=0):
        r"""

        CovAnisoList::makeTensorNoStatDb
        """
        return _gstlearn.CovAnisoList_makeTensorNoStatDb(self, icov, namecol, idim, jdim)

    def makeParamNoStatDb(self, icov, namecol):
        r"""

        CovAnisoList::makeParamNoStatDb
        """
        return _gstlearn.CovAnisoList_makeParamNoStatDb(self, icov, namecol)

    def makeRangeNoStatFunctional(self, icov, func, idim=0):
        r"""

        CovAnisoList::makeRangeNoStatFunctional
        """
        return _gstlearn.CovAnisoList_makeRangeNoStatFunctional(self, icov, func, idim)

    def makeScaleNoStatFunctional(self, icov, func, idim=0):
        r"""

        CovAnisoList::makeScaleNoStatFunctional
        """
        return _gstlearn.CovAnisoList_makeScaleNoStatFunctional(self, icov, func, idim)

    def makeAngleNoStatFunctional(self, icov, func, idim=0):
        r"""

        CovAnisoList::makeAngleNoStatFunctional
        """
        return _gstlearn.CovAnisoList_makeAngleNoStatFunctional(self, icov, func, idim)

    def makeTensorNoStatFunctional(self, icov, func, idim=0, jdim=0):
        r"""

        CovAnisoList::makeTensorNoStatFunctional
        """
        return _gstlearn.CovAnisoList_makeTensorNoStatFunctional(self, icov, func, idim, jdim)

    def makeParamNoStatFunctional(self, icov, func):
        r"""

        CovAnisoList::makeParamNoStatFunctional
        """
        return _gstlearn.CovAnisoList_makeParamNoStatFunctional(self, icov, func)

    def makeRangeStationary(self, icov, idim=0):
        r"""

        CovAnisoList::makeRangeStationary
        """
        return _gstlearn.CovAnisoList_makeRangeStationary(self, icov, idim)

    def makeScaleStationary(self, icov, idim=0):
        r"""

        CovAnisoList::makeScaleStationary
        """
        return _gstlearn.CovAnisoList_makeScaleStationary(self, icov, idim)

    def makeAngleStationary(self, icov, idim=0):
        r"""

        CovAnisoList::makeAngleStationary
        """
        return _gstlearn.CovAnisoList_makeAngleStationary(self, icov, idim)

    def makeTensorStationary(self, icov, idim, jdim):
        r"""

        CovAnisoList::makeTensorStationary
        """
        return _gstlearn.CovAnisoList_makeTensorStationary(self, icov, idim, jdim)

    def makeParamStationary(self, icov):
        r"""

        CovAnisoList::makeParamStationary
        """
        return _gstlearn.CovAnisoList_makeParamStationary(self, icov)

    def getSameRotation(self):
        r"""

        CovAnisoList::getSameRotation
        """
        return _gstlearn.CovAnisoList_getSameRotation(self)

    def setSameRotation(self, samerot):
        r"""

        CovAnisoList::setSameRotation
        """
        return _gstlearn.CovAnisoList_setSameRotation(self, samerot)

    def __repr__(self):
        return _gstlearn.CovAnisoList___repr__(self)

# Register CovAnisoList in _gstlearn:
_gstlearn.CovAnisoList_swigregister(CovAnisoList)
class CovAniso(CovProportional):
    r"""


    This class describes an **elementary covariance**.  

    This covariance is described through the following list of parameters:  

    *   the covariance **type**: the list of these types is provided in ECov.hpp  
    *   the largest set of parameters for any covariance: **range(s)**, **anisotropy
        angle(s)**, **third parameter**. Some of these parameters do not make sense,
        depending on the covariance type: e.g. the range for nugget effect, the
        third parameter for a spherical structure, ... All these parameters are
        processed and stored as a **tensor** in order to avoid repetitive
        calculations.  
    *   the **sill**. This comes as a square symmetric matrix whose dimension is
        equal to the number of variables.  

    C++ includes: CovAniso.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovAniso::CovAniso
        """
        _gstlearn.CovAniso_swiginit(self, _gstlearn.new_CovAniso(*args))
    __swig_destroy__ = _gstlearn.delete_CovAniso

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovAniso_clone(self)

    def toString(self, strfmt=None):
        r"""

        CovAniso::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.CovAniso_toString(self, strfmt)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        CovAniso::eval0
        ASpaceObject Interface.  

        ACov Interface  

        """
        return _gstlearn.CovAniso_eval0(self, ivar, jvar, mode)

    def evalCovOnSphere(self, alpha, degree=50, flagScaleDistance=True, mode=None):
        r"""

        CovAniso::evalCovOnSphere
        """
        return _gstlearn.CovAniso_evalCovOnSphere(self, alpha, degree, flagScaleDistance, mode)

    def evalSpectrumOnSphere(self, n, flagNormDistance=False, flagCumul=False):
        r"""

        CovAniso::evalSpectrumOnSphere
        """
        return _gstlearn.CovAniso_evalSpectrumOnSphere(self, n, flagNormDistance, flagCumul)

    def evalSpectrum(self, freq, ivar=0, jvar=0):
        r"""

        CovAniso::evalSpectrum
        """
        return _gstlearn.CovAniso_evalSpectrum(self, freq, ivar, jvar)

    def getIntegralRange(self, ndisc, hmax):
        r"""

        CovAniso::getIntegralRange
        Calculate the Integral Range in various Space Dimension (1, 2 or 3)  

        Returns
        -------  

        """
        return _gstlearn.CovAniso_getIntegralRange(self, ndisc, hmax)

    def getFormula(self):
        r"""

        CovAniso::getFormula
        """
        return _gstlearn.CovAniso_getFormula(self)

    def getBallRadius(self):
        r"""

        CovAniso::getBallRadius
        """
        return _gstlearn.CovAniso_getBallRadius(self)

    @staticmethod
    def createFromParam(type, range, sill, param, ranges, sills, angles, space, flagRange):
        r"""

        CovAniso::createFromParam
        """
        return _gstlearn.CovAniso_createFromParam(type, range, sill, param, ranges, sills, angles, space, flagRange)

    @staticmethod
    def createIsotropic(ctxt, type, range, sill=1., param=1., flagRange=True):
        r"""

        CovAniso::createIsotropic
        """
        return _gstlearn.CovAniso_createIsotropic(ctxt, type, range, sill, param, flagRange)

    @staticmethod
    def createAnisotropic(*args, **kwargs):
        r"""

        CovAniso::createAnisotropic
        """
        return _gstlearn.CovAniso_createAnisotropic(*args, **kwargs)

    @staticmethod
    def createIsotropicMulti(ctxt, type, range, sills, param=1., flagRange=True):
        r"""

        CovAniso::createIsotropicMulti
        """
        return _gstlearn.CovAniso_createIsotropicMulti(ctxt, type, range, sills, param, flagRange)

    @staticmethod
    def createAnisotropicMulti(*args, **kwargs):
        r"""

        CovAniso::createAnisotropicMulti
        """
        return _gstlearn.CovAniso_createAnisotropicMulti(*args, **kwargs)

    def getSlope(self, ivar, jvar):
        r"""

        CovAniso::getSlope
        Return the Slope calculated as the sill / range(idim=0)  

        Parameters
        ----------
        * `ivar` :  
            Rank of the first variable  
        * `jvar` :  
            Rank of the second variable  

        Returns
        -------  

        """
        return _gstlearn.CovAniso_getSlope(self, ivar, jvar)

    def getAnisoRotation(self):
        r"""

        CovAniso::getAnisoRotation
        """
        return _gstlearn.CovAniso_getAnisoRotation(self)

    def getFlagAniso(self):
        r"""

        CovAniso::getFlagAniso
        """
        return _gstlearn.CovAniso_getFlagAniso(self)

    def getFlagRotation(self):
        r"""

        CovAniso::getFlagRotation
        """
        return _gstlearn.CovAniso_getFlagRotation(self)

    def getAnisoAngles(self):
        r"""

        CovAniso::getAnisoAngles
        """
        return _gstlearn.CovAniso_getAnisoAngles(self)

    def getAnisoRotMat(self):
        r"""

        CovAniso::getAnisoRotMat
        """
        return _gstlearn.CovAniso_getAnisoRotMat(self)

    def getAnisoInvMat(self):
        r"""

        CovAniso::getAnisoInvMat
        """
        return _gstlearn.CovAniso_getAnisoInvMat(self)

    def getAnisoAngle(self, idim):
        r"""

        CovAniso::getAnisoAngle
        """
        return _gstlearn.CovAniso_getAnisoAngle(self, idim)

    def getAnisoRotMatElement(self, idim, jdim):
        r"""

        CovAniso::getAnisoRotMatElement
        """
        return _gstlearn.CovAniso_getAnisoRotMatElement(self, idim, jdim)

    def getAnisoCoeff(self, idim):
        r"""

        CovAniso::getAnisoCoeff
        """
        return _gstlearn.CovAniso_getAnisoCoeff(self, idim)

    def getContext(self):
        r"""

        CovAniso::getContext
        """
        return _gstlearn.CovAniso_getContext(self)

    def getCovName(self):
        r"""

        CovAniso::getCovName
        """
        return _gstlearn.CovAniso_getCovName(self)

    def isIsotropic(self):
        r"""

        CovAniso::isIsotropic
        """
        return _gstlearn.CovAniso_isIsotropic(self)

    def isAsymptotic(self):
        r"""

        CovAniso::isAsymptotic
        """
        return _gstlearn.CovAniso_isAsymptotic(self)

    def hasRotation(self):
        r"""

        CovAniso::hasRotation
        """
        return _gstlearn.CovAniso_hasRotation(self)

    def getAniso(self):
        r"""

        CovAniso::getAniso
        """
        return _gstlearn.CovAniso_getAniso(self)

    def setAniso(self, aniso):
        r"""

        CovAniso::setAniso
        """
        return _gstlearn.CovAniso_setAniso(self, aniso)

    def getCorFunc(self):
        r"""

        CovAniso::getCorFunc
        """
        return _gstlearn.CovAniso_getCorFunc(self)

    def evalCovOnSphereVec(self, alpha, degree=50, flagScaleDistance=False, mode=None):
        r"""

        CovAniso::evalCovOnSphereVec
        """
        return _gstlearn.CovAniso_evalCovOnSphereVec(self, alpha, degree, flagScaleDistance, mode)

    def evalCovFFT(self, hmax, N=128, ivar=0, jvar=0):
        r"""

        CovAniso::evalCovFFT
        """
        return _gstlearn.CovAniso_evalCovFFT(self, hmax, N, ivar, jvar)

    def getNDim(self):
        r"""

        CovAniso::getNDim
        """
        return _gstlearn.CovAniso_getNDim(self)

    def getCorAniso(self, *args):
        r"""

        CovAniso::getCorAniso
        """
        return _gstlearn.CovAniso_getCorAniso(self, *args)

    def createReduce(self, validVars):
        r"""

        CovAniso::createReduce
        """
        return _gstlearn.CovAniso_createReduce(self, validVars)

    def _isOptimEnabled(self):
        r"""

        CovAniso::_isOptimEnabled
        """
        return _gstlearn.CovAniso__isOptimEnabled(self)

    def getScalesParam(self):
        r"""

        CovAniso::getScalesParam
        """
        return _gstlearn.CovAniso_getScalesParam(self)

    def getAnglesParam(self):
        r"""

        CovAniso::getAnglesParam
        """
        return _gstlearn.CovAniso_getAnglesParam(self)

    def _getSillValue(self, ivar, jvar, mode):
        r"""

        CovAniso::_getSillValue
        """
        return _gstlearn.CovAniso__getSillValue(self, ivar, jvar, mode)

    def _eval(self, p1, p2, ivar=0, jvar=0, mode=None):
        r"""

        CovAniso::_eval
        """
        return _gstlearn.CovAniso__eval(self, p1, p2, ivar, jvar, mode)

    def __repr__(self):
        return _gstlearn.CovAniso___repr__(self)

# Register CovAniso in _gstlearn:
_gstlearn.CovAniso_swigregister(CovAniso)

def scale2range(type, scale, param=1.):
    r"""


    """
    return _gstlearn.scale2range(type, scale, param)

def range2scale(type, range, param=1.):
    r"""


    """
    return _gstlearn.range2scale(type, range, param)
class ACovGradient(CovAniso):
    r"""


    Class dedicated to manipulating a variables and its derivatives. This feature is
    limited to the monovariate case  

    C++ includes: ACovGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_ACovGradient

    def evalZAndGradients(self, p1, p2, covVal, covGp, covGG, mode=None, flagGrad=False):
        r"""

        ACovGradient::evalZAndGradients
        """
        return _gstlearn.ACovGradient_evalZAndGradients(self, p1, p2, covVal, covGp, covGG, mode, flagGrad)

    def __repr__(self):
        return _gstlearn.ACovGradient___repr__(self)

# Register ACovGradient in _gstlearn:
_gstlearn.ACovGradient_swigregister(ACovGradient)
class CorGneiting(ACov):
    r"""


    This class describes the Gneiting correlation function.  

    C++ includes: CorGneiting.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CorGneiting::CorGneiting
        """
        _gstlearn.CorGneiting_swiginit(self, _gstlearn.new_CorGneiting(*args))
    __swig_destroy__ = _gstlearn.delete_CorGneiting

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CorGneiting_clone(self)

    def isConsistent(self, space):
        r"""

        CorGneiting::isConsistent
        """
        return _gstlearn.CorGneiting_isConsistent(self, space)

    def getNVar(self):
        r"""

        CorGneiting::getNVar
        ACov Interface.  

        """
        return _gstlearn.CorGneiting_getNVar(self)

    def __repr__(self):
        return _gstlearn.CorGneiting___repr__(self)

# Register CorGneiting in _gstlearn:
_gstlearn.CorGneiting_swigregister(CorGneiting)
class CorMatern(ACov):
    r"""


    This class describes the Gneiting correlation function.  

    C++ includes: CorMatern.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CorMatern::CorMatern
        """
        _gstlearn.CorMatern_swiginit(self, _gstlearn.new_CorMatern(*args))
    __swig_destroy__ = _gstlearn.delete_CorMatern

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CorMatern_clone(self)

    def isConsistent(self, space):
        r"""

        CorMatern::isConsistent
        """
        return _gstlearn.CorMatern_isConsistent(self, space)

    def getNVar(self):
        r"""

        CorMatern::getNVar
        ACov Interface.  

        """
        return _gstlearn.CorMatern_getNVar(self)

    def getCorMax(self, ivar, jvar):
        r"""

        CorMatern::getCorMax
        """
        return _gstlearn.CorMatern_getCorMax(self, ivar, jvar)

    def computeScale(self, ivar, jvar):
        r"""

        CorMatern::computeScale
        """
        return _gstlearn.CorMatern_computeScale(self, ivar, jvar)

    def computeParam(self, ivar, jvar):
        r"""

        CorMatern::computeParam
        """
        return _gstlearn.CorMatern_computeParam(self, ivar, jvar)

    def __repr__(self):
        return _gstlearn.CorMatern___repr__(self)

# Register CorMatern in _gstlearn:
_gstlearn.CorMatern_swigregister(CorMatern)
class Def_Tapering(object):
    r"""


    C++ includes: Tapering.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_gstlearn.Def_Tapering_name_get, _gstlearn.Def_Tapering_name_set)
    maxNDim = property(_gstlearn.Def_Tapering_maxNDim_get, _gstlearn.Def_Tapering_maxNDim_set)
    tapeFunc = property(_gstlearn.Def_Tapering_tapeFunc_get, _gstlearn.Def_Tapering_tapeFunc_set)

    def __init__(self):
        r"""


        C++ includes: Tapering.hpp

        """
        _gstlearn.Def_Tapering_swiginit(self, _gstlearn.new_Def_Tapering())
    __swig_destroy__ = _gstlearn.delete_Def_Tapering

# Register Def_Tapering in _gstlearn:
_gstlearn.Def_Tapering_swigregister(Def_Tapering)

def _tape_spherical(arg1):
    r"""


    """
    return _gstlearn._tape_spherical(arg1)

def _tape_cubic(arg1):
    r"""


    """
    return _gstlearn._tape_cubic(arg1)

def _tape_triangle(arg1):
    r"""


    """
    return _gstlearn._tape_triangle(arg1)

def _tape_penta(arg1):
    r"""


    """
    return _gstlearn._tape_penta(arg1)

def _tape_storkey(arg1):
    r"""


    """
    return _gstlearn._tape_storkey(arg1)

def _tape_wendland1(arg1):
    r"""


    """
    return _gstlearn._tape_wendland1(arg1)

def _tape_wendland2(arg1):
    r"""


    """
    return _gstlearn._tape_wendland2(arg1)

def D_TAPE(rank):
    r"""


    """
    return _gstlearn.D_TAPE(rank)
class CovLMCTapering(CovAnisoList):
    r"""


    C++ includes: CovLMCTapering.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovLMCTapering::CovLMCTapering
        """
        _gstlearn.CovLMCTapering_swiginit(self, _gstlearn.new_CovLMCTapering(*args))
    __swig_destroy__ = _gstlearn.delete_CovLMCTapering

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovLMCTapering_clone(self)

    def toString(self, strfmt=None):
        r"""

        CovLMCTapering::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.CovLMCTapering_toString(self, strfmt)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        CovLMCTapering::eval0
        ACov interface.  

        """
        return _gstlearn.CovLMCTapering_eval0(self, ivar, jvar, mode)

    def init(self, tapetype, taperange):
        r"""

        CovLMCTapering::init
        """
        return _gstlearn.CovLMCTapering_init(self, tapetype, taperange)

    def getName(self):
        r"""

        CovLMCTapering::getName
        """
        return _gstlearn.CovLMCTapering_getName(self)

    def getTapeRange(self):
        r"""

        CovLMCTapering::getTapeRange
        """
        return _gstlearn.CovLMCTapering_getTapeRange(self)

    def setTapeRange(self, range):
        r"""

        CovLMCTapering::setTapeRange
        """
        return _gstlearn.CovLMCTapering_setTapeRange(self, range)

    def __repr__(self):
        return _gstlearn.CovLMCTapering___repr__(self)

# Register CovLMCTapering in _gstlearn:
_gstlearn.CovLMCTapering_swigregister(CovLMCTapering)
class Def_Convolution(object):
    r"""


    C++ includes: CovLMCConvolution.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    convName = property(_gstlearn.Def_Convolution_convName_get, _gstlearn.Def_Convolution_convName_set)
    convScale = property(_gstlearn.Def_Convolution_convScale_get, _gstlearn.Def_Convolution_convScale_set)
    convFunc = property(_gstlearn.Def_Convolution_convFunc_get, _gstlearn.Def_Convolution_convFunc_set)

    def __init__(self):
        r"""


        C++ includes: CovLMCConvolution.hpp

        """
        _gstlearn.Def_Convolution_swiginit(self, _gstlearn.new_Def_Convolution())
    __swig_destroy__ = _gstlearn.delete_Def_Convolution

# Register Def_Convolution in _gstlearn:
_gstlearn.Def_Convolution_swigregister(Def_Convolution)

def _conv_uniform(v):
    r"""


    """
    return _gstlearn._conv_uniform(v)

def _conv_exponential(v):
    r"""


    """
    return _gstlearn._conv_exponential(v)

def _conv_gaussian(v):
    r"""


    """
    return _gstlearn._conv_gaussian(v)

def _conv_sincard(v):
    r"""


    """
    return _gstlearn._conv_sincard(v)

def D_CONV(rank):
    r"""


    """
    return _gstlearn.D_CONV(rank)
class CovLMCConvolution(CovAnisoList):
    r"""


    C++ includes: CovLMCConvolution.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovLMCConvolution::CovLMCConvolution
        """
        _gstlearn.CovLMCConvolution_swiginit(self, _gstlearn.new_CovLMCConvolution(*args))
    __swig_destroy__ = _gstlearn.delete_CovLMCConvolution

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovLMCConvolution_clone(self)

    def toString(self, strfmt=None):
        r"""

        CovLMCConvolution::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.CovLMCConvolution_toString(self, strfmt)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        CovLMCConvolution::eval0
        ACov Interface.  

        """
        return _gstlearn.CovLMCConvolution_eval0(self, ivar, jvar, mode)

    def init(self, conv_type, conv_idir, conv_range, conv_ndisc):
        r"""

        CovLMCConvolution::init
        """
        return _gstlearn.CovLMCConvolution_init(self, conv_type, conv_idir, conv_range, conv_ndisc)

    def getConvRange(self):
        r"""

        CovLMCConvolution::getConvRange
        """
        return _gstlearn.CovLMCConvolution_getConvRange(self)

    def getConvWeight(self):
        r"""

        CovLMCConvolution::getConvWeight
        """
        return _gstlearn.CovLMCConvolution_getConvWeight(self)

    def getConvIncr(self, *args):
        r"""

        CovLMCConvolution::getConvIncr
        """
        return _gstlearn.CovLMCConvolution_getConvIncr(self, *args)

    def getNConv(self):
        r"""

        CovLMCConvolution::getNConv
        """
        return _gstlearn.CovLMCConvolution_getNConv(self)

    def __repr__(self):
        return _gstlearn.CovLMCConvolution___repr__(self)

# Register CovLMCConvolution in _gstlearn:
_gstlearn.CovLMCConvolution_swigregister(CovLMCConvolution)
class CovLMCAnamorphosis(CovAnisoList):
    r"""


    C++ includes: CovLMCAnamorphosis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovLMCAnamorphosis::CovLMCAnamorphosis
        """
        _gstlearn.CovLMCAnamorphosis_swiginit(self, _gstlearn.new_CovLMCAnamorphosis(*args))
    __swig_destroy__ = _gstlearn.delete_CovLMCAnamorphosis

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovLMCAnamorphosis_clone(self)

    def toString(self, strfmt=None):
        r"""

        CovLMCAnamorphosis::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.CovLMCAnamorphosis_toString(self, strfmt)

    def eval0(self, ivar=0, jvar=0, mode=None):
        r"""

        CovLMCAnamorphosis::eval0
        ACov Interface.  

        """
        return _gstlearn.CovLMCAnamorphosis_eval0(self, ivar, jvar, mode)

    def addCov(self, cov):
        r"""

        CovLMCAnamorphosis::addCov
        CovAnisoList Interface.  

        """
        return _gstlearn.CovLMCAnamorphosis_addCov(self, cov)

    def hasAnam(self):
        r"""

        CovLMCAnamorphosis::hasAnam
        """
        return _gstlearn.CovLMCAnamorphosis_hasAnam(self)

    def getAnam(self):
        r"""

        CovLMCAnamorphosis::getAnam
        """
        return _gstlearn.CovLMCAnamorphosis_getAnam(self)

    def setActiveFactor(self, iclass):
        r"""

        CovLMCAnamorphosis::setActiveFactor
        """
        return _gstlearn.CovLMCAnamorphosis_setActiveFactor(self, iclass)

    def getActiveFactor(self):
        r"""

        CovLMCAnamorphosis::getActiveFactor
        """
        return _gstlearn.CovLMCAnamorphosis_getActiveFactor(self)

    def getAnamNClass(self):
        r"""

        CovLMCAnamorphosis::getAnamNClass
        """
        return _gstlearn.CovLMCAnamorphosis_getAnamNClass(self)

    def init(self, *args, **kwargs):
        r"""

        CovLMCAnamorphosis::init
        """
        return _gstlearn.CovLMCAnamorphosis_init(self, *args, **kwargs)

    def getAnamType(self):
        r"""

        CovLMCAnamorphosis::getAnamType
        """
        return _gstlearn.CovLMCAnamorphosis_getAnamType(self)

    def setAnam(self, anam):
        r"""

        CovLMCAnamorphosis::setAnam
        """
        return _gstlearn.CovLMCAnamorphosis_setAnam(self, anam)

    def __repr__(self):
        return _gstlearn.CovLMCAnamorphosis___repr__(self)

# Register CovLMCAnamorphosis in _gstlearn:
_gstlearn.CovLMCAnamorphosis_swigregister(CovLMCAnamorphosis)
class CovLMGradient(CovAnisoList):
    r"""


    C++ includes: CovLMGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovLMGradient::CovLMGradient
        """
        _gstlearn.CovLMGradient_swiginit(self, _gstlearn.new_CovLMGradient(*args))
    __swig_destroy__ = _gstlearn.delete_CovLMGradient

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.CovLMGradient_clone(self)

    def addCov(self, cov):
        r"""

        CovLMGradient::addCov
        ICloneable interface.  

        """
        return _gstlearn.CovLMGradient_addCov(self, cov)

    def evalZAndGradients(self, *args):
        r"""

        CovLMGradient::evalZAndGradients
        TODO : Not true whatever the space  

        """
        return _gstlearn.CovLMGradient_evalZAndGradients(self, *args)

    def __repr__(self):
        return _gstlearn.CovLMGradient___repr__(self)

# Register CovLMGradient in _gstlearn:
_gstlearn.CovLMGradient_swigregister(CovLMGradient)
class CovContext(ASpaceObject):
    r"""


    C++ includes: CovContext.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovContext::CovContext
        """
        _gstlearn.CovContext_swiginit(self, _gstlearn.new_CovContext(*args))
    __swig_destroy__ = _gstlearn.delete_CovContext

    def toString(self, strfmt=None):
        r"""

        CovContext::toString
        AStringable interface.  

        """
        return _gstlearn.CovContext_toString(self, strfmt)

    def isConsistent(self, space):
        r"""

        CovContext::isConsistent
        Indicate if I am consistent with the provided space.  

        TODO: Consistency of CovContext toward a space: Possible duplicate:  

        *   CovFactory::_isValid  
        *   ACovFunc::isConsistent  

        """
        return _gstlearn.CovContext_isConsistent(self, space)

    @staticmethod
    def create(nvar, ndim):
        r"""

        CovContext::create
        """
        return _gstlearn.CovContext_create(nvar, ndim)

    def isEqual(self, r):
        r"""

        CovContext::isEqual
        Checks that two CovContext are 'similar'  

        Parameters
        ----------
        * `r` :  
            Secondary CovContext to be compared with this  

        Returns
        -------  

        """
        return _gstlearn.CovContext_isEqual(self, r)

    def getNVar(self):
        r"""

        CovContext::getNVar
        """
        return _gstlearn.CovContext_getNVar(self)

    def getField(self):
        r"""

        CovContext::getField
        """
        return _gstlearn.CovContext_getField(self)

    def getCovar0(self, *args):
        r"""

        CovContext::getCovar0
        """
        return _gstlearn.CovContext_getCovar0(self, *args)

    def setNVar(self, nvar):
        r"""

        CovContext::setNVar
        """
        return _gstlearn.CovContext_setNVar(self, nvar)

    def setField(self, field):
        r"""

        CovContext::setField
        """
        return _gstlearn.CovContext_setField(self, field)

    def setCovar0s(self, covar0):
        r"""

        CovContext::setCovar0s
        Define the covariance at the origin  

        Parameters
        ----------
        * `covar0` :  
            Values  

        """
        return _gstlearn.CovContext_setCovar0s(self, covar0)

    def setCovar0(self, ivar, jvar, covar0):
        r"""

        CovContext::setCovar0
        """
        return _gstlearn.CovContext_setCovar0(self, ivar, jvar, covar0)

    def copyCovContext(self, ctxt, severe=False):
        r"""

        CovContext::copyCovContext
        This operation sets the contents of the current CovContext class by copying the
        information from a source CovContext  

        Parameters
        ----------
        * `ctxt` :  
            Source CovContext  
        * `severe` :  
            When severe, does not allow modifying the number of variables  

        """
        return _gstlearn.CovContext_copyCovContext(self, ctxt, severe)

    def createReduce(self, validVars):
        r"""

        CovContext::createReduce
        """
        return _gstlearn.CovContext_createReduce(self, validVars)

    def __repr__(self):
        return _gstlearn.CovContext___repr__(self)

# Register CovContext in _gstlearn:
_gstlearn.CovContext_swigregister(CovContext)
class CovCalcMode(AStringable):
    r"""


    C++ includes: CovCalcMode.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovCalcMode::CovCalcMode
        """
        _gstlearn.CovCalcMode_swiginit(self, _gstlearn.new_CovCalcMode(*args))
    __swig_destroy__ = _gstlearn.delete_CovCalcMode

    @staticmethod
    def create(*args, **kwargs):
        r"""

        CovCalcMode::create
        """
        return _gstlearn.CovCalcMode_create(*args, **kwargs)

    def getMember(self):
        r"""

        CovCalcMode::getMember
        """
        return _gstlearn.CovCalcMode_getMember(self)

    def getAsVario(self):
        r"""

        CovCalcMode::getAsVario
        """
        return _gstlearn.CovCalcMode_getAsVario(self)

    def getUnitary(self):
        r"""

        CovCalcMode::getUnitary
        """
        return _gstlearn.CovCalcMode_getUnitary(self)

    def getOrderVario(self):
        r"""

        CovCalcMode::getOrderVario
        """
        return _gstlearn.CovCalcMode_getOrderVario(self)

    def setAsVario(self, asVario):
        r"""

        CovCalcMode::setAsVario
        """
        return _gstlearn.CovCalcMode_setAsVario(self, asVario)

    def setMember(self, member):
        r"""

        CovCalcMode::setMember
        """
        return _gstlearn.CovCalcMode_setMember(self, member)

    def setUnitary(self, unitary):
        r"""

        CovCalcMode::setUnitary
        """
        return _gstlearn.CovCalcMode_setUnitary(self, unitary)

    def setOrderVario(self, orderVario):
        r"""

        CovCalcMode::setOrderVario
        """
        return _gstlearn.CovCalcMode_setOrderVario(self, orderVario)

    def __repr__(self):
        return _gstlearn.CovCalcMode___repr__(self)

# Register CovCalcMode in _gstlearn:
_gstlearn.CovCalcMode_swigregister(CovCalcMode)
class CovBesselJ(ACovFunc):
    r"""


    C++ includes: CovBesselJ.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovBesselJ::CovBesselJ
        """
        _gstlearn.CovBesselJ_swiginit(self, _gstlearn.new_CovBesselJ(*args))
    __swig_destroy__ = _gstlearn.delete_CovBesselJ

    def hasParam(self):
        r"""

        CovBesselJ::hasParam
        """
        return _gstlearn.CovBesselJ_hasParam(self)

    def getParMax(self):
        r"""

        CovBesselJ::getParMax
        """
        return _gstlearn.CovBesselJ_getParMax(self)

    def getFormula(self):
        r"""

        CovBesselJ::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovBesselJ_getFormula(self)

    def getCovName(self):
        r"""

        CovBesselJ::getCovName
        """
        return _gstlearn.CovBesselJ_getCovName(self)

    def getMinOrder(self):
        r"""

        CovBesselJ::getMinOrder
        """
        return _gstlearn.CovBesselJ_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovBesselJ::getCompatibleSpaceR
        """
        return _gstlearn.CovBesselJ_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovBesselJ::isValidForTurningBand
        """
        return _gstlearn.CovBesselJ_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovBesselJ::simulateTurningBand
        """
        return _gstlearn.CovBesselJ_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovBesselJ___repr__(self)

# Register CovBesselJ in _gstlearn:
_gstlearn.CovBesselJ_swigregister(CovBesselJ)
class CovMatern(ACovFunc):
    r"""


    C++ includes: CovMatern.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovMatern::CovMatern
        """
        _gstlearn.CovMatern_swiginit(self, _gstlearn.new_CovMatern(*args))
    __swig_destroy__ = _gstlearn.delete_CovMatern

    def getFormula(self):
        r"""

        CovMatern::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovMatern_getFormula(self)

    def getCovName(self):
        r"""

        CovMatern::getCovName
        """
        return _gstlearn.CovMatern_getCovName(self)

    def getMinOrder(self):
        r"""

        CovMatern::getMinOrder
        """
        return _gstlearn.CovMatern_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovMatern::getCompatibleSpaceR
        """
        return _gstlearn.CovMatern_getCompatibleSpaceR(self)

    def getCompatibleSpaceS(self):
        r"""

        CovMatern::getCompatibleSpaceS
        """
        return _gstlearn.CovMatern_getCompatibleSpaceS(self)

    def hasParam(self):
        r"""

        CovMatern::hasParam
        """
        return _gstlearn.CovMatern_hasParam(self)

    def getParMax(self):
        r"""

        CovMatern::getParMax
        """
        return _gstlearn.CovMatern_getParMax(self)

    def getScadef(self):
        r"""

        CovMatern::getScadef
        """
        return _gstlearn.CovMatern_getScadef(self)

    def hasSpectrumOnSphere(self):
        r"""

        CovMatern::hasSpectrumOnSphere
        """
        return _gstlearn.CovMatern_hasSpectrumOnSphere(self)

    def hasSpectrumOnRn(self):
        r"""

        CovMatern::hasSpectrumOnRn
        """
        return _gstlearn.CovMatern_hasSpectrumOnRn(self)

    def hasMarkovCoeffs(self):
        r"""

        CovMatern::hasMarkovCoeffs
        """
        return _gstlearn.CovMatern_hasMarkovCoeffs(self)

    def evaluateSpectrum(self, freq):
        r"""

        CovMatern::evaluateSpectrum
        """
        return _gstlearn.CovMatern_evaluateSpectrum(self, freq)

    def setMarkovCoeffs(self, coeffs):
        r"""

        CovMatern::setMarkovCoeffs
        """
        return _gstlearn.CovMatern_setMarkovCoeffs(self, coeffs)

    def getMarkovCoeffs(self):
        r"""

        CovMatern::getMarkovCoeffs
        """
        return _gstlearn.CovMatern_getMarkovCoeffs(self)

    def getCorrec(self):
        r"""

        CovMatern::getCorrec
        """
        return _gstlearn.CovMatern_getCorrec(self)

    def computeCorrec(self, ndim):
        r"""

        CovMatern::computeCorrec
        """
        return _gstlearn.CovMatern_computeCorrec(self, ndim)

    def setCorrec(self, val):
        r"""

        CovMatern::setCorrec
        """
        return _gstlearn.CovMatern_setCorrec(self, val)

    def computeMarkovCoeffs(self, dim):
        r"""

        CovMatern::computeMarkovCoeffs
        """
        return _gstlearn.CovMatern_computeMarkovCoeffs(self, dim)

    def isValidForTurningBand(self):
        r"""

        CovMatern::isValidForTurningBand
        """
        return _gstlearn.CovMatern_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovMatern::simulateTurningBand
        """
        return _gstlearn.CovMatern_simulateTurningBand(self, t0, operTB)

    def isValidForSpectral(self):
        r"""

        CovMatern::isValidForSpectral
        """
        return _gstlearn.CovMatern_isValidForSpectral(self)

    def simulateSpectralOmega(self, nb):
        r"""

        CovMatern::simulateSpectralOmega
        """
        return _gstlearn.CovMatern_simulateSpectralOmega(self, nb)

    def __repr__(self):
        return _gstlearn.CovMatern___repr__(self)

# Register CovMatern in _gstlearn:
_gstlearn.CovMatern_swigregister(CovMatern)

def bessel_set_old_style(style):
    r"""


    """
    return _gstlearn.bessel_set_old_style(style)
class CovCauchy(ACovFunc):
    r"""


    C++ includes: CovCauchy.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovCauchy::CovCauchy
        """
        _gstlearn.CovCauchy_swiginit(self, _gstlearn.new_CovCauchy(*args))
    __swig_destroy__ = _gstlearn.delete_CovCauchy

    def getFormula(self):
        r"""

        CovCauchy::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovCauchy_getFormula(self)

    def getCovName(self):
        r"""

        CovCauchy::getCovName
        """
        return _gstlearn.CovCauchy_getCovName(self)

    def getMinOrder(self):
        r"""

        CovCauchy::getMinOrder
        """
        return _gstlearn.CovCauchy_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovCauchy::getCompatibleSpaceR
        """
        return _gstlearn.CovCauchy_getCompatibleSpaceR(self)

    def hasParam(self):
        r"""

        CovCauchy::hasParam
        """
        return _gstlearn.CovCauchy_hasParam(self)

    def getParMax(self):
        r"""

        CovCauchy::getParMax
        """
        return _gstlearn.CovCauchy_getParMax(self)

    def getScadef(self):
        r"""

        CovCauchy::getScadef
        """
        return _gstlearn.CovCauchy_getScadef(self)

    def __repr__(self):
        return _gstlearn.CovCauchy___repr__(self)

# Register CovCauchy in _gstlearn:
_gstlearn.CovCauchy_swigregister(CovCauchy)
class CovCosExp(ACovFunc):
    r"""


    C++ includes: CovCosExp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovCosExp::CovCosExp
        """
        _gstlearn.CovCosExp_swiginit(self, _gstlearn.new_CovCosExp(*args))
    __swig_destroy__ = _gstlearn.delete_CovCosExp

    def getParMax(self):
        r"""

        CovCosExp::getParMax
        """
        return _gstlearn.CovCosExp_getParMax(self)

    def hasParam(self):
        r"""

        CovCosExp::hasParam
        """
        return _gstlearn.CovCosExp_hasParam(self)

    def getScadef(self):
        r"""

        CovCosExp::getScadef
        """
        return _gstlearn.CovCosExp_getScadef(self)

    def getCovName(self):
        r"""

        CovCosExp::getCovName
        """
        return _gstlearn.CovCosExp_getCovName(self)

    def getMinOrder(self):
        r"""

        CovCosExp::getMinOrder
        """
        return _gstlearn.CovCosExp_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovCosExp::getCompatibleSpaceR
        """
        return _gstlearn.CovCosExp_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovCosExp___repr__(self)

# Register CovCosExp in _gstlearn:
_gstlearn.CovCosExp_swigregister(CovCosExp)
class CovCosinus(ACovFunc):
    r"""


    C++ includes: CovCosinus.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovCosinus::CovCosinus
        """
        _gstlearn.CovCosinus_swiginit(self, _gstlearn.new_CovCosinus(*args))
    __swig_destroy__ = _gstlearn.delete_CovCosinus

    def getMaxNDim(self):
        r"""

        CovCosinus::getMaxNDim
        """
        return _gstlearn.CovCosinus_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovCosinus::getCovName
        """
        return _gstlearn.CovCosinus_getCovName(self)

    def getMinOrder(self):
        r"""

        CovCosinus::getMinOrder
        """
        return _gstlearn.CovCosinus_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovCosinus::getCompatibleSpaceR
        """
        return _gstlearn.CovCosinus_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovCosinus___repr__(self)

# Register CovCosinus in _gstlearn:
_gstlearn.CovCosinus_swigregister(CovCosinus)
class CovCubic(ACovFunc):
    r"""


    C++ includes: CovCubic.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovCubic::CovCubic
        """
        _gstlearn.CovCubic_swiginit(self, _gstlearn.new_CovCubic(*args))
    __swig_destroy__ = _gstlearn.delete_CovCubic

    def getMaxNDim(self):
        r"""

        CovCubic::getMaxNDim
        """
        return _gstlearn.CovCubic_getMaxNDim(self)

    def getFormula(self):
        r"""

        CovCubic::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovCubic_getFormula(self)

    def getCovName(self):
        r"""

        CovCubic::getCovName
        """
        return _gstlearn.CovCubic_getCovName(self)

    def getMinOrder(self):
        r"""

        CovCubic::getMinOrder
        """
        return _gstlearn.CovCubic_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovCubic::getCompatibleSpaceR
        """
        return _gstlearn.CovCubic_getCompatibleSpaceR(self)

    def hasCovDerivative(self):
        r"""

        CovCubic::hasCovDerivative
        """
        return _gstlearn.CovCubic_hasCovDerivative(self)

    def isValidForTurningBand(self):
        r"""

        CovCubic::isValidForTurningBand
        """
        return _gstlearn.CovCubic_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovCubic::simulateTurningBand
        """
        return _gstlearn.CovCubic_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovCubic___repr__(self)

# Register CovCubic in _gstlearn:
_gstlearn.CovCubic_swigregister(CovCubic)
class CovExponential(ACovFunc):
    r"""


    C++ includes: CovExponential.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        CovExponential::CovExponential
        """
        _gstlearn.CovExponential_swiginit(self, _gstlearn.new_CovExponential(*args))
    __swig_destroy__ = _gstlearn.delete_CovExponential

    def getFormula(self):
        r"""

        CovExponential::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovExponential_getFormula(self)

    def getScadef(self):
        r"""

        CovExponential::getScadef
        """
        return _gstlearn.CovExponential_getScadef(self)

    def getCovName(self):
        r"""

        CovExponential::getCovName
        """
        return _gstlearn.CovExponential_getCovName(self)

    def getMinOrder(self):
        r"""

        CovExponential::getMinOrder
        """
        return _gstlearn.CovExponential_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovExponential::getCompatibleSpaceR
        """
        return _gstlearn.CovExponential_getCompatibleSpaceR(self)

    def getCompatibleSpaceS(self):
        r"""

        CovExponential::getCompatibleSpaceS
        """
        return _gstlearn.CovExponential_getCompatibleSpaceS(self)

    def hasCovOnSphere(self):
        r"""

        CovExponential::hasCovOnSphere
        """
        return _gstlearn.CovExponential_hasCovOnSphere(self)

    def hasSpectrumOnSphere(self):
        r"""

        CovExponential::hasSpectrumOnSphere
        """
        return _gstlearn.CovExponential_hasSpectrumOnSphere(self)

    def isValidForTurningBand(self):
        r"""

        CovExponential::isValidForTurningBand
        """
        return _gstlearn.CovExponential_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovExponential::simulateTurningBand
        """
        return _gstlearn.CovExponential_simulateTurningBand(self, t0, operTB)

    def isValidForSpectral(self):
        r"""

        CovExponential::isValidForSpectral
        """
        return _gstlearn.CovExponential_isValidForSpectral(self)

    def simulateSpectralOmega(self, nb):
        r"""

        CovExponential::simulateSpectralOmega
        """
        return _gstlearn.CovExponential_simulateSpectralOmega(self, nb)

# Register CovExponential in _gstlearn:
_gstlearn.CovExponential_swigregister(CovExponential)
class CovGamma(ACovFunc):
    r"""


    C++ includes: CovGamma.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGamma::CovGamma
        """
        _gstlearn.CovGamma_swiginit(self, _gstlearn.new_CovGamma(*args))
    __swig_destroy__ = _gstlearn.delete_CovGamma

    def getFormula(self):
        r"""

        CovGamma::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovGamma_getFormula(self)

    def getCovName(self):
        r"""

        CovGamma::getCovName
        """
        return _gstlearn.CovGamma_getCovName(self)

    def getMinOrder(self):
        r"""

        CovGamma::getMinOrder
        """
        return _gstlearn.CovGamma_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGamma::getCompatibleSpaceR
        """
        return _gstlearn.CovGamma_getCompatibleSpaceR(self)

    def hasParam(self):
        r"""

        CovGamma::hasParam
        """
        return _gstlearn.CovGamma_hasParam(self)

    def getParMax(self):
        r"""

        CovGamma::getParMax
        """
        return _gstlearn.CovGamma_getParMax(self)

    def getScadef(self):
        r"""

        CovGamma::getScadef
        """
        return _gstlearn.CovGamma_getScadef(self)

    def __repr__(self):
        return _gstlearn.CovGamma___repr__(self)

# Register CovGamma in _gstlearn:
_gstlearn.CovGamma_swigregister(CovGamma)
class CovGaussian(ACovFunc):
    r"""


    C++ includes: CovGaussian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGaussian::CovGaussian
        """
        _gstlearn.CovGaussian_swiginit(self, _gstlearn.new_CovGaussian(*args))
    __swig_destroy__ = _gstlearn.delete_CovGaussian

    def getFormula(self):
        r"""

        CovGaussian::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovGaussian_getFormula(self)

    def getCovName(self):
        r"""

        CovGaussian::getCovName
        """
        return _gstlearn.CovGaussian_getCovName(self)

    def getMinOrder(self):
        r"""

        CovGaussian::getMinOrder
        """
        return _gstlearn.CovGaussian_getMinOrder(self)

    def getScadef(self):
        r"""

        CovGaussian::getScadef
        """
        return _gstlearn.CovGaussian_getScadef(self)

    def hasCovDerivative(self):
        r"""

        CovGaussian::hasCovDerivative
        """
        return _gstlearn.CovGaussian_hasCovDerivative(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGaussian::getCompatibleSpaceR
        """
        return _gstlearn.CovGaussian_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovGaussian::isValidForTurningBand
        """
        return _gstlearn.CovGaussian_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovGaussian::simulateTurningBand
        """
        return _gstlearn.CovGaussian_simulateTurningBand(self, t0, operTB)

    def isValidForSpectral(self):
        r"""

        CovGaussian::isValidForSpectral
        """
        return _gstlearn.CovGaussian_isValidForSpectral(self)

    def simulateSpectralOmega(self, nb):
        r"""

        CovGaussian::simulateSpectralOmega
        """
        return _gstlearn.CovGaussian_simulateSpectralOmega(self, nb)

    def __repr__(self):
        return _gstlearn.CovGaussian___repr__(self)

# Register CovGaussian in _gstlearn:
_gstlearn.CovGaussian_swigregister(CovGaussian)
class CovGC1(ACovFunc):
    r"""


    C++ includes: CovGC1.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGC1::CovGC1
        """
        _gstlearn.CovGC1_swiginit(self, _gstlearn.new_CovGC1(*args))
    __swig_destroy__ = _gstlearn.delete_CovGC1

    def hasRange(self):
        r"""

        CovGC1::hasRange
        """
        return _gstlearn.CovGC1_hasRange(self)

    def getMinOrder(self):
        r"""

        CovGC1::getMinOrder
        """
        return _gstlearn.CovGC1_getMinOrder(self)

    def getCovName(self):
        r"""

        CovGC1::getCovName
        """
        return _gstlearn.CovGC1_getCovName(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGC1::getCompatibleSpaceR
        """
        return _gstlearn.CovGC1_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovGC1::isValidForTurningBand
        """
        return _gstlearn.CovGC1_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovGC1::simulateTurningBand
        """
        return _gstlearn.CovGC1_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovGC1___repr__(self)

# Register CovGC1 in _gstlearn:
_gstlearn.CovGC1_swigregister(CovGC1)
class CovGC3(ACovFunc):
    r"""


    C++ includes: CovGC3.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGC3::CovGC3
        """
        _gstlearn.CovGC3_swiginit(self, _gstlearn.new_CovGC3(*args))
    __swig_destroy__ = _gstlearn.delete_CovGC3

    def hasRange(self):
        r"""

        CovGC3::hasRange
        """
        return _gstlearn.CovGC3_hasRange(self)

    def getMinOrder(self):
        r"""

        CovGC3::getMinOrder
        """
        return _gstlearn.CovGC3_getMinOrder(self)

    def getCovName(self):
        r"""

        CovGC3::getCovName
        """
        return _gstlearn.CovGC3_getCovName(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGC3::getCompatibleSpaceR
        """
        return _gstlearn.CovGC3_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovGC3::isValidForTurningBand
        """
        return _gstlearn.CovGC3_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovGC3::simulateTurningBand
        """
        return _gstlearn.CovGC3_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovGC3___repr__(self)

# Register CovGC3 in _gstlearn:
_gstlearn.CovGC3_swigregister(CovGC3)
class CovGC5(ACovFunc):
    r"""


    C++ includes: CovGC5.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGC5::CovGC5
        """
        _gstlearn.CovGC5_swiginit(self, _gstlearn.new_CovGC5(*args))
    __swig_destroy__ = _gstlearn.delete_CovGC5

    def hasRange(self):
        r"""

        CovGC5::hasRange
        """
        return _gstlearn.CovGC5_hasRange(self)

    def getMinOrder(self):
        r"""

        CovGC5::getMinOrder
        """
        return _gstlearn.CovGC5_getMinOrder(self)

    def getCovName(self):
        r"""

        CovGC5::getCovName
        """
        return _gstlearn.CovGC5_getCovName(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGC5::getCompatibleSpaceR
        """
        return _gstlearn.CovGC5_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovGC5::isValidForTurningBand
        """
        return _gstlearn.CovGC5_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovGC5::simulateTurningBand
        """
        return _gstlearn.CovGC5_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovGC5___repr__(self)

# Register CovGC5 in _gstlearn:
_gstlearn.CovGC5_swigregister(CovGC5)
class CovGCspline2(ACovFunc):
    r"""


    C++ includes: CovGCspline2.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGCspline2::CovGCspline2
        """
        _gstlearn.CovGCspline2_swiginit(self, _gstlearn.new_CovGCspline2(*args))
    __swig_destroy__ = _gstlearn.delete_CovGCspline2

    def getMinOrder(self):
        r"""

        CovGCspline2::getMinOrder
        """
        return _gstlearn.CovGCspline2_getMinOrder(self)

    def getMaxNDim(self):
        r"""

        CovGCspline2::getMaxNDim
        """
        return _gstlearn.CovGCspline2_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovGCspline2::getCovName
        """
        return _gstlearn.CovGCspline2_getCovName(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGCspline2::getCompatibleSpaceR
        """
        return _gstlearn.CovGCspline2_getCompatibleSpaceR(self)

    def hasCovDerivative(self):
        r"""

        CovGCspline2::hasCovDerivative
        """
        return _gstlearn.CovGCspline2_hasCovDerivative(self)

    def __repr__(self):
        return _gstlearn.CovGCspline2___repr__(self)

# Register CovGCspline2 in _gstlearn:
_gstlearn.CovGCspline2_swigregister(CovGCspline2)
class CovGCspline(ACovFunc):
    r"""


    C++ includes: CovGCspline.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGCspline::CovGCspline
        """
        _gstlearn.CovGCspline_swiginit(self, _gstlearn.new_CovGCspline(*args))
    __swig_destroy__ = _gstlearn.delete_CovGCspline

    def hasRange(self):
        r"""

        CovGCspline::hasRange
        """
        return _gstlearn.CovGCspline_hasRange(self)

    def getCovName(self):
        r"""

        CovGCspline::getCovName
        """
        return _gstlearn.CovGCspline_getCovName(self)

    def getMinOrder(self):
        r"""

        CovGCspline::getMinOrder
        """
        return _gstlearn.CovGCspline_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovGCspline::getCompatibleSpaceR
        """
        return _gstlearn.CovGCspline_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovGCspline::isValidForTurningBand
        """
        return _gstlearn.CovGCspline_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovGCspline::simulateTurningBand
        """
        return _gstlearn.CovGCspline_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovGCspline___repr__(self)

# Register CovGCspline in _gstlearn:
_gstlearn.CovGCspline_swigregister(CovGCspline)
class CovLinear(ACovFunc):
    r"""


    C++ includes: CovLinear.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovLinear::CovLinear
        """
        _gstlearn.CovLinear_swiginit(self, _gstlearn.new_CovLinear(*args))
    __swig_destroy__ = _gstlearn.delete_CovLinear

    def hasRange(self):
        r"""

        CovLinear::hasRange
        """
        return _gstlearn.CovLinear_hasRange(self)

    def getMinOrder(self):
        r"""

        CovLinear::getMinOrder
        """
        return _gstlearn.CovLinear_getMinOrder(self)

    def getCovName(self):
        r"""

        CovLinear::getCovName
        """
        return _gstlearn.CovLinear_getCovName(self)

    def getCompatibleSpaceR(self):
        r"""

        CovLinear::getCompatibleSpaceR
        """
        return _gstlearn.CovLinear_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovLinear::isValidForTurningBand
        """
        return _gstlearn.CovLinear_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovLinear::simulateTurningBand
        """
        return _gstlearn.CovLinear_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovLinear___repr__(self)

# Register CovLinear in _gstlearn:
_gstlearn.CovLinear_swigregister(CovLinear)
class CovNugget(ACovFunc):
    r"""


    C++ includes: CovNugget.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovNugget::CovNugget
        """
        _gstlearn.CovNugget_swiginit(self, _gstlearn.new_CovNugget(*args))
    __swig_destroy__ = _gstlearn.delete_CovNugget

    def getFormula(self):
        r"""

        CovNugget::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovNugget_getFormula(self)

    def getCovName(self):
        r"""

        CovNugget::getCovName
        """
        return _gstlearn.CovNugget_getCovName(self)

    def getMinOrder(self):
        r"""

        CovNugget::getMinOrder
        """
        return _gstlearn.CovNugget_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovNugget::getCompatibleSpaceR
        """
        return _gstlearn.CovNugget_getCompatibleSpaceR(self)

    def hasRange(self):
        r"""

        CovNugget::hasRange
        """
        return _gstlearn.CovNugget_hasRange(self)

    def isValidForTurningBand(self):
        r"""

        CovNugget::isValidForTurningBand
        """
        return _gstlearn.CovNugget_isValidForTurningBand(self)

    def __repr__(self):
        return _gstlearn.CovNugget___repr__(self)

# Register CovNugget in _gstlearn:
_gstlearn.CovNugget_swigregister(CovNugget)
class CovPenta(ACovFunc):
    r"""


    C++ includes: CovPenta.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovPenta::CovPenta
        """
        _gstlearn.CovPenta_swiginit(self, _gstlearn.new_CovPenta(*args))
    __swig_destroy__ = _gstlearn.delete_CovPenta

    def getMaxNDim(self):
        r"""

        CovPenta::getMaxNDim
        """
        return _gstlearn.CovPenta_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovPenta::getCovName
        """
        return _gstlearn.CovPenta_getCovName(self)

    def getMinOrder(self):
        r"""

        CovPenta::getMinOrder
        """
        return _gstlearn.CovPenta_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovPenta::getCompatibleSpaceR
        """
        return _gstlearn.CovPenta_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovPenta___repr__(self)

# Register CovPenta in _gstlearn:
_gstlearn.CovPenta_swigregister(CovPenta)
class CovPower(ACovFunc):
    r"""


    C++ includes: CovPower.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovPower::CovPower
        """
        _gstlearn.CovPower_swiginit(self, _gstlearn.new_CovPower(*args))
    __swig_destroy__ = _gstlearn.delete_CovPower

    def hasRange(self):
        r"""

        CovPower::hasRange
        """
        return _gstlearn.CovPower_hasRange(self)

    def hasParam(self):
        r"""

        CovPower::hasParam
        """
        return _gstlearn.CovPower_hasParam(self)

    def getParMax(self):
        r"""

        CovPower::getParMax
        """
        return _gstlearn.CovPower_getParMax(self)

    def getMinOrder(self):
        r"""

        CovPower::getMinOrder
        """
        return _gstlearn.CovPower_getMinOrder(self)

    def getCovName(self):
        r"""

        CovPower::getCovName
        """
        return _gstlearn.CovPower_getCovName(self)

    def getCompatibleSpaceR(self):
        r"""

        CovPower::getCompatibleSpaceR
        """
        return _gstlearn.CovPower_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovPower::isValidForTurningBand
        """
        return _gstlearn.CovPower_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovPower::simulateTurningBand
        """
        return _gstlearn.CovPower_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovPower___repr__(self)

# Register CovPower in _gstlearn:
_gstlearn.CovPower_swigregister(CovPower)
class CovReg1D(ACovFunc):
    r"""


    C++ includes: CovReg1D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovReg1D::CovReg1D
        """
        _gstlearn.CovReg1D_swiginit(self, _gstlearn.new_CovReg1D(*args))
    __swig_destroy__ = _gstlearn.delete_CovReg1D

    def getScadef(self):
        r"""

        CovReg1D::getScadef
        """
        return _gstlearn.CovReg1D_getScadef(self)

    def getCovName(self):
        r"""

        CovReg1D::getCovName
        """
        return _gstlearn.CovReg1D_getCovName(self)

    def getMinOrder(self):
        r"""

        CovReg1D::getMinOrder
        """
        return _gstlearn.CovReg1D_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovReg1D::getCompatibleSpaceR
        """
        return _gstlearn.CovReg1D_getCompatibleSpaceR(self)

    def getMaxNDim(self):
        r"""

        CovReg1D::getMaxNDim
        """
        return _gstlearn.CovReg1D_getMaxNDim(self)

    def __repr__(self):
        return _gstlearn.CovReg1D___repr__(self)

# Register CovReg1D in _gstlearn:
_gstlearn.CovReg1D_swigregister(CovReg1D)
class CovSincard(ACovFunc):
    r"""


    C++ includes: CovSincard.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovSincard::CovSincard
        """
        _gstlearn.CovSincard_swiginit(self, _gstlearn.new_CovSincard(*args))
    __swig_destroy__ = _gstlearn.delete_CovSincard

    def getScadef(self):
        r"""

        CovSincard::getScadef
        """
        return _gstlearn.CovSincard_getScadef(self)

    def getFormula(self):
        r"""

        CovSincard::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovSincard_getFormula(self)

    def getCovName(self):
        r"""

        CovSincard::getCovName
        """
        return _gstlearn.CovSincard_getCovName(self)

    def getMinOrder(self):
        r"""

        CovSincard::getMinOrder
        """
        return _gstlearn.CovSincard_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovSincard::getCompatibleSpaceR
        """
        return _gstlearn.CovSincard_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovSincard::isValidForTurningBand
        """
        return _gstlearn.CovSincard_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovSincard::simulateTurningBand
        """
        return _gstlearn.CovSincard_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovSincard___repr__(self)

# Register CovSincard in _gstlearn:
_gstlearn.CovSincard_swigregister(CovSincard)
class CovSpherical(ACovFunc):
    r"""


    C++ includes: CovSpherical.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovSpherical::CovSpherical
        """
        _gstlearn.CovSpherical_swiginit(self, _gstlearn.new_CovSpherical(*args))
    __swig_destroy__ = _gstlearn.delete_CovSpherical

    def getMaxNDim(self):
        r"""

        CovSpherical::getMaxNDim
        """
        return _gstlearn.CovSpherical_getMaxNDim(self)

    def getFormula(self):
        r"""

        CovSpherical::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovSpherical_getFormula(self)

    def getCovName(self):
        r"""

        CovSpherical::getCovName
        """
        return _gstlearn.CovSpherical_getCovName(self)

    def getMinOrder(self):
        r"""

        CovSpherical::getMinOrder
        """
        return _gstlearn.CovSpherical_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovSpherical::getCompatibleSpaceR
        """
        return _gstlearn.CovSpherical_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovSpherical::isValidForTurningBand
        """
        return _gstlearn.CovSpherical_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovSpherical::simulateTurningBand
        """
        return _gstlearn.CovSpherical_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovSpherical___repr__(self)

# Register CovSpherical in _gstlearn:
_gstlearn.CovSpherical_swigregister(CovSpherical)
class CovStable(ACovFunc):
    r"""


    C++ includes: CovStable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovStable::CovStable
        """
        _gstlearn.CovStable_swiginit(self, _gstlearn.new_CovStable(*args))
    __swig_destroy__ = _gstlearn.delete_CovStable

    def hasParam(self):
        r"""

        CovStable::hasParam
        """
        return _gstlearn.CovStable_hasParam(self)

    def getScadef(self):
        r"""

        CovStable::getScadef
        """
        return _gstlearn.CovStable_getScadef(self)

    def getParMax(self):
        r"""

        CovStable::getParMax
        """
        return _gstlearn.CovStable_getParMax(self)

    def getCovName(self):
        r"""

        CovStable::getCovName
        """
        return _gstlearn.CovStable_getCovName(self)

    def getMinOrder(self):
        r"""

        CovStable::getMinOrder
        """
        return _gstlearn.CovStable_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovStable::getCompatibleSpaceR
        """
        return _gstlearn.CovStable_getCompatibleSpaceR(self)

    def isValidForTurningBand(self):
        r"""

        CovStable::isValidForTurningBand
        """
        return _gstlearn.CovStable_isValidForTurningBand(self)

    def simulateTurningBand(self, t0, operTB):
        r"""

        CovStable::simulateTurningBand
        """
        return _gstlearn.CovStable_simulateTurningBand(self, t0, operTB)

    def __repr__(self):
        return _gstlearn.CovStable___repr__(self)

# Register CovStable in _gstlearn:
_gstlearn.CovStable_swigregister(CovStable)
class CovStorkey(ACovFunc):
    r"""


    C++ includes: CovStorkey.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovStorkey::CovStorkey
        """
        _gstlearn.CovStorkey_swiginit(self, _gstlearn.new_CovStorkey(*args))
    __swig_destroy__ = _gstlearn.delete_CovStorkey

    def getMaxNDim(self):
        r"""

        CovStorkey::getMaxNDim
        """
        return _gstlearn.CovStorkey_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovStorkey::getCovName
        """
        return _gstlearn.CovStorkey_getCovName(self)

    def getMinOrder(self):
        r"""

        CovStorkey::getMinOrder
        """
        return _gstlearn.CovStorkey_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovStorkey::getCompatibleSpaceR
        """
        return _gstlearn.CovStorkey_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovStorkey___repr__(self)

# Register CovStorkey in _gstlearn:
_gstlearn.CovStorkey_swigregister(CovStorkey)
class CovTriangle(ACovFunc):
    r"""


    C++ includes: CovTriangle.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovTriangle::CovTriangle
        """
        _gstlearn.CovTriangle_swiginit(self, _gstlearn.new_CovTriangle(*args))
    __swig_destroy__ = _gstlearn.delete_CovTriangle

    def getMaxNDim(self):
        r"""

        CovTriangle::getMaxNDim
        """
        return _gstlearn.CovTriangle_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovTriangle::getCovName
        """
        return _gstlearn.CovTriangle_getCovName(self)

    def getMinOrder(self):
        r"""

        CovTriangle::getMinOrder
        """
        return _gstlearn.CovTriangle_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovTriangle::getCompatibleSpaceR
        """
        return _gstlearn.CovTriangle_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovTriangle___repr__(self)

# Register CovTriangle in _gstlearn:
_gstlearn.CovTriangle_swigregister(CovTriangle)
class CovWendland0(ACovFunc):
    r"""


    C++ includes: CovWendland0.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovWendland0::CovWendland0
        """
        _gstlearn.CovWendland0_swiginit(self, _gstlearn.new_CovWendland0(*args))
    __swig_destroy__ = _gstlearn.delete_CovWendland0

    def getMaxNDim(self):
        r"""

        CovWendland0::getMaxNDim
        """
        return _gstlearn.CovWendland0_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovWendland0::getCovName
        """
        return _gstlearn.CovWendland0_getCovName(self)

    def getMinOrder(self):
        r"""

        CovWendland0::getMinOrder
        """
        return _gstlearn.CovWendland0_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovWendland0::getCompatibleSpaceR
        """
        return _gstlearn.CovWendland0_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovWendland0___repr__(self)

# Register CovWendland0 in _gstlearn:
_gstlearn.CovWendland0_swigregister(CovWendland0)
class CovWendland1(ACovFunc):
    r"""


    C++ includes: CovWendland1.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovWendland1::CovWendland1
        """
        _gstlearn.CovWendland1_swiginit(self, _gstlearn.new_CovWendland1(*args))
    __swig_destroy__ = _gstlearn.delete_CovWendland1

    def getMaxNDim(self):
        r"""

        CovWendland1::getMaxNDim
        """
        return _gstlearn.CovWendland1_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovWendland1::getCovName
        """
        return _gstlearn.CovWendland1_getCovName(self)

    def getMinOrder(self):
        r"""

        CovWendland1::getMinOrder
        """
        return _gstlearn.CovWendland1_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovWendland1::getCompatibleSpaceR
        """
        return _gstlearn.CovWendland1_getCompatibleSpaceR(self)

    def __repr__(self):
        return _gstlearn.CovWendland1___repr__(self)

# Register CovWendland1 in _gstlearn:
_gstlearn.CovWendland1_swigregister(CovWendland1)
class CovWendland2(ACovFunc):
    r"""


    C++ includes: CovWendland2.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovWendland2::CovWendland2
        """
        _gstlearn.CovWendland2_swiginit(self, _gstlearn.new_CovWendland2(*args))
    __swig_destroy__ = _gstlearn.delete_CovWendland2

    def getMaxNDim(self):
        r"""

        CovWendland2::getMaxNDim
        """
        return _gstlearn.CovWendland2_getMaxNDim(self)

    def getCovName(self):
        r"""

        CovWendland2::getCovName
        """
        return _gstlearn.CovWendland2_getCovName(self)

    def getMinOrder(self):
        r"""

        CovWendland2::getMinOrder
        """
        return _gstlearn.CovWendland2_getMinOrder(self)

    def getCompatibleSpaceR(self):
        r"""

        CovWendland2::getCompatibleSpaceR
        """
        return _gstlearn.CovWendland2_getCompatibleSpaceR(self)

    def hasCovDerivative(self):
        r"""

        CovWendland2::hasCovDerivative
        """
        return _gstlearn.CovWendland2_hasCovDerivative(self)

    def __repr__(self):
        return _gstlearn.CovWendland2___repr__(self)

# Register CovWendland2 in _gstlearn:
_gstlearn.CovWendland2_swigregister(CovWendland2)
class CovMarkov(ACovFunc):
    r"""


    C++ includes: CovMarkov.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovMarkov::CovMarkov
        """
        _gstlearn.CovMarkov_swiginit(self, _gstlearn.new_CovMarkov(*args))
    __swig_destroy__ = _gstlearn.delete_CovMarkov

    def getFormula(self):
        r"""

        CovMarkov::getFormula
        ACovFunc Interface.  

        """
        return _gstlearn.CovMarkov_getFormula(self)

    def getCovName(self):
        r"""

        CovMarkov::getCovName
        """
        return _gstlearn.CovMarkov_getCovName(self)

    def hasParam(self):
        r"""

        CovMarkov::hasParam
        """
        return _gstlearn.CovMarkov_hasParam(self)

    def getParMax(self):
        r"""

        CovMarkov::getParMax
        """
        return _gstlearn.CovMarkov_getParMax(self)

    def getScadef(self):
        r"""

        CovMarkov::getScadef
        """
        return _gstlearn.CovMarkov_getScadef(self)

    def hasCovOnRn(self):
        r"""

        CovMarkov::hasCovOnRn
        """
        return _gstlearn.CovMarkov_hasCovOnRn(self)

    def hasSpectrumOnRn(self):
        r"""

        CovMarkov::hasSpectrumOnRn
        """
        return _gstlearn.CovMarkov_hasSpectrumOnRn(self)

    def hasSpectrumOnSphere(self):
        r"""

        CovMarkov::hasSpectrumOnSphere
        """
        return _gstlearn.CovMarkov_hasSpectrumOnSphere(self)

    def hasMarkovCoeffs(self):
        r"""

        CovMarkov::hasMarkovCoeffs
        """
        return _gstlearn.CovMarkov_hasMarkovCoeffs(self)

    def normalizeOnSphere(self, n=50, scale=1.):
        r"""

        CovMarkov::normalizeOnSphere
        """
        return _gstlearn.CovMarkov_normalizeOnSphere(self, n, scale)

    def evaluateSpectrum(self, freq):
        r"""

        CovMarkov::evaluateSpectrum
        """
        return _gstlearn.CovMarkov_evaluateSpectrum(self, freq)

    def getMarkovCoeffs(self):
        r"""

        CovMarkov::getMarkovCoeffs
        """
        return _gstlearn.CovMarkov_getMarkovCoeffs(self)

    def setMarkovCoeffs(self, coeffs):
        r"""

        CovMarkov::setMarkovCoeffs
        """
        return _gstlearn.CovMarkov_setMarkovCoeffs(self, coeffs)

    def getCorrec(self):
        r"""

        CovMarkov::getCorrec
        """
        return _gstlearn.CovMarkov_getCorrec(self)

    def setCorrec(self, val):
        r"""

        CovMarkov::setCorrec
        """
        return _gstlearn.CovMarkov_setCorrec(self, val)

    def __repr__(self):
        return _gstlearn.CovMarkov___repr__(self)

# Register CovMarkov in _gstlearn:
_gstlearn.CovMarkov_swigregister(CovMarkov)
class CovGeometric(ACovFunc):
    r"""


    C++ includes: CovGeometric.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovGeometric::CovGeometric
        """
        _gstlearn.CovGeometric_swiginit(self, _gstlearn.new_CovGeometric(*args))
    __swig_destroy__ = _gstlearn.delete_CovGeometric

    def getCovName(self):
        r"""

        CovGeometric::getCovName
        """
        return _gstlearn.CovGeometric_getCovName(self)

    def getMinOrder(self):
        r"""

        CovGeometric::getMinOrder
        """
        return _gstlearn.CovGeometric_getMinOrder(self)

    def getCompatibleSpaceS(self):
        r"""

        CovGeometric::getCompatibleSpaceS
        """
        return _gstlearn.CovGeometric_getCompatibleSpaceS(self)

    def hasCovOnSphere(self):
        r"""

        CovGeometric::hasCovOnSphere
        """
        return _gstlearn.CovGeometric_hasCovOnSphere(self)

    def hasSpectrumOnSphere(self):
        r"""

        CovGeometric::hasSpectrumOnSphere
        """
        return _gstlearn.CovGeometric_hasSpectrumOnSphere(self)

    def __repr__(self):
        return _gstlearn.CovGeometric___repr__(self)

# Register CovGeometric in _gstlearn:
_gstlearn.CovGeometric_swigregister(CovGeometric)
class CovPoisson(ACovFunc):
    r"""


    C++ includes: CovPoisson.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovPoisson::CovPoisson
        """
        _gstlearn.CovPoisson_swiginit(self, _gstlearn.new_CovPoisson(*args))
    __swig_destroy__ = _gstlearn.delete_CovPoisson

    def getCovName(self):
        r"""

        CovPoisson::getCovName
        """
        return _gstlearn.CovPoisson_getCovName(self)

    def hasParam(self):
        r"""

        CovPoisson::hasParam
        """
        return _gstlearn.CovPoisson_hasParam(self)

    def getParMax(self):
        r"""

        CovPoisson::getParMax
        """
        return _gstlearn.CovPoisson_getParMax(self)

    def getMinOrder(self):
        r"""

        CovPoisson::getMinOrder
        """
        return _gstlearn.CovPoisson_getMinOrder(self)

    def getCompatibleSpaceS(self):
        r"""

        CovPoisson::getCompatibleSpaceS
        """
        return _gstlearn.CovPoisson_getCompatibleSpaceS(self)

    def hasCovOnRn(self):
        r"""

        CovPoisson::hasCovOnRn
        """
        return _gstlearn.CovPoisson_hasCovOnRn(self)

    def hasCovOnSphere(self):
        r"""

        CovPoisson::hasCovOnSphere
        """
        return _gstlearn.CovPoisson_hasCovOnSphere(self)

    def hasSpectrumOnSphere(self):
        r"""

        CovPoisson::hasSpectrumOnSphere
        """
        return _gstlearn.CovPoisson_hasSpectrumOnSphere(self)

    def isValidForSpectral(self):
        r"""

        CovPoisson::isValidForSpectral
        """
        return _gstlearn.CovPoisson_isValidForSpectral(self)

    def __repr__(self):
        return _gstlearn.CovPoisson___repr__(self)

# Register CovPoisson in _gstlearn:
_gstlearn.CovPoisson_swigregister(CovPoisson)
class CovLinearSph(ACovFunc):
    r"""


    C++ includes: CovLinearSph.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        CovLinearSph::CovLinearSph
        """
        _gstlearn.CovLinearSph_swiginit(self, _gstlearn.new_CovLinearSph(*args))
    __swig_destroy__ = _gstlearn.delete_CovLinearSph

    def getCovName(self):
        r"""

        CovLinearSph::getCovName
        """
        return _gstlearn.CovLinearSph_getCovName(self)

    def getMinOrder(self):
        r"""

        CovLinearSph::getMinOrder
        """
        return _gstlearn.CovLinearSph_getMinOrder(self)

    def getCompatibleSpaceS(self):
        r"""

        CovLinearSph::getCompatibleSpaceS
        """
        return _gstlearn.CovLinearSph_getCompatibleSpaceS(self)

    def hasCovOnRn(self):
        r"""

        CovLinearSph::hasCovOnRn
        """
        return _gstlearn.CovLinearSph_hasCovOnRn(self)

    def hasCovOnSphere(self):
        r"""

        CovLinearSph::hasCovOnSphere
        """
        return _gstlearn.CovLinearSph_hasCovOnSphere(self)

    def hasSpectrumOnSphere(self):
        r"""

        CovLinearSph::hasSpectrumOnSphere
        """
        return _gstlearn.CovLinearSph_hasSpectrumOnSphere(self)

    def isValidForSpectral(self):
        r"""

        CovLinearSph::isValidForSpectral
        """
        return _gstlearn.CovLinearSph_isValidForSpectral(self)

    def __repr__(self):
        return _gstlearn.CovLinearSph___repr__(self)

# Register CovLinearSph in _gstlearn:
_gstlearn.CovLinearSph_swigregister(CovLinearSph)
class CovDiffusionAdvection(object):
    r"""


    C++ includes: CovDiffusionAdvection.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        CovDiffusionAdvection::CovDiffusionAdvection
        """
        _gstlearn.CovDiffusionAdvection_swiginit(self, _gstlearn.new_CovDiffusionAdvection(*args))
    __swig_destroy__ = _gstlearn.delete_CovDiffusionAdvection

    @staticmethod
    def create(*args, **kwargs):
        r"""

        CovDiffusionAdvection::create
        """
        return _gstlearn.CovDiffusionAdvection_create(*args, **kwargs)

    def getMarkovL(self):
        r"""

        CovDiffusionAdvection::getMarkovL
        """
        return _gstlearn.CovDiffusionAdvection_getMarkovL(self)

    def setMarkovL(self, markovL):
        r"""

        CovDiffusionAdvection::setMarkovL
        """
        return _gstlearn.CovDiffusionAdvection_setMarkovL(self, markovL)

    def getMarkovR(self):
        r"""

        CovDiffusionAdvection::getMarkovR
        """
        return _gstlearn.CovDiffusionAdvection_getMarkovR(self)

    def setMarkovR(self, markovR):
        r"""

        CovDiffusionAdvection::setMarkovR
        """
        return _gstlearn.CovDiffusionAdvection_setMarkovR(self, markovR)

    def getScaleTime(self):
        r"""

        CovDiffusionAdvection::getScaleTime
        """
        return _gstlearn.CovDiffusionAdvection_getScaleTime(self)

    def setScaleTime(self, scaleTime):
        r"""

        CovDiffusionAdvection::setScaleTime
        """
        return _gstlearn.CovDiffusionAdvection_setScaleTime(self, scaleTime)

    def getSigma2(self):
        r"""

        CovDiffusionAdvection::getSigma2
        """
        return _gstlearn.CovDiffusionAdvection_getSigma2(self)

    def setSigma2(self, sigma2):
        r"""

        CovDiffusionAdvection::setSigma2
        """
        return _gstlearn.CovDiffusionAdvection_setSigma2(self, sigma2)

    def getVel(self):
        r"""

        CovDiffusionAdvection::getVel
        """
        return _gstlearn.CovDiffusionAdvection_getVel(self)

    def setVel(self, vel):
        r"""

        CovDiffusionAdvection::setVel
        """
        return _gstlearn.CovDiffusionAdvection_setVel(self, vel)

    def getGlobalCorrec(self):
        r"""

        CovDiffusionAdvection::getGlobalCorrec
        """
        return _gstlearn.CovDiffusionAdvection_getGlobalCorrec(self)

    def getSpatialTrace(self):
        r"""

        CovDiffusionAdvection::getSpatialTrace
        """
        return _gstlearn.CovDiffusionAdvection_getSpatialTrace(self)

    def isNoneMarkovL(self):
        r"""

        CovDiffusionAdvection::isNoneMarkovL
        """
        return _gstlearn.CovDiffusionAdvection_isNoneMarkovL(self)

    def isNoneMarkovR(self):
        r"""

        CovDiffusionAdvection::isNoneMarkovR
        """
        return _gstlearn.CovDiffusionAdvection_isNoneMarkovR(self)

    def evalSpatialSpectrum(self, freq, time):
        r"""

        CovDiffusionAdvection::evalSpatialSpectrum
        """
        return _gstlearn.CovDiffusionAdvection_evalSpatialSpectrum(self, freq, time)

    def evalCovFFT(self, hmax, time=0, N=128):
        r"""

        CovDiffusionAdvection::evalCovFFT
        """
        return _gstlearn.CovDiffusionAdvection_evalCovFFT(self, hmax, time, N)

# Register CovDiffusionAdvection in _gstlearn:
_gstlearn.CovDiffusionAdvection_swigregister(CovDiffusionAdvection)
class CovHelper(object):
    r"""


    C++ includes: CovHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CovHelper::CovHelper
        """
        _gstlearn.CovHelper_swiginit(self, _gstlearn.new_CovHelper())
    __swig_destroy__ = _gstlearn.delete_CovHelper

    @staticmethod
    def getAllCovariances(ndim=2, minorder=-1, hasrange=False, flagSimtub=False, flagSimuSpectral=False):
        r"""

        CovHelper::getAllCovariances
        Returns the list of covariance names that are valid according to various
        options:  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `minorder` :  
            Minimum degree of the IRF (-1 for stationary, 0 for Intrinsic, ...)  
        * `hasrange` :  
            Check if the Covariance has a Range defined  
        * `flagSimtub` :  
            Check that the Covariance can be simulated using Turning Band Method  
        * `flagSimuSpectral` :  
            Check if the Covariance can be simulated using the Spectral Method  

        """
        return _gstlearn.CovHelper_getAllCovariances(ndim, minorder, hasrange, flagSimtub, flagSimuSpectral)

# Register CovHelper in _gstlearn:
_gstlearn.CovHelper_swigregister(CovHelper)
class ADrift(AStringable, ICloneable):
    r"""


    This class describes one basic Drift Function.  

    It is the uppermost class of the Drift Tree and is conceived as simple as
    possible on purpose (in order to let the user defined its own version if
    necessary): it must simply be able to return its value at the location of one
    sample from a Db.  

    This returned value depends on the implementation of this basic drift function
    and mainly depends upon:  

    *   the space dimension  
    *   the coordinates of the target  

    If NDIM represents the space dimension, each basic drift function belongs to one
    of the following categories:  

    *   an internal drift function (**DRIFTM**) characterized by a vector of
        coefficients P (of dimension NDIM): it returns the numerical expression
        elaborated starting from the coordinates (X) of one sample such as:  

        X_1**P_1 * X_2**P_2 * ... * X_NDIM**P_NDIM  
    *   an **external drift** function (**DRIFTF**) identified by its rank
        (corresponding locator ELoc::F) for one sample.  

    C++ includes: ADrift.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_ADrift

    def toString(self, strfmt=None):
        r"""

        ADrift::toString
        AStringable Interface.  

        """
        return _gstlearn.ADrift_toString(self, strfmt)

    def getPowers(self):
        r"""

        ADrift::getPowers
        Interface for daughter classes.  

        """
        return _gstlearn.ADrift_getPowers(self)

    def getRankFex(self):
        r"""

        ADrift::getRankFex
        """
        return _gstlearn.ADrift_getRankFex(self)

    def getDriftName(self):
        r"""

        ADrift::getDriftName
        """
        return _gstlearn.ADrift_getDriftName(self)

    def getOrderIRF(self):
        r"""

        ADrift::getOrderIRF
        """
        return _gstlearn.ADrift_getOrderIRF(self)

    def getOrderIRFIdim(self, idim):
        r"""

        ADrift::getOrderIRFIdim
        """
        return _gstlearn.ADrift_getOrderIRFIdim(self, idim)

    def eval(self, db, iech):
        r"""

        ADrift::eval
        """
        return _gstlearn.ADrift_eval(self, db, iech)

    def getDriftNDimMax(self):
        r"""

        ADrift::getDriftNDimMax
        """
        return _gstlearn.ADrift_getDriftNDimMax(self)

    def isDriftExternal(self):
        r"""

        ADrift::isDriftExternal
        """
        return _gstlearn.ADrift_isDriftExternal(self)

    def __repr__(self):
        return _gstlearn.ADrift___repr__(self)

# Register ADrift in _gstlearn:
_gstlearn.ADrift_swigregister(ADrift)
class DriftList(AStringable, ICloneable):
    r"""


    This class provides the information on **Drift** part of the Model. The drift
    plays the role of the average of the target Random Function which may be
    constant or vary as a function with low frequency variations (by opposition to
    the complementary part of the Spatial Characteristics which is described by its
    Covariance)  

    This class essentially contains a list of basic (active)e drift functions: see
    ADrift.hpp for details.  

    This class also carry other important informations:  

    *   a vector giving the status of each basic drift functions: it may be *active*
        or *filtered*  
    *   some additional information defining some relationship between the basic
        drift function: this is used for the special case where the different Random
        Functions obey to algebraic relations.  

    C++ includes: DriftList.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DriftList::DriftList
        """
        _gstlearn.DriftList_swiginit(self, _gstlearn.new_DriftList(*args))
    __swig_destroy__ = _gstlearn.delete_DriftList

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DriftList_clone(self)

    def toString(self, strfmt=None):
        r"""

        DriftList::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.DriftList_toString(self, strfmt)

    def getNVar(self):
        r"""

        DriftList::getNVar
        """
        return _gstlearn.DriftList_getNVar(self)

    def getNDrift(self):
        r"""

        DriftList::getNDrift
        """
        return _gstlearn.DriftList_getNDrift(self)

    def hasDrift(self):
        r"""

        DriftList::hasDrift
        """
        return _gstlearn.DriftList_hasDrift(self)

    def addDrift(self, drift):
        r"""

        DriftList::addDrift
        """
        return _gstlearn.DriftList_addDrift(self, drift)

    def delDrift(self, rank):
        r"""

        DriftList::delDrift
        """
        return _gstlearn.DriftList_delDrift(self, rank)

    def delAllDrifts(self):
        r"""

        DriftList::delAllDrifts
        """
        return _gstlearn.DriftList_delAllDrifts(self)

    def getFiltered(self):
        r"""

        DriftList::getFiltered
        """
        return _gstlearn.DriftList_getFiltered(self)

    def isDriftFiltered(self, i):
        r"""

        DriftList::isDriftFiltered
        """
        return _gstlearn.DriftList_isDriftFiltered(self, i)

    def setFiltered(self, *args):
        r"""

        DriftList::setFiltered
        """
        return _gstlearn.DriftList_setFiltered(self, *args)

    def getNDriftEquation(self):
        r"""

        DriftList::getNDriftEquation
        """
        return _gstlearn.DriftList_getNDriftEquation(self)

    def hasExternalDrift(self):
        r"""

        DriftList::hasExternalDrift
        """
        return _gstlearn.DriftList_hasExternalDrift(self)

    def isValid(self):
        r"""

        DriftList::isValid
        Check that the set of drift functions is valid  

        Returns
        -------  

        """
        return _gstlearn.DriftList_isValid(self)

    def getNExtDrift(self):
        r"""

        DriftList::getNExtDrift
        """
        return _gstlearn.DriftList_getNExtDrift(self)

    def getContext(self):
        r"""

        DriftList::getContext
        """
        return _gstlearn.DriftList_getContext(self)

    def getDrift(self, il):
        r"""

        DriftList::getDrift
        TODO : to be removed (encapsulation)  

        """
        return _gstlearn.DriftList_getDrift(self, il)

    def getRankFex(self, il):
        r"""

        DriftList::getRankFex
        """
        return _gstlearn.DriftList_getRankFex(self, il)

    def getDriftName(self, il):
        r"""

        DriftList::getDriftName
        """
        return _gstlearn.DriftList_getDriftName(self, il)

    def getBetaHats(self):
        r"""

        DriftList::getBetaHats
        """
        return _gstlearn.DriftList_getBetaHats(self)

    def setDriftCLByPart(self, ivar, ib, coef):
        r"""

        DriftList::setDriftCLByPart
        Set the values of the internal array 'driftCL' This feature is used when the
        drift equation does not coincide with a drift function (when working with the
        gradient of the target variable, for example)  

        Parameters
        ----------
        * `ivar` :  
            Rank of the variable (_nVar)  
        * `ib` :  
            Rank of the drift equation (_driftEquationNumber)  
        * `coef` :  
            Vector of coefficients  

        """
        return _gstlearn.DriftList_setDriftCLByPart(self, ivar, ib, coef)

    def resetDriftList(self):
        r"""

        DriftList::resetDriftList
        """
        return _gstlearn.DriftList_resetDriftList(self)

    def isDriftSampleDefined(self, db, ib, nech, nbgh, loctype):
        r"""

        DriftList::isDriftSampleDefined
        Check that the drift 'ib' is defined for at least one variable one sample  

        Parameters
        ----------
        * `db` :  
            Data file used for reading the drift contents (depends on its type)  
        * `ib` :  
            Rank of the drift function  
        * `nech` :  
            Number of samples to be checked  
        * `nbgh` :  
            Vector of sample indices within the data base  
        * `loctype` :  
            Locator to be checked  

        """
        return _gstlearn.DriftList_isDriftSampleDefined(self, db, ib, nech, nbgh, loctype)

    def computeDrift(self, db, ib, iech):
        r"""

        DriftList::computeDrift
        """
        return _gstlearn.DriftList_computeDrift(self, db, ib, iech)

    def getDrifts(self, db, useSel=True):
        r"""

        DriftList::getDrifts
        """
        return _gstlearn.DriftList_getDrifts(self, db, useSel)

    def isFlagLinked(self):
        r"""

        DriftList::isFlagLinked
        """
        return _gstlearn.DriftList_isFlagLinked(self)

    def isFlagCombined(self):
        r"""

        DriftList::isFlagCombined
        """
        return _gstlearn.DriftList_isFlagCombined(self)

    def getDriftMaxIRFOrder(self):
        r"""

        DriftList::getDriftMaxIRFOrder
        Returns
        -------
        Maximum IRF-order (-1 for order-2 stationarity)  

        """
        return _gstlearn.DriftList_getDriftMaxIRFOrder(self)

    def isDriftDefined(self, powers, rank_fex=0):
        r"""

        DriftList::isDriftDefined
        Check if a given drift type is defined among the drift functions  

        Parameters
        ----------
        * `powers` :  
            Vector of exponents for monomials  
        * `rank_fex` :  
            Rank of the variable for external dift  

        Returns
        -------  

        """
        return _gstlearn.DriftList_isDriftDefined(self, powers, rank_fex)

    def isDriftDifferentDefined(self, powers, rank_fex=-1):
        r"""

        DriftList::isDriftDifferentDefined
        Check if at least one drift function exists whose type is different from the
        target type  

        Parameters
        ----------
        * `powers` :  
            Vector of exponent for monomials of a polynomial drift  
        * `rank_fex` :  
            Rank of the variable for external Drift  

        Returns
        -------  

        """
        return _gstlearn.DriftList_isDriftDifferentDefined(self, powers, rank_fex)

    def copyCovContext(self, ctxt):
        r"""

        DriftList::copyCovContext
        """
        return _gstlearn.DriftList_copyCovContext(self, ctxt)

    def setFlagLinked(self, flagLinked):
        r"""

        DriftList::setFlagLinked
        """
        return _gstlearn.DriftList_setFlagLinked(self, flagLinked)

    def setFlagCombined(self, flagCombined):
        r"""

        DriftList::setFlagCombined
        """
        return _gstlearn.DriftList_setFlagCombined(self, flagCombined)

    def setBetaHat(self, betaHat):
        r"""

        DriftList::setBetaHat
        """
        return _gstlearn.DriftList_setBetaHat(self, betaHat)

    def evalDrift(self, *args, **kwargs):
        r"""

        DriftList::evalDrift
        Evaluate a given drift function for a given sample  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `iech` :  
            Rank of the target sample  
        * `il` :  
            Rank of the drift function  
        * `member` :  
            Member type (used to check filtering)  

        Returns
        -------  

        """
        return _gstlearn.DriftList_evalDrift(self, *args, **kwargs)

    def evalDriftCoef(self, db, iech, coeffs):
        r"""

        DriftList::evalDriftCoef
        """
        return _gstlearn.DriftList_evalDriftCoef(self, db, iech, coeffs)

    def evalDriftCoefs(self, db, coeffs, useSel=False):
        r"""

        DriftList::evalDriftCoefs
        Evaluate the Linear combination of drift terms at each sample of a Db  

        Parameters
        ----------
        * `db` :  
            Target Db  
        * `coeffs` :  
            Vector of coefficients (must have dimension of number of drift elements)  
        * `useSel` :  
            True if the selection must be taken into account  

        Returns
        -------  

        """
        return _gstlearn.DriftList_evalDriftCoefs(self, db, coeffs, useSel)

    def evalDriftBySample(self, *args, **kwargs):
        r"""

        DriftList::evalDriftBySample
        """
        return _gstlearn.DriftList_evalDriftBySample(self, *args, **kwargs)

    def evalDriftBySampleInPlace(self, db, iech, member, drftab):
        r"""

        DriftList::evalDriftBySampleInPlace
        """
        return _gstlearn.DriftList_evalDriftBySampleInPlace(self, db, iech, member, drftab)

    def evalDriftMat(self, *args, **kwargs):
        r"""

        DriftList::evalDriftMat
        Establish the drift rectangular matrix for a given Db  

        Returns
        -------
        Returned matrix (Dimension/ nrows = nvar * nech; ncols = nfeq * nvar)  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `nbgh` :  
            Vector of indices of active samples in db (optional)  
        * `member` :  
            Member of the Kriging System (ECalcMember)  

        """
        return _gstlearn.DriftList_evalDriftMat(self, *args, **kwargs)

    def evalDriftMatInPlace(self, *args, **kwargs):
        r"""

        DriftList::evalDriftMatInPlace
        """
        return _gstlearn.DriftList_evalDriftMatInPlace(self, *args, **kwargs)

    def evalDriftMatByRanksInPlace(self, *args, **kwargs):
        r"""

        DriftList::evalDriftMatByRanksInPlace
        Calculate the Drift matrix.  

        Parameters
        ----------
        * `mat` :  
            Drift matrix (possibly resized)  
        * `db` :  
            Data Db  
        * `sampleRanks` :  
            Vector of sample ranks in 'db'  
        * `member` :  
            CalcMember  

        Returns
        -------
        int Error returned code  

        """
        return _gstlearn.DriftList_evalDriftMatByRanksInPlace(self, *args, **kwargs)

    def evalDriftMatByRanks(self, *args, **kwargs):
        r"""

        DriftList::evalDriftMatByRanks
        Returns the Matrix of the Drift elements.  

        Parameters
        ----------
        * `db` :  
        * `sampleRanks` :  
        * `member` :  

        Returns
        -------
        MatrixDense  

        """
        return _gstlearn.DriftList_evalDriftMatByRanks(self, *args, **kwargs)

    def evalMeanVecByRanks(self, *args, **kwargs):
        r"""

        DriftList::evalMeanVecByRanks
        """
        return _gstlearn.DriftList_evalMeanVecByRanks(self, *args, **kwargs)

    def evalDriftMatByTargetInPlace(self, *args, **kwargs):
        r"""

        DriftList::evalDriftMatByTargetInPlace
        Establish the drift rectangular matrix for a given Db  

        Returns
        -------
        Returned matrix (Dimension/ nrows = nvar * nech; ncols = nfeq * nvar)  

        Parameters
        ----------
        * `mat` :  
            Drift matrix (possibly resized)  
        * `db` :  
            Db structure  
        * `iech2` :  
            Index of active samples in db  
        * `krigopt` :  
            KrigOpt structure  

        """
        return _gstlearn.DriftList_evalDriftMatByTargetInPlace(self, *args, **kwargs)

    def evalDriftValue(self, *args, **kwargs):
        r"""

        DriftList::evalDriftValue
        Returns the Drift value for a given variable and a given drift function  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `iech` :  
            Rank of the sample  
        * `ivar` :  
            Rank of the variable  
        * `ib` :  
            Rank of the Drift function  
        * `member` :  
            ECalcMember characteristics  

        """
        return _gstlearn.DriftList_evalDriftValue(self, *args, **kwargs)

    def setMeans(self, mean):
        r"""

        DriftList::setMeans
        """
        return _gstlearn.DriftList_setMeans(self, mean)

    def setMean(self, mean, ivar=0):
        r"""

        DriftList::setMean
        Define the Mean for one variable  

        Parameters
        ----------
        * `mean` :  
            Value for the mean  
        * `ivar` :  
            Rank of the variable (starting from 0)  

        """
        return _gstlearn.DriftList_setMean(self, mean, ivar)

    def getMean(self, ivar):
        r"""

        DriftList::getMean
        """
        return _gstlearn.DriftList_getMean(self, ivar)

    def getMeans(self):
        r"""

        DriftList::getMeans
        """
        return _gstlearn.DriftList_getMeans(self)

    def createReduce(self, validVars):
        r"""

        DriftList::createReduce
        """
        return _gstlearn.DriftList_createReduce(self, validVars)

    def evalDriftVarCoef(self, db, iech, ivar, coeffs):
        r"""

        DriftList::evalDriftVarCoef
        Evaluate the drift with a given sample and a given variable The value is scaled
        by 'coeffs'  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `iech` :  
            Rank of the sample  
        * `ivar` :  
            Rank of the variable  
        * `coeffs` :  
            Vector of coefficients  

        """
        return _gstlearn.DriftList_evalDriftVarCoef(self, db, iech, ivar, coeffs)

    def evalDriftVarCoefs(self, db, coeffs, useSel=False):
        r"""

        DriftList::evalDriftVarCoefs
        A vector of the drift evaluation (for all samples)  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `coeffs` :  
            Vector of drift coefficients  
        * `useSel` :  
            When TRUE, only non masked samples are returned  

        Returns
        -------
        The vector of values  

        remark: When no drift is defined, a vector is returned filled with the variable
            mean  

        """
        return _gstlearn.DriftList_evalDriftVarCoefs(self, db, coeffs, useSel)

    def appendParams(self, listParams):
        r"""

        DriftList::appendParams
        """
        return _gstlearn.DriftList_appendParams(self, listParams)

    def updateDriftList(self):
        r"""

        DriftList::updateDriftList
        """
        return _gstlearn.DriftList_updateDriftList(self)

    def initParams(self, vars, href=1.):
        r"""

        DriftList::initParams
        """
        return _gstlearn.DriftList_initParams(self, vars, href)

    def __repr__(self):
        return _gstlearn.DriftList___repr__(self)

# Register DriftList in _gstlearn:
_gstlearn.DriftList_swigregister(DriftList)
class DriftM(ADrift):
    r"""


    Monomial drift term. Examples:  

    *   driftM() is the Universality condition  
    *   driftM([2]) (where [] stands for a vector of integers) stands for x_1^2  
    *   driftM([2,3]) stands for x_1^2 * x_2^3 Note: the size of the vector (when
        defined) must be smaller or equal to the space dimension  

    C++ includes: DriftM.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DriftM::DriftM
        """
        _gstlearn.DriftM_swiginit(self, _gstlearn.new_DriftM(*args))
    __swig_destroy__ = _gstlearn.delete_DriftM

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DriftM_clone(self)

    def getDriftName(self):
        r"""

        DriftM::getDriftName
        ICloneable interface.  

        """
        return _gstlearn.DriftM_getDriftName(self)

    def getOrderIRF(self):
        r"""

        DriftM::getOrderIRF
        """
        return _gstlearn.DriftM_getOrderIRF(self)

    def getOrderIRFIdim(self, idim):
        r"""

        DriftM::getOrderIRFIdim
        """
        return _gstlearn.DriftM_getOrderIRFIdim(self, idim)

    def getDriftNDimMax(self):
        r"""

        DriftM::getDriftNDimMax
        """
        return _gstlearn.DriftM_getDriftNDimMax(self)

    def eval(self, db, iech):
        r"""

        DriftM::eval
        """
        return _gstlearn.DriftM_eval(self, db, iech)

    def getPowers(self):
        r"""

        DriftM::getPowers
        Interface for daughter classes.  

        """
        return _gstlearn.DriftM_getPowers(self)

    @staticmethod
    def createByIdentifier(driftname):
        r"""

        DriftM::createByIdentifier
        """
        return _gstlearn.DriftM_createByIdentifier(driftname)

    def __repr__(self):
        return _gstlearn.DriftM___repr__(self)

# Register DriftM in _gstlearn:
_gstlearn.DriftM_swigregister(DriftM)
class DriftF(ADrift):
    r"""


    C++ includes: DriftF.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DriftF::DriftF
        """
        _gstlearn.DriftF_swiginit(self, _gstlearn.new_DriftF(*args))
    __swig_destroy__ = _gstlearn.delete_DriftF

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DriftF_clone(self)

    def getDriftName(self):
        r"""

        DriftF::getDriftName
        ICloneable interface.  

        """
        return _gstlearn.DriftF_getDriftName(self)

    def getOrderIRF(self):
        r"""

        DriftF::getOrderIRF
        """
        return _gstlearn.DriftF_getOrderIRF(self)

    def getOrderIRFIdim(self, idim):
        r"""

        DriftF::getOrderIRFIdim
        """
        return _gstlearn.DriftF_getOrderIRFIdim(self, idim)

    def isDriftExternal(self):
        r"""

        DriftF::isDriftExternal
        """
        return _gstlearn.DriftF_isDriftExternal(self)

    def eval(self, db, iech):
        r"""

        DriftF::eval
        """
        return _gstlearn.DriftF_eval(self, db, iech)

    def getRankFex(self):
        r"""

        DriftF::getRankFex
        """
        return _gstlearn.DriftF_getRankFex(self)

    @staticmethod
    def createByIdentifier(driftname):
        r"""

        DriftF::createByIdentifier
        """
        return _gstlearn.DriftF_createByIdentifier(driftname)

    def __repr__(self):
        return _gstlearn.DriftF___repr__(self)

# Register DriftF in _gstlearn:
_gstlearn.DriftF_swigregister(DriftF)
class DriftFactory(object):
    r"""


    C++ includes: DriftFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createDriftByRank(rank, rank_fex):
        r"""

        DriftFactory::createDriftByRank
        This Drift identification is used for interpreting old serialized files where
        the drift function was encoded by its rank.  

        Parameters
        ----------
        * `rank` :  
            Rank of the drift function (in a deprecated Enum)  
        * `rank_fex` :  
            Rank of the External Drift variable  

        Returns
        -------  

        """
        return _gstlearn.DriftFactory_createDriftByRank(rank, rank_fex)

    @staticmethod
    def createDriftBySymbol(symbol):
        r"""

        DriftFactory::createDriftBySymbol
        Create a Drift Item defined by a symbol This function is left for compatibility
        with RGeostats code.  

        Parameters
        ----------
        * `symbol` :  
            Name of the symbol  

        Returns
        -------  

        """
        return _gstlearn.DriftFactory_createDriftBySymbol(symbol)

    @staticmethod
    def createDriftByIdentifier(driftname):
        r"""

        DriftFactory::createDriftByIdentifier
        """
        return _gstlearn.DriftFactory_createDriftByIdentifier(driftname)

    @staticmethod
    def createDriftListFromIRF(*args, **kwargs):
        r"""

        DriftFactory::createDriftListFromIRF
        Creating the list of Drift functions correspondaing to the following
        constraints:  

        *   Rank of the IRF  
        *   Number of external drift functions  

            Parameters:  
            * `order` :  
                Rank of the IRF  
            * `nfex` :  
                Number of external drift functions  
            * `ctxt` :  
                Cov_context  

            Returns:  

            remark: : this function is limited to order<=2 and ndim<= 3  

        """
        return _gstlearn.DriftFactory_createDriftListFromIRF(*args, **kwargs)

    @staticmethod
    def createDriftListForGradients(*args, **kwargs):
        r"""

        DriftFactory::createDriftListForGradients
        Create the list of drift functions for a Cokriging system starting from a list
        of initial drift functions It is implemented for ndim=1 or 2  

        Parameters
        ----------
        * `olddrifts` :  
            list of drift funcitons  
        * `ctxt` :  
            CovContext structure  

        Returns
        -------  

        """
        return _gstlearn.DriftFactory_createDriftListForGradients(*args, **kwargs)

    def __init__(self):
        r"""


        C++ includes: DriftFactory.hpp

        """
        _gstlearn.DriftFactory_swiginit(self, _gstlearn.new_DriftFactory())
    __swig_destroy__ = _gstlearn.delete_DriftFactory

# Register DriftFactory in _gstlearn:
_gstlearn.DriftFactory_swigregister(DriftFactory)
class SPDE(object):
    r"""


    The SPDE class provides the SPDE implementation of a univariate model defined by
    the sum of a nugget effect and Matern's models. Its main objectives are:  

    *   point kriging with or without linear drifts (SK, OK, KED, UK)  
    *   point simulations, conditional or non conditional  
    *   evaluation of the log likelihood of the model, in order to estimate the
        parameter using maximum likelihood  

    C++ includes: SPDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""

        SPDE::SPDE
        """
        _gstlearn.SPDE_swiginit(self, _gstlearn.new_SPDE(*args, **kwargs))
    __swig_destroy__ = _gstlearn.delete_SPDE

    @staticmethod
    def create(*args, **kwargs):
        r"""

        SPDE::create
        """
        return _gstlearn.SPDE_create(*args, **kwargs)

    def compute(self, *args, **kwargs):
        r"""

        SPDE::compute
        """
        return _gstlearn.SPDE_compute(self, *args, **kwargs)

    def computeTotalLogDet(self, nMC=1):
        r"""

        SPDE::computeTotalLogDet
        """
        return _gstlearn.SPDE_computeTotalLogDet(self, nMC)

    def computeQuad(self):
        r"""

        SPDE::computeQuad
        """
        return _gstlearn.SPDE_computeQuad(self)

    def computeLogLikelihood(self, nbsimu=1, verbose=False):
        r"""

        SPDE::computeLogLikelihood
        Calculate the Log-Likelihood profiling the Drift parameters  

        """
        return _gstlearn.SPDE_computeLogLikelihood(self, nbsimu, verbose)

    def getCoeffs(self):
        r"""

        SPDE::getCoeffs
        """
        return _gstlearn.SPDE_getCoeffs(self)

    def setDriftCoeffs(self, coeffs):
        r"""

        SPDE::setDriftCoeffs
        """
        return _gstlearn.SPDE_setDriftCoeffs(self, coeffs)

    def getPrecisionOpMatrix(self, i=0):
        r"""

        SPDE::getPrecisionOpMatrix
        """
        return _gstlearn.SPDE_getPrecisionOpMatrix(self, i)

    def getProjMatrix(self, i=0):
        r"""

        SPDE::getProjMatrix
        """
        return _gstlearn.SPDE_getProjMatrix(self, i)

    def getPrecisionKrig(self):
        r"""

        SPDE::getPrecisionKrig
        """
        return _gstlearn.SPDE_getPrecisionKrig(self)

    def getMeshingKrig(self, i=0):
        r"""

        SPDE::getMeshingKrig
        """
        return _gstlearn.SPDE_getMeshingKrig(self, i)

    def getMeshingSimu(self, i=0):
        r"""

        SPDE::getMeshingSimu
        """
        return _gstlearn.SPDE_getMeshingSimu(self, i)

    def getData(self):
        r"""

        SPDE::getData
        """
        return _gstlearn.SPDE_getData(self)

# Register SPDE in _gstlearn:
_gstlearn.SPDE_swigregister(SPDE)

def krigingSPDE(*args, **kwargs):
    r"""


    Perform the estimation by KRIGING under the SPDE framework  

    Parameters
    ----------
    * `dbin` :  
        Input Db (must contain the variable to be estimated)  
    * `dbout` :  
        Output Db where the estimation must be performed  
    * `model` :  
        Model definition  
    * `flag_est` :  
        True for the estimation  
    * `flag_std` :  
        True for the standard deviation of estimation error  
    * `useCholesky` :  
        Define the choice regarding Cholesky (see _defineCholesky)  
    * `meshesK` :  
        Meshes description (optional)  
    * `projInK` :  
        Matrix of projection (optional)  
    * `meshesS` :  
        Meshes used for Variance calulcation (optional)  
    * `projInS` :  
        Matrix of projection used for Variance calculation (optional)  
    * `params` :  
        Set of SPDE parameters  
    * `namconv` :  
        Naming convention  

    Returns
    -------
    Returned vector  

    remark: Algorithm for 'meshesK' or 'mesheS' and 'projInK' or 'projInS':  

        *   Each one of the previous arguments is considered individually and
            sequentially.  
        *   For 'meshes' in general ('meshesK' or 'meshesS'):
            -   If it is not defined, it is created from 'model' and so as to cover
                both 'dbin' and 'dbout' (if provided).  
            -   If is already exist, the number of meshes must be equal:
                -   either to 1: the same mesh is used for all structures  
                -   or to the number of structures (nugget discarded)  
            -   Otherwise an error is raised  
        *   For 'projIn' in general ('projInK' or 'projInS'):
            -   If it is not defined, it is created from 'meshesK'  
            -   If it is already exist, the number of projectors must be equal to
                the number of meshes  
            -   Otherwise an error is raised  
        *   If 'mesheS' does not exist, 'meshesK' is used instead  
        *   If 'projInS' does not exist, 'projInK' is used instead  

    'meshesS' and 'projInS' are used only if 'flag_std' is true and useCholesky=0  

    """
    return _gstlearn.krigingSPDE(*args, **kwargs)

def simulateSPDE(*args, **kwargs):
    r"""


    Perform the conditional SIMULATIONs in the SPDE framework  

    Parameters
    ----------
    * `dbin` :  
        Input Db (variable to be estimated). Only for conditional simulations  
    * `dbout` :  
        Output Db where the estimation must be performed  
    * `model` :  
        Model definition  
    * `nbsimu` :  
        Number of simulations  
    * `useCholesky` :  
        Define the choice regarding Cholesky (see _defineCholesky)  
    * `meshesK` :  
        Meshes used for Kriging (optional)  
    * `projInK` :  
        Matrix of projection used for Kriging (optional)  
    * `meshesS` :  
        Meshes used for Simulations (optional)  
    * `projInS` :  
        Matrix of projection used for Simulations (optional)  
    * `params` :  
        Set of SPDE parameters  
    * `namconv` :  
        see NamingConvention  

    Returns
    -------
    Error returned code  

    remark: Algorithm for 'meshesK', 'projInK', 'meshesS' and 'projInS':  

        *   Each one of the previous arguments is considered individually and
            sequentially.  
        *   For 'meshes' in general ('meshesK' or 'meshesS'):
            -   If it is not defined, it is created from 'model' and so as to cover
                both 'dbin' and 'dbout' (if provided).  
            -   If is already exist, the number of meshes must be equal:
                -   either to 1: the same mesh is used for all structures  
                -   or to the number of structures (nugget discarded)  
            -   Otherwise an error is raised  
        *   For 'projIn' in general ('projInK' or 'projInS'):
            -   If it is not defined, it is created from 'meshes'  
            -   If it is already exist, the number of projectors must be equal to
                the number of meshes  
            -   Otherwise an error is raised  
        *   If 'mesheS' does not exist, 'meshesK' is used instead  
        *   If 'projInS' does not exist, 'projInK' is used instead  

    """
    return _gstlearn.simulateSPDE(*args, **kwargs)

def logLikelihoodSPDEOld(*args, **kwargs):
    r"""


    """
    return _gstlearn.logLikelihoodSPDEOld(*args, **kwargs)

def logLikelihoodSPDE(*args, **kwargs):
    r"""


    Calculate the Log-Likelihood under the SPDE framework  

    Parameters
    ----------
    * `dbin` :  
        Input Db (must contain the variable to be estimated)  
    * `model` :  
        Model definition  
    * `useCholesky` :  
        Define the choice regarding Cholesky (see _defineCholesky)  
    * `meshes` :  
        Meshes description (optional)  
    * `projIn` :  
        Matrix of projection (optional)  
    * `params` :  
        Set of SPDE parameters  
    * `verbose` :  
        True for verbose output  

    Returns
    -------
    Returned value  

    """
    return _gstlearn.logLikelihoodSPDE(*args, **kwargs)

def buildInvNugget(*args, **kwargs):
    r"""


    Build the inverse of the Nugget Effect matrix It is established for:  

    *   the number of variables defined in 'dbin' (and in 'Model')  
    *   the active samples of 'dbin'  
    *   the samples where Z-variable (and possibly V-variable) is defined  

    Parameters
    ----------
    * `db` :  
        Input Db structure  
    * `model` :  
        Input Model structure  
    * `params` :  
        A structure for ruling the parameters of SPDE  

    """
    return _gstlearn.buildInvNugget(*args, **kwargs)

def defineMeshesFromDbs(*args, **kwargs):
    r"""


    """
    return _gstlearn.defineMeshesFromDbs(*args, **kwargs)
class PGSSPDE(object):
    r"""


    C++ includes: PGSSPDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, models, field, ruleprop, data=None):
        r"""

        PGSSPDE::PGSSPDE
        """
        _gstlearn.PGSSPDE_swiginit(self, _gstlearn.new_PGSSPDE(models, field, ruleprop, data))
    __swig_destroy__ = _gstlearn.delete_PGSSPDE

    def compute(self, *args, **kwargs):
        r"""

        PGSSPDE::compute
        """
        return _gstlearn.PGSSPDE_compute(self, *args, **kwargs)

# Register PGSSPDE in _gstlearn:
_gstlearn.PGSSPDE_swigregister(PGSSPDE)
class TestInheritance(AStringable):
    r"""


    C++ includes: TestInheritance.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        r"""

        TestInheritance::TestInheritance
        """
        _gstlearn.TestInheritance_swiginit(self, _gstlearn.new_TestInheritance())

    def toString(self, strfmt=None):
        r"""

        TestInheritance::toString
        AStringable Interface.  

        """
        return _gstlearn.TestInheritance_toString(self, strfmt)

    def setIproj(self, ipr):
        r"""

        TestInheritance::setIproj
        """
        return _gstlearn.TestInheritance_setIproj(self, ipr)
    __swig_destroy__ = _gstlearn.delete_TestInheritance

    def __repr__(self):
        return _gstlearn.TestInheritance___repr__(self)

# Register TestInheritance in _gstlearn:
_gstlearn.TestInheritance_swigregister(TestInheritance)
class Style(object):
    r"""


    The Style class contains all the recommended styles considerations. It has no
    special functionalities.  
     This is only a template class that developers can mimic.  

    This class includes **coding rules** and **doxygen documentation** examples.  

    Since doxygen 1.8.0, Markdown support is available in doxygen comments (see
    here).  

    Look at *gstlearn* READMEs for a quick overview of Markdown syntax.  
    Main class features
    This class demonstrates:  

    *   How to use doxygen for documenting the class:
        -   this global class description  
        -   the private member attributes documentation  
        -   all methods and arguments documentation (at least public ones)  
    *   Some mandatory coding rules (see below):
        -   constructors  
        -   pro active usage of `const`  
        -   error handling with exceptions,  
        -   etc...  
    *   How to use some *gstlearn* global features such has:
        -   Enumerations (see AEnum) - TODO  
        -   `DECLARE_UNUSED` macro (need including geoslib_define.h)  
        -   ...to be expanded  
    *   When functions should not be used anymore by developpers, use
        GSTLEARN_DEPRECATED in body of function definition (see
        Db::getNSampleActive())  
    *   When functions are kept in order to be refactored later, put TODO
        FUTURE_REFACTOR as a comment  
    *   Some coding constraints due to the [customized] SWIG for R version:
        -   limit the use of function overriding  
        -   do not use namespace or static variables in default argument values  
        -   do not comment the argument name when it is unused (use
            `DECLARE_UNUSED`)  
        -   do not use following argument names: 'in', '_*'  
        -   always inherit from pure virtual classes in last position (ex:
            ICloneable)  
    C++ naming convention
    Here are some rules about naming C++ types, functions, variables and symbols:  

    *   Only usual abbreviations are accepted (ie: min, max, idx, temp, ...)  
    *   Constants (macro): all in capitals with underscore (MAX_LENGTH)  
    *   Enums: idem  
    *   Class or structure names: upper camel case (ie: SparseMatrix, Database)  
    *   Aliases (typedef): idem  
    *   Class' methods: lower camel case (ie: loadData, getArmonicMean, isEmpty)  
    *   Class' attributes (variables): idem  
    *   Anything which is 'private' or 'protected' in a class starts with underscore
        (ie: *myMember)*  
    *   *Local variables: lower case separated by underscore (i.e.: temp_value,
        color_idx)*  
    *   *Methods visibility; Method _func() is internal to the class (private or
        protected) Method func*() is not exported via SWIG (using ifndef SWIG)  
    *   Use of "InPlace" suffix: It is used in methods that modify either a member
        of this class or a returned argument. Important remark. The member or
        agument must have been correctly dimensioned beforehand; no test will be
        performed (in order to speed up the processing).  
    C++ coding rules
    Here are some coding rules (good practices) for C++ developers:  

    *   Do not use `goto`  
    *   Use `break` only in `switch` cases  
    *   Limit the number of global variables  
    *   Use `const` every where  
    *   Do not use old C-style (use C++ STL)  
    *   Do not use `using namespace`  
    *   Make the includes list as small as possible in C++ header (use forward
        declaration)  
    *   Expose only what is necessary (all is private by default)  

    More good practices available here  

    Important note: All C++ coding rules are configured in the .clang-format file.
    located in the root folder. Developers can use the "Clang format" VS code
    extension to benefit from the automatic formating feature  
    Class' constructors/destructors
    Here are some rules regarding constructors and destructors:  

    *   Always add a default constructor (no arguments or arguments with default
        values)  
    *   Always add a copy constructor (with some exceptions - see Calc* classes)  
    *   Always add an assignment operator (with some exceptions - see Calc* classes)  
    *   Always add a virtual destructor  
    Documenting Methods
    Main principles for documenting class methods are the following:  

    *   Add one-line comment before each public prototype in the C++ header  
    *   Add a doxygen section above each method definition in the C++ body  
    *   All this except for trivial methods\footnote{getters, setters and inline
        functions}<sup title='getters, setters and inline
        functions'>*</sup>, constructors and destructors  
    *   Define pointer for ENUM. Example to point to EMorpho Enum: EMorpho  

    C++ includes: Style.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Style::Style
        Copy constructor  

        Always use the initialization list to set the value of each class member. Put
        attributes in the same order than their declaration in the C++ header.  

        """
        _gstlearn.Style_swiginit(self, _gstlearn.new_Style(*args))
    __swig_destroy__ = _gstlearn.delete_Style

    @staticmethod
    def documentedStandard(myArg):
        r"""

        Style::documentedStandard
        A method with standard argument documentation  

        Parameters
        ----------
        * `myArg` :  
            Here should be placed the description of this argument  

        Returns
        -------
        Description of the returned value  

        """
        return _gstlearn.Style_documentedStandard(myArg)

    @staticmethod
    def documentedWithFormula(myArg):
        r"""

        Style::documentedWithFormula
        Documentation with Latex formula  

        The distance between $ p1=(x_1,y_1) $ and $ p2=(x_2,y_2) $ is
        $\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$ (this formula may need to do this:
        https://github.com/doxygen/doxygen/issues/7484#issuecomment-572503569)  

        See also: SpaceRN::getDistance  

        Parameters
        ----------
        * `myArg` :  
            Here should be placed the description of this argument  

        Returns
        -------
        The value of the argument + 1  

        """
        return _gstlearn.Style_documentedWithFormula(myArg)

    @staticmethod
    def unusedArgument(a):
        r"""

        Style::unusedArgument
        A function where the argument is not used (could be the case in abstract
        methods)  

        Parameters
        ----------
        * `a` :  
            Input argument not used (but documented)  

        Returns
        -------
        Error returned code  

        """
        return _gstlearn.Style_unusedArgument(a)

    @staticmethod
    def myFunction(myArgInt, myArgDoubleDef=2.):
        r"""

        Style::myFunction
        Description of a static function  

        Parameters
        ----------
        * `myArgInt` :  
            Integer argument  
        * `myArgDoubleDef` :  
            Double argument  

        """
        return _gstlearn.Style_myFunction(myArgInt, myArgDoubleDef)

    def getArgDouble(self):
        return _gstlearn.Style_getArgDouble(self)

    def getArgInt(self):
        return _gstlearn.Style_getArgInt(self)

    def getArgVectorDouble(self):
        return _gstlearn.Style_getArgVectorDouble(self)

    def getArgVectorInt(self):
        return _gstlearn.Style_getArgVectorInt(self)

    def setArgDouble(self, argDouble):
        return _gstlearn.Style_setArgDouble(self, argDouble)

    def setArgInt(self, argInt):
        return _gstlearn.Style_setArgInt(self, argInt)

    def setArgVectorDouble(self, argVectorDouble):
        return _gstlearn.Style_setArgVectorDouble(self, argVectorDouble)

    def setArgVectorInt(self, argVectorInt):
        return _gstlearn.Style_setArgVectorInt(self, argVectorInt)

# Register Style in _gstlearn:
_gstlearn.Style_swigregister(Style)
class SPDEParam(object):
    r"""


    Definition of the parameters used within SPDE.  

    refineK Discretization factor used for Kriging refineS Discretization factor
    used for Simulation border Border size nxmax Maximum number of vertices in the
    internal mesh (0 : no limit) epsNugget Nugget effect useStencil Default option
    for no Cholesky (can only be used in stationary case for Turbo Meshing) nMC
    Number of Monte-Carlo simulations (used for Variance and logdet) seedMC Seed for
    the random number generator (used for Variance and logdet)  

    cgparams Parameters for the Conjugate Gradient method  

    C++ includes: SPDEParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        SPDEParam::SPDEParam
        """
        _gstlearn.SPDEParam_swiginit(self, _gstlearn.new_SPDEParam(*args))
    __swig_destroy__ = _gstlearn.delete_SPDEParam

    @staticmethod
    def create(*args, **kwargs):
        r"""

        SPDEParam::create
        """
        return _gstlearn.SPDEParam_create(*args, **kwargs)

    def getBorder(self):
        r"""

        SPDEParam::getBorder
        """
        return _gstlearn.SPDEParam_getBorder(self)

    def getCGparams(self):
        r"""

        SPDEParam::getCGparams
        """
        return _gstlearn.SPDEParam_getCGparams(self)

    def getEpsNugget(self):
        r"""

        SPDEParam::getEpsNugget
        """
        return _gstlearn.SPDEParam_getEpsNugget(self)

    def getRefineK(self):
        r"""

        SPDEParam::getRefineK
        """
        return _gstlearn.SPDEParam_getRefineK(self)

    def getRefineS(self):
        r"""

        SPDEParam::getRefineS
        """
        return _gstlearn.SPDEParam_getRefineS(self)

    def isPolarized(self):
        r"""

        SPDEParam::isPolarized
        """
        return _gstlearn.SPDEParam_isPolarized(self)

    def setPolarized(self, flagPolarized):
        r"""

        SPDEParam::setPolarized
        """
        return _gstlearn.SPDEParam_setPolarized(self, flagPolarized)

    def getNxMax(self):
        r"""

        SPDEParam::getNxMax
        """
        return _gstlearn.SPDEParam_getNxMax(self)

    def getUseStencil(self):
        r"""

        SPDEParam::getUseStencil
        """
        return _gstlearn.SPDEParam_getUseStencil(self)

    def getNMC(self):
        r"""

        SPDEParam::getNMC
        """
        return _gstlearn.SPDEParam_getNMC(self)

    def getSeedMC(self):
        r"""

        SPDEParam::getSeedMC
        """
        return _gstlearn.SPDEParam_getSeedMC(self)

    def setBorder(self, border):
        r"""

        SPDEParam::setBorder
        """
        return _gstlearn.SPDEParam_setBorder(self, border)

    def setCGparams(self, CGparams):
        r"""

        SPDEParam::setCGparams
        """
        return _gstlearn.SPDEParam_setCGparams(self, CGparams)

    def setEpsNugget(self, epsNugget):
        r"""

        SPDEParam::setEpsNugget
        """
        return _gstlearn.SPDEParam_setEpsNugget(self, epsNugget)

    def setRefineK(self, refineK):
        r"""

        SPDEParam::setRefineK
        """
        return _gstlearn.SPDEParam_setRefineK(self, refineK)

    def setRefineS(self, refineS):
        r"""

        SPDEParam::setRefineS
        """
        return _gstlearn.SPDEParam_setRefineS(self, refineS)

    def setNxMax(self, nxmax):
        r"""

        SPDEParam::setNxMax
        """
        return _gstlearn.SPDEParam_setNxMax(self, nxmax)

    def setUseStencil(self, useStencil):
        r"""

        SPDEParam::setUseStencil
        """
        return _gstlearn.SPDEParam_setUseStencil(self, useStencil)

    def setNMC(self, nMC):
        r"""

        SPDEParam::setNMC
        """
        return _gstlearn.SPDEParam_setNMC(self, nMC)

    def setSeedMC(self, seedMC):
        r"""

        SPDEParam::setSeedMC
        """
        return _gstlearn.SPDEParam_setSeedMC(self, seedMC)

# Register SPDEParam in _gstlearn:
_gstlearn.SPDEParam_swigregister(SPDEParam)
class Db(AStringable, ASerializable, ICloneable):
    r"""


    Class containing the Data Information.  

    This Data Set benefits from the comparison to an Excel spread sheet: it can be
    considered as a Data Frame with a number of rows and a number of columns. The
    columns will correspond to **variables** and the rows to **samples**.  

    Notes:  

    *   For short, this Data Base organization is referred to as **Db**,  
    *   At any time, variables can be added, renamed or deleted,  
    *   In the current version, this Data Set is currently limited to numerical
        contents. The data frame is necessarily completely filled with values:
        therefore, a specific value stands for a missing value (printed as **NA**);  

    Moreover each variable may be assigned a *role* (or functionality) in the rest
    of a script. This role is defined by a **locator**: for example, a variable can
    serve as a coordinate, or a target variable. The locators can be viewed in the
    following list (see ELoc.hpp). Note that a variable which does not play any role
    in particular may be assigned to an idle role (locator NA); This locator may be
    modified or cancelled (by the user) at any time.  

    There are two status for these locators: **unique** or **multiple**.  

    *Unique*. Only one variable can be assigned this unique locator: this is the
    case for the selection (*SEL*) as there may be only one current selection
    activated at a time.  

    *Multiple*. Several variable may be assigned the same locator: this is the case
    for the coordinates (*X*). In that case, the locator name is followed by its
    rank (1-based). Then the first coordinate will correspond to the locator *X1*,
    the second coordinate to *X2*, ... Note that:  

    *   for a given locator name, the ranks are always consecutive between 1 and N
        (if it happens that you delete X3, the locator X4 is automatically modified
        into X3, X5 into X4, and so on up to X{N} into X{N-1}.  
    *   there is no limitation in the number of ranks for a given locator name.  

    Each variable (or column) can be designated:  

    *   by its name (unique in the Data Base) or  
    *   by its locator (name and rank) or  
    *   by its column index (0-based): this designation mode is dangerous (and not
        recommended) as the index may change over time.  

    C++ includes: Db.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Db::Db
        """
        _gstlearn.Db_swiginit(self, _gstlearn.new_Db(*args))
    __swig_destroy__ = _gstlearn.delete_Db

    def toTL(self):
        return _gstlearn.Db_toTL(self)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.Db_clone(self)

    def toString(self, strfmt=None):
        r"""

        Db::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.Db_toString(self, strfmt)

    def isGrid(self):
        r"""

        Db::isGrid
        Interface for Db.  

        """
        return _gstlearn.Db_isGrid(self)

    def isLine(self):
        r"""

        Db::isLine
        """
        return _gstlearn.Db_isLine(self)

    def isMesh(self):
        r"""

        Db::isMesh
        """
        return _gstlearn.Db_isMesh(self)

    def getCoordinate(self, iech, idim, flag_rotate=True):
        r"""

        Db::getCoordinate
        Return the coordinate of a sample along one Space Dimension  

        Parameters
        ----------
        * `iech` :  
            Rank of the sample  
        * `idim` :  
            Rank of the Space Dimension  
        * `flag_rotate` :  
            Use the rotation (only for Grid)  

        Returns
        -------  

        """
        return _gstlearn.Db_getCoordinate(self, iech, idim, flag_rotate)

    def getCoordinatesInPlace(self, coor, iech, flag_rotate=True):
        r"""

        Db::getCoordinatesInPlace
        Update the vector of coordinates (optimized manner) No check is done with
        respect to the dimension of the returned vector.  

        Parameters
        ----------
        * `coor` :  
            Returned vector of coordinates (should be dimensionned beforehand)  
        * `iech` :  
            Rank of the target  
        * `flag_rotate` :  
            True if Grid rotation must be taken into account  

        """
        return _gstlearn.Db_getCoordinatesInPlace(self, coor, iech, flag_rotate)

    def getUnit(self, idim=0):
        r"""

        Db::getUnit
        Return a Unit calculated for a Db (in a given Space dimension)  

        Parameters
        ----------
        * `idim` :  
            Rank of the Space dimension  

        Returns
        -------  

        remark: This unit is defined as 1/1000 of the extension in the given space
            dimension  

        """
        return _gstlearn.Db_getUnit(self, idim)

    def getNDim(self):
        r"""

        Db::getNDim
        """
        return _gstlearn.Db_getNDim(self)

    def mayChangeSampleNumber(self):
        r"""

        Db::mayChangeSampleNumber
        """
        return _gstlearn.Db_mayChangeSampleNumber(self)

    def resetDims(self, ncol, nech):
        r"""

        Db::resetDims
        """
        return _gstlearn.Db_resetDims(self, ncol, nech)

    def isConsistent(self):
        r"""

        Db::isConsistent
        """
        return _gstlearn.Db_isConsistent(self)

    def resetFromSamples(self, *args, **kwargs):
        return _gstlearn.Db_resetFromSamples(self, *args, **kwargs)

    def resetFromCSV(self, filename, verbose, csvfmt, ncol_max=-1, nrow_max=-1, flagAddSampleRank=True):
        return _gstlearn.Db_resetFromCSV(self, filename, verbose, csvfmt, ncol_max, nrow_max, flagAddSampleRank)

    def resetFromBox(self, nech, coormin, coormax, ndim=2, extend=0., seed=321415, flagAddSampleRank=True):
        return _gstlearn.Db_resetFromBox(self, nech, coormin, coormax, ndim, extend, seed, flagAddSampleRank)

    def resetFromOnePoint(self, *args, **kwargs):
        return _gstlearn.Db_resetFromOnePoint(self, *args, **kwargs)

    def resetSamplingDb(self, *args, **kwargs):
        return _gstlearn.Db_resetSamplingDb(self, *args, **kwargs)

    def resetReduce(self, *args, **kwargs):
        return _gstlearn.Db_resetReduce(self, *args, **kwargs)

    def resetFromGridRandomized(self, dbin, randperc=0., flagAddSampleRank=True):
        return _gstlearn.Db_resetFromGridRandomized(self, dbin, randperc, flagAddSampleRank)

    @staticmethod
    def create():
        return _gstlearn.Db_create()

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        return _gstlearn.Db_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromSamples(*args, **kwargs):
        return _gstlearn.Db_createFromSamples(*args, **kwargs)

    @staticmethod
    def createFromCSV(*args, **kwargs):
        return _gstlearn.Db_createFromCSV(*args, **kwargs)

    @staticmethod
    def createFromBox(nech, coormin, coormax, seed=43241, flag_exact=True, flag_repulsion=False, range=0., beta=0., extend=0., flagAddSampleRank=True):
        return _gstlearn.Db_createFromBox(nech, coormin, coormax, seed, flag_exact, flag_repulsion, range, beta, extend, flagAddSampleRank)

    @staticmethod
    def createFromOnePoint(*args, **kwargs):
        return _gstlearn.Db_createFromOnePoint(*args, **kwargs)

    @staticmethod
    def createSamplingDb(*args, **kwargs):
        return _gstlearn.Db_createSamplingDb(*args, **kwargs)

    @staticmethod
    def createFromDbGrid(nech, dbgrid, seed=432423, flag_exact=True, flag_repulsion=False, range=0., beta=0., flagAddSampleRank=True):
        return _gstlearn.Db_createFromDbGrid(nech, dbgrid, seed, flag_exact, flag_repulsion, range, beta, flagAddSampleRank)

    @staticmethod
    def createReduce(*args, **kwargs):
        return _gstlearn.Db_createReduce(*args, **kwargs)

    @staticmethod
    def createFillRandom(*args, **kwargs):
        return _gstlearn.Db_createFillRandom(*args, **kwargs)

    @staticmethod
    def createEmpty(ndat, ndim=2, nvar=1, nfex=0, ncode=0, flagVerr=False, flagSel=False, flagAddSampleRank=True):
        return _gstlearn.Db_createEmpty(ndat, ndim, nvar, nfex, ncode, flagVerr, flagSel, flagAddSampleRank)

    @staticmethod
    def createFromGridRandomized(dbgrid, randperc=0., flagAddSampleRank=True):
        return _gstlearn.Db_createFromGridRandomized(dbgrid, randperc, flagAddSampleRank)

    def getArrays(self):
        r"""

        Db::getArrays
        """
        return _gstlearn.Db_getArrays(self)

    def getNameByLocator(self, locatorType, locatorIndex=0):
        return _gstlearn.Db_getNameByLocator(self, locatorType, locatorIndex)

    def getNameByColIdx(self, icol):
        return _gstlearn.Db_getNameByColIdx(self, icol)

    def getNameByUID(self, iuid):
        return _gstlearn.Db_getNameByUID(self, iuid)

    def initThread(self):
        return _gstlearn.Db_initThread(self)

    def getName(self, name):
        return _gstlearn.Db_getName(self, name)

    def getNames(self, names):
        return _gstlearn.Db_getNames(self, names)

    def getNamesByLocator(self, locatorType):
        return _gstlearn.Db_getNamesByLocator(self, locatorType)

    def getNamesByColIdx(self, icols):
        return _gstlearn.Db_getNamesByColIdx(self, icols)

    def getNamesByUID(self, iuids):
        return _gstlearn.Db_getNamesByUID(self, iuids)

    def getAllNames(self, excludeRankAndCoordinates=False, verbose=False):
        return _gstlearn.Db_getAllNames(self, excludeRankAndCoordinates, verbose)

    def setName(self, *args):
        return _gstlearn.Db_setName(self, *args)

    def setNameByUID(self, iuid, name):
        return _gstlearn.Db_setNameByUID(self, iuid, name)

    def setNameByColIdx(self, icol, name):
        return _gstlearn.Db_setNameByColIdx(self, icol, name)

    def setNameByLocator(self, locatorType, name):
        return _gstlearn.Db_setNameByLocator(self, locatorType, name)

    def expandNameList(self, *args):
        return _gstlearn.Db_expandNameList(self, *args)

    def identifyNames(self, names):
        return _gstlearn.Db_identifyNames(self, names)

    def getNUIDMax(self):
        r"""

        Db::getNUIDMax
        """
        return _gstlearn.Db_getNUIDMax(self)

    def getNColumn(self):
        r"""

        Db::getNColumn
        """
        return _gstlearn.Db_getNColumn(self)

    @staticmethod
    def getNEloc():
        r"""

        Db::getNEloc
        """
        return _gstlearn.Db_getNEloc()

    def getNSample(self, useSel=False):
        r"""

        Db::getNSample
        Returns the Number of samples  

        Parameters
        ----------
        * `useSel` :  
            When FALSE returns the total sample number. When TRUE returns the number of
            active samples  

        Returns
        -------  

        """
        return _gstlearn.Db_getNSample(self, useSel)

    def getNSampleActiveAndDefined(self, *args):
        r"""

        Db::getNSampleActiveAndDefined
        Returns the number of active samples for which the variable 'name' is defined  

        Parameters
        ----------
        * `name` :  
            Name of the Target variable  

        Returns
        -------
        Number of samples  

        """
        return _gstlearn.Db_getNSampleActiveAndDefined(self, *args)

    def getNSampleActive(self):
        r"""

        Db::getNSampleActive
        Returns the number of active samples if a Selection is already defined.  

        If no Selection is currently defined, it returns the total number of samples
        (see getNSample())  

        Returns
        -------
        Number of active samples  

        remark: This method is deprecated and should be replaced by a call to
            getNSample()  

        """
        return _gstlearn.Db_getNSampleActive(self)

    def getRankRelativeToAbsolute(self, irel):
        r"""

        Db::getRankRelativeToAbsolute
        Return the absolute rank of a sample from its relative rank  

        Parameters
        ----------
        * `irel` :  
            Relative rank  

        Returns
        -------  

        """
        return _gstlearn.Db_getRankRelativeToAbsolute(self, irel)

    def getRankAbsoluteToRelative(self, iabs):
        r"""

        Db::getRankAbsoluteToRelative
        """
        return _gstlearn.Db_getRankAbsoluteToRelative(self, iabs)

    def clearLocators(self, locatorType):
        r"""

        Db::clearLocators
        """
        return _gstlearn.Db_clearLocators(self, locatorType)

    def clearSelection(self):
        r"""

        Db::clearSelection
        """
        return _gstlearn.Db_clearSelection(self)

    def setLocatorByUID(self, *args, **kwargs):
        r"""

        Db::setLocatorByUID
        Setting the locator for a variable designated by its UID  

        Parameters
        ----------
        * `iuid` :  
            Index of the UID  
        * `locatorType` :  
            Type of locator (include ELoc::UNKNOWN)  
        * `locatorIndex` :  
            Rank in the Locator (starting from 0)  
        * `cleanSameLocator` :  
            When TRUE, clean variables with same locator beforehand  

        remark: : 1) At this stage, no check is performed to see if items  

        remark: : are consecutive and all defined. This allow using this function in any
            order.  

        remark: : Argument 'locatorIndex' can be set to a negative value: in that case,  

        remark: : the next index of the same 'locatorType' is generated automatically  

        """
        return _gstlearn.Db_setLocatorByUID(self, *args, **kwargs)

    def setLocatorByColIdx(self, *args, **kwargs):
        r"""

        Db::setLocatorByColIdx
        """
        return _gstlearn.Db_setLocatorByColIdx(self, *args, **kwargs)

    def setLocator(self, *args, **kwargs):
        r"""

        Db::setLocator
        Define the Locator(s) for the given variable(s)  

        Parameters
        ----------
        * `name` :  
            Variable name  
        * `locatorType` :  
            Locator Type  
        * `locatorIndex` :  
            Locator Index (for the first variable) (starting from 0)  
        * `cleanSameLocator` :  
            When TRUE, clean variables with same locator beforehand  

        """
        return _gstlearn.Db_setLocator(self, *args, **kwargs)

    def setLocators(self, *args, **kwargs):
        r"""

        Db::setLocators
        Setting the locator for a set of variables designated by their names  

        Parameters
        ----------
        * `names` :  
            Vector of variable names  
        * `locatorType` :  
            Locator type (include ELoc::UNKNOWN)  
        * `locatorIndex` :  
            Starting locator rank (starting from 0)  
        * `cleanSameLocator` :  
            When TRUE, clean variables with same locator beforehand  

        """
        return _gstlearn.Db_setLocators(self, *args, **kwargs)

    def setLocatorsByUID(self, *args):
        r"""

        Db::setLocatorsByUID
        """
        return _gstlearn.Db_setLocatorsByUID(self, *args)

    def setLocatorsByColIdx(self, *args, **kwargs):
        r"""

        Db::setLocatorsByColIdx
        """
        return _gstlearn.Db_setLocatorsByColIdx(self, *args, **kwargs)

    def addColumnsByVVD(self, tab, radix, locatorType, locatorIndex=0, useSel=False):
        r"""

        Db::addColumnsByVVD
        """
        return _gstlearn.Db_addColumnsByVVD(self, tab, radix, locatorType, locatorIndex, useSel)

    def addColumns(self, *args, **kwargs):
        r"""

        Db::addColumns
        Add one or several columns to an already existing Db. This is performed by
        providing an array of values 'tab'. Its dimension must be equal to the number of
        samples (or active samples if 'useSel' is true, times the number of variables
        'nvar'.  

        Parameters
        ----------
        * `tab` :  
            Array to be loaded  
        * `radix` :  
            Generic name for the newly created variables  
        * `locatorType` :  
            Generic locator assigned to new variables  
        * `locatorIndex` :  
            Locator index (starting from 0)  
        * `useSel` :  
            true if the Selection must be taken into account  
        * `valinit` :  
            initial value (for unselected samples)  
        * `nvar` :  
            Number of variables loaded  

        Returns
        -------
        Rank of the first UID  

        remark: When 'useSel' is used, you must have a Selection already defined. Then
            the number  

        remark: of samples provided in 'tab' must match the number of active samples  

        remark: When a vector 'tab' is provided, the number of variables 'nvar'  

        remark: is calculated as its size divided by the number of samples in the grid.  

        """
        return _gstlearn.Db_addColumns(self, *args, **kwargs)

    def addColumnsByConstant(self, *args, **kwargs):
        r"""

        Db::addColumnsByConstant
        Create a set of new variables in an already existing Db and initialize their
        contents to a constant value  

        Parameters
        ----------
        * `nadd` :  
            Number of variables to be added  
        * `valinit` :  
            Value to be used for variable initialization  
        * `radix` :  
            Generic radix given to the newly created variables  
        * `locatorType` :  
            Generic locator assigned to new variables  
        * `locatorIndex` :  
            Locator index (starting from 0)  
        * `nechInit` :  
            Number of samples (used only if the Db is initially empty)  

        Returns
        -------
        Rank of the first UID  

        """
        return _gstlearn.Db_addColumnsByConstant(self, *args, **kwargs)

    def addColumnsRandom(self, *args, **kwargs):
        r"""

        Db::addColumnsRandom
        Create a set of new variables in an already existing Db and initialize their
        contents as a ranom value (from Normal distribution)  

        Parameters
        ----------
        * `nadd` :  
            Number of variables to be added  
        * `radix` :  
            Generic radix given to the newly created variables  
        * `locatorType` :  
            Generic locator assigned to new variables  
        * `locatorIndex` :  
            Locator index (starting from 0)  
        * `seed` :  
            Seed value  
        * `nechInit` :  
            Number of samples (used only if the Db is initially empty)  

        Returns
        -------
        Rank of the first UID  

        """
        return _gstlearn.Db_addColumnsRandom(self, *args, **kwargs)

    def addSelection(self, *args, **kwargs):
        r"""

        Db::addSelection
        Add the contents of the 'tab' as a Selection  

        Parameters
        ----------
        * `tab` :  
            Input array  
        * `name` :  
            Name given to the newly created Selection variable  
        * `combine` :  
            How to combine with an already existing selection (see combineSelection()
            for details)  

        Returns
        -------
        Rank of the newly created Column within the Data Base  

        remark: The Selection is set to True if tab is not zero and to False otherwise.  

        remark: If the dimension of 'tab' does not match the number of samples in the Db  

        remark: the action is cancelled (a message is issued)  

        """
        return _gstlearn.Db_addSelection(self, *args, **kwargs)

    def addSelectionByVariable(self, *args, **kwargs):
        r"""

        Db::addSelectionByVariable
        Create a selection by testing a target variable against 'lower' and 'upper'.  

        Parameters
        ----------
        * `varname` :  
            Name of the target variable  
        * `lower` :  
            Lower bound (included) or TEST for no lower bound  
        * `upper` :  
            Upper bound (included) or TEST for no upper bound  
        * `name` :  
            Name given to the newly created selection  
        * `oldSelName` :  
            If defined, the current selection is combined with the existing one  

        Returns
        -------
        int  

        """
        return _gstlearn.Db_addSelectionByVariable(self, *args, **kwargs)

    def addSelectionByRanks(self, *args, **kwargs):
        r"""

        Db::addSelectionByRanks
        Add a Selection by considering the input 'ranks' vector which give the ranks of
        the active samples (starting from 0)  

        Parameters
        ----------
        * `ranks` :  
            Vector of ranks of active samples  
        * `name` :  
            Name given to the newly created Selection variable  
        * `combine` :  
            How to combine with an already existing selection (see combineSelection()
            for details)  

        Returns
        -------  

        """
        return _gstlearn.Db_addSelectionByRanks(self, *args, **kwargs)

    def addSelectionByLimit(self, *args, **kwargs):
        r"""

        Db::addSelectionByLimit
        Create a selection around the only defined values of the target variable  

        Parameters
        ----------
        * `testvar` :  
            Name of the target variable  
        * `limits` :  
            Limits defining the Definition Domain to be tested (optional)  
        * `name` :  
            Name of the newly created selection  
        * `combine` :  
            How to combine with an already existing selection (see combineSelection()
            for details)  

        Returns
        -------
        The rank of the newly created selection variable within the Db  

        """
        return _gstlearn.Db_addSelectionByLimit(self, *args, **kwargs)

    def addSelectionFromDbByConvexHull(self, *args, **kwargs):
        r"""

        Db::addSelectionFromDbByConvexHull
        Create a Selection based on the Convex Hull of the active samples of 'Db'  

        Parameters
        ----------
        * `db` :  
            Data Base providing the (active) samples  
        * `dilate` :  
            The convex hull can be dilated: this gives the radius  
        * `verbose` :  
            Verbose option  
        * `namconv` :  
            Naming Convention  

        Returns
        -------  

        """
        return _gstlearn.Db_addSelectionFromDbByConvexHull(self, *args, **kwargs)

    def addSelectionRandom(self, *args, **kwargs):
        r"""

        Db::addSelectionRandom
        Create a Selection based on a proportion of active samples  

        Parameters
        ----------
        * `prop` :  
            Proportion of active samples (between 0 and 1)  
        * `seed` :  
            Seed for the random number generator  
        * `name` :  
            Name of the newly created selection  
        * `combine` :  
            How to combine with an already existing selection (see combineSelection()
            for details)  

        Returns
        -------  

        """
        return _gstlearn.Db_addSelectionRandom(self, *args, **kwargs)

    def addSamples(self, nadd, valinit=1.234e30):
        r"""

        Db::addSamples
        Add samples to the Data Base  

        Parameters
        ----------
        * `nadd` :  
            Number of samples to be added  
        * `valinit` :  
            Default value given to the added samples  

        Returns
        -------
        Index of the first newly added sample (or -1 if adding samples is not
        authorized)  

        """
        return _gstlearn.Db_addSamples(self, nadd, valinit)

    def deleteSample(self, e_del):
        r"""

        Db::deleteSample
        Deleting a sample  

        Parameters
        ----------
        * `e_del` :  
            Index of the sample to be deleted  

        Returns
        -------
        0 if successfull or -1 if sample deletion is not authorized  

        """
        return _gstlearn.Db_deleteSample(self, e_del)

    def deleteSamples(self, e_dels):
        r"""

        Db::deleteSamples
        """
        return _gstlearn.Db_deleteSamples(self, e_dels)

    def switchLocator(self, locatorType_in, locatorType_out):
        r"""

        Db::switchLocator
        """
        return _gstlearn.Db_switchLocator(self, locatorType_in, locatorType_out)

    def getLastUID(self, number=0):
        r"""

        Db::getLastUID
        Returns the rank of (one of) the lastly added UID in the Db  

        Parameters
        ----------
        * `number` :  
            0 designates the last, 1 the one before last...  

        Returns
        -------  

        """
        return _gstlearn.Db_getLastUID(self, number)

    def getLastName(self, number=0):
        r"""

        Db::getLastName
        """
        return _gstlearn.Db_getLastName(self, number)

    def getColIdx(self, name):
        r"""

        Db::getColIdx
        Returns the rank of the Single Column corresponding to 'name'  

        Parameters
        ----------
        * `name` :  
            Named for the searched column  

        Returns
        -------
        The rank of the Single column or -1  

        """
        return _gstlearn.Db_getColIdx(self, name)

    def getColIdxByUID(self, iuid):
        r"""

        Db::getColIdxByUID
        """
        return _gstlearn.Db_getColIdxByUID(self, iuid)

    def getColIdxByLocator(self, locatorType, locatorIndex=0):
        r"""

        Db::getColIdxByLocator
        Find Column for a given Locator characteristics  

        Parameters
        ----------
        * `locatorType` :  
            Locator type  
        * `locatorIndex` :  
            Locator index (starting from 0)  

        Returns
        -------  

        """
        return _gstlearn.Db_getColIdxByLocator(self, locatorType, locatorIndex)

    def getColIdxs(self, *args):
        r"""

        Db::getColIdxs
        """
        return _gstlearn.Db_getColIdxs(self, *args)

    def getColIdxsByUID(self, iuids):
        r"""

        Db::getColIdxsByUID
        """
        return _gstlearn.Db_getColIdxsByUID(self, iuids)

    def getColIdxsByLocator(self, locatorType):
        r"""

        Db::getColIdxsByLocator
        """
        return _gstlearn.Db_getColIdxsByLocator(self, locatorType)

    def setColumn(self, *args, **kwargs):
        r"""

        Db::setColumn
        Set the values for an already existing Column. Note that, if the Column does not
        exist, this Column is added beforehand  

        Parameters
        ----------
        * `tab` :  
            Array of values to be stored in the target Column  
        * `name` :  
            Name of the Column  
        * `locatorType` :  
            Locator type  
        * `locatorIndex` :  
            Locator index (starting from 0)  
        * `useSel` :  
            Should an already existing Selection be taken into account  

        remark: : Arguments 'locatorType' and 'locatorIndex' are only used  

        remark: : for newly added variables  

        """
        return _gstlearn.Db_setColumn(self, *args, **kwargs)

    def setColumnByUIDOldStyle(self, tab, iuid, useSel=False):
        r"""

        Db::setColumnByUIDOldStyle
        Update the contents of an already existing variable in a Db  

        Parameters
        ----------
        * `tab` :  
            Vector containing the values to be written  
        * `iuid` :  
            UID of the already existing variable to be written  
        * `useSel` :  
            When TRUE, take the Selection into account (seed remarks)  

        remark: When useSel=TRUE, the input vector should be dimensioned to  

        remark: the number of active samples. Only the active samples of the Db  

        remark: are updated using the contents of the input 'tab' vector.  

        """
        return _gstlearn.Db_setColumnByUIDOldStyle(self, tab, iuid, useSel)

    def setColumnByUID(self, tab, iuid, useSel=False):
        r"""

        Db::setColumnByUID
        """
        return _gstlearn.Db_setColumnByUID(self, tab, iuid, useSel)

    def setColumnByColIdx(self, tab, icol, useSel=False):
        r"""

        Db::setColumnByColIdx
        """
        return _gstlearn.Db_setColumnByColIdx(self, tab, icol, useSel)

    def setColumnsByColIdx(self, tabs, icols, useSel=False):
        r"""

        Db::setColumnsByColIdx
        """
        return _gstlearn.Db_setColumnsByColIdx(self, tabs, icols, useSel)

    def setColumnByColIdxOldStyle(self, tab, icol, useSel=False):
        r"""

        Db::setColumnByColIdxOldStyle
        """
        return _gstlearn.Db_setColumnByColIdxOldStyle(self, tab, icol, useSel)

    def duplicateColumnByUID(self, iuid_in, iuid_out):
        r"""

        Db::duplicateColumnByUID
        """
        return _gstlearn.Db_duplicateColumnByUID(self, iuid_in, iuid_out)

    def getItem(self, *args):
        r"""

        Db::getItem
        """
        return _gstlearn.Db_getItem(self, *args)

    def getItemNames(self, *args):
        r"""

        Db::getItemNames
        """
        return _gstlearn.Db_getItemNames(self, *args)

    def setItem(self, *args):
        r"""

        Db::setItem
        """
        return _gstlearn.Db_setItem(self, *args)

    def getLocator(self, name, ret_locatorType, ret_locatorIndex):
        r"""

        Db::getLocator
        Return the locator information corresponding to the input variable  

        Parameters
        ----------
        * `name` :  
            Input variable name (unique)  
        * `ret_locatorType` :  
            Locator Type  
        * `ret_locatorIndex` :  
            Locator Index (starting from 0)  

        Returns
        -------  

        """
        return _gstlearn.Db_getLocator(self, name, ret_locatorType, ret_locatorIndex)

    def getLocatorByColIdx(self, icol, ret_locatorType, ret_locatorIndex):
        r"""

        Db::getLocatorByColIdx
        Find the locator characteristics of a given Column  

        Parameters
        ----------
        * `icol` :  
            Index of the target column  
        * `ret_locatorType` :  
            Locator type  
        * `ret_locatorIndex` :  
            Locator index (starting from 0)  

        Returns
        -------
        true if the target variable has a locator assigned and false otherwise  

        """
        return _gstlearn.Db_getLocatorByColIdx(self, icol, ret_locatorType, ret_locatorIndex)

    def getLocatorByUID(self, iuid, ret_locatorType, ret_locatorIndex):
        r"""

        Db::getLocatorByUID
        """
        return _gstlearn.Db_getLocatorByUID(self, iuid, ret_locatorType, ret_locatorIndex)

    def getLocators(self, *args, **kwargs):
        r"""

        Db::getLocators
        """
        return _gstlearn.Db_getLocators(self, *args, **kwargs)

    def isUIDDefined(self, iuid):
        r"""

        Db::isUIDDefined
        """
        return _gstlearn.Db_isUIDDefined(self, iuid)

    def getUID(self, name):
        r"""

        Db::getUID
        Returns the Single UID which corresponds to the searched name  

        Parameters
        ----------
        * `name` :  
            Name to be searched for  

        Returns
        -------
        Rank of the UID or -1  

        """
        return _gstlearn.Db_getUID(self, name)

    def getUIDByColIdx(self, icol):
        r"""

        Db::getUIDByColIdx
        """
        return _gstlearn.Db_getUIDByColIdx(self, icol)

    def getUIDByLocator(self, locatorType, locatorIndex=0):
        r"""

        Db::getUIDByLocator
        """
        return _gstlearn.Db_getUIDByLocator(self, locatorType, locatorIndex)

    def getUIDs(self, names):
        r"""

        Db::getUIDs
        """
        return _gstlearn.Db_getUIDs(self, names)

    def getUIDsByLocator(self, locatorType):
        r"""

        Db::getUIDsByLocator
        """
        return _gstlearn.Db_getUIDsByLocator(self, locatorType)

    def getUIDsByColIdx(self, icols):
        r"""

        Db::getUIDsByColIdx
        """
        return _gstlearn.Db_getUIDsByColIdx(self, icols)

    def getAllUIDs(self, *args):
        r"""

        Db::getAllUIDs
        """
        return _gstlearn.Db_getAllUIDs(self, *args)

    def copyByUID(self, iuidIn, iuidOut):
        r"""

        Db::copyByUID
        """
        return _gstlearn.Db_copyByUID(self, iuidIn, iuidOut)

    def copyByCol(self, icolIn, icolOut):
        r"""

        Db::copyByCol
        """
        return _gstlearn.Db_copyByCol(self, icolIn, icolOut)

    def getNFacies(self):
        r"""

        Db::getNFacies
        Returns the Number of different facies (labelling starts at 1) The facies
        variable must be locatorized as ELoc::Z and be unique  

        """
        return _gstlearn.Db_getNFacies(self)

    def hasLocatorDefined(self, name, locatorType, locatorIndex=0):
        r"""

        Db::hasLocatorDefined
        Check if a variable (specified by its name) matches the required locator  

        Parameters
        ----------
        * `name` :  
            Name of the target Variable  
        * `locatorType` :  
            Characteristics of the required Locator Type  
        * `locatorIndex` :  
            Index of the required Locator (or -1)  

        Returns
        -------  

        """
        return _gstlearn.Db_hasLocatorDefined(self, name, locatorType, locatorIndex)

    def getSampleCoordinates(self, iech):
        r"""

        Db::getSampleCoordinates
        """
        return _gstlearn.Db_getSampleCoordinates(self, iech)

    def getSampleAsSPInPlace(self, P, iabs):
        r"""

        Db::getSampleAsSPInPlace
        In the SpacePoint 'P', define the sample rank and coordinates.  

        Parameters
        ----------
        * `P` :  
            SpacePoint reference (output)  
        * `iabs` :  
            Rank of the sample  

        """
        return _gstlearn.Db_getSampleAsSPInPlace(self, P, iabs)

    def getSampleAsSTInPlace(self, iech, P):
        r"""

        Db::getSampleAsSTInPlace
        Load a Space Target with all possible contents gathered from Db  

        Parameters
        ----------
        * `iech` :  
            Rank of the target sample  
        * `P` :  
            Space Target (used to store information)  

        """
        return _gstlearn.Db_getSampleAsSTInPlace(self, iech, P)

    def getSampleLocators(self, locatorType, iech):
        r"""

        Db::getSampleLocators
        """
        return _gstlearn.Db_getSampleLocators(self, locatorType, iech)

    def getIncrements(self, iechs, jechs):
        r"""

        Db::getIncrements
        """
        return _gstlearn.Db_getIncrements(self, iechs, jechs)

    def getOneCoordinate(self, idim, useSel=False, flag_rotate=True):
        r"""

        Db::getOneCoordinate
        Returns the vector of coordinates along a given Space Dimension  

        Parameters
        ----------
        * `idim` :  
            Rank of the Space dimension  
        * `useSel` :  
            Use the Data Selection  
        * `flag_rotate` :  
            Flag for rotation (only for Grid)  

        Returns
        -------  

        """
        return _gstlearn.Db_getOneCoordinate(self, idim, useSel, flag_rotate)

    def getAllCoordinates(self, useSel=False):
        r"""

        Db::getAllCoordinates
        Constitute a Vector of Vector of coordinates for all (active) samples  

        *   the first dimension is the space dimension  
        *   the second dimension is the number of (active) samples  

            Parameters:  
            * `useSel` :  

            Returns:  

        """
        return _gstlearn.Db_getAllCoordinates(self, useSel)

    def getAllCoordinatesMat(self, *args, **kwargs):
        r"""

        Db::getAllCoordinatesMat
        Constitute a Matrix of coordinates for all (active) samples  

        *   one row per sample  
        *   one column by Space Dimension  

            Returns:  

        """
        return _gstlearn.Db_getAllCoordinatesMat(self, *args, **kwargs)

    def setCoordinate(self, iech, idim, value):
        r"""

        Db::setCoordinate
        """
        return _gstlearn.Db_setCoordinate(self, iech, idim, value)

    def setCoordinates(self, idim, coor, useSel=False):
        r"""

        Db::setCoordinates
        """
        return _gstlearn.Db_setCoordinates(self, idim, coor, useSel)

    def setSampleCoordinates(self, iech, coor):
        r"""

        Db::setSampleCoordinates
        """
        return _gstlearn.Db_setSampleCoordinates(self, iech, coor)

    def getDistance1D(self, iech, jech, idim=0, flagAbs=False):
        r"""

        Db::getDistance1D
        """
        return _gstlearn.Db_getDistance1D(self, iech, jech, idim, flagAbs)

    def getDistance(self, iech, jech):
        r"""

        Db::getDistance
        """
        return _gstlearn.Db_getDistance(self, iech, jech)

    def getDistanceVecInPlace(self, iech, jech, dd, db2=None):
        r"""

        Db::getDistanceVecInPlace
        Calculate the distance vector in place  

        Parameters
        ----------
        * `iech` :  
            Rank of the first sample  
        * `jech` :  
            Rank of the second sample (from db2 if db2 provided)  
        * `dd` :  
            Vector for distances (It must be dimensioned to getNDim())  
        * `db2` :  
            Second Db if different from current one (or nullptr)  

        Returns
        -------  

        """
        return _gstlearn.Db_getDistanceVecInPlace(self, iech, jech, dd, db2)

    def getValue(self, name, iech):
        r"""

        Db::getValue
        Returns the value of the 'iech' sample of the variable 'name'  

        This function does not use 'ids' mechanism in order to allow referring to a non-
        existing variable  

        """
        return _gstlearn.Db_getValue(self, name, iech)

    def setValue(self, name, iech, value):
        r"""

        Db::setValue
        Sets the value of the 'iech' sample of the variable 'name'  

        This function does not use 'ids' mechanism in order to allow referring to a non-
        existing variable  

        """
        return _gstlearn.Db_setValue(self, name, iech, value)

    def getArray(self, iech, iuid):
        r"""

        Db::getArray
        Return the value defined by Sample and UID  

        Parameters
        ----------
        * `iech` :  
            Sample Index  
        * `iuid` :  
            UID Index  

        Returns
        -------  

        """
        return _gstlearn.Db_getArray(self, iech, iuid)

    def getArrayVec(self, iechs, iuid, values):
        r"""

        Db::getArrayVec
        Get the values of a series of samples  

        Parameters
        ----------
        * `iechs` :  
            List of sample indices  
        * `iuid` :  
            Index of the UID  
        * `values` :  
            List of values to be written  

        remark: : for efficiency purpose, no check is performed on the sample ranks  

        """
        return _gstlearn.Db_getArrayVec(self, iechs, iuid, values)

    def setArray(self, iech, iuid, value):
        r"""

        Db::setArray
        Set the value by Sample and UID  

        Parameters
        ----------
        * `iech` :  
            Index of the Sample  
        * `iuid` :  
            Index of the UID  
        * `value` :  
            Value to be assigned  

        """
        return _gstlearn.Db_setArray(self, iech, iuid, value)

    def setArrayVec(self, iechs, iuid, values):
        r"""

        Db::setArrayVec
        Set the values of a series of samples  

        Parameters
        ----------
        * `iechs` :  
            List of sample indices  
        * `iuid` :  
            Index of the UID  
        * `values` :  
            List of values to be written  

        remark: : for efficiency purpose, no check is performed on the sample ranks  

        """
        return _gstlearn.Db_setArrayVec(self, iechs, iuid, values)

    def updArray(self, iech, iuid, oper, value):
        r"""

        Db::updArray
        """
        return _gstlearn.Db_updArray(self, iech, iuid, oper, value)

    def updArrayVec(self, iechs, iuid, oper, values):
        r"""

        Db::updArrayVec
        """
        return _gstlearn.Db_updArrayVec(self, iechs, iuid, oper, values)

    def getArrayByUID(self, iuid, useSel=False):
        r"""

        Db::getArrayByUID
        """
        return _gstlearn.Db_getArrayByUID(self, iuid, useSel)

    def setArrayByUID(self, tab, iuid):
        r"""

        Db::setArrayByUID
        """
        return _gstlearn.Db_setArrayByUID(self, tab, iuid)

    def getArrayBySample(self, vals, iech):
        r"""

        Db::getArrayBySample
        """
        return _gstlearn.Db_getArrayBySample(self, vals, iech)

    def setArrayBySample(self, iech, vec):
        r"""

        Db::setArrayBySample
        """
        return _gstlearn.Db_setArrayBySample(self, iech, vec)

    def getSamplesAsSP(self, pvec, space, useSel=False):
        r"""

        Db::getSamplesAsSP
        """
        return _gstlearn.Db_getSamplesAsSP(self, pvec, space, useSel)

    def getSamplesFromNbghAsSP(self, pvec, nbgh):
        r"""

        Db::getSamplesFromNbghAsSP
        """
        return _gstlearn.Db_getSamplesFromNbghAsSP(self, pvec, nbgh)

    def hasLocator(self, locatorType):
        r"""

        Db::hasLocator
        """
        return _gstlearn.Db_hasLocator(self, locatorType)

    def getFromLocator(self, locatorType, iech, locatorIndex=0):
        r"""

        Db::getFromLocator
        """
        return _gstlearn.Db_getFromLocator(self, locatorType, iech, locatorIndex)

    def setFromLocator(self, locatorType, iech, locatorIndex, value):
        r"""

        Db::setFromLocator
        """
        return _gstlearn.Db_setFromLocator(self, locatorType, iech, locatorIndex, value)

    def getValueByColIdx(self, iech, icol, flagCheck=True):
        r"""

        Db::getValueByColIdx
        """
        return _gstlearn.Db_getValueByColIdx(self, iech, icol, flagCheck)

    def getColAdressByColIdx(self, icol):
        r"""

        Db::getColAdressByColIdx
        """
        return _gstlearn.Db_getColAdressByColIdx(self, icol)

    def setValueByColIdx(self, iech, icol, value, flagCheck=True):
        r"""

        Db::setValueByColIdx
        """
        return _gstlearn.Db_setValueByColIdx(self, iech, icol, value, flagCheck)

    def getValuesByNames(self, iechs, names, bySample=False):
        r"""

        Db::getValuesByNames
        """
        return _gstlearn.Db_getValuesByNames(self, iechs, names, bySample)

    def getValuesByColIdx(self, iechs, icols, bySample=False):
        r"""

        Db::getValuesByColIdx
        """
        return _gstlearn.Db_getValuesByColIdx(self, iechs, icols, bySample)

    def setValuesByNames(self, iechs, names, values, bySample=False):
        r"""

        Db::setValuesByNames
        """
        return _gstlearn.Db_setValuesByNames(self, iechs, names, values, bySample)

    def setValuesByColIdx(self, iechs, icols, values, bySample=False):
        r"""

        Db::setValuesByColIdx
        """
        return _gstlearn.Db_setValuesByColIdx(self, iechs, icols, values, bySample)

    def getNLoc(self, loctype):
        return _gstlearn.Db_getNLoc(self, loctype)

    def hasLocVariable(self, loctype):
        return _gstlearn.Db_hasLocVariable(self, loctype)

    def getLocVariable(self, loctype, iech, item):
        return _gstlearn.Db_getLocVariable(self, loctype, iech, item)

    def setLocVariable(self, loctype, iech, item, value):
        return _gstlearn.Db_setLocVariable(self, loctype, iech, item, value)

    def updLocVariable(self, loctype, iech, item, oper, value):
        return _gstlearn.Db_updLocVariable(self, loctype, iech, item, oper, value)

    def getNZValues(self):
        r"""

        Db::getNZValues
        """
        return _gstlearn.Db_getNZValues(self)

    def hasZVariable(self):
        r"""

        Db::hasZVariable
        """
        return _gstlearn.Db_hasZVariable(self)

    def getZVariable(self, iech, item):
        r"""

        Db::getZVariable
        """
        return _gstlearn.Db_getZVariable(self, iech, item)

    def setZVariable(self, iech, item, value):
        r"""

        Db::setZVariable
        """
        return _gstlearn.Db_setZVariable(self, iech, item, value)

    def updZVariable(self, iech, item, oper, value):
        r"""

        Db::updZVariable
        """
        return _gstlearn.Db_updZVariable(self, iech, item, oper, value)

    def getLocVariables(self, loctype, iech, nitemax=0):
        r"""

        Db::getLocVariables
        """
        return _gstlearn.Db_getLocVariables(self, loctype, iech, nitemax)

    def setLocVariables(self, loctype, iech, values):
        r"""

        Db::setLocVariables
        """
        return _gstlearn.Db_setLocVariables(self, loctype, iech, values)

    def isNVarComparedTo(self, nvar, compare=0):
        r"""

        Db::isNVarComparedTo
        Checks the number of variables in 'this' compared to the required 'nvar'  

        *   compare=0: they should be equal  
        *   compare<0: 'this' should contain less (or equal) than 'nvar'  
        *   compare>0: 'this' should contain more (or equal) than 'nvar'  

        """
        return _gstlearn.Db_isNVarComparedTo(self, nvar, compare)

    def isIsotopic(self, iech, nvar_max=-1):
        r"""

        Db::isIsotopic
        Check if the information (ELOC.Z) for a sample is isotopic or not Isotopic says
        that all variables (for this sample) are defined  

        Parameters
        ----------
        * `iech` :  
            Rank of the sample  
        * `nvar_max` :  
            Maximum number of variables to be checked (or -1)  

        remark: The returned answer is false is there is no variable defined or if the
            sample rank is not valid. If 'nvar_max' is defined, the test is performed on
            the 'nvar_max' first variables. Otherwise, it is performed on all ELOC.Z
            variables  

        """
        return _gstlearn.Db_isIsotopic(self, iech, nvar_max)

    def isAllUndefined(self, iech):
        r"""

        Db::isAllUndefined
        """
        return _gstlearn.Db_isAllUndefined(self, iech)

    def isAllUndefinedByType(self, loctype, iech):
        r"""

        Db::isAllUndefinedByType
        """
        return _gstlearn.Db_isAllUndefinedByType(self, loctype, iech)

    def isAllIsotopic(self):
        r"""

        Db::isAllIsotopic
        Check that all the active samples are isotopic  

        """
        return _gstlearn.Db_isAllIsotopic(self)

    def setInterval(self, iech, item, rklow=1.234e30, rkup=1.234e30):
        r"""

        Db::setInterval
        """
        return _gstlearn.Db_setInterval(self, iech, item, rklow, rkup)

    def getNInterval(self):
        r"""

        Db::getNInterval
        """
        return _gstlearn.Db_getNInterval(self)

    def setBound(self, iech, item, lower=1.234e30, upper=1.234e30):
        r"""

        Db::setBound
        """
        return _gstlearn.Db_setBound(self, iech, item, lower, upper)

    def getWithinBounds(self, item, useSel=False):
        r"""

        Db::getWithinBounds
        """
        return _gstlearn.Db_getWithinBounds(self, item, useSel)

    def getGradient(self, item, useSel=False):
        r"""

        Db::getGradient
        """
        return _gstlearn.Db_getGradient(self, item, useSel)

    def getTangent(self, item, useSel=False):
        r"""

        Db::getTangent
        """
        return _gstlearn.Db_getTangent(self, item, useSel)

    def getCodeList(self):
        r"""

        Db::getCodeList
        Returns the list of Unique codes  

        Returns
        -------
        Pointer to the array containing a single occurence of each code  

        """
        return _gstlearn.Db_getCodeList(self)

    def getSelection(self, iech):
        r"""

        Db::getSelection
        Return the Selection value at Sample 'iech'  

        Parameters
        ----------
        * `iech` :  
            Sample number  

        Returns
        -------  

        remark: If the selection value if TEST, the sample is considered as masked off.  

        """
        return _gstlearn.Db_getSelection(self, iech)

    def getSelections(self):
        r"""

        Db::getSelections
        """
        return _gstlearn.Db_getSelections(self)

    def getSampleRanksPerVariable(self, *args, **kwargs):
        r"""

        Db::getSampleRanksPerVariable
        Create the vector of elligible sample ranks for the variable 'ivar'.  

        Parameters
        ----------
        * `ranks` :  
            Vector of elligible sample ranks (Input/Output)  
        * `nbgh` :  
            Set of potentiel sample ranks  
        * `ivar` :  
            Target variable rank  
        * `useSel` :  
            True if the selection must be taken into account  
        * `useZ` :  
            True if the definition of the target variable must be checked  
        * `useVerr` :  
            True if the definition of the Variance of Measurement Error must be checked  
        * `useExtD` :  
            True if the definition of the External Drift must be checked  

        """
        return _gstlearn.Db_getSampleRanksPerVariable(self, *args, **kwargs)

    def getSampleRanks(self, *args, **kwargs):
        r"""

        Db::getSampleRanks
        Returns the list of indices 'index' for valid samples for the set of variables
        'ivars'. Note: each address is ABSOLUTE to the target set of available samples.  

        Parameters
        ----------
        * `ivars` :  
            Vector giving the indices of the variables of interest  
        * `nbgh` :  
            Vector giving the ranks of the elligible samples (optional)  
        * `useSel` :  
            Discard the masked samples (if True)  
        * `useZ` :  
            Discard samples when Z is not defined  
        * `useVerr` :  
            Discard the samples where Verr (optional) is not defined  
        * `useExtD` :  
            True if the definition of the External Drift must be checked  

        note: : if the current 'db' has some Z-variable defined, only samples  

        note: : where a variable is defined is considered (search for heterotopy).  

        note: : if 'nbgh' is not provided, the absolute and relative indices  

        note: : returned by this function are similar.  

        note: : if 'useExtD' is ON, each sample for each variable is tested against  

        note: : all the values of External Drift functions.  

        """
        return _gstlearn.Db_getSampleRanks(self, *args, **kwargs)

    def getSampleRanksInPlace(self, *args, **kwargs):
        r"""

        Db::getSampleRanksInPlace
        Compute the list of indices 'index' for valid samples for the set of variables
        'ivars'. Note: each address is ABSOLUTE to the target set of available samples.  

        Parameters
        ----------
        * `sampleRanks` :  
            Return the list of indices 'index' for valid samples  
        * `ivars` :  
            Vector giving the indices of the variables of interest  
        * `nbgh` :  
            Vector giving the ranks of the elligible samples (optional)  
        * `useSel` :  
            Discard the masked samples (if True)  
        * `useZ` :  
            Discard samples when Z is not defined  
        * `useVerr` :  
            Discard the samples where Verr (optional) is not defined  
        * `useExtD` :  
            True if the definition of the External Drift must be checked  

        note: : if the current 'db' has some Z-variable defined, only samples  

        note: : where a variable is defined is considered (search for heterotopy).  

        note: : if 'nbgh' is not provided, the absolute and relative indices  

        note: : returned by this function are similar.  

        note: : if 'useExtD' is ON, each sample for each variable is tested against  

        note: : all the values of External Drift functions.  

        """
        return _gstlearn.Db_getSampleRanksInPlace(self, *args, **kwargs)

    def getValuesByRanks(self, *args, **kwargs):
        r"""

        Db::getValuesByRanks
        Returns the values of the Z variables for the samples  

        Parameters
        ----------
        * `sampleRanks` :  
            Vector of ranks of the samples  
        * `means` :  
            Vector of means (optional)  
        * `subtractMean` :  
            Subtract the mean from the values  

        Returns
        -------
        VectorDouble  

        """
        return _gstlearn.Db_getValuesByRanks(self, *args, **kwargs)

    def getValuesByRanksInPlace(self, *args, **kwargs):
        r"""

        Db::getValuesByRanksInPlace
        """
        return _gstlearn.Db_getValuesByRanksInPlace(self, *args, **kwargs)

    @staticmethod
    def getMultipleSelectedRanks(*args, **kwargs):
        r"""

        Db::getMultipleSelectedRanks
        Return the vector of the ranks within 'index' of data beloging:  

        *   to the variable indices 'ivars' (default: all samples)  
        *   to the sample indices 'nbgh' (default: all samples)  

        Parameters
        ----------
        * `index` :  
            Input data information ranks  
        * `ivars` :  
            Vector of selection variables  
        * `nbgh` :  
            Vector of selection samples  

        Returns
        -------
        VectorInt  

        """
        return _gstlearn.Db_getMultipleSelectedRanks(*args, **kwargs)

    @staticmethod
    def getMultipleSelectedVariables(*args, **kwargs):
        r"""

        Db::getMultipleSelectedVariables
        """
        return _gstlearn.Db_getMultipleSelectedVariables(*args, **kwargs)

    def getWeight(self, iech):
        r"""

        Db::getWeight
        """
        return _gstlearn.Db_getWeight(self, iech)

    def getWeights(self, useSel=False):
        r"""

        Db::getWeights
        """
        return _gstlearn.Db_getWeights(self, useSel)

    @staticmethod
    def getSimRank(isimu, ivar, icase, nbsimu, nvar):
        return _gstlearn.Db_getSimRank(isimu, ivar, icase, nbsimu, nvar)

    def getSimvar(self, locatorType, iech, isimu, ivar, icase, nbsimu, nvar):
        return _gstlearn.Db_getSimvar(self, locatorType, iech, isimu, ivar, icase, nbsimu, nvar)

    def setSimvar(self, locatorType, iech, isimu, ivar, icase, nbsimu, nvar, value):
        return _gstlearn.Db_setSimvar(self, locatorType, iech, isimu, ivar, icase, nbsimu, nvar, value)

    def updSimvar(self, locatorType, iech, isimu, ivar, icase, nbsimu, nvar, oper, value):
        return _gstlearn.Db_updSimvar(self, locatorType, iech, isimu, ivar, icase, nbsimu, nvar, oper, value)

    def isActive(self, iech):
        r"""

        Db::isActive
        """
        return _gstlearn.Db_isActive(self, iech)

    def isActiveDomain(self, iech):
        r"""

        Db::isActiveDomain
        """
        return _gstlearn.Db_isActiveDomain(self, iech)

    def isActiveAndDefined(self, iech, item):
        r"""

        Db::isActiveAndDefined
        """
        return _gstlearn.Db_isActiveAndDefined(self, iech, item)

    def getActiveArray(self):
        r"""

        Db::getActiveArray
        """
        return _gstlearn.Db_getActiveArray(self)

    def getSortArray(self):
        r"""

        Db::getSortArray
        Return the vector of ordered samples by increasing coordinate along X  

        Returns
        -------
        Array containing the increasing order  

        remark: The returned array must be desallocated  

        """
        return _gstlearn.Db_getSortArray(self)

    def getCosineToDirection(self, iech1, iech2, codir):
        r"""

        Db::getCosineToDirection
        Calculates the cosine of the angle between a reference direction and the
        increment between two points in the same Db  

        Returns
        -------
        Cosine of the angle  

        Parameters
        ----------
        * `iech1` :  
            rank of the first sample  
        * `iech2` :  
            rank of the second sample  
        * `codir` :  
            Direction coefficient  

        """
        return _gstlearn.Db_getCosineToDirection(self, iech1, iech2, codir)

    def getColumn(self, name, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumn(self, name, useSel, flagCompress)

    def getColumnByUID(self, iuid, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumnByUID(self, iuid, useSel, flagCompress)

    def getColumnByLocator(self, locatorType, locatorIndex=0, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumnByLocator(self, locatorType, locatorIndex, useSel, flagCompress)

    def getColumnByColIdx(self, icol, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumnByColIdx(self, icol, useSel, flagCompress)

    def getAllColumns(self, useSel=False, flagCompress=True):
        return _gstlearn.Db_getAllColumns(self, useSel, flagCompress)

    def getColumns(self, *args, **kwargs):
        return _gstlearn.Db_getColumns(self, *args, **kwargs)

    def getColumnsAsVVD(self, *args, **kwargs):
        return _gstlearn.Db_getColumnsAsVVD(self, *args, **kwargs)

    def getColumnsAsMatrix(self, names, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumnsAsMatrix(self, names, useSel, flagCompress)

    def getColumnsByColIdx(self, *args, **kwargs):
        return _gstlearn.Db_getColumnsByColIdx(self, *args, **kwargs)

    def getColumnsByColIdxInterval(self, icol_beg, icol_end, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumnsByColIdxInterval(self, icol_beg, icol_end, useSel, flagCompress)

    def getColumnsActiveAndDefined(self, *args, **kwargs):
        return _gstlearn.Db_getColumnsActiveAndDefined(self, *args, **kwargs)

    def getColumnsByLocator(self, *args, **kwargs):
        return _gstlearn.Db_getColumnsByLocator(self, *args, **kwargs)

    def getColumnsByUID(self, *args, **kwargs):
        return _gstlearn.Db_getColumnsByUID(self, *args, **kwargs)

    def getColumnsByUIDInterval(self, iuid_beg, iuid_end, useSel=False, flagCompress=True):
        return _gstlearn.Db_getColumnsByUIDInterval(self, iuid_beg, iuid_end, useSel, flagCompress)

    def setAllColumns(self, tabs):
        r"""

        Db::setAllColumns
        Setting the contents of all the Columns of a Db  

        Parameters
        ----------
        * `tabs` :  
            Vector of vectors containing the values to be assigned  

        """
        return _gstlearn.Db_setAllColumns(self, tabs)

    def deleteColumn(self, name):
        return _gstlearn.Db_deleteColumn(self, name)

    def deleteColumnByUID(self, iuid_del):
        return _gstlearn.Db_deleteColumnByUID(self, iuid_del)

    def deleteColumnByColIdx(self, icol_del):
        return _gstlearn.Db_deleteColumnByColIdx(self, icol_del)

    def deleteColumns(self, names):
        return _gstlearn.Db_deleteColumns(self, names)

    def deleteColumnsByLocator(self, locatorType):
        return _gstlearn.Db_deleteColumnsByLocator(self, locatorType)

    def deleteColumnsByUID(self, iuids):
        return _gstlearn.Db_deleteColumnsByUID(self, iuids)

    def deleteColumnsByColIdx(self, icols):
        return _gstlearn.Db_deleteColumnsByColIdx(self, icols)

    def deleteColumnsByUIDRange(self, i_del, n_del):
        return _gstlearn.Db_deleteColumnsByUIDRange(self, i_del, n_del)

    def getExtrema(self, idim, useSel=False):
        return _gstlearn.Db_getExtrema(self, idim, useSel)

    def getExtremas(self, useSel=False):
        return _gstlearn.Db_getExtremas(self, useSel)

    def getExtends(self, useSel=False):
        return _gstlearn.Db_getExtends(self, useSel)

    def getCoorMinimum(self, useSel=False):
        return _gstlearn.Db_getCoorMinimum(self, useSel)

    def getCoorMaximum(self, useSel=False):
        return _gstlearn.Db_getCoorMaximum(self, useSel)

    def getExtension(self, idim, useSel=False):
        return _gstlearn.Db_getExtension(self, idim, useSel)

    def getExtensionDiagonal(self, useSel=False):
        return _gstlearn.Db_getExtensionDiagonal(self, useSel)

    def getCenter(self, idim, useSel=False):
        return _gstlearn.Db_getCenter(self, idim, useSel)

    def getCenters(self, useSel=False):
        return _gstlearn.Db_getCenters(self, useSel)

    def getExtensionInPlace(self, mini, maxi, flagPreserve=False, useSel=False):
        return _gstlearn.Db_getExtensionInPlace(self, mini, maxi, flagPreserve, useSel)

    def getMinimum(self, name, useSel=False):
        return _gstlearn.Db_getMinimum(self, name, useSel)

    def getMaximum(self, name, useSel=False):
        return _gstlearn.Db_getMaximum(self, name, useSel)

    def getRange(self, name, useSel=False):
        return _gstlearn.Db_getRange(self, name, useSel)

    def getMean(self, name, useSel=False):
        return _gstlearn.Db_getMean(self, name, useSel)

    def getVariance(self, name, useSel=False):
        return _gstlearn.Db_getVariance(self, name, useSel)

    def getStdv(self, name, useSel=False):
        return _gstlearn.Db_getStdv(self, name, useSel)

    def getCorrelation(self, name1, name2, useSel=False):
        return _gstlearn.Db_getCorrelation(self, name1, name2, useSel)

    def hasSameDimension(self, dbaux):
        r"""

        Db::hasSameDimension
        """
        return _gstlearn.Db_hasSameDimension(self, dbaux)

    def hasLargerDimension(self, dbaux):
        r"""

        Db::hasLargerDimension
        Check if the Space Dimension of 'dbaux' is larger (or equal) than the one of
        'this'  

        Parameters
        ----------
        * `dbaux` :  
            Second Db  

        Returns
        -------  

        """
        return _gstlearn.Db_hasLargerDimension(self, dbaux)

    def isColIdxValid(self, icol):
        return _gstlearn.Db_isColIdxValid(self, icol)

    def isUIDValid(self, iuid):
        return _gstlearn.Db_isUIDValid(self, iuid)

    def isSampleIndexValid(self, iech):
        return _gstlearn.Db_isSampleIndexValid(self, iech)

    def isSampleIndicesValid(self, iechs, useSel=False):
        return _gstlearn.Db_isSampleIndicesValid(self, iechs, useSel)

    def isLocatorIndexValid(self, locatorType, locatorIndex):
        return _gstlearn.Db_isLocatorIndexValid(self, locatorType, locatorIndex)

    def isDimensionIndexValid(self, idim):
        return _gstlearn.Db_isDimensionIndexValid(self, idim)

    def combineSelection(self, *args, **kwargs):
        r"""

        Db::combineSelection
        Combine 'sel' input argument with an already existing selection (if any)  

        Parameters
        ----------
        * `sel` :  
            Input selection (only 0 and 1)  
        * `combine` :  
            Type of combination: "set", "not", "or", "and", "xor"  

        remark: Argument 'sel' may be modified by this procedure  

        """
        return _gstlearn.Db_combineSelection(self, *args, **kwargs)

    def generateRank(self, *args, **kwargs):
        r"""

        Db::generateRank
        """
        return _gstlearn.Db_generateRank(self, *args, **kwargs)

    def shrinkToValidRows(self, rows):
        r"""

        Db::shrinkToValidRows
        """
        return _gstlearn.Db_shrinkToValidRows(self, rows)

    def shrinkToValidCols(self, cols):
        r"""

        Db::shrinkToValidCols
        """
        return _gstlearn.Db_shrinkToValidCols(self, cols)

    @staticmethod
    def coverSeveralDbs(db1, db2, isBuilt):
        r"""

        Db::coverSeveralDbs
        """
        return _gstlearn.Db_coverSeveralDbs(db1, db2, isBuilt)

    def statisticsBySample(self, *args, **kwargs):
        return _gstlearn.Db_statisticsBySample(self, *args, **kwargs)

    def statisticsMulti(self, *args, **kwargs):
        return _gstlearn.Db_statisticsMulti(self, *args, **kwargs)

    def areSame(self, name1, name2, eps=1.e-3, useSel=True, verbose=False):
        r"""

        Db::areSame
        """
        return _gstlearn.Db_areSame(self, name1, name2, eps, useSel, verbose)

    def filter(self, name, interval, belowRow=-1234567, aboveRow=-1234567):
        r"""

        Db::filter
        Find the occurrence of a given range of values for a given variable  

        Parameters
        ----------
        * `name` :  
            Name of the Target variable  
        * `interval` :  
            Interval definition  
        * `belowRow` :  
            If specified, search must be performed below this row  
        * `aboveRow` :  
            If specified, search must be performed above this row  

        Returns
        -------  

        """
        return _gstlearn.Db_filter(self, name, interval, belowRow, aboveRow)

    def printOneSample(self, *args, **kwargs):
        r"""

        Db::printOneSample
        """
        return _gstlearn.Db_printOneSample(self, *args, **kwargs)

    def dumpGeometry(self, iech, jech):
        r"""

        Db::dumpGeometry
        """
        return _gstlearn.Db_dumpGeometry(self, iech, jech)

    def __repr__(self):
        return _gstlearn.Db___repr__(self)

# Register Db in _gstlearn:
_gstlearn.Db_swigregister(Db)
class DbGrid(Db):
    r"""


    Class containing the Data Information organized as a Regular Grid.  

    This class is derived from the Db class, with a specific decoration: its samples
    correspond to the nodes of a regular grid defined in the current space.  

    A regular grid is a tessellation of n-dimensional Euclidean space by congruent
    parallelotopes (e.g. bricks). The number of meshes along each space direction is
    defined by NX and the total number of samples is equal to: NX[1] x NX[2] x ... x
    NX[NDIM] where NDIM is he space dimension.  

    Note that this particular Db does not allow the modification of the sample
    number by addition or deletion.  

    The grid decoration contains the following information:  

    *   the number of meshes per direction (**NX**)  
    *   the coordinates of the grid origin (**X0**) defined as the node located in
        first position (smallest index) along each space direction  
    *   the mesh value along each space direction (**DX**)  
    *   the rotation angles around the grid origin (the origin is invariant through
        this rotation).  

    Note that rotation is defined by as many angles as the space dimension. This
    general property is not valid:  

    *   for 1D where the rotation concept does not make sense  
    *   for 2D where a single angle would be sufficient: however a second dummy
        angle (always set to 0) is used for generality sake.  

    Note that this grid decoration essentially describes the organization of the
    grid nodes. Then the same grid can be considered as a grid of points
    (**punctual** grid) or a grid of cells (**block** grid). In the latter case:  

    *   the origin is (currently) the lower-left corner (for 2D) or the origin cell.  
    *   the extensions of the cells are considered as constant by default and equal
        to DX. However, they can be replaced by a set of variables allowing the user
        to assign a variable cell extension for each cell.  

    C++ includes: DbGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DbGrid::DbGrid
        """
        _gstlearn.DbGrid_swiginit(self, _gstlearn.new_DbGrid(*args))
    __swig_destroy__ = _gstlearn.delete_DbGrid

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DbGrid_clone(self)

    def toString(self, strfmt=None):
        r"""

        DbGrid::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.DbGrid_toString(self, strfmt)

    def isGrid(self):
        r"""

        DbGrid::isGrid
        Db Interface.  

        """
        return _gstlearn.DbGrid_isGrid(self)

    def getCoordinate(self, iech, idim, flag_rotate=True):
        r"""

        DbGrid::getCoordinate
        Return the coordinate of a sample along one Space Dimension  

        Parameters
        ----------
        * `iech` :  
            Rank of the sample  
        * `idim` :  
            Rank of the Space Dimension  
        * `flag_rotate` :  
            Use the rotation (only for Grid)  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_getCoordinate(self, iech, idim, flag_rotate)

    def getCoordinatesInPlace(self, coor, iech, flag_rotate=True):
        r"""

        DbGrid::getCoordinatesInPlace
        Update the vector of coordinates (optimized manner) No check is done with
        respect to the dimension of the returned vector.  

        Parameters
        ----------
        * `coor` :  
            Returned vector of coordinates (should be dimensionned beforehand)  
        * `iech` :  
            Rank of the target  
        * `flag_rotate` :  
            True if Grid rotation must be taken into account  

        """
        return _gstlearn.DbGrid_getCoordinatesInPlace(self, coor, iech, flag_rotate)

    def getUnit(self, idim=0):
        r"""

        DbGrid::getUnit
        Return a Unit calculated for a Db (in a given Space dimension)  

        Parameters
        ----------
        * `idim` :  
            Rank of the Space dimension  

        Returns
        -------  

        remark: This unit is defined as 1/1000 of the extension in the given space
            dimension  

        """
        return _gstlearn.DbGrid_getUnit(self, idim)

    def getNDim(self):
        r"""

        DbGrid::getNDim
        """
        return _gstlearn.DbGrid_getNDim(self)

    def mayChangeSampleNumber(self):
        r"""

        DbGrid::mayChangeSampleNumber
        """
        return _gstlearn.DbGrid_mayChangeSampleNumber(self)

    def resetDims(self, ncol, nech):
        r"""

        DbGrid::resetDims
        Set dimension  

        Parameters
        ----------
        * `ncol` :  
            Number of columns (= variables)  
        * `nech` :  
            Number of samples (ignore in case of Grid)  

        """
        return _gstlearn.DbGrid_resetDims(self, ncol, nech)

    def isConsistent(self):
        r"""

        DbGrid::isConsistent
        """
        return _gstlearn.DbGrid_isConsistent(self)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        DbGrid::createFromNF
        Create a Db by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (Db format)  
        * `verbose` :  
            Verbose  

        remark: The name does not need to be completed in particular when defined by
            absolute path  

        remark: or read from the Data Directory (in the gstlearn distribution)  

        """
        return _gstlearn.DbGrid_createFromNF(NFFilename, verbose)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        DbGrid::create
        """
        return _gstlearn.DbGrid_create(*args, **kwargs)

    @staticmethod
    def createCoveringDb(*args, **kwargs):
        r"""

        DbGrid::createCoveringDb
        """
        return _gstlearn.DbGrid_createCoveringDb(*args, **kwargs)

    @staticmethod
    def createFromPolygon(polygon, nodes, dcell, flagAddSampleRank=True):
        r"""

        DbGrid::createFromPolygon
        """
        return _gstlearn.DbGrid_createFromPolygon(polygon, nodes, dcell, flagAddSampleRank)

    @staticmethod
    def createCoarse(dbin, nmult, flagCell=True, flagAddSampleRank=True):
        r"""

        DbGrid::createCoarse
        """
        return _gstlearn.DbGrid_createCoarse(dbin, nmult, flagCell, flagAddSampleRank)

    @staticmethod
    def createRefine(dbin, nmult, flagCell=True, flagAddSampleRank=True):
        r"""

        DbGrid::createRefine
        """
        return _gstlearn.DbGrid_createRefine(dbin, nmult, flagCell, flagAddSampleRank)

    @staticmethod
    def createFromGridExtend(gridIn, tops, bots, nxnew, verbose=False, eps=1.e-3):
        r"""

        DbGrid::createFromGridExtend
        Create a new Grid, starting from an initial Grid, and extending its space
        dimensions A set of Top and Bottom variables is provided which serve in
        designing the Top and Bottom of the new coordinates.  

        Parameters
        ----------
        * `gridIn` :  
            Initial  
        * `tops` :  
            Vector of Variable names which define the Tops  
        * `bots` :  
            Vector of Variable names which define the Bottoms  
        * `nxnew` :  
            Vector giving the number of meshes for each additional space dimension  
        * `verbose` :  
            Verbose flag  
        * `eps` :  
            Each new coordinate is calculated from the top to bottom extension inflated
            by eps  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_createFromGridExtend(gridIn, tops, bots, nxnew, verbose, eps)

    @staticmethod
    def createFromGridShrink(gridIn, deletedRanks):
        r"""

        DbGrid::createFromGridShrink
        Create a new grid, from an Initial Grid, by suppressing a set of space
        dimensions  

        Parameters
        ----------
        * `gridIn` :  
            Initial grid  
        * `deletedRanks` :  
            Vector of indices of space dimensions to be suppressed  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_createFromGridShrink(gridIn, deletedRanks)

    @staticmethod
    def createGrid2D(*args, **kwargs):
        r"""

        DbGrid::createGrid2D
        Create a 2-D Db structure  

        Returns
        -------
        Pointer to the newly created 2-D Db grid structure  

        Parameters
        ----------
        * `order` :  
            Manner in which values in tab are ordered (ELoadBy)  
        * `flagAddSampleRank` :  
            true to add 'rank' as a supplementary field  
        * `nx` :  
            Number of grid nodes along X  
        * `ny` :  
            Number of grid nodes along Y  
        * `x0` :  
            Grid origin along X  
        * `y0` :  
            Grid origin along Y  
        * `dx` :  
            Grid mesh along X  
        * `dy` :  
            Grid mesh along Y  
        * `angle` :  
            Rotation angle  
        * `tab` :  
            Array containing the data  

        """
        return _gstlearn.DbGrid_createGrid2D(*args, **kwargs)

    @staticmethod
    def createSqueezeAndStretchForward(grid3Din, surf2D, nameTop, nameBot, names, nzout, thickmin=0.):
        r"""

        DbGrid::createSqueezeAndStretchForward
        Creating a 3D grid by squeeze-and-stretch forwards, i.e. from structural to
        sugar box, from:  

        *   a 3D grid containing the relevant information  
        *   a 2D grid containing the top and bottom information  

            Parameters:  
            * `grid3Din` :  
                3D input grid  
            * `surf2D` :  
                2D grid of surfaces  
            * `nameTop` :  
                Name of the variable in 'surf2D' containing the top information  
            * `nameBot` :  
                Name of the variable in 'surf2D' containing the bottom information  
            * `names` :  
                Vector of names in 'grid3D' to be exported in output 3D grid  
            * `nzout` :  
                Number of Vertical meshes in the output 3D grid  
            * `thickmin` :  
                The algorithm is not applied if  

            Returns:
            The output 3D grid (or nullptr in case of error)  

            remark: :  
        *   the grid files 'surf2D' and 'grid3Din' should match (in 2-D)  
        *   the grid 'surf2D' contains the top and bottom (identified by the
            corresponding locators)  
        *   the grid 'surf2D' contains a selection which designates the only pixels
            where 'top' and 'bot' are defined and correctly ordered (o save time)  

        """
        return _gstlearn.DbGrid_createSqueezeAndStretchForward(grid3Din, surf2D, nameTop, nameBot, names, nzout, thickmin)

    @staticmethod
    def createSqueezeAndStretchBackward(grid3Din, surf2D, nameTop, nameBot, names, nzout, z0out, dzout):
        r"""

        DbGrid::createSqueezeAndStretchBackward
        Creating a 3D grid by squeeze-and-stretch backwards, i.e. from sugar box to
        structural, from:  

        *   a 3D grid containing the relevant information  
        *   a 2D grid containing the top and bottom information  

            Parameters:  
            * `grid3Din` :  
                3D input grid  
            * `surf2D` :  
                2D grid of surfaces  
            * `nameTop` :  
                Name of the variable in 'surf2D' containing the top information  
            * `nameBot` :  
                Name of the variable in 'surf2D' containing the bottom information  
            * `names` :  
                Vector of names in 'grid3D' to be exported in output 3D grid  
            * `nzout`, `z0out`, `dzout` :  
                Specification along third dimension of the output 3D Grid  

            Returns:
            The output 3D grid (or nullptr in case of error)  

            remark: :  
        *   the grid files 'surf2D' and 'grid3Din' should match (in 2-D)  
        *   the grid 'surf2D' contains the top and bottom (identified by the
            corresponding locators)  
        *   the grid 'surf2D' contains a selection which designates the only pixels
            where 'top' and 'bot' are defined and correctly ordered (o save time)  

        """
        return _gstlearn.DbGrid_createSqueezeAndStretchBackward(grid3Din, surf2D, nameTop, nameBot, names, nzout, z0out, dzout)

    @staticmethod
    def createSubGrid(gridin, limits, flagAddCoordinates=False):
        r"""

        DbGrid::createSubGrid
        Create the sub-grid, extracted from 'gridIn' and reduced to the vector of limits  

        Parameters
        ----------
        * `gridIn` :  
            Input grid  
        * `limits` :  
            A vector of Min and Max per space dimension (Dimension: [ndim][2])  
        * `flagAddCoordinates` :  
            True if the grid coordinates must be included in the output file  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_createSubGrid(gridin, limits, flagAddCoordinates)

    @staticmethod
    def createMultiple(dbin, nmult, flagAddSampleRank):
        r"""

        DbGrid::createMultiple
        Create a Grid Db as a multiple of another Grid Db  

        Returns
        -------
        Pointer to the newly created Db grid structure  

        Parameters
        ----------
        * `dbin` :  
            Initial Db Grid  
        * `nmult` :  
            Array of multiplicity coefficients  
        * `flagAddSampleRank` :  
            true to add the 'rank' as first column **  

        """
        return _gstlearn.DbGrid_createMultiple(dbin, nmult, flagAddSampleRank)

    @staticmethod
    def createDivider(dbin, nmult, flagAddSampleRank):
        r"""

        DbGrid::createDivider
        Create a Grid Db as a divider of another Grid Db  

        Returns
        -------
        Pointer to the newly created Db grid structure  

        Parameters
        ----------
        * `dbin` :  
            Initial Db Grid  
        * `nmult` :  
            Array of subdivision coefficients  
        * `flagAddSampleRank` :  
            true to add the 'rank' as first column  

        """
        return _gstlearn.DbGrid_createDivider(dbin, nmult, flagAddSampleRank)

    @staticmethod
    def createFillRandom(*args, **kwargs):
        r"""

        DbGrid::createFillRandom
        Creating a new Db loaded with random values  

        Parameters
        ----------
        * `nx` :  
            Vector of mesh indices  
        * `nvar` :  
            Number of variables  
        * `nfex` :  
            Number of external drift functions  
        * `ncode` :  
            Number of codes (no code when 0)  
        * `varmax` :  
            Maximum value for the measurement error  
        * `selRatio` :  
            Percentage of samples that must be masked off (between 0 and 1)  
        * `heteroRatio` :  
            Vector of proportions of NA to be generated per variable  
        * `means` :  
            Vector of means per variable (optional)  
        * `seed` :  
            Value for the Random Generator seed  

        Returns
        -------
        A pointer to the newly created DbGrid  

        remark: The generated grid lies within a [0,1] hypercube. The variance of
            measurement error is created only if 'varmax' is positive. Then a field is
            created for each variable. this field is filled with random values uniformly
            generated in [0, varmax] The external drift values are generated according
            to Normal distribution.  

        """
        return _gstlearn.DbGrid_createFillRandom(*args, **kwargs)

    def reset(self, *args, **kwargs):
        r"""

        DbGrid::reset
        Creating a Db regular grid of any dimension  

        Parameters
        ----------
        * `nx` :  
            A vector of the number of grid meshes. The number of items in this argument
            gives the dimension of the space. (size = ndim)  
        * `dx` :  
            Vector cell meshes size in each direction (size = ndim) (by default, use 1)  
        * `x0` :  
            Vector of origin coordinates (size = ndim) (by default, use 0)  
        * `angles` :  
            Array giving the rotation angles (only for dimension 2 or 3). The first
            angle corresponds to the rotation around OZ axis, the second to a rotation
            around OY'and the third one around Ox. The dimension of this array cannot
            exceed the space dimension.  
        * `order` :  
            Flag for values order in 'tab' (defined ELoadBy.hpp)  
        * `tab` :  
            Variable values array (size = nvar * nsamples)  
        * `names` :  
            Names of the Variables of 'tab' (size = nvar)  
        * `locatorNames` :  
            Locators for each variable of array 'tab' (size = nvar)  
        * `flagAddSampleRank` :  
            If true, add an automatic rank variable  
        * `flagAddCoordinates` :  
            If TRUE, add the grid coordinates  

        """
        return _gstlearn.DbGrid_reset(self, *args, **kwargs)

    def resetCoveringDb(self, *args, **kwargs):
        r"""

        DbGrid::resetCoveringDb
        Creating a Grid Db which covers the extension of the input 'Db'  

        Parameters
        ----------
        * `db` :  
            Input Db from which the newly created Db is constructed  
        * `nx` :  
            Vector of the expected number of grid nodes (default = 10)  
        * `dx` :  
            Vector of the expected sizes for the grid meshes (in distance)  
        * `x0` :  
            Vector of the expected origin of the grid (in coordinate)  
        * `margin` :  
            Vector of the expected margins of the grid (in distance)  

        remark: Arguments 'nodes' and 'dcell' are disjunctive. If both defined, 'dcell'
            prevails  

        Load the data  

        """
        return _gstlearn.DbGrid_resetCoveringDb(self, *args, **kwargs)

    def resetFromPolygon(self, polygon, nodes, dcell, flagAddSampleRank=True):
        r"""

        DbGrid::resetFromPolygon
        Creating a regular grid Db which covers the input Polygon  

        Parameters
        ----------
        * `polygon` :  
            Pointer to the input Polygon  
        * `nodes` :  
            Vector of the expected number of nodes  
        * `dcell` :  
            Vector of the expected dimensions for the grid cells  
        * `flagAddSampleRank` :  
            true if the sample rank must be generated  

        Load the data  

        """
        return _gstlearn.DbGrid_resetFromPolygon(self, polygon, nodes, dcell, flagAddSampleRank)

    def coarsify(self, nmult):
        r"""

        DbGrid::coarsify
        """
        return _gstlearn.DbGrid_coarsify(self, nmult)

    def refine(self, nmult):
        r"""

        DbGrid::refine
        """
        return _gstlearn.DbGrid_refine(self, nmult)

    def migrateAllVariables(self, dbin, flag_fill=True, flag_inter=True, flag_ball=False, flagAddSampleRank=True):
        r"""

        DbGrid::migrateAllVariables
        Migrate all the variables (Z_locator) from 'dbin' on the nodes of 'this' (grid)  

        Parameters
        ----------
        * `dbin` :  
            Input Db  
        * `flagAddSampleRank` :  
            true if the rank of the samples must be aaded  
        * `flag_fill` :  
            Filling option  
        * `flag_inter` :  
            Interpolation  
        * `flag_ball` :  
            Use BallTree sorting algorithm when available  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_migrateAllVariables(self, dbin, flag_fill, flag_inter, flag_ball, flagAddSampleRank)

    def getGrid(self):
        r"""

        DbGrid::getGrid
        """
        return _gstlearn.DbGrid_getGrid(self)

    def generateCoordinates(self, *args, **kwargs):
        r"""

        DbGrid::generateCoordinates
        """
        return _gstlearn.DbGrid_generateCoordinates(self, *args, **kwargs)

    def getColumnSubGrid(self, name, idim0, rank, useSel=False):
        r"""

        DbGrid::getColumnSubGrid
        """
        return _gstlearn.DbGrid_getColumnSubGrid(self, name, idim0, rank, useSel)

    def gridDefine(self, *args, **kwargs):
        r"""

        DbGrid::gridDefine
        """
        return _gstlearn.DbGrid_gridDefine(self, *args, **kwargs)

    def gridCopyParams(self, mode, gridaux):
        r"""

        DbGrid::gridCopyParams
        """
        return _gstlearn.DbGrid_gridCopyParams(self, mode, gridaux)

    def isSameGrid(self, grid):
        r"""

        DbGrid::isSameGrid
        """
        return _gstlearn.DbGrid_isSameGrid(self, grid)

    def isSameGridMesh(self, dbaux):
        r"""

        DbGrid::isSameGridMesh
        """
        return _gstlearn.DbGrid_isSameGridMesh(self, dbaux)

    def isSameGridRotation(self, dbaux):
        r"""

        DbGrid::isSameGridRotation
        """
        return _gstlearn.DbGrid_isSameGridRotation(self, dbaux)

    def isGridRotated(self):
        r"""

        DbGrid::isGridRotated
        """
        return _gstlearn.DbGrid_isGridRotated(self)

    def getNTotal(self):
        r"""

        DbGrid::getNTotal
        """
        return _gstlearn.DbGrid_getNTotal(self)

    def getCellSize(self):
        r"""

        DbGrid::getCellSize
        """
        return _gstlearn.DbGrid_getCellSize(self)

    def getVolume(self):
        r"""

        DbGrid::getVolume
        """
        return _gstlearn.DbGrid_getVolume(self)

    def getExtends(self):
        r"""

        DbGrid::getExtends
        """
        return _gstlearn.DbGrid_getExtends(self)

    def getExtend(self, idim):
        r"""

        DbGrid::getExtend
        """
        return _gstlearn.DbGrid_getExtend(self, idim)

    def getNX(self, idim):
        r"""

        DbGrid::getNX
        """
        return _gstlearn.DbGrid_getNX(self, idim)

    def getNXs(self):
        r"""

        DbGrid::getNXs
        """
        return _gstlearn.DbGrid_getNXs(self)

    def getNXsExt(self, ndimMax):
        r"""

        DbGrid::getNXsExt
        """
        return _gstlearn.DbGrid_getNXsExt(self, ndimMax)

    def hasSingleBlock(self):
        r"""

        DbGrid::hasSingleBlock
        """
        return _gstlearn.DbGrid_hasSingleBlock(self)

    def getDX(self, idim):
        r"""

        DbGrid::getDX
        """
        return _gstlearn.DbGrid_getDX(self, idim)

    def getDXs(self):
        r"""

        DbGrid::getDXs
        """
        return _gstlearn.DbGrid_getDXs(self)

    def getX0(self, idim):
        r"""

        DbGrid::getX0
        """
        return _gstlearn.DbGrid_getX0(self, idim)

    def getX0s(self):
        r"""

        DbGrid::getX0s
        """
        return _gstlearn.DbGrid_getX0s(self)

    def getAngle(self, idim):
        r"""

        DbGrid::getAngle
        """
        return _gstlearn.DbGrid_getAngle(self, idim)

    def getAngles(self):
        r"""

        DbGrid::getAngles
        """
        return _gstlearn.DbGrid_getAngles(self)

    def getRotMat(self):
        r"""

        DbGrid::getRotMat
        """
        return _gstlearn.DbGrid_getRotMat(self)

    def setNX(self, idim, value):
        r"""

        DbGrid::setNX
        """
        return _gstlearn.DbGrid_setNX(self, idim, value)

    def setX0(self, idim, value):
        r"""

        DbGrid::setX0
        """
        return _gstlearn.DbGrid_setX0(self, idim, value)

    def setDX(self, idim, value):
        r"""

        DbGrid::setDX
        """
        return _gstlearn.DbGrid_setDX(self, idim, value)

    def getGridAxis(self, idim):
        r"""

        DbGrid::getGridAxis
        """
        return _gstlearn.DbGrid_getGridAxis(self, idim)

    def getCoordinateFromCorner(self, icorner):
        r"""

        DbGrid::getCoordinateFromCorner
        """
        return _gstlearn.DbGrid_getCoordinateFromCorner(self, icorner)

    def getCoordinatesByIndice(self, *args, **kwargs):
        r"""

        DbGrid::getCoordinatesByIndice
        """
        return _gstlearn.DbGrid_getCoordinatesByIndice(self, *args, **kwargs)

    def getCoordinatesPerSample(self, iech, flag_rotate=True):
        r"""

        DbGrid::getCoordinatesPerSample
        """
        return _gstlearn.DbGrid_getCoordinatesPerSample(self, iech, flag_rotate)

    def coordinateToRank(self, coor, centered=False, eps=1.e-6):
        r"""

        DbGrid::coordinateToRank
        """
        return _gstlearn.DbGrid_coordinateToRank(self, coor, centered, eps)

    def coordinateToIndices(self, coor, centered=False, eps=1.e-6):
        r"""

        DbGrid::coordinateToIndices
        """
        return _gstlearn.DbGrid_coordinateToIndices(self, coor, centered, eps)

    def coordinateToIndicesInPlace(self, coor, indices, centered=False, eps=1.e-6):
        r"""

        DbGrid::coordinateToIndicesInPlace
        """
        return _gstlearn.DbGrid_coordinateToIndicesInPlace(self, coor, indices, centered, eps)

    def getCenterIndices(self, flagSup=False):
        r"""

        DbGrid::getCenterIndices
        """
        return _gstlearn.DbGrid_getCenterIndices(self, flagSup)

    def indiceToRank(self, indice):
        r"""

        DbGrid::indiceToRank
        """
        return _gstlearn.DbGrid_indiceToRank(self, indice)

    def rankToIndice(self, node, indices, minusOne=False):
        r"""

        DbGrid::rankToIndice
        """
        return _gstlearn.DbGrid_rankToIndice(self, node, indices, minusOne)

    def rankToCoordinatesInPlace(self, *args, **kwargs):
        r"""

        DbGrid::rankToCoordinatesInPlace
        """
        return _gstlearn.DbGrid_rankToCoordinatesInPlace(self, *args, **kwargs)

    def rankToCoordinates(self, *args, **kwargs):
        r"""

        DbGrid::rankToCoordinates
        """
        return _gstlearn.DbGrid_rankToCoordinates(self, *args, **kwargs)

    def indicesToCoordinateInPlace(self, *args, **kwargs):
        r"""

        DbGrid::indicesToCoordinateInPlace
        """
        return _gstlearn.DbGrid_indicesToCoordinateInPlace(self, *args, **kwargs)

    def indicesToCoordinate(self, *args, **kwargs):
        r"""

        DbGrid::indicesToCoordinate
        """
        return _gstlearn.DbGrid_indicesToCoordinate(self, *args, **kwargs)

    def sampleBelongsToCell(self, *args, **kwargs):
        r"""

        DbGrid::sampleBelongsToCell
        """
        return _gstlearn.DbGrid_sampleBelongsToCell(self, *args, **kwargs)

    def centerCoordinateInPlace(self, coor, centered=False, stopIfOut=False, eps=1.e-6):
        r"""

        DbGrid::centerCoordinateInPlace
        """
        return _gstlearn.DbGrid_centerCoordinateInPlace(self, coor, centered, stopIfOut, eps)

    def locateDataInGrid(self, *args, **kwargs):
        r"""

        DbGrid::locateDataInGrid
        """
        return _gstlearn.DbGrid_locateDataInGrid(self, *args, **kwargs)

    def getMirrorIndex(self, idim, ix):
        r"""

        DbGrid::getMirrorIndex
        """
        return _gstlearn.DbGrid_getMirrorIndex(self, idim, ix)

    def getSlice(self, name, pos=0, indice=0, useSel=False):
        r"""

        DbGrid::getSlice
        Extracts a slice from a 3-D Grid  

        Parameters
        ----------
        * `name` :  
            Name of the target variable  
        * `pos` :  
            Type of section: 0 for YoZ; 1 for XoZ and 2 for XoY  
        * `indice` :  
            Rank of the section  
        * `useSel` :  
            Use the active selection  

        Returns
        -------
        A VectorVectorDouble with 4 columns, i.e: X, Y, Z, Var  

        remark: In presence of a selection and if useSel is TRUE,  

        remark: values are returned but set to TEST  

        """
        return _gstlearn.DbGrid_getSlice(self, name, pos, indice, useSel)

    def getOneSlice(self, *args, **kwargs):
        r"""

        DbGrid::getOneSlice
        Returns the contents of one slice extracted from a DbGrid  

        Parameters
        ----------
        * `name` :  
            Name of the targte variable  
        * `posx` :  
            Rank of the first extracted coordinate (in [0, ndim[)  
        * `posy` :  
            Rank of the second extracted coordinate (in [0, ndim[)  
        * `corner` :  
            Vector giving a reference node that belongs to the extracted section  
        * `useSel` :  
            Use of the current Selection  

        Returns
        -------  

        remark: The argument 'corner' gives the indices of a node that belongs to the  

        remark: extracted section. Obviously corner[posx] and corner[posy] are not used  

        """
        return _gstlearn.DbGrid_getOneSlice(self, *args, **kwargs)

    def getOneSliceForCoordinate(self, *args, **kwargs):
        r"""

        DbGrid::getOneSliceForCoordinate
        Returns the contents of one slice extracted from a DbGrid  

        Parameters
        ----------
        * `idim` :  
            Rank of the target coordinate  
        * `posx` :  
            Rank of the first extracted coordinate (in [0, ndim[)  
        * `posy` :  
            Rank of the second extracted coordinate (in [0, ndim[)  
        * `corner` :  
            Vector giving a reference node that belongs to the extracted section  
        * `useSel` :  
            Use of the current Selection  

        Returns
        -------  

        remark: If idim does not match the Space dimension of the DbGrid, empty vector
            if returned  

        remark: If the variable exists physically, this variable is read  

        remark: Otherwise, the coordinate is generated on the fly  

        remark: The argument 'corner' gives the indices of a node that belongs to the  

        remark: extracted section. Obviously corner[posx] and corner[posy] are not used  

        """
        return _gstlearn.DbGrid_getOneSliceForCoordinate(self, *args, **kwargs)

    def assignGridColumn(self, name, idim, rank, value, useSel=False):
        r"""

        DbGrid::assignGridColumn
        Set all elements of a column (1-D) along a given space dimension to a constant
        value  

        Parameters
        ----------
        * `name` :  
            Name of the target variable  
        * `idim` :  
            Rank of the Space dimension  
        * `rank` :  
            Rank of the target Column  
        * `value` :  
            Assigned value  
        * `useSel` :  
            Use the selection  

        """
        return _gstlearn.DbGrid_assignGridColumn(self, name, idim, rank, value, useSel)

    def getBlockExtensions(self, node):
        r"""

        DbGrid::getBlockExtensions
        """
        return _gstlearn.DbGrid_getBlockExtensions(self, node)

    def getCellEdges(self, node=0, forceGridMesh=False):
        r"""

        DbGrid::getCellEdges
        Return the VectorVectorDouble containing the borders of a cell  

        Parameters
        ----------
        * `node` :  
            Target cell  
        * `forceGridMesh` :  
            When TRUE, returns the edges of the standard grid mesh even if a variable
            block extension is defined  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_getCellEdges(self, node, forceGridMesh)

    def getAllCellsEdges(self, forceGridMesh=False):
        r"""

        DbGrid::getAllCellsEdges
        """
        return _gstlearn.DbGrid_getAllCellsEdges(self, forceGridMesh)

    def getGridEdges(self):
        r"""

        DbGrid::getGridEdges
        Return the VectorVectorDouble containing the borders of the grid  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_getGridEdges(self)

    def getCodir(self, grincr):
        r"""

        DbGrid::getCodir
        """
        return _gstlearn.DbGrid_getCodir(self, grincr)

    def getLimitsFromVariableExtend(self, *args, **kwargs):
        r"""

        DbGrid::getLimitsFromVariableExtend
        Returns the minimum and maximum indices of the subgrid where variables 'nameTop'
        and 'nameBot' are both defined  

        Parameters
        ----------
        * `nameTop` :  
            Name of the Top variable  
        * `nameBot` :  
            Name of the Bottom variable  
        * `dimExclude` :  
            Array giving excluding dimension (see details)  

        Returns
        -------
        A vector of Min and Max per space dimension (Dimension: [ndim][2])  

        : When a dimension is 'excluded', the reduction of the output grid should not be
        applied to this dimension  

        """
        return _gstlearn.DbGrid_getLimitsFromVariableExtend(self, *args, **kwargs)

    def setSelectionFromVariableExtend(self, nameTop, nameBot):
        r"""

        DbGrid::setSelectionFromVariableExtend
        Defines a selection in the current grid where variables 'nameTop' and 'nameBot'
        are both defined and ordered properly  

        Parameters
        ----------
        * `nameTop` :  
            Name of the Top variable  
        * `nameBot` :  
            Name of the Bottom variable  

        : This method also adds a selection in the current grid which masks off the
        pixels where 'nameTop' and 'nameBot' are defined but not correctly ordered. This
        is the reason why this method cannot be 'const'  

        """
        return _gstlearn.DbGrid_setSelectionFromVariableExtend(self, nameTop, nameBot)

    def clean3DFromSurfaces(self, *args, **kwargs):
        r"""

        DbGrid::clean3DFromSurfaces
        Clean the contents of a 3D file by using surfaces extracted from the 2D file  

        Parameters
        ----------
        * `names` :  
            Vector of variable of the current grid which must be processed  
        * `surf2D` :  
            Name of the 2-D grid file containing the surfaces  
        * `nameTop` :  
            Name of the Top surface (optional)  
        * `nameBot` :  
            Name of the Bottom surface (optional)  
        * `verbose` :  
            Verbose flag  

        remark: The input file 'surf2D' and the current grid should match (in 2-D)  

        """
        return _gstlearn.DbGrid_clean3DFromSurfaces(self, *args, **kwargs)

    def morpho(self, *args, **kwargs):
        r"""

        DbGrid::morpho
        """
        return _gstlearn.DbGrid_morpho(self, *args, **kwargs)

    def smooth(self, *args, **kwargs):
        r"""

        DbGrid::smooth
        """
        return _gstlearn.DbGrid_smooth(self, *args, **kwargs)

    def addSelectionFromDbByMorpho(self, *args, **kwargs):
        r"""

        DbGrid::addSelectionFromDbByMorpho
        Create a selection based on the count of active samples of 'db'  

        Parameters
        ----------
        * `db` :  
            Db used for statistics  
        * `nmin` :  
            Minimum number of samples  
        * `radius` :  
            Radius of the cell neighborhood used when counting the samples  
        * `option` :  
            Type of structuring element: 0 for Cross and 1 for Block  
        * `dilation` :  
            Vector giving the radius extension for Dilation operation  
        * `verbose` :  
            Verbose flag  
        * `namconv` :  
            Naming convention  

        Returns
        -------  

        """
        return _gstlearn.DbGrid_addSelectionFromDbByMorpho(self, *args, **kwargs)

    def getSampleAsSTInPlace(self, iech, P):
        r"""

        DbGrid::getSampleAsSTInPlace
        Load a Space Target with all possible contents gathered from Db  

        Parameters
        ----------
        * `iech` :  
            Rank of the target sample  
        * `P` :  
            Space Target (used to store information)  

        """
        return _gstlearn.DbGrid_getSampleAsSTInPlace(self, iech, P)

    def getDiscretizedBlock(self, ndiscs, iech=0, flagPerCell=False, flagRandom=False, seed=132433):
        r"""

        DbGrid::getDiscretizedBlock
        Generate a set of discretization locations, relative to the block center
        Dimension: number of discretization locations, space dimension  

        Parameters
        ----------
        * `ndiscs` :  
            Number of discretization (per space dimension)  
        * `iech` :  
            Rank of the target sample (used if flagPerCell = true)  
        * `flagPerCell` :  
            TRUE when the cell dimension are read from the Db (BLEX)  
        * `flagRandom` :  
            TRUE if the discretization location must be randomized  
        * `seed` :  
            Seed for random number generator  

        Returns
        -------  

        remark: : Although randomization can be performed, this process does not consume
            random numbers.  

        """
        return _gstlearn.DbGrid_getDiscretizedBlock(self, ndiscs, iech, flagPerCell, flagRandom, seed)

    def getGridPileInPlace(self, iuid, indg, idim0, vec):
        r"""

        DbGrid::getGridPileInPlace
        """
        return _gstlearn.DbGrid_getGridPileInPlace(self, iuid, indg, idim0, vec)

    def setGridPileInPlace(self, iuid, indg, idim0, vec):
        r"""

        DbGrid::setGridPileInPlace
        """
        return _gstlearn.DbGrid_setGridPileInPlace(self, iuid, indg, idim0, vec)

    def getDistanceToOrigin(self, *args, **kwargs):
        r"""

        DbGrid::getDistanceToOrigin
        """
        return _gstlearn.DbGrid_getDistanceToOrigin(self, *args, **kwargs)

    def initThread(self):
        r"""

        DbGrid::initThread
        """
        return _gstlearn.DbGrid_initThread(self)

    def __repr__(self):
        return _gstlearn.DbGrid___repr__(self)

# Register DbGrid in _gstlearn:
_gstlearn.DbGrid_swigregister(DbGrid)
class DbLine(Db):
    r"""


    Class containing the Data Information organized as a set of Lines.  

    This class is derived from the Db class, with a specific decoration: samples
    within the Db are organized sequenially along lines.  

    Note that this particular Db does not allow the modification of the sample
    number by addition or deletion.  

    The Line decoration provides a vector giving the number of samples per line.
    Within one line, samples are ordered sequentailly (the order must not be
    modified).  

    C++ includes: DbLine.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DbLine::DbLine
        """
        _gstlearn.DbLine_swiginit(self, _gstlearn.new_DbLine(*args))
    __swig_destroy__ = _gstlearn.delete_DbLine

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DbLine_clone(self)

    def toString(self, strfmt=None):
        r"""

        DbLine::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.DbLine_toString(self, strfmt)

    def isLine(self):
        r"""

        DbLine::isLine
        Db Interface.  

        """
        return _gstlearn.DbLine_isLine(self)

    def mayChangeSampleNumber(self):
        r"""

        DbLine::mayChangeSampleNumber
        """
        return _gstlearn.DbLine_mayChangeSampleNumber(self)

    def isConsistent(self):
        r"""

        DbLine::isConsistent
        Check if the contents of private member of this class is compatible with the
        number of samples stored in the Db.  

        Returns
        -------
        true if everything is OK; false if a problem occurs  

        """
        return _gstlearn.DbLine_isConsistent(self)

    def resetFromSamples(self, *args, **kwargs):
        r"""

        DbLine::resetFromSamples
        Reset the contents of a DbLine from arguments (previous contents is cleared
        beforehand). The line contents is provided in 'lineCounts'.  

        Parameters
        ----------
        * `nech` :  
            Number of samples to be loaded  
        * `order` :  
            Ordering mode used for storing in 'tab' (by column or by sample)  
        * `tab` :  
            Vector containing the values to be imported  
        * `lineCounts` :  
            Vector giving the number of samples per Line (see details)  
        * `names` :  
            Names given to the output variables  
        * `locatorNames` :  
            Name of the locators given to the output variables  
        * `flagAddSampleRank` :  
            When TRUE, the 'rank' variable is added  

        Returns
        -------
        int Error returned code  

        : Argument 'lineCounts' give the number of samples per Line.  

        : This assumes that samples of per line are ordered sequentially  

        and that samples of Line 'j' are followed by those of Line 'j+1'.  

        """
        return _gstlearn.DbLine_resetFromSamples(self, *args, **kwargs)

    def resetFromSamplesById(self, *args, **kwargs):
        r"""

        DbLine::resetFromSamplesById
        Reset the contents of a DbLine from arguments (previous contents is cleared
        beforehand). The line contents is provided in 'lineIds' and 'ranksPerId'.  

        Parameters
        ----------
        * `nech` :  
            Number of samples to be loaded  
        * `order` :  
            Ordering mode used for storing in 'tab' (by column or by sample)  
        * `tab` :  
            Vector containing the values to be imported  
        * `lineIds` :  
            Vector giving the LineId to which each sample belongs (see details)  
        * `ranksPerId` :  
            Vector giving the ordering of samples within Line (see details)  
        * `names` :  
            Names given to the output variables  
        * `locatorNames` :  
            Name of the locators given to the output variables  
        * `flagAddSampleRank` :  
            When TRUE, the 'rank' variable is added  

        Returns
        -------
        int Error returned code  

        : Argument 'lineIds' is dimensioned to the total number of samples.  

        : For each sample, it gives Id of Line to which the sample belongs.  

        : LineId must be numeric: equzl for samples of the same line and  

        : different for samples of different lines  

        : Argument 'ranksPerId' is dimensionned to total number of samples.  

        : Along the samples belonging to one line (sharing the same LineId)  

        : it should provide the ordering of the samples.  

        : For one line, the values of 'ranksPerId' must be numeric:  

        : they do not need to be consecutive ... simply ordered.  

        """
        return _gstlearn.DbLine_resetFromSamplesById(self, *args, **kwargs)

    @staticmethod
    def createFromSamples(*args, **kwargs):
        r"""

        DbLine::createFromSamples
        """
        return _gstlearn.DbLine_createFromSamples(*args, **kwargs)

    @staticmethod
    def createFromSamplesById(*args, **kwargs):
        r"""

        DbLine::createFromSamplesById
        """
        return _gstlearn.DbLine_createFromSamplesById(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        DbLine::createFromNF
        Create a Db by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (Db format)  
        * `verbose` :  
            Verbose  

        remark: The name does not need to be completed in particular when defined by
            absolute path  

        remark: or read from the Data Directory (in the gstlearn distribution)  

        """
        return _gstlearn.DbLine_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFillRandom(*args, **kwargs):
        r"""

        DbLine::createFillRandom
        Create a DbLine from the following information provided as input arguments.  

        Parameters
        ----------
        * `ndim` :  
            Space dimension  
        * `nbline` :  
            Number of Lines  
        * `nperline` :  
            Average number of samples per line  
        * `deltaX` :  
            Average distance between Lines along first space dimension  
        * `delta` :  
            Average distances between samples along each line (in all directions)  
        * `unifDelta` :  
            5half-) width of uniform distribution  
        * `seed` :  
            Seed used for the random number generator  

        Returns
        -------
        DbLine* Pointer to the newly created DbLine structure  

        """
        return _gstlearn.DbLine_createFillRandom(*args, **kwargs)

    @staticmethod
    def createVerticalFromGrid(grid, names, xranks, yranks, byZ=1):
        r"""

        DbLine::createVerticalFromGrid
        """
        return _gstlearn.DbLine_createVerticalFromGrid(grid, names, xranks, yranks, byZ)

    @staticmethod
    def createMarkersFromGrid(grid, name, xranks, yranks, cuts):
        r"""

        DbLine::createMarkersFromGrid
        """
        return _gstlearn.DbLine_createMarkersFromGrid(grid, name, xranks, yranks, cuts)

    def createStatToHeader(self):
        r"""

        DbLine::createStatToHeader
        This is an example for a future more sophisticated method which will collect
        statistics calculated per line, and store them into a newly created Db. In the
        current version, the statistics only concerns the number of samples per Line.  

        Returns
        -------
        Db* Resulting Db  

        """
        return _gstlearn.DbLine_createStatToHeader(self)

    def getNLine(self):
        r"""

        DbLine::getNLine
        """
        return _gstlearn.DbLine_getNLine(self)

    def getNSamplePerLine(self, iline):
        r"""

        DbLine::getNSamplePerLine
        """
        return _gstlearn.DbLine_getNSamplePerLine(self, iline)

    def getLineLength(self, iline):
        r"""

        DbLine::getLineLength
        """
        return _gstlearn.DbLine_getLineLength(self, iline)

    def getNTotal(self):
        r"""

        DbLine::getNTotal
        """
        return _gstlearn.DbLine_getNTotal(self)

    def getLineBySample(self, iech):
        r"""

        DbLine::getLineBySample
        Returns the rank of the line containing the target address.  

        Parameters
        ----------
        * `iech` :  
            Target address  

        Returns
        -------
        int Returne line number  

        """
        return _gstlearn.DbLine_getLineBySample(self, iech)

    def _getHeaderCoordinate(self, idim):
        r"""

        DbLine::_getHeaderCoordinate
        """
        return _gstlearn.DbLine__getHeaderCoordinate(self, idim)

    def getCoordinatesPerLine(self, iline, idim):
        r"""

        DbLine::getCoordinatesPerLine
        """
        return _gstlearn.DbLine_getCoordinatesPerLine(self, iline, idim)

    def getLineLengths(self):
        r"""

        DbLine::getLineLengths
        """
        return _gstlearn.DbLine_getLineLengths(self)

    def getLineSampleRank(self, iline, isample):
        r"""

        DbLine::getLineSampleRank
        Returns the absolute rank of the sample 'isample' or the line 'iline' within the
        Db structure (ir -1 if an error occurs)  

        Parameters
        ----------
        * `iline` :  
            Target line number  
        * `isample` :  
            Target sample number within line  

        Returns
        -------
        Rank of the sample  

        """
        return _gstlearn.DbLine_getLineSampleRank(self, iline, isample)

    def __repr__(self):
        return _gstlearn.DbLine___repr__(self)

# Register DbLine in _gstlearn:
_gstlearn.DbLine_swigregister(DbLine)
class DbGraphO(Db):
    r"""


    Class containing the Data Information organized as a Oriented Graph.  

    This class is derived from the Db class, with a specific decoration: samples or
    'nodes' are connected via oriented 'arcs' within a Graph.  

    Note that this particular Db does not allow the modification of the sample
    number by addition or deletion.  

    The graph is stored as a non-symmetric sparse square matrix. Its number of rows
    and columns (regardless of sparcity) must be equal to the number of samples
    contained in the Db) By convention, a dowstream arc starts from a sample (whose
    rank is given by row index) and ends to another sample (whose rank is given by
    column index).  

    C++ includes: DbGraphO.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DbGraphO::DbGraphO
        """
        _gstlearn.DbGraphO_swiginit(self, _gstlearn.new_DbGraphO(*args))
    __swig_destroy__ = _gstlearn.delete_DbGraphO

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DbGraphO_clone(self)

    def toString(self, strfmt=None):
        r"""

        DbGraphO::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.DbGraphO_toString(self, strfmt)

    def isLine(self):
        r"""

        DbGraphO::isLine
        Db Interface.  

        """
        return _gstlearn.DbGraphO_isLine(self)

    def mayChangeSampleNumber(self):
        r"""

        DbGraphO::mayChangeSampleNumber
        """
        return _gstlearn.DbGraphO_mayChangeSampleNumber(self)

    def isConsistent(self):
        r"""

        DbGraphO::isConsistent
        Check if the contents of private member of this class is compatible with the
        number of samples stored in the Db.  

        Returns
        -------
        true if everything is OK; false if a problem occurs  

        """
        return _gstlearn.DbGraphO_isConsistent(self)

    def resetFromSamples(self, *args, **kwargs):
        r"""

        DbGraphO::resetFromSamples
        Reset the contents of a DbGraphO from arguments (previous contents is cleared
        beforehand). The line contents is provided in 'lineCounts'.  

        Parameters
        ----------
        * `nech` :  
            Number of samples to be loaded  
        * `order` :  
            Ordering mode used for storing in 'tab' (by column or by sample)  
        * `tab` :  
            Vector containing the values to be imported  
        * `NF_arcs` :  
            List of connected arcs provided as a triplet structure  
        * `names` :  
            Names given to the output variables  
        * `locatorNames` :  
            Name of the locators given to the output variables  
        * `flagAddSampleRank` :  
            When TRUE, the 'rank' variable is added  

        Returns
        -------
        int Error returned code  

        """
        return _gstlearn.DbGraphO_resetFromSamples(self, *args, **kwargs)

    def resetFromMatrix(self, *args, **kwargs):
        r"""

        DbGraphO::resetFromMatrix
        Reset the contents of a DbGraphO from arguments (previous contents is cleared
        beforehand). The line contents is provided in 'lineCounts'.  

        Parameters
        ----------
        * `nech` :  
            Number of samples to be loaded  
        * `order` :  
            Ordering mode used for storing in 'tab' (by column or by sample)  
        * `tab` :  
            Vector containing the values to be imported  
        * `MatArcs` :  
            Sparse Matrix giving the arcs  
        * `names` :  
            Names given to the output variables  
        * `locatorNames` :  
            Name of the locators given to the output variables  
        * `flagAddSampleRank` :  
            When TRUE, the 'rank' variable is added  

        Returns
        -------
        int Error returned code  

        """
        return _gstlearn.DbGraphO_resetFromMatrix(self, *args, **kwargs)

    @staticmethod
    def createFromSamples(*args, **kwargs):
        r"""

        DbGraphO::createFromSamples
        """
        return _gstlearn.DbGraphO_createFromSamples(*args, **kwargs)

    @staticmethod
    def createFromMatrix(*args, **kwargs):
        r"""

        DbGraphO::createFromMatrix
        """
        return _gstlearn.DbGraphO_createFromMatrix(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        DbGraphO::createFromNF
        Create a Db by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (Db format)  
        * `verbose` :  
            Verbose  

        remark: The name does not need to be completed in particular when defined by
            absolute path  

        remark: or read from the Data Directory (in the gstlearn distribution)  

        """
        return _gstlearn.DbGraphO_createFromNF(NFFilename, verbose)

    def getNArc(self):
        r"""

        DbGraphO::getNArc
        """
        return _gstlearn.DbGraphO_getNArc(self)

    def getNNode(self):
        r"""

        DbGraphO::getNNode
        """
        return _gstlearn.DbGraphO_getNNode(self)

    def getArc(self, iarc, idim):
        r"""

        DbGraphO::getArc
        """
        return _gstlearn.DbGraphO_getArc(self, iarc, idim)

    def getArcValue(self, iarc):
        r"""

        DbGraphO::getArcValue
        """
        return _gstlearn.DbGraphO_getArcValue(self, iarc)

    def getOrderDown(self, node=0):
        r"""

        DbGraphO::getOrderDown
        """
        return _gstlearn.DbGraphO_getOrderDown(self, node)

    def getCumulDown(self, node):
        r"""

        DbGraphO::getCumulDown
        """
        return _gstlearn.DbGraphO_getCumulDown(self, node)

    def getIndicesNextDown(self, node=0):
        r"""

        DbGraphO::getIndicesNextDown
        """
        return _gstlearn.DbGraphO_getIndicesNextDown(self, node)

    def getIndicesNextUp(self, node=0):
        r"""

        DbGraphO::getIndicesNextUp
        """
        return _gstlearn.DbGraphO_getIndicesNextUp(self, node)

    def isEndDown(self, node=0):
        r"""

        DbGraphO::isEndDown
        """
        return _gstlearn.DbGraphO_isEndDown(self, node)

    def isEndUp(self, node=0):
        r"""

        DbGraphO::isEndUp
        """
        return _gstlearn.DbGraphO_isEndUp(self, node)

    def areConnected(self, node1, node2):
        r"""

        DbGraphO::areConnected
        """
        return _gstlearn.DbGraphO_areConnected(self, node1, node2)

    def getEndsDown(self):
        r"""

        DbGraphO::getEndsDown
        """
        return _gstlearn.DbGraphO_getEndsDown(self)

    def getEndsUp(self):
        r"""

        DbGraphO::getEndsUp
        """
        return _gstlearn.DbGraphO_getEndsUp(self)

    def getOrphans(self):
        r"""

        DbGraphO::getOrphans
        """
        return _gstlearn.DbGraphO_getOrphans(self)

    def getMatArcs(self):
        r"""

        DbGraphO::getMatArcs
        """
        return _gstlearn.DbGraphO_getMatArcs(self)

    def setArcLine(self, nodes, value=1.):
        r"""

        DbGraphO::setArcLine
        """
        return _gstlearn.DbGraphO_setArcLine(self, nodes, value)

    def __repr__(self):
        return _gstlearn.DbGraphO___repr__(self)

# Register DbGraphO in _gstlearn:
_gstlearn.DbGraphO_swigregister(DbGraphO)
class DbMeshTurbo(DbGrid):
    r"""


    Class containing the Data Information organized as a Turbo Meshing.  

    This class is derived from the DbGrid class, with a specific decoration: samples
    or 'nodes' are connected via oriented the 'meshing' information which is stored
    in this class.  

    Note that in this particular case of Turbo Meshing, the Db must be organized as
    a grid and the information regarding the meshing is minimum.  

    C++ includes: DbMeshTurbo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DbMeshTurbo::DbMeshTurbo
        """
        _gstlearn.DbMeshTurbo_swiginit(self, _gstlearn.new_DbMeshTurbo(*args))
    __swig_destroy__ = _gstlearn.delete_DbMeshTurbo

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DbMeshTurbo_clone(self)

    def toString(self, strfmt=None):
        r"""

        DbMeshTurbo::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.DbMeshTurbo_toString(self, strfmt)

    def isMesh(self):
        r"""

        DbMeshTurbo::isMesh
        Db Interface.  

        """
        return _gstlearn.DbMeshTurbo_isMesh(self)

    def mayChangeSampleNumber(self):
        r"""

        DbMeshTurbo::mayChangeSampleNumber
        """
        return _gstlearn.DbMeshTurbo_mayChangeSampleNumber(self)

    def isConsistent(self):
        r"""

        DbMeshTurbo::isConsistent
        Check if the contents of private member of this class is compatible with the
        number of samples stored in the DbGrid.  

        Returns
        -------
        true if everything is OK; false if a problem occurs  

        """
        return _gstlearn.DbMeshTurbo_isConsistent(self)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        DbMeshTurbo::create
        """
        return _gstlearn.DbMeshTurbo_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        DbMeshTurbo::createFromNF
        Create a DbMesh by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (DbMesh format)  
        * `verbose` :  
            Verbose  

        remark: The name does not need to be completed in particular when defined by
            absolute path  

        remark: or read from the Data Directory (in the gstlearn distribution)  

        """
        return _gstlearn.DbMeshTurbo_createFromNF(NFFilename, verbose)

    def getNApices(self):
        r"""

        DbMeshTurbo::getNApices
        """
        return _gstlearn.DbMeshTurbo_getNApices(self)

    def getNMeshes(self):
        r"""

        DbMeshTurbo::getNMeshes
        """
        return _gstlearn.DbMeshTurbo_getNMeshes(self)

    def getApex(self, imesh, rank):
        r"""

        DbMeshTurbo::getApex
        """
        return _gstlearn.DbMeshTurbo_getApex(self, imesh, rank)

    def getCoor(self, imesh, rank, idim):
        r"""

        DbMeshTurbo::getCoor
        """
        return _gstlearn.DbMeshTurbo_getCoor(self, imesh, rank, idim)

    def getCoordinatesPerMeshInPlace(self, imesh, rank, coords):
        r"""

        DbMeshTurbo::getCoordinatesPerMeshInPlace
        """
        return _gstlearn.DbMeshTurbo_getCoordinatesPerMeshInPlace(self, imesh, rank, coords)

    def getApexCoor(self, i, idim):
        r"""

        DbMeshTurbo::getApexCoor
        """
        return _gstlearn.DbMeshTurbo_getApexCoor(self, i, idim)

    def getApexCoordinatesInPlace(self, i, coords):
        r"""

        DbMeshTurbo::getApexCoordinatesInPlace
        """
        return _gstlearn.DbMeshTurbo_getApexCoordinatesInPlace(self, i, coords)

    def getCoordinatesPerMesh(self, imesh, idim, flagClose=False):
        r"""

        DbMeshTurbo::getCoordinatesPerMesh
        """
        return _gstlearn.DbMeshTurbo_getCoordinatesPerMesh(self, imesh, idim, flagClose)

    def __repr__(self):
        return _gstlearn.DbMeshTurbo___repr__(self)

# Register DbMeshTurbo in _gstlearn:
_gstlearn.DbMeshTurbo_swigregister(DbMeshTurbo)
class DbMeshStandard(Db):
    r"""


    Class containing the Data Information organized as a General Meshing.  

    This class is derived from the Db class, with a specific decoration: samples or
    'nodes' are connected via oriented the 'meshing' information which is stored in
    this class.  

    C++ includes: DbMeshStandard.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DbMeshStandard::DbMeshStandard
        """
        _gstlearn.DbMeshStandard_swiginit(self, _gstlearn.new_DbMeshStandard(*args))
    __swig_destroy__ = _gstlearn.delete_DbMeshStandard

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.DbMeshStandard_clone(self)

    def toString(self, strfmt=None):
        r"""

        DbMeshStandard::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.DbMeshStandard_toString(self, strfmt)

    def isMesh(self):
        r"""

        DbMeshStandard::isMesh
        Db Interface.  

        """
        return _gstlearn.DbMeshStandard_isMesh(self)

    def mayChangeSampleNumber(self):
        r"""

        DbMeshStandard::mayChangeSampleNumber
        """
        return _gstlearn.DbMeshStandard_mayChangeSampleNumber(self)

    def isConsistent(self):
        r"""

        DbMeshStandard::isConsistent
        Check if the contents of private member of this class is compatible with the
        number of samples stored in the DbGrid.  

        Returns
        -------
        true if everything is OK; false if a problem occurs  

        """
        return _gstlearn.DbMeshStandard_isConsistent(self)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        DbMeshStandard::create
        """
        return _gstlearn.DbMeshStandard_create(*args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        DbMeshStandard::createFromNF
        Create a DbMesh by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File (DbMesh format)  
        * `verbose` :  
            Verbose  

        remark: The name does not need to be completed in particular when defined by
            absolute path  

        remark: or read from the Data Directory (in the gstlearn distribution)  

        """
        return _gstlearn.DbMeshStandard_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromExternal(*args, **kwargs):
        r"""

        DbMeshStandard::createFromExternal
        """
        return _gstlearn.DbMeshStandard_createFromExternal(*args, **kwargs)

    def getNApices(self):
        r"""

        DbMeshStandard::getNApices
        """
        return _gstlearn.DbMeshStandard_getNApices(self)

    def getNMeshes(self):
        r"""

        DbMeshStandard::getNMeshes
        """
        return _gstlearn.DbMeshStandard_getNMeshes(self)

    def getApex(self, imesh, rank):
        r"""

        DbMeshStandard::getApex
        """
        return _gstlearn.DbMeshStandard_getApex(self, imesh, rank)

    def getCoor(self, imesh, rank, idim):
        r"""

        DbMeshStandard::getCoor
        """
        return _gstlearn.DbMeshStandard_getCoor(self, imesh, rank, idim)

    def getCoordinatesPerMeshInPlace(self, imesh, rank, coords):
        r"""

        DbMeshStandard::getCoordinatesPerMeshInPlace
        """
        return _gstlearn.DbMeshStandard_getCoordinatesPerMeshInPlace(self, imesh, rank, coords)

    def getApexCoor(self, i, idim):
        r"""

        DbMeshStandard::getApexCoor
        """
        return _gstlearn.DbMeshStandard_getApexCoor(self, i, idim)

    def getApexCoordinatesInPlace(self, i, coords):
        r"""

        DbMeshStandard::getApexCoordinatesInPlace
        """
        return _gstlearn.DbMeshStandard_getApexCoordinatesInPlace(self, i, coords)

    def getCoordinatesPerMesh(self, imesh, idim, flagClose=False):
        r"""

        DbMeshStandard::getCoordinatesPerMesh
        """
        return _gstlearn.DbMeshStandard_getCoordinatesPerMesh(self, imesh, idim, flagClose)

    def __repr__(self):
        return _gstlearn.DbMeshStandard___repr__(self)

# Register DbMeshStandard in _gstlearn:
_gstlearn.DbMeshStandard_swigregister(DbMeshStandard)
class DbStringFormat(AStringable, AStringFormat):
    r"""


    C++ includes: DbStringFormat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        DbStringFormat::DbStringFormat
        """
        _gstlearn.DbStringFormat_swiginit(self, _gstlearn.new_DbStringFormat(*args))
    __swig_destroy__ = _gstlearn.delete_DbStringFormat

    def toString(self, strfmt=None):
        r"""

        DbStringFormat::toString
        Interface to AStringable.  

        """
        return _gstlearn.DbStringFormat_toString(self, strfmt)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        DbStringFormat::create
        """
        return _gstlearn.DbStringFormat_create(*args, **kwargs)

    @staticmethod
    def createFromKeys(params, names, cols, useSel):
        r"""

        DbStringFormat::createFromKeys
        """
        return _gstlearn.DbStringFormat_createFromKeys(params, names, cols, useSel)

    @staticmethod
    def createFromFlags(*args, **kwargs):
        r"""

        DbStringFormat::createFromFlags
        """
        return _gstlearn.DbStringFormat_createFromFlags(*args, **kwargs)

    def getCols(self):
        r"""

        DbStringFormat::getCols
        """
        return _gstlearn.DbStringFormat_getCols(self)

    def getUseSel(self):
        r"""

        DbStringFormat::getUseSel
        """
        return _gstlearn.DbStringFormat_getUseSel(self)

    def getMode(self):
        r"""

        DbStringFormat::getMode
        """
        return _gstlearn.DbStringFormat_getMode(self)

    def getParams(self):
        r"""

        DbStringFormat::getParams
        """
        return _gstlearn.DbStringFormat_getParams(self)

    def getNames(self):
        r"""

        DbStringFormat::getNames
        """
        return _gstlearn.DbStringFormat_getNames(self)

    def setCols(self, cols):
        r"""

        DbStringFormat::setCols
        Reduce the set of variables for which the print is provided  

        Parameters
        ----------
        * `cols` :  
            Vector of Column indices on which Stats or Array is applied (optional)  

        remark: This selection is performed by Column Rank. It invalidates any possible
            selection already performed.  

        """
        return _gstlearn.DbStringFormat_setCols(self, cols)

    def setUseSel(self, useSel):
        r"""

        DbStringFormat::setUseSel
        Using the current Selection or Not  

        Parameters
        ----------
        * `useSel` :  
            Take the selection into account when true  

        """
        return _gstlearn.DbStringFormat_setUseSel(self, useSel)

    def setMode(self, mode):
        r"""

        DbStringFormat::setMode
        Parameters
        ----------
        * `mode` :  
            Way to consider the variable for Stats (1: Real; 2: Categorical)  

        """
        return _gstlearn.DbStringFormat_setMode(self, mode)

    def setNames(self, names):
        r"""

        DbStringFormat::setNames
        Reduce the set of variables for which the print is provided  

        Parameters
        ----------
        * `names` :  
            Vector of Column names  

        remark: This selection is performed by Variable Name. It invalidates any
            possible selection already performed.  

        """
        return _gstlearn.DbStringFormat_setNames(self, names)

    def setParams(self, params):
        r"""

        DbStringFormat::setParams
        Set the String Format parameters  

        Parameters
        ----------
        * `params` :  
            Mask defining the printout  

        remark: The Mask is a combination of DISPLAY_PARAMS, i.e.:  

        remark: - FLAG_RESUME: for a Summary of the contents  

        remark: - FLAG_VARS: for the Field Names and Locators  

        remark: - FLAG_EXTEND: for the area covered by the Db  

        remark: - FLAG_STATS: for Basic Statistics on the variables  

        remark: - FLAG_ARRAY: for the extensive printout of the variables  

        """
        return _gstlearn.DbStringFormat_setParams(self, params)

    def setFlags(self, *args, **kwargs):
        r"""

        DbStringFormat::setFlags
        """
        return _gstlearn.DbStringFormat_setFlags(self, *args, **kwargs)

    def setResume(self):
        r"""

        DbStringFormat::setResume
        """
        return _gstlearn.DbStringFormat_setResume(self)

    def setVars(self):
        r"""

        DbStringFormat::setVars
        """
        return _gstlearn.DbStringFormat_setVars(self)

    def setExtend(self):
        r"""

        DbStringFormat::setExtend
        """
        return _gstlearn.DbStringFormat_setExtend(self)

    def setStats(self):
        r"""

        DbStringFormat::setStats
        """
        return _gstlearn.DbStringFormat_setStats(self)

    def setArray(self):
        r"""

        DbStringFormat::setArray
        """
        return _gstlearn.DbStringFormat_setArray(self)

    def setLocator(self):
        r"""

        DbStringFormat::setLocator
        """
        return _gstlearn.DbStringFormat_setLocator(self)

    def matchResume(self):
        r"""

        DbStringFormat::matchResume
        """
        return _gstlearn.DbStringFormat_matchResume(self)

    def matchVars(self):
        r"""

        DbStringFormat::matchVars
        """
        return _gstlearn.DbStringFormat_matchVars(self)

    def matchExtend(self):
        r"""

        DbStringFormat::matchExtend
        """
        return _gstlearn.DbStringFormat_matchExtend(self)

    def matchStats(self):
        r"""

        DbStringFormat::matchStats
        """
        return _gstlearn.DbStringFormat_matchStats(self)

    def matchArray(self):
        r"""

        DbStringFormat::matchArray
        """
        return _gstlearn.DbStringFormat_matchArray(self)

    def matchLocator(self):
        r"""

        DbStringFormat::matchLocator
        """
        return _gstlearn.DbStringFormat_matchLocator(self)

    def __repr__(self):
        return _gstlearn.DbStringFormat___repr__(self)

# Register DbStringFormat in _gstlearn:
_gstlearn.DbStringFormat_swigregister(DbStringFormat)
class DbHelper(object):
    r"""


    C++ includes: DbHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def findDuplicates(db1, db2, flag_same, verbose, opt_code, tolcode, dist, sel):
        r"""

        DbHelper::findDuplicates
        Look for duplicates  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db1` :  
            First Db  
        * `db2` :  
            Second Db  
        * `flag_same` :  
            True if the two Db files are the same  
        * `verbose` :  
            True for verbose output  
        * `opt_code` :  
            code selection option (if code is defined)  

            *   0 : no use of the code selection  
            *   1 : codes must be close enough  
            *   2 : codes must be different  
        * `tolcode` :  
            Code tolerance  
        * `dist` :  
            Array of the minimum distance whose length is the space dimension (or NULL
            for a null distance)  
        * `sel` :  
            Array containing the selection  

        """
        return _gstlearn.DbHelper_findDuplicates(db1, db2, flag_same, verbose, opt_code, tolcode, dist, sel)

    @staticmethod
    def centerPointToGrid(db_point, db_grid, eps_random=1.e-6):
        r"""

        DbHelper::centerPointToGrid
        Centers the samples of a Db to the center of blocks of a grid Db  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db_point` :  
            descriptor of the point parameters  
        * `db_grid` :  
            descriptor of the grid parameters  
        * `eps_random` :  
            Randomisation Epsilon  

        remark: The argument 'eps_random' allows perturbating the centered  

        remark: coordinate so that it does not lie exactly on the node.  

        remark: This possibility makes sense in order to identify centered data  

        remark: from data actually located on the grid center (before migration)  

        remark: The perturbation is calculated as DX(i) * eps  

        """
        return _gstlearn.DbHelper_centerPointToGrid(db_point, db_grid, eps_random)

    @staticmethod
    def normalizeVariables(db, oper, cols, center, stdv):
        r"""

        DbHelper::normalizeVariables
        Normalize a set of variables  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `oper` :  
            Name of the operator  

            *   "mean" : Normalize the mean to the input value  
            *   "stdv" : Normalize the st. dev. to the input value  
            *   "scal" : Normalize the mean and st. dev.  
            *   "prop" : Normalize the variables to proportions  
        * `cols` :  
            Ranks of the variables  
        * `center` :  
            Theoretical Mean value  
        * `stdv` :  
            Theoretical Standard Deviation value  

        """
        return _gstlearn.DbHelper_normalizeVariables(db, oper, cols, center, stdv)

    @staticmethod
    def dbgrid_filling(*args, **kwargs):
        r"""

        DbHelper::dbgrid_filling
        Fill an incomplete grid  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `dbgrid` :  
            Db grid structure  
        * `mode` :  
            Type of interpolation  

            *   0 : Moving average  
            *   1 : Inverse squared distance  
            *   2 : Interpolation by a linear plane  
            *   3 : Distance to the initial grains  
        * `seed` :  
            Seed used for the random number generation  
        * `radius` :  
            Radius of the neighborhood  
        * `verbose` :  
            Verbose flag  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.DbHelper_dbgrid_filling(*args, **kwargs)

    @staticmethod
    def db_duplicate(*args, **kwargs):
        r"""

        DbHelper::db_duplicate
        Look for duplicates within a Db  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db Structure  
        * `verbose` :  
            True for verbose output  
        * `dist` :  
            Array of the minimum distance  
        * `opt_code` :  
            code selection option (if code is defined)  

            *   0 : no use of the code selection  
            *   1 : codes must be close enough  
            *   2 : codes must be different  
        * `tolcode` :  
            Code tolerance  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.DbHelper_db_duplicate(*args, **kwargs)

    @staticmethod
    def db_compositional_transform(db, verbose, mode, type, number, iatt_in, iatt_out, numout):
        r"""

        DbHelper::db_compositional_transform
        Translate a set of compositional variables into auxiliary variables  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db characteristics  
        * `verbose` :  
            1 for a Verbose option  
        * `mode` :  
            1 for Forward and -1 for Backward transformation  
        * `type` :  
            Type of conversion  

            *   0 : Simple transformation in proportion  
            *   1 : Additive logratio  
            *   2 : Centered logratio  
            *   3 : Isometric logratio  
        * `number` :  
            Number of input attributes  
        * `iatt_in` :  
            Array of the input attribute  
        * `iatt_out` :  
            Array of the output attribute  
        * `numout` :  
            Number of variables in output  

        remark: The additive and the isometric logratio transformations  

        remark: transform N+1 compositional variables into N elements (Forward)  

        remark: and from N transformed elements into N+1 compositional variables  

        remark: (Backwards).  

        remark: The zero-values are replaced by a conventional small value  

        remark: This is defined by a variable that can be corrected using  

        remark: the keypair facility with the keyword 'CompositionalEps'  

        remark: The arguments 'iatt_in' and 'iatt_out' can coincide.  

        remark: Outlier Detection for Compositional Data Using Robust Methods  

        remark: Math Geosciences (2008) 40: 233-248  

        """
        return _gstlearn.DbHelper_db_compositional_transform(db, verbose, mode, type, number, iatt_in, iatt_out, numout)

    @staticmethod
    def dbgrid_sampling(dbin, nmult):
        r"""

        DbHelper::dbgrid_sampling
        Sample a grid into a finer subgrid (all variables)  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `dbin` :  
            Descriptor of the grid parameters  
        * `nmult` :  
            Array of multiplicity coefficients  

        """
        return _gstlearn.DbHelper_dbgrid_sampling(dbin, nmult)

    @staticmethod
    def db_grid1D_fill(*args, **kwargs):
        r"""

        DbHelper::db_grid1D_fill
        Fill an incomplete 1-D grid  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `dbgrid` :  
            Db grid structure  
        * `mode` :  
            Type of interpolation  

            *   0 : Linear interpolation  
            *   1 : Cubic Spline  
        * `seed` :  
            Seed used for the random number generation  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.DbHelper_db_grid1D_fill(*args, **kwargs)

    def __init__(self):
        r"""


        C++ includes: DbHelper.hpp

        """
        _gstlearn.DbHelper_swiginit(self, _gstlearn.new_DbHelper())
    __swig_destroy__ = _gstlearn.delete_DbHelper

# Register DbHelper in _gstlearn:
_gstlearn.DbHelper_swigregister(DbHelper)
class DbH(DbHelper):
    r"""


    C++ includes: DbHelper.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        C++ includes: DbHelper.hpp

        """
        _gstlearn.DbH_swiginit(self, _gstlearn.new_DbH())
    __swig_destroy__ = _gstlearn.delete_DbH

# Register DbH in _gstlearn:
_gstlearn.DbH_swigregister(DbH)
class RankHandler(object):
    r"""


    Class returning the list of sample IDs for a quick search within a Db.  

    The main functionality of this class is to return the list of samples per
    variable, within a given list of elligible sample ranks (neighborhood)  

    C++ includes: RankHandler.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        RankHandler::RankHandler
        """
        _gstlearn.RankHandler_swiginit(self, _gstlearn.new_RankHandler(*args))
    __swig_destroy__ = _gstlearn.delete_RankHandler

    def defineSampleRanks(self, *args, **kwargs):
        r"""

        RankHandler::defineSampleRanks
        Defines the list of indices 'index' for valid samples for the set of variables
        (Z locator)  

        Parameters
        ----------
        * `nbgh` :  
            Vector giving the ranks of the elligible samples (optional)  

        """
        return _gstlearn.RankHandler_defineSampleRanks(self, *args, **kwargs)

    def getSampleRanks(self, *args):
        r"""

        RankHandler::getSampleRanks
        """
        return _gstlearn.RankHandler_getSampleRanks(self, *args)

    def getSampleRanksByVariable(self, ivar):
        r"""

        RankHandler::getSampleRanksByVariable
        """
        return _gstlearn.RankHandler_getSampleRanksByVariable(self, ivar)

    def getZflatten(self):
        r"""

        RankHandler::getZflatten
        """
        return _gstlearn.RankHandler_getZflatten(self)

    def getNumber(self):
        r"""

        RankHandler::getNumber
        Return the total number of samples.  

        Returns
        -------
        int  

        """
        return _gstlearn.RankHandler_getNumber(self)

    def getCount(self, ivar):
        r"""

        RankHandler::getCount
        Get the number of active samples for a given variable.  

        Parameters
        ----------
        * `ivar` :  
            Rank of the target variable  

        Returns
        -------
        int  

        """
        return _gstlearn.RankHandler_getCount(self, ivar)

    def getTotalCount(self):
        r"""

        RankHandler::getTotalCount
        Get the total number of active samples for all variables.  

        Returns
        -------
        int  

        """
        return _gstlearn.RankHandler_getTotalCount(self)

    def identifyVariableRank(self, ipos):
        r"""

        RankHandler::identifyVariableRank
        """
        return _gstlearn.RankHandler_identifyVariableRank(self, ipos)

    def identifySampleRank(self, ipos):
        r"""

        RankHandler::identifySampleRank
        """
        return _gstlearn.RankHandler_identifySampleRank(self, ipos)

    def dump(self, flagFull=False):
        r"""

        RankHandler::dump
        """
        return _gstlearn.RankHandler_dump(self, flagFull)

# Register RankHandler in _gstlearn:
_gstlearn.RankHandler_swigregister(RankHandler)
class CalcAnamTransform(ACalcDbVarCreator):
    r"""


    C++ includes: CalcAnamTransform.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, anam):
        r"""

        CalcAnamTransform::CalcAnamTransform
        """
        _gstlearn.CalcAnamTransform_swiginit(self, _gstlearn.new_CalcAnamTransform(anam))
    __swig_destroy__ = _gstlearn.delete_CalcAnamTransform

    def setAnam(self, anam):
        r"""

        CalcAnamTransform::setAnam
        """
        return _gstlearn.CalcAnamTransform_setAnam(self, anam)

    def getAnam(self):
        r"""

        CalcAnamTransform::getAnam
        """
        return _gstlearn.CalcAnamTransform_getAnam(self)

    def setFlagVars(self, flagVars):
        r"""

        CalcAnamTransform::setFlagVars
        """
        return _gstlearn.CalcAnamTransform_setFlagVars(self, flagVars)

    def setFlagToFactors(self, flagToFactors):
        r"""

        CalcAnamTransform::setFlagToFactors
        """
        return _gstlearn.CalcAnamTransform_setFlagToFactors(self, flagToFactors)

    def setFlagZToY(self, flagZToY):
        r"""

        CalcAnamTransform::setFlagZToY
        """
        return _gstlearn.CalcAnamTransform_setFlagZToY(self, flagZToY)

    def setFlagNormalScore(self, flagNormalScore):
        r"""

        CalcAnamTransform::setFlagNormalScore
        """
        return _gstlearn.CalcAnamTransform_setFlagNormalScore(self, flagNormalScore)

    def setIfacs(self, ifacs):
        r"""

        CalcAnamTransform::setIfacs
        """
        return _gstlearn.CalcAnamTransform_setIfacs(self, ifacs)

    def setIptrEst(self, iptrEst):
        r"""

        CalcAnamTransform::setIptrEst
        """
        return _gstlearn.CalcAnamTransform_setIptrEst(self, iptrEst)

    def setIptrStd(self, iptrStd):
        r"""

        CalcAnamTransform::setIptrStd
        """
        return _gstlearn.CalcAnamTransform_setIptrStd(self, iptrStd)

    def setSelectivity(self, selectivity):
        r"""

        CalcAnamTransform::setSelectivity
        """
        return _gstlearn.CalcAnamTransform_setSelectivity(self, selectivity)

    def setFlagOk(self, flagOk):
        r"""

        CalcAnamTransform::setFlagOk
        """
        return _gstlearn.CalcAnamTransform_setFlagOk(self, flagOk)

    def setNbsimu(self, nbsimu):
        r"""

        CalcAnamTransform::setNbsimu
        """
        return _gstlearn.CalcAnamTransform_setNbsimu(self, nbsimu)

    def setProba(self, proba):
        r"""

        CalcAnamTransform::setProba
        """
        return _gstlearn.CalcAnamTransform_setProba(self, proba)

    def setFlagDisjKrig(self, flagDisjKrig):
        r"""

        CalcAnamTransform::setFlagDisjKrig
        """
        return _gstlearn.CalcAnamTransform_setFlagDisjKrig(self, flagDisjKrig)

    def setFlagCondExp(self, flagCondExp):
        r"""

        CalcAnamTransform::setFlagCondExp
        """
        return _gstlearn.CalcAnamTransform_setFlagCondExp(self, flagCondExp)

    def setFlagUniCond(self, flagUniCond):
        r"""

        CalcAnamTransform::setFlagUniCond
        """
        return _gstlearn.CalcAnamTransform_setFlagUniCond(self, flagUniCond)

# Register CalcAnamTransform in _gstlearn:
_gstlearn.CalcAnamTransform_swigregister(CalcAnamTransform)

def DisjunctiveKriging(*args, **kwargs):
    r"""


    Calculate the recoveries (z,T,Q,m,B) starting from the factors  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure containing the factors (Z-locators)  
    * `anam` :  
        Point anamorphosis  
    * `selectivity` :  
        Selectivity structure  
    * `name_est` :  
        Array of variable names for factor estimation  
    * `name_std` :  
        Array of variable names for factor St. Dev.  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.DisjunctiveKriging(*args, **kwargs)

def ConditionalExpectation(*args, **kwargs):
    r"""


    Calculate the Conditional Expectation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure containing the factors (Z-locators)  
    * `anam` :  
        Point anamorphosis  
    * `selectivity` :  
        Selectivity structure  
    * `name_est` :  
        Name of the Kriging estimate  
    * `name_std` :  
        Name of the Kriging St. deviation  
    * `flag_OK` :  
        1 if kriging has ben performed in Ordinary Kriging  
    * `proba` :  
        Probability  
    * `nbsimu` :  
        Number of Simulation outcomes  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.ConditionalExpectation(*args, **kwargs)

def UniformConditioning(*args, **kwargs):
    r"""


    Calculate the Uniform Conditioning  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure containing the factors (Z-locators)  
    * `anam` :  
        Point anamorphosis  
    * `selectivity` :  
        Selectivity structure  
    * `name_est` :  
        Name of the Kriging estimate  
    * `name_varz` :  
        Name of the Variance of Kriging estimate  
    * `namconv` :  
        Naming Convention  

    remark: We need the variance of Estimation Error... even if it will be  

    remark: temporarily stored in a member names iptrStd.  

    """
    return _gstlearn.UniformConditioning(*args, **kwargs)

def anamPointToBlock(anam, verbose, cvv, coeff, mu):
    r"""


    Transform a point anamorphosis into a block anamorphosis  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `anam` :  
        Point anamorphosis -> Block anamorphosis [out]  
    * `verbose` :  
        Verbose option  
    * `cvv` :  
        Block variance  
    * `coeff` :  
        Coefficient of change of support  
    * `mu` :  
        Additional coefficient for Discrete case  

    remark: If 'coeff' is provided, it is used directly ('cvv' is ignored)  

    remark: Otherwise, it is derived from 'cvv'  

    """
    return _gstlearn.anamPointToBlock(anam, verbose, cvv, coeff, mu)
class AAnam(AStringable, ASerializable, ICloneable):
    r"""


    C++ includes: AAnam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AAnam

    def getType(self):
        r"""

        AAnam::getType
        Interface for AAnam.  

        """
        return _gstlearn.AAnam_getType(self)

    def getVariance(self):
        r"""

        AAnam::getVariance
        """
        return _gstlearn.AAnam_getVariance(self)

    def hasFactor(self):
        r"""

        AAnam::hasFactor
        """
        return _gstlearn.AAnam_hasFactor(self)

    def getNFactor(self):
        r"""

        AAnam::getNFactor
        """
        return _gstlearn.AAnam_getNFactor(self)

    def getNClass(self):
        r"""

        AAnam::getNClass
        """
        return _gstlearn.AAnam_getNClass(self)

    def isChangeSupportDefined(self):
        r"""

        AAnam::isChangeSupportDefined
        """
        return _gstlearn.AAnam_isChangeSupportDefined(self)

    def z2factor(self, z, ifacs):
        r"""

        AAnam::z2factor
        """
        return _gstlearn.AAnam_z2factor(self, z, ifacs)

    def computeVariance(self, sval):
        r"""

        AAnam::computeVariance
        Calculates the block variance  

        Returns
        -------
        Value of the block variance (as a function of support coefficient)  

        """
        return _gstlearn.AAnam_computeVariance(self, sval)

    def updatePointToBlock(self, r_coef):
        r"""

        AAnam::updatePointToBlock
        """
        return _gstlearn.AAnam_updatePointToBlock(self, r_coef)

    def allowChangeSupport(self):
        r"""

        AAnam::allowChangeSupport
        """
        return _gstlearn.AAnam_allowChangeSupport(self)

    def hasGaussian(self):
        r"""

        AAnam::hasGaussian
        """
        return _gstlearn.AAnam_hasGaussian(self)

    def rawToTransformValue(self, z):
        r"""

        AAnam::rawToTransformValue
        """
        return _gstlearn.AAnam_rawToTransformValue(self, z)

    def transformToRawValue(self, y):
        r"""

        AAnam::transformToRawValue
        """
        return _gstlearn.AAnam_transformToRawValue(self, y)

    def fitFromArray(self, *args, **kwargs):
        r"""

        AAnam::fitFromArray
        """
        return _gstlearn.AAnam_fitFromArray(self, *args, **kwargs)

    def invertVariance(self, cvv):
        r"""

        AAnam::invertVariance
        Find the coefficient of change of support  

        Returns
        -------
        Value for the change of support coefficient  

        Parameters
        ----------
        * `cvv` :  
            Mean covariance value over a block  

        """
        return _gstlearn.AAnam_invertVariance(self, cvv)

    def rawToTransformVec(self, z):
        r"""

        AAnam::rawToTransformVec
        """
        return _gstlearn.AAnam_rawToTransformVec(self, z)

    def transformToRawVec(self, y):
        r"""

        AAnam::transformToRawVec
        """
        return _gstlearn.AAnam_transformToRawVec(self, y)

    def fitFromLocator(self, *args, **kwargs):
        r"""

        AAnam::fitFromLocator
        """
        return _gstlearn.AAnam_fitFromLocator(self, *args, **kwargs)

    def fit(self, db, name):
        r"""

        AAnam::fit
        """
        return _gstlearn.AAnam_fit(self, db, name)

    def rawToGaussianByLocator(self, *args, **kwargs):
        r"""

        AAnam::rawToGaussianByLocator
        Process the variable(s) stored with locator Z  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `namconv` :  
            Naming Convention  

        Returns
        -------  

        """
        return _gstlearn.AAnam_rawToGaussianByLocator(self, *args, **kwargs)

    def rawToGaussian(self, *args, **kwargs):
        r"""

        AAnam::rawToGaussian
        """
        return _gstlearn.AAnam_rawToGaussian(self, *args, **kwargs)

    def normalScore(self, *args, **kwargs):
        r"""

        AAnam::normalScore
        Transform the target variable inti Gaussian by Normal Score  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db Structure  
        * `name` :  
            Target variable  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.AAnam_normalScore(self, *args, **kwargs)

    def gaussianToRawByLocator(self, *args, **kwargs):
        r"""

        AAnam::gaussianToRawByLocator
        """
        return _gstlearn.AAnam_gaussianToRawByLocator(self, *args, **kwargs)

    def gaussianToRaw(self, *args, **kwargs):
        r"""

        AAnam::gaussianToRaw
        """
        return _gstlearn.AAnam_gaussianToRaw(self, *args, **kwargs)

    def rawToFactorByRanks(self, *args, **kwargs):
        r"""

        AAnam::rawToFactorByRanks
        Calculate the factors corresponding to an input data vector  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `ifacs` :  
            Array of factor ranks  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.AAnam_rawToFactorByRanks(self, *args, **kwargs)

    def rawToFactor(self, *args, **kwargs):
        r"""

        AAnam::rawToFactor
        Calculate the factors corresponding to an input data vector  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `nfactor` :  
            Number of first factors  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.AAnam_rawToFactor(self, *args, **kwargs)

    def __repr__(self):
        return _gstlearn.AAnam___repr__(self)

# Register AAnam in _gstlearn:
_gstlearn.AAnam_swigregister(AAnam)
class AnamContinuousFit(object):
    r"""


    Output structure  

    C++ includes: AnamContinuous.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getAylim(self):
        r"""

        AnamContinuousFit::getAylim
        """
        return _gstlearn.AnamContinuousFit_getAylim(self)

    def setAylim(self, aylim):
        r"""

        AnamContinuousFit::setAylim
        """
        return _gstlearn.AnamContinuousFit_setAylim(self, aylim)

    def getAzlim(self):
        r"""

        AnamContinuousFit::getAzlim
        """
        return _gstlearn.AnamContinuousFit_getAzlim(self)

    def setAzlim(self, azlim):
        r"""

        AnamContinuousFit::setAzlim
        """
        return _gstlearn.AnamContinuousFit_setAzlim(self, azlim)

    def getPylim(self):
        r"""

        AnamContinuousFit::getPylim
        """
        return _gstlearn.AnamContinuousFit_getPylim(self)

    def setPylim(self, pylim):
        r"""

        AnamContinuousFit::setPylim
        """
        return _gstlearn.AnamContinuousFit_setPylim(self, pylim)

    def getPzlim(self):
        r"""

        AnamContinuousFit::getPzlim
        """
        return _gstlearn.AnamContinuousFit_getPzlim(self)

    def setPzlim(self, pzlim):
        r"""

        AnamContinuousFit::setPzlim
        """
        return _gstlearn.AnamContinuousFit_setPzlim(self, pzlim)

    def getY(self):
        r"""

        AnamContinuousFit::getY
        """
        return _gstlearn.AnamContinuousFit_getY(self)

    def setY(self, y):
        r"""

        AnamContinuousFit::setY
        """
        return _gstlearn.AnamContinuousFit_setY(self, y)

    def getZ(self):
        r"""

        AnamContinuousFit::getZ
        """
        return _gstlearn.AnamContinuousFit_getZ(self)

    def setZ(self, z):
        r"""

        AnamContinuousFit::setZ
        """
        return _gstlearn.AnamContinuousFit_setZ(self, z)

    def __init__(self):
        r"""


        Output structure  

        C++ includes: AnamContinuous.hpp

        """
        _gstlearn.AnamContinuousFit_swiginit(self, _gstlearn.new_AnamContinuousFit())
    __swig_destroy__ = _gstlearn.delete_AnamContinuousFit

# Register AnamContinuousFit in _gstlearn:
_gstlearn.AnamContinuousFit_swigregister(AnamContinuousFit)
class AnamContinuous(AAnam):
    r"""


    C++ includes: AnamContinuous.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AnamContinuous

    def toString(self, strfmt=None):
        r"""

        AnamContinuous::toString
        AStringable Interface.  

        """
        return _gstlearn.AnamContinuous_toString(self, strfmt)

    def hasGaussian(self):
        r"""

        AnamContinuous::hasGaussian
        AAnam interface.  

        """
        return _gstlearn.AnamContinuous_hasGaussian(self)

    def calculateMeanAndVariance(self):
        r"""

        AnamContinuous::calculateMeanAndVariance
        Interface for AnamContinuous.  

        """
        return _gstlearn.AnamContinuous_calculateMeanAndVariance(self)

    def getVariance(self):
        r"""

        AnamContinuous::getVariance
        """
        return _gstlearn.AnamContinuous_getVariance(self)

    def setABounds(self, azmin=1.234e30, azmax=1.234e30, aymin=1.234e30, aymax=1.234e30):
        r"""

        AnamContinuous::setABounds
        """
        return _gstlearn.AnamContinuous_setABounds(self, azmin, azmax, aymin, aymax)

    def setPBounds(self, pzmin=1.234e30, pzmax=1.234e30, pymin=1.234e30, pymax=1.234e30):
        r"""

        AnamContinuous::setPBounds
        """
        return _gstlearn.AnamContinuous_setPBounds(self, pzmin, pzmax, pymin, pymax)

    def rawToGaussianVector(self, z):
        r"""

        AnamContinuous::rawToGaussianVector
        """
        return _gstlearn.AnamContinuous_rawToGaussianVector(self, z)

    def gaussianToRawVector(self, y):
        r"""

        AnamContinuous::gaussianToRawVector
        """
        return _gstlearn.AnamContinuous_gaussianToRawVector(self, y)

    def sample(self, ndisc=100, aymin=-10, aymax=10):
        r"""

        AnamContinuous::sample
        Calculate Anamorphosis function for a set of Y-values  

        Parameters
        ----------
        * `ndisc` :  
            Number of discretization steps  
        * `aymin` :  
            Minimum Y value  
        * `aymax` :  
            Maximum Y value  

        Returns
        -------
        AnamContinuousFit structure  

        """
        return _gstlearn.AnamContinuous_sample(self, ndisc, aymin, aymax)

    def getMean(self):
        r"""

        AnamContinuous::getMean
        """
        return _gstlearn.AnamContinuous_getMean(self)

    def getAymax(self):
        r"""

        AnamContinuous::getAymax
        """
        return _gstlearn.AnamContinuous_getAymax(self)

    def getAymin(self):
        r"""

        AnamContinuous::getAymin
        """
        return _gstlearn.AnamContinuous_getAymin(self)

    def getAzmax(self):
        r"""

        AnamContinuous::getAzmax
        """
        return _gstlearn.AnamContinuous_getAzmax(self)

    def getAzmin(self):
        r"""

        AnamContinuous::getAzmin
        """
        return _gstlearn.AnamContinuous_getAzmin(self)

    def getPymax(self):
        r"""

        AnamContinuous::getPymax
        """
        return _gstlearn.AnamContinuous_getPymax(self)

    def getPymin(self):
        r"""

        AnamContinuous::getPymin
        """
        return _gstlearn.AnamContinuous_getPymin(self)

    def getPzmax(self):
        r"""

        AnamContinuous::getPzmax
        """
        return _gstlearn.AnamContinuous_getPzmax(self)

    def getPzmin(self):
        r"""

        AnamContinuous::getPzmin
        """
        return _gstlearn.AnamContinuous_getPzmin(self)

    def setAzmin(self, azmin):
        r"""

        AnamContinuous::setAzmin
        """
        return _gstlearn.AnamContinuous_setAzmin(self, azmin)

    def setAzmax(self, azmax):
        r"""

        AnamContinuous::setAzmax
        """
        return _gstlearn.AnamContinuous_setAzmax(self, azmax)

    def setAymin(self, aymin):
        r"""

        AnamContinuous::setAymin
        """
        return _gstlearn.AnamContinuous_setAymin(self, aymin)

    def setAymax(self, aymax):
        r"""

        AnamContinuous::setAymax
        """
        return _gstlearn.AnamContinuous_setAymax(self, aymax)

    def setPzmin(self, pzmin):
        r"""

        AnamContinuous::setPzmin
        """
        return _gstlearn.AnamContinuous_setPzmin(self, pzmin)

    def setPzmax(self, pzmax):
        r"""

        AnamContinuous::setPzmax
        """
        return _gstlearn.AnamContinuous_setPzmax(self, pzmax)

    def setPymin(self, pymin):
        r"""

        AnamContinuous::setPymin
        """
        return _gstlearn.AnamContinuous_setPymin(self, pymin)

    def setPymax(self, pymax):
        r"""

        AnamContinuous::setPymax
        """
        return _gstlearn.AnamContinuous_setPymax(self, pymax)

    def setMean(self, mean):
        r"""

        AnamContinuous::setMean
        """
        return _gstlearn.AnamContinuous_setMean(self, mean)

    def setVariance(self, variance):
        r"""

        AnamContinuous::setVariance
        """
        return _gstlearn.AnamContinuous_setVariance(self, variance)

    def __repr__(self):
        return _gstlearn.AnamContinuous___repr__(self)

# Register AnamContinuous in _gstlearn:
_gstlearn.AnamContinuous_swigregister(AnamContinuous)
class AnamDiscrete(AAnam):
    r"""


    C++ includes: AnamDiscrete.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AnamDiscrete

    def toString(self, strfmt=None):
        r"""

        AnamDiscrete::toString
        AStringable Interface.  

        """
        return _gstlearn.AnamDiscrete_toString(self, strfmt)

    def hasGaussian(self):
        r"""

        AnamDiscrete::hasGaussian
        AAnam interface.  

        """
        return _gstlearn.AnamDiscrete_hasGaussian(self)

    def getNClass(self):
        r"""

        AnamDiscrete::getNClass
        """
        return _gstlearn.AnamDiscrete_getNClass(self)

    def calculateMeanAndVariance(self):
        r"""

        AnamDiscrete::calculateMeanAndVariance
        Interface for AnamDiscrete.  

        """
        return _gstlearn.AnamDiscrete_calculateMeanAndVariance(self)

    def getVariance(self):
        r"""

        AnamDiscrete::getVariance
        """
        return _gstlearn.AnamDiscrete_getVariance(self)

    def getNCut(self):
        r"""

        AnamDiscrete::getNCut
        """
        return _gstlearn.AnamDiscrete_getNCut(self)

    def getNElem(self):
        r"""

        AnamDiscrete::getNElem
        """
        return _gstlearn.AnamDiscrete_getNElem(self)

    def getZCut(self, *args):
        r"""

        AnamDiscrete::getZCut
        """
        return _gstlearn.AnamDiscrete_getZCut(self, *args)

    def getMean(self):
        r"""

        AnamDiscrete::getMean
        """
        return _gstlearn.AnamDiscrete_getMean(self)

    def setMean(self, mean):
        r"""

        AnamDiscrete::setMean
        """
        return _gstlearn.AnamDiscrete_setMean(self, mean)

    def setVariance(self, variance):
        r"""

        AnamDiscrete::setVariance
        """
        return _gstlearn.AnamDiscrete_setVariance(self, variance)

    def setNCut(self, ncut):
        r"""

        AnamDiscrete::setNCut
        """
        return _gstlearn.AnamDiscrete_setNCut(self, ncut)

    def setZCut(self, zcut):
        r"""

        AnamDiscrete::setZCut
        """
        return _gstlearn.AnamDiscrete_setZCut(self, zcut)

    def setNElem(self, nelem):
        r"""

        AnamDiscrete::setNElem
        """
        return _gstlearn.AnamDiscrete_setNElem(self, nelem)

    def setStats(self, stats):
        r"""

        AnamDiscrete::setStats
        """
        return _gstlearn.AnamDiscrete_setStats(self, stats)

    def getDDStatProp(self, iclass):
        r"""

        AnamDiscrete::getDDStatProp
        """
        return _gstlearn.AnamDiscrete_getDDStatProp(self, iclass)

    def getDDStatZmoy(self, iclass):
        r"""

        AnamDiscrete::getDDStatZmoy
        """
        return _gstlearn.AnamDiscrete_getDDStatZmoy(self, iclass)

    def getDDStatCnorm(self, iclass):
        r"""

        AnamDiscrete::getDDStatCnorm
        """
        return _gstlearn.AnamDiscrete_getDDStatCnorm(self, iclass)

    def getDDStatLambda(self, iclass):
        r"""

        AnamDiscrete::getDDStatLambda
        """
        return _gstlearn.AnamDiscrete_getDDStatLambda(self, iclass)

    def getDDStatU(self, iclass):
        r"""

        AnamDiscrete::getDDStatU
        """
        return _gstlearn.AnamDiscrete_getDDStatU(self, iclass)

    def getDDStatMul(self, iclass):
        r"""

        AnamDiscrete::getDDStatMul
        """
        return _gstlearn.AnamDiscrete_getDDStatMul(self, iclass)

    def setDDStatProp(self, iclass, value):
        r"""

        AnamDiscrete::setDDStatProp
        """
        return _gstlearn.AnamDiscrete_setDDStatProp(self, iclass, value)

    def setDDStatZmoy(self, iclass, value):
        r"""

        AnamDiscrete::setDDStatZmoy
        """
        return _gstlearn.AnamDiscrete_setDDStatZmoy(self, iclass, value)

    def setDDStatCnorm(self, iclass, value):
        r"""

        AnamDiscrete::setDDStatCnorm
        """
        return _gstlearn.AnamDiscrete_setDDStatCnorm(self, iclass, value)

    def setDDStatLambda(self, iclass, value):
        r"""

        AnamDiscrete::setDDStatLambda
        """
        return _gstlearn.AnamDiscrete_setDDStatLambda(self, iclass, value)

    def setDDStatU(self, iclass, value):
        r"""

        AnamDiscrete::setDDStatU
        """
        return _gstlearn.AnamDiscrete_setDDStatU(self, iclass, value)

    def setDDStatMul(self, iclass, value):
        r"""

        AnamDiscrete::setDDStatMul
        """
        return _gstlearn.AnamDiscrete_setDDStatMul(self, iclass, value)

    def getIRStatT(self, iclass):
        r"""

        AnamDiscrete::getIRStatT
        """
        return _gstlearn.AnamDiscrete_getIRStatT(self, iclass)

    def getIRStatQ(self, iclass):
        r"""

        AnamDiscrete::getIRStatQ
        """
        return _gstlearn.AnamDiscrete_getIRStatQ(self, iclass)

    def getIRStatZ(self, iclass):
        r"""

        AnamDiscrete::getIRStatZ
        """
        return _gstlearn.AnamDiscrete_getIRStatZ(self, iclass)

    def getIRStatB(self, iclass):
        r"""

        AnamDiscrete::getIRStatB
        """
        return _gstlearn.AnamDiscrete_getIRStatB(self, iclass)

    def getIRStatR(self, iclass):
        r"""

        AnamDiscrete::getIRStatR
        """
        return _gstlearn.AnamDiscrete_getIRStatR(self, iclass)

    def getIRStatRV(self, iclass):
        r"""

        AnamDiscrete::getIRStatRV
        """
        return _gstlearn.AnamDiscrete_getIRStatRV(self, iclass)

    def setIRStatT(self, iclass, value):
        r"""

        AnamDiscrete::setIRStatT
        """
        return _gstlearn.AnamDiscrete_setIRStatT(self, iclass, value)

    def setIRStatQ(self, iclass, value):
        r"""

        AnamDiscrete::setIRStatQ
        """
        return _gstlearn.AnamDiscrete_setIRStatQ(self, iclass, value)

    def setIRStatZ(self, iclass, value):
        r"""

        AnamDiscrete::setIRStatZ
        """
        return _gstlearn.AnamDiscrete_setIRStatZ(self, iclass, value)

    def setIRStatB(self, iclass, value):
        r"""

        AnamDiscrete::setIRStatB
        """
        return _gstlearn.AnamDiscrete_setIRStatB(self, iclass, value)

    def setIRStatR(self, iclass, value):
        r"""

        AnamDiscrete::setIRStatR
        """
        return _gstlearn.AnamDiscrete_setIRStatR(self, iclass, value)

    def setIRStatRV(self, iclass, value):
        r"""

        AnamDiscrete::setIRStatRV
        """
        return _gstlearn.AnamDiscrete_setIRStatRV(self, iclass, value)

    def getStats(self):
        r"""

        AnamDiscrete::getStats
        """
        return _gstlearn.AnamDiscrete_getStats(self)

    def __repr__(self):
        return _gstlearn.AnamDiscrete___repr__(self)

# Register AnamDiscrete in _gstlearn:
_gstlearn.AnamDiscrete_swigregister(AnamDiscrete)
class AnamUser(AnamContinuous):
    r"""


    C++ includes: AnamUser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        AnamUser::AnamUser
        """
        _gstlearn.AnamUser_swiginit(self, _gstlearn.new_AnamUser(*args))
    __swig_destroy__ = _gstlearn.delete_AnamUser

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.AnamUser_clone(self)

    def toString(self, strfmt=None):
        r"""

        AnamUser::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.AnamUser_toString(self, strfmt)

    def getType(self):
        r"""

        AnamUser::getType
        AAnam Interface.  

        """
        return _gstlearn.AnamUser_getType(self)

    def isChangeSupportDefined(self):
        r"""

        AnamUser::isChangeSupportDefined
        """
        return _gstlearn.AnamUser_isChangeSupportDefined(self)

    def calculateMeanAndVariance(self):
        r"""

        AnamUser::calculateMeanAndVariance
        AnamContinuous Interface.  

        """
        return _gstlearn.AnamUser_calculateMeanAndVariance(self)

    def transformToRawValue(self, h):
        r"""

        AnamUser::transformToRawValue
        """
        return _gstlearn.AnamUser_transformToRawValue(self, h)

    def rawToTransformValue(self, h):
        r"""

        AnamUser::rawToTransformValue
        """
        return _gstlearn.AnamUser_rawToTransformValue(self, h)

    def setY2zFunction(self, y2z_function):
        r"""

        AnamUser::setY2zFunction
        """
        return _gstlearn.AnamUser_setY2zFunction(self, y2z_function)

    def setZ2yFunction(self, z2y_function):
        r"""

        AnamUser::setZ2yFunction
        """
        return _gstlearn.AnamUser_setZ2yFunction(self, z2y_function)

    def __repr__(self):
        return _gstlearn.AnamUser___repr__(self)

# Register AnamUser in _gstlearn:
_gstlearn.AnamUser_swigregister(AnamUser)
class AnamHermite(AnamContinuous):
    r"""


    C++ includes: AnamHermite.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        AnamHermite::AnamHermite
        """
        _gstlearn.AnamHermite_swiginit(self, _gstlearn.new_AnamHermite(*args))
    __swig_destroy__ = _gstlearn.delete_AnamHermite

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.AnamHermite_clone(self)

    def toString(self, strfmt=None):
        r"""

        AnamHermite::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.AnamHermite_toString(self, strfmt)

    def getType(self):
        r"""

        AnamHermite::getType
        Interface AAnam.  

        """
        return _gstlearn.AnamHermite_getType(self)

    def hasFactor(self):
        r"""

        AnamHermite::hasFactor
        """
        return _gstlearn.AnamHermite_hasFactor(self)

    def getNFactor(self):
        r"""

        AnamHermite::getNFactor
        """
        return _gstlearn.AnamHermite_getNFactor(self)

    def z2factor(self, z, ifacs):
        r"""

        AnamHermite::z2factor
        """
        return _gstlearn.AnamHermite_z2factor(self, z, ifacs)

    def computeVariance(self, chh):
        r"""

        AnamHermite::computeVariance
        Compute the Gaussian covariance from Raw covariance: Sum_n psi_n^2 C^n  

        Parameters
        ----------
        * `chh` :  

        Returns
        -------  

        """
        return _gstlearn.AnamHermite_computeVariance(self, chh)

    def updatePointToBlock(self, r_coef):
        r"""

        AnamHermite::updatePointToBlock
        """
        return _gstlearn.AnamHermite_updatePointToBlock(self, r_coef)

    def allowChangeSupport(self):
        r"""

        AnamHermite::allowChangeSupport
        """
        return _gstlearn.AnamHermite_allowChangeSupport(self)

    def isChangeSupportDefined(self):
        r"""

        AnamHermite::isChangeSupportDefined
        """
        return _gstlearn.AnamHermite_isChangeSupportDefined(self)

    def getNClass(self):
        r"""

        AnamHermite::getNClass
        """
        return _gstlearn.AnamHermite_getNClass(self)

    def fitFromArray(self, *args, **kwargs):
        r"""

        AnamHermite::fitFromArray
        """
        return _gstlearn.AnamHermite_fitFromArray(self, *args, **kwargs)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        AnamHermite::createFromNF
        ASerializable Interface.  

        """
        return _gstlearn.AnamHermite_createFromNF(NFFilename, verbose)

    def rawToTransformValue(self, z):
        r"""

        AnamHermite::rawToTransformValue
        AnamContinuous Interface.  

        """
        return _gstlearn.AnamHermite_rawToTransformValue(self, z)

    def transformToRawValue(self, y):
        r"""

        AnamHermite::transformToRawValue
        """
        return _gstlearn.AnamHermite_transformToRawValue(self, y)

    def calculateMeanAndVariance(self):
        r"""

        AnamHermite::calculateMeanAndVariance
        Interface for AnamContinuous.  

        """
        return _gstlearn.AnamHermite_calculateMeanAndVariance(self)

    @staticmethod
    def create(nbpoly=0, flagBound=True, rCoef=1.):
        r"""

        AnamHermite::create
        """
        return _gstlearn.AnamHermite_create(nbpoly, flagBound, rCoef)

    def reset(self, pymin, pzmin, pymax, pzmax, aymin, azmin, aymax, azmax, r, psi_hn):
        r"""

        AnamHermite::reset
        """
        return _gstlearn.AnamHermite_reset(self, pymin, pzmin, pymax, pzmax, aymin, azmin, aymax, azmax, r, psi_hn)

    def getNbPoly(self):
        r"""

        AnamHermite::getNbPoly
        """
        return _gstlearn.AnamHermite_getNbPoly(self)

    def getPsiHns(self):
        r"""

        AnamHermite::getPsiHns
        """
        return _gstlearn.AnamHermite_getPsiHns(self)

    def getPsiHn(self, ih):
        r"""

        AnamHermite::getPsiHn
        """
        return _gstlearn.AnamHermite_getPsiHn(self, ih)

    def getRCoef(self):
        r"""

        AnamHermite::getRCoef
        """
        return _gstlearn.AnamHermite_getRCoef(self)

    def getFlagBound(self):
        r"""

        AnamHermite::getFlagBound
        """
        return _gstlearn.AnamHermite_getFlagBound(self)

    def setPsiHns(self, psi_hn):
        r"""

        AnamHermite::setPsiHns
        """
        return _gstlearn.AnamHermite_setPsiHns(self, psi_hn)

    def setFlagBound(self, flagBound):
        r"""

        AnamHermite::setFlagBound
        """
        return _gstlearn.AnamHermite_setFlagBound(self, flagBound)

    def setPsiHn(self, i, psi_hn):
        r"""

        AnamHermite::setPsiHn
        """
        return _gstlearn.AnamHermite_setPsiHn(self, i, psi_hn)

    def setRCoef(self, r_coef):
        r"""

        AnamHermite::setRCoef
        """
        return _gstlearn.AnamHermite_setRCoef(self, r_coef)

    def factor2Selectivity(self, db, selectivity, cols_est, cols_std, iptr0):
        r"""

        AnamHermite::factor2Selectivity
        Calculate Experimental Grade-Tonnage curves from factors Case of Hermite
        Anamorphosis  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db structure containing the factors (Z-locators)  
        * `selectivity` :  
            Selectivity structure  
        * `cols_est` :  
            Array of UIDs for factor estimation  
        * `cols_std` :  
            Array of UIDs for factor St. Dev.  
        * `iptr0` :  
            Rank for storing the results  

        """
        return _gstlearn.AnamHermite_factor2Selectivity(self, db, selectivity, cols_est, cols_std, iptr0)

    def evalSupportCoefficient(self, *args, **kwargs):
        r"""

        AnamHermite::evalSupportCoefficient
        """
        return _gstlearn.AnamHermite_evalSupportCoefficient(self, *args, **kwargs)

    def cumulateVarianceRatio(self, chh):
        r"""

        AnamHermite::cumulateVarianceRatio
        """
        return _gstlearn.AnamHermite_cumulateVarianceRatio(self, chh)

    def __repr__(self):
        return _gstlearn.AnamHermite___repr__(self)

# Register AnamHermite in _gstlearn:
_gstlearn.AnamHermite_swigregister(AnamHermite)
class AnamEmpirical(AnamContinuous):
    r"""


    Gaussian Anamorphosis using Empirical Method  

    This class is meant in order to construct the transfer function from Raw to
    Gaussian scale directly based on the data.  

    It essentially maps the cumulative function (CDF) of the raw values into the CDF
    of the theoretical Gaussian distribution.  

    This can be performed directly on the experimental CDF (normal score) or by
    diluting the data values beforehand. In the latter solution, each (valid) datum
    is replaced by a small local distribution. This is meant to smooth the stepwise
    CDF.  

    The dilution function (implemented at any data point) can be either a Gaussian
    or a Lognormal one. In the Gaussian case, the variance (width of the dilution
    function) is considered as constant (either provided by the user or defaulted by
    the program)* In the lognormal case, the logarithmic variance is constant (hence
    the width is proportional to the square of the value).  

    C++ includes: AnamEmpirical.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        AnamEmpirical::AnamEmpirical
        """
        _gstlearn.AnamEmpirical_swiginit(self, _gstlearn.new_AnamEmpirical(*args))
    __swig_destroy__ = _gstlearn.delete_AnamEmpirical

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.AnamEmpirical_clone(self)

    def toString(self, strfmt=None):
        r"""

        AnamEmpirical::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.AnamEmpirical_toString(self, strfmt)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        AnamEmpirical::createFromNF
        ASerializable Interface.  

        """
        return _gstlearn.AnamEmpirical_createFromNF(NFFilename, verbose)

    def reset(self, ndisc, pymin, pzmin, pymax, pzmax, aymin, azmin, aymax, azmax, sigma2e, zdisc, ydisc):
        r"""

        AnamEmpirical::reset
        """
        return _gstlearn.AnamEmpirical_reset(self, ndisc, pymin, pzmin, pymax, pzmax, aymin, azmin, aymax, azmax, sigma2e, zdisc, ydisc)

    def getType(self):
        r"""

        AnamEmpirical::getType
        AAnam Interface.  

        """
        return _gstlearn.AnamEmpirical_getType(self)

    def getNFactor(self):
        r"""

        AnamEmpirical::getNFactor
        """
        return _gstlearn.AnamEmpirical_getNFactor(self)

    def fitFromArray(self, *args, **kwargs):
        r"""

        AnamEmpirical::fitFromArray
        """
        return _gstlearn.AnamEmpirical_fitFromArray(self, *args, **kwargs)

    def calculateMeanAndVariance(self):
        r"""

        AnamEmpirical::calculateMeanAndVariance
        AnamContinuous Interface.  

        """
        return _gstlearn.AnamEmpirical_calculateMeanAndVariance(self)

    def rawToTransformValue(self, zz):
        r"""

        AnamEmpirical::rawToTransformValue
        """
        return _gstlearn.AnamEmpirical_rawToTransformValue(self, zz)

    def transformToRawValue(self, yy):
        r"""

        AnamEmpirical::transformToRawValue
        """
        return _gstlearn.AnamEmpirical_transformToRawValue(self, yy)

    def isChangeSupportDefined(self):
        r"""

        AnamEmpirical::isChangeSupportDefined
        """
        return _gstlearn.AnamEmpirical_isChangeSupportDefined(self)

    @staticmethod
    def create(ndisc=100, sigma2e=1.234e30):
        r"""

        AnamEmpirical::create
        """
        return _gstlearn.AnamEmpirical_create(ndisc, sigma2e)

    def getNDisc(self):
        r"""

        AnamEmpirical::getNDisc
        """
        return _gstlearn.AnamEmpirical_getNDisc(self)

    def getSigma2e(self):
        r"""

        AnamEmpirical::getSigma2e
        """
        return _gstlearn.AnamEmpirical_getSigma2e(self)

    def getZDisc(self):
        r"""

        AnamEmpirical::getZDisc
        """
        return _gstlearn.AnamEmpirical_getZDisc(self)

    def getYDisc(self):
        r"""

        AnamEmpirical::getYDisc
        """
        return _gstlearn.AnamEmpirical_getYDisc(self)

    def isFlagDilution(self):
        r"""

        AnamEmpirical::isFlagDilution
        """
        return _gstlearn.AnamEmpirical_isFlagDilution(self)

    def isFlagGaussian(self):
        r"""

        AnamEmpirical::isFlagGaussian
        """
        return _gstlearn.AnamEmpirical_isFlagGaussian(self)

    def setSigma2e(self, sigma2e):
        r"""

        AnamEmpirical::setSigma2e
        """
        return _gstlearn.AnamEmpirical_setSigma2e(self, sigma2e)

    def setNDisc(self, ndisc):
        r"""

        AnamEmpirical::setNDisc
        """
        return _gstlearn.AnamEmpirical_setNDisc(self, ndisc)

    def setDisc(self, zdisc, ydisc):
        r"""

        AnamEmpirical::setDisc
        """
        return _gstlearn.AnamEmpirical_setDisc(self, zdisc, ydisc)

    def setFlagDilution(self, flagDilution):
        r"""

        AnamEmpirical::setFlagDilution
        """
        return _gstlearn.AnamEmpirical_setFlagDilution(self, flagDilution)

    def setFlagGaussian(self, flagGaussian):
        r"""

        AnamEmpirical::setFlagGaussian
        """
        return _gstlearn.AnamEmpirical_setFlagGaussian(self, flagGaussian)

    def __repr__(self):
        return _gstlearn.AnamEmpirical___repr__(self)

# Register AnamEmpirical in _gstlearn:
_gstlearn.AnamEmpirical_swigregister(AnamEmpirical)
class AnamDiscreteDD(AnamDiscrete):
    r"""


    C++ includes: AnamDiscreteDD.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        AnamDiscreteDD::AnamDiscreteDD
        """
        _gstlearn.AnamDiscreteDD_swiginit(self, _gstlearn.new_AnamDiscreteDD(*args))
    __swig_destroy__ = _gstlearn.delete_AnamDiscreteDD

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.AnamDiscreteDD_clone(self)

    def toString(self, strfmt=None):
        r"""

        AnamDiscreteDD::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.AnamDiscreteDD_toString(self, strfmt)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        AnamDiscreteDD::createFromNF
        ASerializable Interface.  

        """
        return _gstlearn.AnamDiscreteDD_createFromNF(NFFilename, verbose)

    def getType(self):
        r"""

        AnamDiscreteDD::getType
        AAnam Interface.  

        """
        return _gstlearn.AnamDiscreteDD_getType(self)

    def hasFactor(self):
        r"""

        AnamDiscreteDD::hasFactor
        """
        return _gstlearn.AnamDiscreteDD_hasFactor(self)

    def getNFactor(self):
        r"""

        AnamDiscreteDD::getNFactor
        """
        return _gstlearn.AnamDiscreteDD_getNFactor(self)

    def z2factor(self, z, ifacs):
        r"""

        AnamDiscreteDD::z2factor
        """
        return _gstlearn.AnamDiscreteDD_z2factor(self, z, ifacs)

    def computeVariance(self, sval):
        r"""

        AnamDiscreteDD::computeVariance
        Calculates the block variance  

        Returns
        -------
        Value of the block variance (as a function of support coefficient)  

        """
        return _gstlearn.AnamDiscreteDD_computeVariance(self, sval)

    def updatePointToBlock(self, r_coef):
        r"""

        AnamDiscreteDD::updatePointToBlock
        """
        return _gstlearn.AnamDiscreteDD_updatePointToBlock(self, r_coef)

    def allowChangeSupport(self):
        r"""

        AnamDiscreteDD::allowChangeSupport
        """
        return _gstlearn.AnamDiscreteDD_allowChangeSupport(self)

    def isChangeSupportDefined(self):
        r"""

        AnamDiscreteDD::isChangeSupportDefined
        """
        return _gstlearn.AnamDiscreteDD_isChangeSupportDefined(self)

    def fitFromArray(self, *args, **kwargs):
        r"""

        AnamDiscreteDD::fitFromArray
        """
        return _gstlearn.AnamDiscreteDD_fitFromArray(self, *args, **kwargs)

    def calculateMeanAndVariance(self):
        r"""

        AnamDiscreteDD::calculateMeanAndVariance
        AnamDiscrete Interface.  

        """
        return _gstlearn.AnamDiscreteDD_calculateMeanAndVariance(self)

    def factors_exp(self, verbose=False):
        r"""

        AnamDiscreteDD::factors_exp
        """
        return _gstlearn.AnamDiscreteDD_factors_exp(self, verbose)

    def factors_maf(self, verbose=False):
        r"""

        AnamDiscreteDD::factors_maf
        """
        return _gstlearn.AnamDiscreteDD_factors_maf(self, verbose)

    def factors_mod(self):
        r"""

        AnamDiscreteDD::factors_mod
        """
        return _gstlearn.AnamDiscreteDD_factors_mod(self)

    def chi2I(self, chi, mode):
        r"""

        AnamDiscreteDD::chi2I
        Parameters
        ----------
        * `chi` :  
            Chi Matrix  
        * `mode` :  
            Type of recovery function  

            *   1 : Indicator  
            *   2 : Metal quantity  
            *   3 : Benefit  

        Returns
        -------
        Calculate the transition matrix from factor to a recovery item i.e. Indicator,
        Metal Quantity or Benefit (according to mode) (Diffusion Discrete)  

        """
        return _gstlearn.AnamDiscreteDD_chi2I(self, chi, mode)

    @staticmethod
    def create(mu=1., scoef=0.):
        r"""

        AnamDiscreteDD::create
        """
        return _gstlearn.AnamDiscreteDD_create(mu, scoef)

    def reset(self, ncut, scoef, mu, zcut, pcaz2f, pcaf2z, stats):
        r"""

        AnamDiscreteDD::reset
        """
        return _gstlearn.AnamDiscreteDD_reset(self, ncut, scoef, mu, zcut, pcaz2f, pcaf2z, stats)

    def getMAF(self):
        r"""

        AnamDiscreteDD::getMAF
        """
        return _gstlearn.AnamDiscreteDD_getMAF(self)

    def getMu(self):
        r"""

        AnamDiscreteDD::getMu
        """
        return _gstlearn.AnamDiscreteDD_getMu(self)

    def getSCoef(self):
        r"""

        AnamDiscreteDD::getSCoef
        """
        return _gstlearn.AnamDiscreteDD_getSCoef(self)

    def getI2Chi(self):
        r"""

        AnamDiscreteDD::getI2Chi
        """
        return _gstlearn.AnamDiscreteDD_getI2Chi(self)

    def getPcaZ2Fs(self):
        r"""

        AnamDiscreteDD::getPcaZ2Fs
        """
        return _gstlearn.AnamDiscreteDD_getPcaZ2Fs(self)

    def getPcaF2Zs(self):
        r"""

        AnamDiscreteDD::getPcaF2Zs
        """
        return _gstlearn.AnamDiscreteDD_getPcaF2Zs(self)

    def setMu(self, mu):
        r"""

        AnamDiscreteDD::setMu
        """
        return _gstlearn.AnamDiscreteDD_setMu(self, mu)

    def setRCoef(self, rcoef):
        r"""

        AnamDiscreteDD::setRCoef
        """
        return _gstlearn.AnamDiscreteDD_setRCoef(self, rcoef)

    def setPcaZ2F(self, pcaz2f):
        r"""

        AnamDiscreteDD::setPcaZ2F
        """
        return _gstlearn.AnamDiscreteDD_setPcaZ2F(self, pcaz2f)

    def setPcaF2Z(self, pcaf2z):
        r"""

        AnamDiscreteDD::setPcaF2Z
        """
        return _gstlearn.AnamDiscreteDD_setPcaF2Z(self, pcaf2z)

    def setI2Chi(self, i2Chi):
        r"""

        AnamDiscreteDD::setI2Chi
        """
        return _gstlearn.AnamDiscreteDD_setI2Chi(self, i2Chi)

    def factor2Selectivity(self, db, selectivity, cols_est, cols_std, iptr0):
        r"""

        AnamDiscreteDD::factor2Selectivity
        Calculate Experimental Grade-Tonnage curves from factors Case of Discrete
        Diffusion  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db structure containing the factors (Z-locators)  
        * `selectivity` :  
            Selectivity structure  
        * `cols_est` :  
            Array of UIDs for factor estimation  
        * `cols_std` :  
            Array of UIDs for factor st. dev.  
        * `iptr0` :  
            Rank for storing the results  

        """
        return _gstlearn.AnamDiscreteDD_factor2Selectivity(self, db, selectivity, cols_est, cols_std, iptr0)

    def __repr__(self):
        return _gstlearn.AnamDiscreteDD___repr__(self)

# Register AnamDiscreteDD in _gstlearn:
_gstlearn.AnamDiscreteDD_swigregister(AnamDiscreteDD)
class AnamDiscreteIR(AnamDiscrete):
    r"""


    C++ includes: AnamDiscreteIR.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        AnamDiscreteIR::AnamDiscreteIR
        """
        _gstlearn.AnamDiscreteIR_swiginit(self, _gstlearn.new_AnamDiscreteIR(*args))
    __swig_destroy__ = _gstlearn.delete_AnamDiscreteIR

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.AnamDiscreteIR_clone(self)

    def toString(self, strfmt=None):
        r"""

        AnamDiscreteIR::toString
        ICloneable Interface.  

        AStringable Interface  

        """
        return _gstlearn.AnamDiscreteIR_toString(self, strfmt)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        AnamDiscreteIR::createFromNF
        ASerializable Interface.  

        """
        return _gstlearn.AnamDiscreteIR_createFromNF(NFFilename, verbose)

    def getType(self):
        r"""

        AnamDiscreteIR::getType
        AAnam Interface.  

        """
        return _gstlearn.AnamDiscreteIR_getType(self)

    def hasFactor(self):
        r"""

        AnamDiscreteIR::hasFactor
        """
        return _gstlearn.AnamDiscreteIR_hasFactor(self)

    def z2factor(self, z, ifacs):
        r"""

        AnamDiscreteIR::z2factor
        """
        return _gstlearn.AnamDiscreteIR_z2factor(self, z, ifacs)

    def computeVariance(self, sval):
        r"""

        AnamDiscreteIR::computeVariance
        Calculates the block variance  

        Returns
        -------
        Value of the block variance (as a function of support coefficient)  

        """
        return _gstlearn.AnamDiscreteIR_computeVariance(self, sval)

    def updatePointToBlock(self, r_coef):
        r"""

        AnamDiscreteIR::updatePointToBlock
        """
        return _gstlearn.AnamDiscreteIR_updatePointToBlock(self, r_coef)

    def allowChangeSupport(self):
        r"""

        AnamDiscreteIR::allowChangeSupport
        """
        return _gstlearn.AnamDiscreteIR_allowChangeSupport(self)

    def isChangeSupportDefined(self):
        r"""

        AnamDiscreteIR::isChangeSupportDefined
        """
        return _gstlearn.AnamDiscreteIR_isChangeSupportDefined(self)

    def fitFromArray(self, *args, **kwargs):
        r"""

        AnamDiscreteIR::fitFromArray
        """
        return _gstlearn.AnamDiscreteIR_fitFromArray(self, *args, **kwargs)

    def calculateMeanAndVariance(self):
        r"""

        AnamDiscreteIR::calculateMeanAndVariance
        AnamDiscrete Interface.  

        """
        return _gstlearn.AnamDiscreteIR_calculateMeanAndVariance(self)

    @staticmethod
    def create(rcoef=0.):
        r"""

        AnamDiscreteIR::create
        """
        return _gstlearn.AnamDiscreteIR_create(rcoef)

    def reset(self, ncut, r_coef, zcut, stats):
        r"""

        AnamDiscreteIR::reset
        """
        return _gstlearn.AnamDiscreteIR_reset(self, ncut, r_coef, zcut, stats)

    def getRCoef(self):
        r"""

        AnamDiscreteIR::getRCoef
        """
        return _gstlearn.AnamDiscreteIR_getRCoef(self)

    def setRCoef(self, rcoef):
        r"""

        AnamDiscreteIR::setRCoef
        """
        return _gstlearn.AnamDiscreteIR_setRCoef(self, rcoef)

    def factor2Selectivity(self, db, selectivity, cols_est, cols_std, iptr0):
        r"""

        AnamDiscreteIR::factor2Selectivity
        Calculate Experimental Grade-Tonnage curves from factors Case of Discrete
        Indicator Residuals  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db structure containing the factors (Z-locators)  
        * `selectivity` :  
            Selectivity structure  
        * `cols_est` :  
            Array of UIDs for factor estimation  
        * `cols_std` :  
            Array of UIDs for factor St. Dev.  
        * `iptr0` :  
            Rank for storing the results  

        """
        return _gstlearn.AnamDiscreteIR_factor2Selectivity(self, db, selectivity, cols_est, cols_std, iptr0)

    def __repr__(self):
        return _gstlearn.AnamDiscreteIR___repr__(self)

# Register AnamDiscreteIR in _gstlearn:
_gstlearn.AnamDiscreteIR_swigregister(AnamDiscreteIR)
class PPMT(AStringable, ICloneable):
    r"""


    C++ includes: PPMT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        PPMT::PPMT
        """
        _gstlearn.PPMT_swiginit(self, _gstlearn.new_PPMT(*args))
    __swig_destroy__ = _gstlearn.delete_PPMT

    def toString(self, strfmt=None):
        r"""

        PPMT::toString
        AStringable Interface.  

        """
        return _gstlearn.PPMT_toString(self, strfmt)

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.PPMT_clone(self)

    @staticmethod
    def create(*args, **kwargs):
        r"""

        PPMT::create
        ICloneable Interface.  

        Create the Multivariate Gaussian anamorphosis  

        Parameters
        ----------
        * `ndir` :  
            Number of Directions to be tested at each iteration  
        * `flagPreprocessing` :  
            True for pre-processing (Normal Score and Sphering)  
        * `methodDir` :  
            Method for Direction Generation  
        * `methodTrans` :  
            Method for Gaussian Transformation  
        * `nbpoly` :  
            Number of Polynomial (only used for "hermite" transformation)  
        * `alpha` :  
            Distance exponent  

        Returns
        -------
        An instance of PPMT class  

        """
        return _gstlearn.PPMT_create(*args, **kwargs)

    def getNiter(self):
        r"""

        PPMT::getNiter
        """
        return _gstlearn.PPMT_getNiter(self)

    def getAlpha(self):
        r"""

        PPMT::getAlpha
        """
        return _gstlearn.PPMT_getAlpha(self)

    def getNdir(self):
        r"""

        PPMT::getNdir
        """
        return _gstlearn.PPMT_getNdir(self)

    def getNdim(self):
        r"""

        PPMT::getNdim
        """
        return _gstlearn.PPMT_getNdim(self)

    def getNbpoly(self):
        r"""

        PPMT::getNbpoly
        """
        return _gstlearn.PPMT_getNbpoly(self)

    def isFitted(self):
        r"""

        PPMT::isFitted
        """
        return _gstlearn.PPMT_isFitted(self)

    def getMethodDir(self):
        r"""

        PPMT::getMethodDir
        """
        return _gstlearn.PPMT_getMethodDir(self)

    def getMethodTrans(self):
        r"""

        PPMT::getMethodTrans
        """
        return _gstlearn.PPMT_getMethodTrans(self)

    def getSerieAngle(self):
        r"""

        PPMT::getSerieAngle
        """
        return _gstlearn.PPMT_getSerieAngle(self)

    def getSerieScore(self, flagLog=False):
        r"""

        PPMT::getSerieScore
        """
        return _gstlearn.PPMT_getSerieScore(self, flagLog)

    def fit(self, *args, **kwargs):
        r"""

        PPMT::fit
        """
        return _gstlearn.PPMT_fit(self, *args, **kwargs)

    def fitFromMatrix(self, Y, niter, verbose=False):
        r"""

        PPMT::fitFromMatrix
        """
        return _gstlearn.PPMT_fitFromMatrix(self, Y, niter, verbose)

    def rawToGaussian(self, *args, **kwargs):
        r"""

        PPMT::rawToGaussian
        """
        return _gstlearn.PPMT_rawToGaussian(self, *args, **kwargs)

    def gaussianToRaw(self, *args, **kwargs):
        r"""

        PPMT::gaussianToRaw
        """
        return _gstlearn.PPMT_gaussianToRaw(self, *args, **kwargs)

    def __repr__(self):
        return _gstlearn.PPMT___repr__(self)

# Register PPMT in _gstlearn:
_gstlearn.PPMT_swigregister(PPMT)
class AGibbs(AStringable):
    r"""


    C++ includes: AGibbs.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_AGibbs

    def toString(self, strfmt=None):
        r"""

        AGibbs::toString
        Interface for AStringable.  

        """
        return _gstlearn.AGibbs_toString(self, strfmt)

    def calculInitialize(self, y, isimu, ipgs):
        r"""

        AGibbs::calculInitialize
        Interface for AGibbs.  

        """
        return _gstlearn.AGibbs_calculInitialize(self, y, isimu, ipgs)

    def update(self, y, isimu, ipgs, iter):
        r"""

        AGibbs::update
        """
        return _gstlearn.AGibbs_update(self, y, isimu, ipgs, iter)

    def covmatAlloc(self, verbose, verboseTimer=False):
        r"""

        AGibbs::covmatAlloc
        """
        return _gstlearn.AGibbs_covmatAlloc(self, verbose, verboseTimer)

    def getSimulate(self, y, yk, sk, icase, ipgs, ivar, iact, iter):
        r"""

        AGibbs::getSimulate
        """
        return _gstlearn.AGibbs_getSimulate(self, y, yk, sk, icase, ipgs, ivar, iact, iter)

    def checkGibbs(self, y, isimu, ipgs):
        r"""

        AGibbs::checkGibbs
        """
        return _gstlearn.AGibbs_checkGibbs(self, y, isimu, ipgs)

    def cleanup(self):
        r"""

        AGibbs::cleanup
        """
        return _gstlearn.AGibbs_cleanup(self)

    def init(self, npgs, nvar, nburn, niter, seed=3241, flag_order=0, flag_decay=True):
        r"""

        AGibbs::init
        """
        return _gstlearn.AGibbs_init(self, npgs, nvar, nburn, niter, seed, flag_order, flag_decay)

    def run(self, y, ipgs0=0, isimu0=0, verboseTimer=False, flagCheck=False):
        r"""

        AGibbs::run
        Simulate a vector for the current 'ipgs' and current 'isimu'  

        Parameters
        ----------
        * `y` :  
            Simulation vector (used in input and output)  
        * `ipgs0` :  
            Rank of the current 'pgs'  
        * `isimu0` :  
            Rank of the current simulation  
        * `verboseTimer` :  
            Verbose option for time consumption  
        * `flagCheck` :  
            True if the checks must be performed  

        Returns
        -------  

        """
        return _gstlearn.AGibbs_run(self, y, ipgs0, isimu0, verboseTimer, flagCheck)

    def getNvar(self):
        r"""

        AGibbs::getNvar
        """
        return _gstlearn.AGibbs_getNvar(self)

    def setNvar(self, nvar):
        r"""

        AGibbs::setNvar
        """
        return _gstlearn.AGibbs_setNvar(self, nvar)

    def getNpgs(self):
        r"""

        AGibbs::getNpgs
        """
        return _gstlearn.AGibbs_getNpgs(self)

    def setNpgs(self, npgs):
        r"""

        AGibbs::setNpgs
        """
        return _gstlearn.AGibbs_setNpgs(self, npgs)

    def getNburn(self):
        r"""

        AGibbs::getNburn
        """
        return _gstlearn.AGibbs_getNburn(self)

    def setNburn(self, nburn):
        r"""

        AGibbs::setNburn
        """
        return _gstlearn.AGibbs_setNburn(self, nburn)

    def getNiter(self):
        r"""

        AGibbs::getNiter
        """
        return _gstlearn.AGibbs_getNiter(self)

    def setNiter(self, niter):
        r"""

        AGibbs::setNiter
        """
        return _gstlearn.AGibbs_setNiter(self, niter)

    def getFlagOrder(self):
        r"""

        AGibbs::getFlagOrder
        """
        return _gstlearn.AGibbs_getFlagOrder(self)

    def setFlagOrder(self, flagOrder):
        r"""

        AGibbs::setFlagOrder
        """
        return _gstlearn.AGibbs_setFlagOrder(self, flagOrder)

    def getOptionStats(self):
        r"""

        AGibbs::getOptionStats
        """
        return _gstlearn.AGibbs_getOptionStats(self)

    def setOptionStats(self, option_stats):
        r"""

        AGibbs::setOptionStats
        """
        return _gstlearn.AGibbs_setOptionStats(self, option_stats)

    def getDb(self):
        r"""

        AGibbs::getDb
        """
        return _gstlearn.AGibbs_getDb(self)

    def allocY(self):
        r"""

        AGibbs::allocY
        Returns a Vector of Vector Double used to store one simulation. Its first
        dimension is set to 'npgs' * 'nvar' Its second dimension if set to the number of
        samples  

        Returns
        -------  

        """
        return _gstlearn.AGibbs_allocY(self)

    def storeResult(self, y, isimu, ipgs):
        r"""

        AGibbs::storeResult
        Store the Gaussian array in ELoc::GAUS variable. This should be performed once
        for all GS and all variables  

        Parameters
        ----------
        * `y` :  
            The Gaussian vector to be stored  
        * `isimu` :  
            Rank of the simulation  
        * `ipgs` :  
            Rank of the GS  

        """
        return _gstlearn.AGibbs_storeResult(self, y, isimu, ipgs)

    def getNSample(self):
        r"""

        AGibbs::getNSample
        """
        return _gstlearn.AGibbs_getNSample(self)

    def getSampleRank(self, i):
        r"""

        AGibbs::getSampleRank
        """
        return _gstlearn.AGibbs_getSampleRank(self, i)

    def getRank(self, ipgs, ivar):
        r"""

        AGibbs::getRank
        """
        return _gstlearn.AGibbs_getRank(self, ipgs, ivar)

    def __repr__(self):
        return _gstlearn.AGibbs___repr__(self)

# Register AGibbs in _gstlearn:
_gstlearn.AGibbs_swigregister(AGibbs)
class GibbsMulti(AGibbs):
    r"""


    C++ includes: GibbsMulti.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _gstlearn.delete_GibbsMulti

    def calculInitialize(self, y, isimu, ipgs):
        r"""

        GibbsMulti::calculInitialize
        Interface for AGibbs.  

        Initializes the Gibbs sampler for a set of inequalities  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `y` :  
            Gaussian vector  
        * `isimu` :  
            Rank of the simulation  
        * `ipgs` :  
            Rank of the GS  

        """
        return _gstlearn.GibbsMulti_calculInitialize(self, y, isimu, ipgs)

    def getSimulate(self, y, yk, sk, icase, ipgs, ivar, iact, iter):
        r"""

        GibbsMulti::getSimulate
        Generate a simulated value  

        Parameters
        ----------
        * `y` :  
            : Gaussian vector  
        * `yk` :  
            : Kriged value  
        * `sk` :  
            : Standard deviation  
        * `icase` :  
            : Rank in the 'y' array  
        * `ipgs` :  
            : Rank of the current GS  
        * `ivar` :  
            : Rank of the current Variable  
        * `iact` :  
            : Rank of the target sample (relative)  
        * `iter` :  
            : Rank of the iteration  

        Returns
        -------
        Simulated value  

        """
        return _gstlearn.GibbsMulti_getSimulate(self, y, yk, sk, icase, ipgs, ivar, iact, iter)

    def checkGibbs(self, y, isimu, ipgs):
        r"""

        GibbsMulti::checkGibbs
        Check/Show the facies against gaussian at wells  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `y` :  
            Gaussian vector  
        * `isimu` :  
            Rank of the simulation  
        * `ipgs` :  
            Rank of the GS  

        """
        return _gstlearn.GibbsMulti_checkGibbs(self, y, isimu, ipgs)

    def getModel(self):
        r"""

        GibbsMulti::getModel
        """
        return _gstlearn.GibbsMulti_getModel(self)

    def __repr__(self):
        return _gstlearn.GibbsMulti___repr__(self)

# Register GibbsMulti in _gstlearn:
_gstlearn.GibbsMulti_swigregister(GibbsMulti)
class GibbsMMulti(GibbsMulti):
    r"""


    C++ includes: GibbsMMulti.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        GibbsMMulti::GibbsMMulti
        """
        _gstlearn.GibbsMMulti_swiginit(self, _gstlearn.new_GibbsMMulti(*args))
    __swig_destroy__ = _gstlearn.delete_GibbsMMulti

    def update(self, y, isimu, ipgs, iter):
        r"""

        GibbsMMulti::update
        Perform one update of the Gibbs sampler  

        Parameters
        ----------
        * `y` :  
            Gaussian Vector  
        * `isimu` :  
            Rank of the simulation  
        * `ipgs` :  
            Rank of the GS  
        * `iter` :  
            Rank of the iteration  

        """
        return _gstlearn.GibbsMMulti_update(self, y, isimu, ipgs, iter)

    def covmatAlloc(self, verbose, verboseTimer=False):
        r"""

        GibbsMMulti::covmatAlloc
        Establish the covariance matrix for Gibbs  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `verbose` :  
            Verbose flag  
        * `verboseTimer` :  
            True to show elapse times  

        """
        return _gstlearn.GibbsMMulti_covmatAlloc(self, verbose, verboseTimer)

    def setEps(self, eps):
        r"""

        GibbsMMulti::setEps
        """
        return _gstlearn.GibbsMMulti_setEps(self, eps)

    def cleanup(self):
        r"""

        GibbsMMulti::cleanup
        """
        return _gstlearn.GibbsMMulti_cleanup(self)

    def setFlagStoreInternal(self, flagStoreInternal):
        r"""

        GibbsMMulti::setFlagStoreInternal
        """
        return _gstlearn.GibbsMMulti_setFlagStoreInternal(self, flagStoreInternal)

    def __repr__(self):
        return _gstlearn.GibbsMMulti___repr__(self)

# Register GibbsMMulti in _gstlearn:
_gstlearn.GibbsMMulti_swigregister(GibbsMMulti)
class GibbsUMulti(GibbsMulti):
    r"""


    C++ includes: GibbsUMulti.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        GibbsUMulti::GibbsUMulti
        """
        _gstlearn.GibbsUMulti_swiginit(self, _gstlearn.new_GibbsUMulti(*args))
    __swig_destroy__ = _gstlearn.delete_GibbsUMulti

    def update(self, y, isimu, ipgs, iter):
        r"""

        GibbsUMulti::update
        Perform one update of the Gibbs sampler  

        Parameters
        ----------
        * `y` :  
            Gaussian vector  
        * `isimu` :  
            Rank of the simulation  
        * `ipgs` :  
            Rank of the GS  
        * `iter` :  
            Rank of the iteration  

        """
        return _gstlearn.GibbsUMulti_update(self, y, isimu, ipgs, iter)

    def covmatAlloc(self, verbose, verboseTimer=False):
        r"""

        GibbsUMulti::covmatAlloc
        Establish the covariance matrix for Gibbs  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `verbose` :  
            Verbose flag  
        * `verboseTimer` :  
            True to show elapse times  

        """
        return _gstlearn.GibbsUMulti_covmatAlloc(self, verbose, verboseTimer)

    def __repr__(self):
        return _gstlearn.GibbsUMulti___repr__(self)

# Register GibbsUMulti in _gstlearn:
_gstlearn.GibbsUMulti_swigregister(GibbsUMulti)
class Spill_Res(object):
    r"""


    C++ includes: Morpho.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    success = property(_gstlearn.Spill_Res_success_get, _gstlearn.Spill_Res_success_set)
    h = property(_gstlearn.Spill_Res_h_get, _gstlearn.Spill_Res_h_set)
    th = property(_gstlearn.Spill_Res_th_get, _gstlearn.Spill_Res_th_set)
    ix0 = property(_gstlearn.Spill_Res_ix0_get, _gstlearn.Spill_Res_ix0_set)
    iy0 = property(_gstlearn.Spill_Res_iy0_get, _gstlearn.Spill_Res_iy0_set)

    def __init__(self):
        r"""


        C++ includes: Morpho.hpp

        """
        _gstlearn.Spill_Res_swiginit(self, _gstlearn.new_Spill_Res())
    __swig_destroy__ = _gstlearn.delete_Spill_Res

# Register Spill_Res in _gstlearn:
_gstlearn.Spill_Res_swigregister(Spill_Res)

def morpho_count(imagin):
    return _gstlearn.morpho_count(imagin)

def morpho_duplicate(imagin, imagout):
    return _gstlearn.morpho_duplicate(imagin, imagout)

def morpho_erosion(option, radius, imagin, imagout, verbose=False):
    return _gstlearn.morpho_erosion(option, radius, imagin, imagout, verbose)

def morpho_dilation(option, radius, imagin, imagout, verbose=False):
    return _gstlearn.morpho_dilation(option, radius, imagin, imagout, verbose)

def morpho_opening(option, radius, imagin, imagout, verbose=False):
    return _gstlearn.morpho_opening(option, radius, imagin, imagout, verbose)

def morpho_closing(option, radius, imagin, imagout, verbose=False):
    return _gstlearn.morpho_closing(option, radius, imagin, imagout, verbose)

def morpho_intersection(image1, image2, imagout, verbose=False):
    return _gstlearn.morpho_intersection(image1, image2, imagout, verbose)

def morpho_union(image1, image2, imagout, verbose=False):
    return _gstlearn.morpho_union(image1, image2, imagout, verbose)

def morpho_negation(imagin, imagout, verbose=False):
    return _gstlearn.morpho_negation(imagin, imagout, verbose)

def morpho_double2imageInPlace(nx, tabin, vmin, vmax, imagout, verbose=False):
    return _gstlearn.morpho_double2imageInPlace(nx, tabin, vmin, vmax, imagout, verbose)

def morpho_double2image(nx, tabin, vmin, vmax, verbose=False):
    return _gstlearn.morpho_double2image(nx, tabin, vmin, vmax, verbose)

def morpho_image2double(imagin, mode, grain, pore, tabout, verbose=False):
    return _gstlearn.morpho_image2double(imagin, mode, grain, pore, tabout, verbose)

def morpho_labelling(option, flag_size, imagin, ccvoid, verbose=False):
    return _gstlearn.morpho_labelling(option, flag_size, imagin, ccvoid, verbose)

def morpho_labelsize(option, imagin):
    return _gstlearn.morpho_labelsize(option, imagin)

def morpho_distance(option, radius, flagDistErode, imagin, dist, verbose=False):
    return _gstlearn.morpho_distance(option, radius, flagDistErode, imagin, dist, verbose)

def gridcell_neigh(ndim, option, radius, flag_center=True, verbose=False):
    return _gstlearn.gridcell_neigh(ndim, option, radius, flag_center, verbose)

def spillPoint(dbgrid, name_depth, name_data, option=0, flag_up=True, verbose_step=0, hmax=1.234e30):
    r"""


    Evaluates the spill point  

    Returns
    -------
    The Spill_Res structure which contains:  

    Returns
    -------
    h elevation of the spill point  

    Returns
    -------
    th maximum reservoir thickness  

    Returns
    -------
    ix0 location of the spill point grid node along X  

    Returns
    -------
    iy0 location of the spill point grid node along Y  

    Parameters
    ----------
    * `dbgrid` :  
        Grid Db structure  
    * `name_depth` :  
        Name of the variable containing the depth  
    * `name_data` :  
        Name of the variable containing the data  
    * `option` :  
        0 for 4-connectivity; 1 for 8-connectivity  
    * `flag_up` :  
        TRUE when working in elevation; FALSE in depth  
    * `verbose_step` :  
        Step for the verbose flag  
    * `hmax` :  
        maximum reservoir thickness (FFFF not used)  

    remark: The variable 'ind_data', which contains the constraints, must  

    remark: be set to:  

    remark: 0 for an idle node  

    remark: 1 for a node located outside the reservoir  

    remark: 2 for a node belonging to the reservoir  

    remark: The numbering of the grid node corresponding to the spill point  

    remark: must start with 1  

    """
    return _gstlearn.spillPoint(dbgrid, name_depth, name_data, option, flag_up, verbose_step, hmax)

def db_morpho_calc(dbgrid, iptr0, oper, vmin, vmax, option, radius, flagDistErode, verbose):
    r"""


    Perform a morphological operation with a DbGrid  

    """
    return _gstlearn.db_morpho_calc(dbgrid, iptr0, oper, vmin, vmax, option, radius, flagDistErode, verbose)

def db_morpho_angle2D(dbgrid, radius, iptr0):
    r"""


    Calculate the gradient orientations of a colored image  

    """
    return _gstlearn.db_morpho_angle2D(dbgrid, radius, iptr0)

def db_morpho_gradients(dbgrid, iptr0):
    r"""


    Calculate the gradient components of a colord image  

    """
    return _gstlearn.db_morpho_gradients(dbgrid, iptr0)
class Polygons(AStringable, ASerializable):
    r"""


    C++ includes: Polygons.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Polygons::Polygons
        """
        _gstlearn.Polygons_swiginit(self, _gstlearn.new_Polygons(*args))
    __swig_destroy__ = _gstlearn.delete_Polygons

    def toString(self, strfmt=None):
        r"""

        Polygons::toString
        Interface to AStringable.  

        """
        return _gstlearn.Polygons_toString(self, strfmt)

    def resetFromDb(self, db, dilate=0., verbose=False):
        r"""

        Polygons::resetFromDb
        """
        return _gstlearn.Polygons_resetFromDb(self, db, dilate, verbose)

    def resetFromCSV(self, filename, csv, verbose=0, ncol_max=-1, nrow_max=-1):
        r"""

        Polygons::resetFromCSV
        Reset the Polygon from a CSV file  

        Parameters
        ----------
        * `filename` :  
            Filename  
        * `csv` :  
            CSV characteristics  
        * `verbose` :  
            Verbose flag  
        * `ncol_max` :  
            Maximum number of columns  
        * `nrow_max` :  
            Maximum number of rows  

        Returns
        -------  

        """
        return _gstlearn.Polygons_resetFromCSV(self, filename, csv, verbose, ncol_max, nrow_max)

    def resetFromWKT(self, filename, csv, verbose=0, ncol_max=-1, nrow_max=-1):
        r"""

        Polygons::resetFromWKT
        Reset the Polygon from a CSV file using WKT format (first column) exported by
        QGIS  

        Parameters
        ----------
        * `filename` :  
            Filename  
        * `csv` :  
            CSV characteristics  
        * `verbose` :  
            Verbose flag  
        * `ncol_max` :  
            Maximum number of columns  
        * `nrow_max` :  
            Maximum number of rows  

        Returns
        -------  

        """
        return _gstlearn.Polygons_resetFromWKT(self, filename, csv, verbose, ncol_max, nrow_max)

    @staticmethod
    def create():
        r"""

        Polygons::create
        """
        return _gstlearn.Polygons_create()

    @staticmethod
    def createFromNF(NFFilename, verbose=False):
        r"""

        Polygons::createFromNF
        """
        return _gstlearn.Polygons_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromCSV(*args, **kwargs):
        r"""

        Polygons::createFromCSV
        """
        return _gstlearn.Polygons_createFromCSV(*args, **kwargs)

    @staticmethod
    def createFromWKT(*args, **kwargs):
        r"""

        Polygons::createFromWKT
        """
        return _gstlearn.Polygons_createFromWKT(*args, **kwargs)

    @staticmethod
    def createFromDb(db, dilate=0., verbose=False):
        r"""

        Polygons::createFromDb
        """
        return _gstlearn.Polygons_createFromDb(db, dilate, verbose)

    def getNPolyElem(self):
        r"""

        Polygons::getNPolyElem
        """
        return _gstlearn.Polygons_getNPolyElem(self)

    def addPolyElem(self, polyelem):
        r"""

        Polygons::addPolyElem
        Add the PolyElem to the list of polygons. This is performed only if the current
        PolyElem contains at least 3 vertices.  

        Parameters
        ----------
        * `polyelem` :  

        """
        return _gstlearn.Polygons_addPolyElem(self, polyelem)

    def getPolyElems(self):
        r"""

        Polygons::getPolyElems
        """
        return _gstlearn.Polygons_getPolyElems(self)

    def getPolyElem(self, ipol):
        r"""

        Polygons::getPolyElem
        """
        return _gstlearn.Polygons_getPolyElem(self, ipol)

    def getClosedPolyElem(self, ipol):
        r"""

        Polygons::getClosedPolyElem
        """
        return _gstlearn.Polygons_getClosedPolyElem(self, ipol)

    def getX(self, ipol):
        r"""

        Polygons::getX
        """
        return _gstlearn.Polygons_getX(self, ipol)

    def getY(self, ipol):
        r"""

        Polygons::getY
        """
        return _gstlearn.Polygons_getY(self, ipol)

    def setX(self, ipol, x):
        r"""

        Polygons::setX
        """
        return _gstlearn.Polygons_setX(self, ipol, x)

    def setY(self, ipol, y):
        r"""

        Polygons::setY
        """
        return _gstlearn.Polygons_setY(self, ipol, y)

    def getExtension(self, xmin, xmax, ymin, ymax):
        r"""

        Polygons::getExtension
        """
        return _gstlearn.Polygons_getExtension(self, xmin, xmax, ymin, ymax)

    def getSurface(self):
        r"""

        Polygons::getSurface
        """
        return _gstlearn.Polygons_getSurface(self)

    def inside(self, coor, flag_nested=False):
        r"""

        Polygons::inside
        Check if one point belongs to a Polygons  

        Returns
        -------
        1 if the point belongs to the Polygons; 0 otherwise  

        Parameters
        ----------
        * `coor` :  
            Vector of coordinates  
        * `flag_nested` :  
            Option for nested polyelems (see details)  

        remark: When coor is dimensioned to 3, the third dimension test is performed  

        remark: If flag_nested=TRUE, a sample is masked off if the number of  

        remark: polyelems to which it belongs is odd  

        remark: If flag_nested=FALSE, a sample is masked off as soon as it  

        remark: belongs to one PolyElem  

        """
        return _gstlearn.Polygons_inside(self, coor, flag_nested)

    def reduceComplexity(self, distmin):
        r"""

        Polygons::reduceComplexity
        """
        return _gstlearn.Polygons_reduceComplexity(self, distmin)

    def __repr__(self):
        return _gstlearn.Polygons___repr__(self)

# Register Polygons in _gstlearn:
_gstlearn.Polygons_swigregister(Polygons)

def db_polygon(*args, **kwargs):
    r"""


    Create a selection if the samples of a Db are inside Polygons  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `polygon` :  
        Polygons structure  
    * `flag_sel` :  
        true if previous selection must be taken into account  
    * `flag_period` :  
        true if first coordinate is longitude (in degree) and must be cycled for the
        check  
    * `flag_nested` :  
        Option for nested polyelems (see details)  
    * `namconv` :  
        Naming Convention  

    remark: If flag_nested=true, a sample is masked off if the number of  

    remark: polyelems to which it belongs is odd  

    remark: If flag_nested=false, a sample is masked off as soon as it  

    remark: belongs to one polyelem  

    remark: The Naming Convention locator Type is overwritten to ELoc::SEL  

    """
    return _gstlearn.db_polygon(*args, **kwargs)

def dbPolygonDistance(*args, **kwargs):
    r"""


    Determine the distance to a polyline  

    Returns
    -------
    Error returned code  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `polygon` :  
        Polygons structure  
    * `dmax` :  
        Maximum distance  
    * `scale` :  
        Scaling option 0 : no scaling >0 : scaling between 0 and 1 <0 : scaling
        between 1 and 0  
    * `polin` :  
        Option for checking against the polygon 0 : no check >0 : if sample is
        outside polygon, return TEST <0 : if sample is inside polygon, return TEST  
    * `namconv` :  
        Naming convention  

    remark: When patching values with respect to the polygon, when abs(polin):  

    remark: 1 : put NA  

    remark: 2 : put minimum distance  

    remark: 3 : put maximum distance  

    """
    return _gstlearn.dbPolygonDistance(*args, **kwargs)

def db_selhull(*args, **kwargs):
    r"""


    Select samples from a file according to the 2-D convex hull computed over the
    active samples of a second file  

    Returns
    -------
    Error returned code  

    Parameters
    ----------
    * `db1` :  
        descriptor of the Db serving for convex hull calculation  
    * `db2` :  
        descriptor of the Db where the mask must be stored  
    * `dilate` :  
        Radius of the dilation  
    * `verbose` :  
        Verbose flag  
    * `namconv` :  
        Naming convention  

    remark: The Naming Convention locator Type is overwritten to ELoc::SEL  

    """
    return _gstlearn.db_selhull(*args, **kwargs)
class PolyElem(PolyLine2D):
    r"""


    C++ includes: PolyElem.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        PolyElem::PolyElem
        """
        _gstlearn.PolyElem_swiginit(self, _gstlearn.new_PolyElem(*args))
    __swig_destroy__ = _gstlearn.delete_PolyElem

    def toString(self, strfmt=None):
        r"""

        PolyElem::toString
        Interface of AStringable.  

        """
        return _gstlearn.PolyElem_toString(self, strfmt)

    @staticmethod
    def create():
        r"""

        PolyElem::create
        """
        return _gstlearn.PolyElem_create()

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        PolyElem::createFromNF
        """
        return _gstlearn.PolyElem_createFromNF(NFFilename, verbose)

    def getX(self, *args):
        r"""

        PolyElem::getX
        """
        return _gstlearn.PolyElem_getX(self, *args)

    def getY(self, *args):
        r"""

        PolyElem::getY
        """
        return _gstlearn.PolyElem_getY(self, *args)

    def getZmax(self):
        r"""

        PolyElem::getZmax
        """
        return _gstlearn.PolyElem_getZmax(self)

    def getZmin(self):
        r"""

        PolyElem::getZmin
        """
        return _gstlearn.PolyElem_getZmin(self)

    def init(self, x, y, zmin=1.234e30, zmax=1.234e30):
        r"""

        PolyElem::init
        """
        return _gstlearn.PolyElem_init(self, x, y, zmin, zmax)

    def getExtension(self, xmin, xmax, ymin, ymax):
        r"""

        PolyElem::getExtension
        """
        return _gstlearn.PolyElem_getExtension(self, xmin, xmax, ymin, ymax)

    def getSurface(self):
        r"""

        PolyElem::getSurface
        """
        return _gstlearn.PolyElem_getSurface(self)

    def closePolyElem(self):
        r"""

        PolyElem::closePolyElem
        Close the PolyElem if necessary  

        """
        return _gstlearn.PolyElem_closePolyElem(self)

    def inside(self, coor):
        r"""

        PolyElem::inside
        Check if one point belongs to a 2-D polyelem  

        Returns
        -------
        True if the point belongs to the polygon; False otherwise  

        Parameters
        ----------
        * `coor` :  
            Vector giving the coordinates of the target point  

        """
        return _gstlearn.PolyElem_inside(self, coor)

    def inside3D(self, zz):
        r"""

        PolyElem::inside3D
        Check if one point belongs to a vertical interval of a (limited) polyelem  

        Returns
        -------
        True if the point belongs to the polygon; False otherwise  

        Parameters
        ----------
        * `zz` :  
            array of point coordinates of the point along Z or TEST  

        """
        return _gstlearn.PolyElem_inside3D(self, zz)

    def reduceComplexity(self, distmin):
        r"""

        PolyElem::reduceComplexity
        """
        return _gstlearn.PolyElem_reduceComplexity(self, distmin)

    def __repr__(self):
        return _gstlearn.PolyElem___repr__(self)

# Register PolyElem in _gstlearn:
_gstlearn.PolyElem_swigregister(PolyElem)

def statOptionToName(opers):
    r"""


    """
    return _gstlearn.statOptionToName(opers)

def KeysToStatOptions(opers):
    r"""


    """
    return _gstlearn.KeysToStatOptions(opers)

def dbStatisticsMono(*args, **kwargs):
    return _gstlearn.dbStatisticsMono(*args, **kwargs)

def dbStatisticsCorrel(*args, **kwargs):
    return _gstlearn.dbStatisticsCorrel(*args, **kwargs)

def dbStatisticsPrint(*args, **kwargs):
    return _gstlearn.dbStatisticsPrint(*args, **kwargs)

def dbStatisticsMulti(*args, **kwargs):
    return _gstlearn.dbStatisticsMulti(*args, **kwargs)

def dbStatisticsPerCell(*args, **kwargs):
    return _gstlearn.dbStatisticsPerCell(*args, **kwargs)

def statisticsProportion(dbin, dbout, pos, nfacies, radius):
    r"""


    Calculates the "montee" from a grid into a 1-D grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Db for the input grid  
    * `dbout` :  
        Db for the output grid  
    * `pos` :  
        Rank of the montee axis (starting from 0)  
    * `nfacies` :  
        Number of facies  
    * `radius` :  
        Radius of the neighborhood  

    """
    return _gstlearn.statisticsProportion(dbin, dbout, pos, nfacies, radius)

def statisticsTransition(dbin, dbout, pos, nfacies, radius, orient):
    r"""


    Calculates the transition from a grid into a 1-D grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Db for the input grid  
    * `dbout` :  
        Db for the output grid  
    * `pos` :  
        Rank of the montee axis (starting from 0)  
    * `nfacies` :  
        Number of facies  
    * `radius` :  
        Radius of the neighborhood  
    * `orient` :  
        Orientation (+1 or -1)  

    """
    return _gstlearn.statisticsTransition(dbin, dbout, pos, nfacies, radius, orient)

def dbStatisticsFacies(db):
    r"""


    Considering that the Unique variable is a Facies (positive integer) returns the
    vector of proportions  

    Returns
    -------
    The vector of proportions per Facies  

    Parameters
    ----------
    * `db` :  
        Db structure  

    """
    return _gstlearn.dbStatisticsFacies(db)

def dbStatisticsIndicator(db):
    r"""


    Considering that the Unique variable is an Indicator (0 or 1) returns the
    proportion of 1  

    Returns
    -------
    The vector of proportions per Facies  

    Parameters
    ----------
    * `db` :  
        Db structure  

    """
    return _gstlearn.dbStatisticsIndicator(db)

def sphering(X):
    r"""


    Sphering procedure  

    Parameters
    ----------
    * `X` :  
        Input Data vector  

    Returns
    -------
    The Sphering matrix (or nullptr if problem)  

    remark: When performing the (forward) sphering, you must perform the following
        operation  

    remark: X <- prodMatMat(X, S)  

    """
    return _gstlearn.sphering(X)

def correlationPairs(db1, db2, name1, name2, flagFrom1=False, verbose=False):
    r"""


    Evaluate the correlation Correl(Z1(x) , Z2(x))  

    Returns
    -------
    Array of the indices of pairs of samples (or VectorVectorInt())  

    Parameters
    ----------
    * `db1` :  
        Db descriptor (first variable)  
    * `db2` :  
        Db descriptor (second variable for flag.same=T)  
    * `name1` :  
        Name of the first variable  
    * `name2` :  
        Name of the second variable  
    * `flagFrom1` :  
        Start numbering of indices from 1 if True  
    * `verbose` :  
        Verbose flag  

    remark: The two input Db must match exactly (same number of samples with  

    remark: same set of coordinates and same optional selection)  

    remark: The returned Vector of Vector of integer 'indices' contain  

    remark: the set of indices of the pairs of samples.  

    remark: Its contents is i1,j1,i2,j2,...  

    remark: The indices are numbered starting from 0  

    """
    return _gstlearn.correlationPairs(db1, db2, name1, name2, flagFrom1, verbose)

def hscatterPairs(db, name1, name2, varioparam, ilag=0, idir=0, verbose=False):
    r"""


    Evaluate the shifted correlation calculated as follows: Correl(Z1(x) , Z2(x+h))  

    Returns
    -------
    Vector of indices (or VectorVectorInt())  

    Parameters
    ----------
    * `db` :  
        Db descriptor  
    * `name1` :  
        Name of the first variable  
    * `name2` :  
        Name of the second variable  
    * `varioparam` :  
        pointer to a VarioParam structure  
    * `ilag` :  
        Rank of the lag of interest  
    * `idir` :  
        Rank of the direction of interest (within VarioParam)  
    * `verbose` :  
        Verbose flag  

    remark: The returned Vector of Vector of integer 'indices' contain  

    remark: the set of indices of the pairs of samples.  

    remark: Its contents is i1,j1,i2,j2,...  

    remark: The indices are numbered starting from 1  

    """
    return _gstlearn.hscatterPairs(db, name1, name2, varioparam, ilag, idir, verbose)

def correlationIdentify(db1, db2, icol1, icol2, polygon):
    r"""


    Identify samples from scatter plot when included within a polygon  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db1` :  
        Db descriptor (first variable)  
    * `db2` :  
        Db descriptor (second variable for flag.same=T)  
    * `icol1` :  
        Rank of the first column  
    * `icol2` :  
        Rank of the second column  
    * `polygon` :  
        Polygons structure  

    remark: The two input Db must match exactly (same number of samples with  

    remark: same set of coordinates and same optional selection)  

    """
    return _gstlearn.correlationIdentify(db1, db2, icol1, icol2, polygon)

def condexp(db1, db2, icol1, icol2, mini, maxi, nclass, verbose=False):
    r"""


    Evaluate the experimental conditional expectation  

    Parameters
    ----------
    * `db1` :  
        Db descriptor (for target variable)  
    * `db2` :  
        Db descriptor (for auxiliary variables)  
    * `icol1` :  
        Rank of the target variable  
    * `icol2` :  
        Rank of the explanatory variable  
    * `mini` :  
        Minimum value for the explanaroty variable  
    * `maxi` :  
        Maximum value for the explanaroty variable  
    * `nclass` :  
        Number of classes  
    * `verbose` :  
        Verbose flag  

    """
    return _gstlearn.condexp(db1, db2, icol1, icol2, mini, maxi, nclass, verbose)

def contingencyTable(values):
    r"""


    """
    return _gstlearn.contingencyTable(values)

def contingencyTable2(values, bins):
    r"""


    """
    return _gstlearn.contingencyTable2(values, bins)

def dbVarianceMatrix(db):
    r"""


    Calculate the variance-covariance matrix on the isotopic data set from the
    Z-locator variables.  

    Parameters
    ----------
    * `db` :  
        Target Data Base  

    """
    return _gstlearn.dbVarianceMatrix(db)
class PCA(AStringable):
    r"""


    C++ includes: PCA.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        PCA::PCA
        """
        _gstlearn.PCA_swiginit(self, _gstlearn.new_PCA(*args))
    __swig_destroy__ = _gstlearn.delete_PCA

    def toString(self, strfmt=None):
        r"""

        PCA::toString
        Interface for AStringable.  

        """
        return _gstlearn.PCA_toString(self, strfmt)

    def init(self, nvar):
        r"""

        PCA::init
        """
        return _gstlearn.PCA_init(self, nvar)

    def getEigVals(self):
        r"""

        PCA::getEigVals
        """
        return _gstlearn.PCA_getEigVals(self)

    def getEigVal(self, ivar):
        r"""

        PCA::getEigVal
        """
        return _gstlearn.PCA_getEigVal(self, ivar)

    def getEigVecs(self):
        r"""

        PCA::getEigVecs
        """
        return _gstlearn.PCA_getEigVecs(self)

    def getEigVec(self, ivar, jvar):
        r"""

        PCA::getEigVec
        """
        return _gstlearn.PCA_getEigVec(self, ivar, jvar)

    def getVarianceRatio(self):
        r"""

        PCA::getVarianceRatio
        """
        return _gstlearn.PCA_getVarianceRatio(self)

    def getMeans(self):
        r"""

        PCA::getMeans
        """
        return _gstlearn.PCA_getMeans(self)

    def getMean(self, ivar):
        r"""

        PCA::getMean
        """
        return _gstlearn.PCA_getMean(self, ivar)

    def getC0(self):
        r"""

        PCA::getC0
        """
        return _gstlearn.PCA_getC0(self)

    def getNVar(self):
        r"""

        PCA::getNVar
        """
        return _gstlearn.PCA_getNVar(self)

    def getF2Zs(self):
        r"""

        PCA::getF2Zs
        """
        return _gstlearn.PCA_getF2Zs(self)

    def getZ2Fs(self):
        r"""

        PCA::getZ2Fs
        """
        return _gstlearn.PCA_getZ2Fs(self)

    def getSigmas(self):
        r"""

        PCA::getSigmas
        """
        return _gstlearn.PCA_getSigmas(self)

    def getSigma(self, ivar):
        r"""

        PCA::getSigma
        """
        return _gstlearn.PCA_getSigma(self, ivar)

    def setMeans(self, mean):
        r"""

        PCA::setMeans
        """
        return _gstlearn.PCA_setMeans(self, mean)

    def setSigmas(self, sigma):
        r"""

        PCA::setSigmas
        """
        return _gstlearn.PCA_setSigmas(self, sigma)

    def setZ2Fs(self, z2f):
        r"""

        PCA::setZ2Fs
        """
        return _gstlearn.PCA_setZ2Fs(self, z2f)

    def setF2Zs(self, f2z):
        r"""

        PCA::setF2Zs
        """
        return _gstlearn.PCA_setF2Zs(self, f2z)

    def setEigVals(self, eigval):
        r"""

        PCA::setEigVals
        """
        return _gstlearn.PCA_setEigVals(self, eigval)

    def setEigVal(self, ivar, eigval):
        r"""

        PCA::setEigVal
        """
        return _gstlearn.PCA_setEigVal(self, ivar, eigval)

    def setEigVecs(self, eigvec):
        r"""

        PCA::setEigVecs
        """
        return _gstlearn.PCA_setEigVecs(self, eigvec)

    def setEigVec(self, ivar, jvar, eigvec):
        r"""

        PCA::setEigVec
        """
        return _gstlearn.PCA_setEigVec(self, ivar, jvar, eigvec)

    def pca_compute(self, db, verbose=False, optionPositive=True):
        r"""

        PCA::pca_compute
        """
        return _gstlearn.PCA_pca_compute(self, db, verbose, optionPositive)

    def maf_compute(self, db, varioparam, ilag0=1, idir0=0, verbose=False):
        r"""

        PCA::maf_compute
        Evaluate the MAF  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db descriptor  
        * `varioparam` :  
            VarioParam structure  
        * `ilag0` :  
            Reference Lag  
        * `idir0` :  
            Reference direction  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.PCA_maf_compute(self, db, varioparam, ilag0, idir0, verbose)

    def maf_compute_interval(self, db, hmin, hmax, verbose=False):
        r"""

        PCA::maf_compute_interval
        Evaluate the MAF  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db descriptor  
        * `hmin` :  
            Lower bound on distance  
        * `hmax` :  
            Upper bound on distance  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.PCA_maf_compute_interval(self, db, hmin, hmax, verbose)

    def dbZ2F(self, *args, **kwargs):
        r"""

        PCA::dbZ2F
        """
        return _gstlearn.PCA_dbZ2F(self, *args, **kwargs)

    def dbF2Z(self, *args, **kwargs):
        r"""

        PCA::dbF2Z
        """
        return _gstlearn.PCA_dbF2Z(self, *args, **kwargs)

    def mafOfIndex(self):
        r"""

        PCA::mafOfIndex
        """
        return _gstlearn.PCA_mafOfIndex(self)

    def __repr__(self):
        return _gstlearn.PCA___repr__(self)

# Register PCA in _gstlearn:
_gstlearn.PCA_swigregister(PCA)
class PCAStringFormat(AStringFormat):
    r"""


    C++ includes: PCAStringFormat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        PCAStringFormat::PCAStringFormat
        """
        _gstlearn.PCAStringFormat_swiginit(self, _gstlearn.new_PCAStringFormat(*args))
    __swig_destroy__ = _gstlearn.delete_PCAStringFormat

    def getflagCenter(self):
        r"""

        PCAStringFormat::getflagCenter
        """
        return _gstlearn.PCAStringFormat_getflagCenter(self)

    def getflagStats(self):
        r"""

        PCAStringFormat::getflagStats
        """
        return _gstlearn.PCAStringFormat_getflagStats(self)

    def setflagCenter(self, flagCenter):
        r"""

        PCAStringFormat::setflagCenter
        """
        return _gstlearn.PCAStringFormat_setflagCenter(self, flagCenter)

    def setflagStats(self, flagStats):
        r"""

        PCAStringFormat::setflagStats
        """
        return _gstlearn.PCAStringFormat_setflagStats(self, flagStats)

# Register PCAStringFormat in _gstlearn:
_gstlearn.PCAStringFormat_swigregister(PCAStringFormat)
class Selectivity(AStringable, ICloneable):
    r"""


    C++ includes: Selectivity.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Selectivity::Selectivity
        """
        _gstlearn.Selectivity_swiginit(self, _gstlearn.new_Selectivity(*args))
    __swig_destroy__ = _gstlearn.delete_Selectivity

    def clone(self):
        r"""

        ICloneable::clone
        """
        return _gstlearn.Selectivity_clone(self)

    def toString(self, strfmt=None):
        r"""

        Selectivity::toString
        ICloneable interface.  

        AStringable Interface  

        """
        return _gstlearn.Selectivity_toString(self, strfmt)

    @staticmethod
    def create(ncut):
        r"""

        Selectivity::create
        """
        return _gstlearn.Selectivity_create(ncut)

    @staticmethod
    def createByCuts(zcut):
        r"""

        Selectivity::createByCuts
        """
        return _gstlearn.Selectivity_createByCuts(zcut)

    @staticmethod
    def createByCodes(*args, **kwargs):
        r"""

        Selectivity::createByCodes
        """
        return _gstlearn.Selectivity_createByCodes(*args, **kwargs)

    @staticmethod
    def createByKeys(*args, **kwargs):
        r"""

        Selectivity::createByKeys
        """
        return _gstlearn.Selectivity_createByKeys(*args, **kwargs)

    @staticmethod
    def createInterpolation(zcuts, selecin, verbose):
        r"""

        Selectivity::createInterpolation
        Interpolate the Grade-Tonnage curves  

        Parameters
        ----------
        * `zcuts` :  
            Array of cutoffs  
        * `selecin` :  
            Input Selectivity  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.Selectivity_createInterpolation(zcuts, selecin, verbose)

    def calculateFromDb(self, db, autoCuts=False):
        r"""

        Selectivity::calculateFromDb
        """
        return _gstlearn.Selectivity_calculateFromDb(self, db, autoCuts)

    def calculateFromArray(self, *args, **kwargs):
        r"""

        Selectivity::calculateFromArray
        """
        return _gstlearn.Selectivity_calculateFromArray(self, *args, **kwargs)

    def calculateFromAnamorphosis(self, anam):
        r"""

        Selectivity::calculateFromAnamorphosis
        """
        return _gstlearn.Selectivity_calculateFromAnamorphosis(self, anam)

    def eval(self, db, autoCuts=False):
        r"""

        Selectivity::eval
        """
        return _gstlearn.Selectivity_eval(self, db, autoCuts)

    def evalFromArray(self, *args, **kwargs):
        r"""

        Selectivity::evalFromArray
        """
        return _gstlearn.Selectivity_evalFromArray(self, *args, **kwargs)

    def evalFromAnamorphosis(self, anam):
        r"""

        Selectivity::evalFromAnamorphosis
        """
        return _gstlearn.Selectivity_evalFromAnamorphosis(self, anam)

    def resetCuts(self, zcuts):
        r"""

        Selectivity::resetCuts
        """
        return _gstlearn.Selectivity_resetCuts(self, zcuts)

    def getNCuts(self):
        r"""

        Selectivity::getNCuts
        """
        return _gstlearn.Selectivity_getNCuts(self)

    @staticmethod
    def getNQT():
        r"""

        Selectivity::getNQT
        """
        return _gstlearn.Selectivity_getNQT()

    def getNVar(self):
        r"""

        Selectivity::getNVar
        """
        return _gstlearn.Selectivity_getNVar(self)

    def getVariableName(self, *args):
        r"""

        Selectivity::getVariableName
        """
        return _gstlearn.Selectivity_getVariableName(self, *args)

    def getVariableNames(self):
        r"""

        Selectivity::getVariableNames
        """
        return _gstlearn.Selectivity_getVariableNames(self)

    def setZcut(self, iclass, zcut):
        r"""

        Selectivity::setZcut
        """
        return _gstlearn.Selectivity_setZcut(self, iclass, zcut)

    def setBest(self, iclass, best):
        r"""

        Selectivity::setBest
        """
        return _gstlearn.Selectivity_setBest(self, iclass, best)

    def setMest(self, iclass, mest):
        r"""

        Selectivity::setMest
        """
        return _gstlearn.Selectivity_setMest(self, iclass, mest)

    def setQest(self, iclass, qest):
        r"""

        Selectivity::setQest
        """
        return _gstlearn.Selectivity_setQest(self, iclass, qest)

    def setQstd(self, iclass, qstd):
        r"""

        Selectivity::setQstd
        """
        return _gstlearn.Selectivity_setQstd(self, iclass, qstd)

    def setTest(self, iclass, test):
        r"""

        Selectivity::setTest
        """
        return _gstlearn.Selectivity_setTest(self, iclass, test)

    def setTstd(self, iclass, tstd):
        r"""

        Selectivity::setTstd
        """
        return _gstlearn.Selectivity_setTstd(self, iclass, tstd)

    def getBest(self, iclass):
        r"""

        Selectivity::getBest
        """
        return _gstlearn.Selectivity_getBest(self, iclass)

    def getMest(self, iclass):
        r"""

        Selectivity::getMest
        """
        return _gstlearn.Selectivity_getMest(self, iclass)

    def getQest(self, iclass):
        r"""

        Selectivity::getQest
        """
        return _gstlearn.Selectivity_getQest(self, iclass)

    def getQstd(self, iclass):
        r"""

        Selectivity::getQstd
        """
        return _gstlearn.Selectivity_getQstd(self, iclass)

    def getTest(self, iclass):
        r"""

        Selectivity::getTest
        """
        return _gstlearn.Selectivity_getTest(self, iclass)

    def getTstd(self, iclass):
        r"""

        Selectivity::getTstd
        """
        return _gstlearn.Selectivity_getTstd(self, iclass)

    def getZcut(self, *args):
        r"""

        Selectivity::getZcut
        """
        return _gstlearn.Selectivity_getZcut(self, *args)

    def calculateBenefitAndGrade(self):
        r"""

        Selectivity::calculateBenefitAndGrade
        From the cutoff, tonnage and metal quantity, derive the conventional benefit and
        the average recovered grade  

        """
        return _gstlearn.Selectivity_calculateBenefitAndGrade(self)

    def dumpGini(self):
        r"""

        Selectivity::dumpGini
        Calculate and print the Gini index  

        """
        return _gstlearn.Selectivity_dumpGini(self)

    def correctTonnageOrder(self):
        r"""

        Selectivity::correctTonnageOrder
        Correct the order relationship for Tonnage  

        """
        return _gstlearn.Selectivity_correctTonnageOrder(self)

    def defineRecoveries(self, codes, flag_est, flag_std, proba=1.234e30, verbose=False):
        r"""

        Selectivity::defineRecoveries
        Analyze the contents of the codes  

        Parameters
        ----------
        * `codes` :  
            Array of selectivity codes  
        * `flag_est` :  
            True for estimation  
        * `flag_std` :  
            True for st. dev.  
        * `proba` :  
            Probability value (or TEST)  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.Selectivity_defineRecoveries(self, codes, flag_est, flag_std, proba, verbose)

    def isUsed(self, code):
        r"""

        Selectivity::isUsed
        """
        return _gstlearn.Selectivity_isUsed(self, code)

    def isUsedEst(self, code):
        r"""

        Selectivity::isUsedEst
        """
        return _gstlearn.Selectivity_isUsedEst(self, code)

    def isUsedStD(self, code):
        r"""

        Selectivity::isUsedStD
        """
        return _gstlearn.Selectivity_isUsedStD(self, code)

    def isNeededT(self):
        r"""

        Selectivity::isNeededT
        """
        return _gstlearn.Selectivity_isNeededT(self)

    def isNeededQ(self):
        r"""

        Selectivity::isNeededQ
        """
        return _gstlearn.Selectivity_isNeededQ(self)

    def getAddressQTEst(self, code, iptr0, rank=0):
        r"""

        Selectivity::getAddressQTEst
        """
        return _gstlearn.Selectivity_getAddressQTEst(self, code, iptr0, rank)

    def getAddressQTStd(self, code, iptr0, rank=0):
        r"""

        Selectivity::getAddressQTStd
        """
        return _gstlearn.Selectivity_getAddressQTStd(self, code, iptr0, rank)

    def getNQTStd(self, code):
        r"""

        Selectivity::getNQTStd
        """
        return _gstlearn.Selectivity_getNQTStd(self, code)

    def getNQTEst(self, *args):
        r"""

        Selectivity::getNQTEst
        """
        return _gstlearn.Selectivity_getNQTEst(self, *args)

    def geNQTStd(self):
        r"""

        Selectivity::geNQTStd
        """
        return _gstlearn.Selectivity_geNQTStd(self)

    def storeInDb(self, db, iech0, iptr, zestim, zstdev):
        r"""

        Selectivity::storeInDb
        Store the local results of the recovery  

        Parameters
        ----------
        * `db` :  
            Db structure containing the factors (Z-locators)  
        * `iech0` :  
            Rank of the target sample  
        * `iptr` :  
            Rank for storing the results  
        * `zestim` :  
            Estimated grade  
        * `zstdev` :  
            St. dev.  

        """
        return _gstlearn.Selectivity_storeInDb(self, db, iech0, iptr, zestim, zstdev)

    def interpolateSelectivity(self, selecin):
        r"""

        Selectivity::interpolateSelectivity
        Interpolate the QT curves (Local estimation)  

        Parameters
        ----------
        * `selecin` :  
            Selectivity  

        """
        return _gstlearn.Selectivity_interpolateSelectivity(self, selecin)

    def setFlagTonnageCorrect(self, flagTonnageCorrect):
        r"""

        Selectivity::setFlagTonnageCorrect
        """
        return _gstlearn.Selectivity_setFlagTonnageCorrect(self, flagTonnageCorrect)

    def setZmax(self, zmax):
        r"""

        Selectivity::setZmax
        """
        return _gstlearn.Selectivity_setZmax(self, zmax)

    def isFlagTonnageCorrect(self):
        r"""

        Selectivity::isFlagTonnageCorrect
        """
        return _gstlearn.Selectivity_isFlagTonnageCorrect(self)

    def getZmax(self):
        r"""

        Selectivity::getZmax
        """
        return _gstlearn.Selectivity_getZmax(self)

    def isOnlyZDefined(self):
        r"""

        Selectivity::isOnlyZDefined
        """
        return _gstlearn.Selectivity_isOnlyZDefined(self)

    def getStats(self):
        r"""

        Selectivity::getStats
        """
        return _gstlearn.Selectivity_getStats(self)

    def getAllStats(self):
        r"""

        Selectivity::getAllStats
        """
        return _gstlearn.Selectivity_getAllStats(self)

    def getCountQT(self):
        r"""

        Selectivity::getCountQT
        """
        return _gstlearn.Selectivity_getCountQT(self)

    def getRankQt(self):
        r"""

        Selectivity::getRankQt
        """
        return _gstlearn.Selectivity_getRankQt(self)

    def __repr__(self):
        return _gstlearn.Selectivity___repr__(self)

# Register Selectivity in _gstlearn:
_gstlearn.Selectivity_swigregister(Selectivity)

def dbSelectivity(*args, **kwargs):
    r"""


    """
    return _gstlearn.dbSelectivity(*args, **kwargs)
class Regression(AStringable):
    r"""


    C++ includes: Regression.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Regression::Regression
        """
        _gstlearn.Regression_swiginit(self, _gstlearn.new_Regression(*args))
    __swig_destroy__ = _gstlearn.delete_Regression

    def toString(self, strfmt=None):
        r"""

        Regression::toString
        Interface for AStringable.  

        """
        return _gstlearn.Regression_toString(self, strfmt)

    def setCoeffs(self, coeffs):
        r"""

        Regression::setCoeffs
        """
        return _gstlearn.Regression_setCoeffs(self, coeffs)

    def setCount(self, count):
        r"""

        Regression::setCount
        """
        return _gstlearn.Regression_setCount(self, count)

    def setFlagCst(self, flagCst):
        r"""

        Regression::setFlagCst
        """
        return _gstlearn.Regression_setFlagCst(self, flagCst)

    def setNvar(self, nvar):
        r"""

        Regression::setNvar
        """
        return _gstlearn.Regression_setNvar(self, nvar)

    def setVariance(self, variance):
        r"""

        Regression::setVariance
        """
        return _gstlearn.Regression_setVariance(self, variance)

    def setVarres(self, varres):
        r"""

        Regression::setVarres
        """
        return _gstlearn.Regression_setVarres(self, varres)

    def getCoeffs(self):
        r"""

        Regression::getCoeffs
        """
        return _gstlearn.Regression_getCoeffs(self)

    def getCoeff(self, i):
        r"""

        Regression::getCoeff
        """
        return _gstlearn.Regression_getCoeff(self, i)

    def getNvar(self):
        r"""

        Regression::getNvar
        """
        return _gstlearn.Regression_getNvar(self)

    def getCount(self):
        r"""

        Regression::getCount
        """
        return _gstlearn.Regression_getCount(self)

    def getVariance(self):
        r"""

        Regression::getVariance
        """
        return _gstlearn.Regression_getVariance(self)

    def getVarres(self):
        r"""

        Regression::getVarres
        """
        return _gstlearn.Regression_getVarres(self)

    def apply(self, db1, iptr0, nameResp, nameAux, mode=0, flagCst=False, db2=None, model=None):
        r"""

        Regression::apply
        Evaluate the regression  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db1` :  
            Db descriptor (for target variable)  
        * `iptr0` :  
            Storing address (already allocated)  
        * `nameResp` :  
            Name of the target variable  
        * `nameAux` :  
            Vector of names of the explanatory variables  
        * `mode` :  
            Type of calculation  

            *   0 : standard multivariate case  
            *   1 : using external drifts  
            *   2 : using standard drift functions (mode==2)  
        * `flagCst` :  
            The constant is added as explanatory variable]  
        * `db2` :  
            Db descriptor (for auxiliary variables)  
        * `model` :  
            Model descriptor  

        remark: The flag_mode indicates the type of regression calculation:  

        remark: 0 : V[icol] as a function of V[icols[i]]  

        remark: 1 : Z1 as a function of the different Fi's  

        remark: The Db1 structure is modified: the column (iptr0) of the Db1  

        remark: is added by this function; it contains the value  

        remark: of the residuals at each datum (or TEST if the residual has not  

        remark: been calculated).  

        """
        return _gstlearn.Regression_apply(self, db1, iptr0, nameResp, nameAux, mode, flagCst, db2, model)

    def __repr__(self):
        return _gstlearn.Regression___repr__(self)

# Register Regression in _gstlearn:
_gstlearn.Regression_swigregister(Regression)

def regression(*args, **kwargs):
    r"""


    Evaluate the regression  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db1` :  
        Db descriptor (for target variable)  
    * `nameResp` :  
        Name of the target variable  
    * `nameAux` :  
        Vector of names of the explanatory variables  
    * `mode` :  
        Type of calculation  

        *   0 : standard multivariate case  
        *   1 : using external drifts  
        *   2 : using standard drift functions (in 'model')  
    * `flagCst` :  
        The constant is added as explanatory variable  
    * `db2` :  
        Db descriptor (for auxiliary variables)  
    * `model` :  
        Model (only used for Drift functions if mode==2)  

    remark: The flag_mode indicates the type of regression calculation:  

    remark: 0 : V[icol] as a function of V[icols[i]]  

    remark: 1 : Z1 as a function of the different Fi's  

    """
    return _gstlearn.regression(*args, **kwargs)

def regressionDeming(x, y, delta=1):
    r"""


    Calculate the coefficients of the Deming regression (with 2 variables)  

    Parameters
    ----------
    * `x` :  
        Vector for the first variable  
    * `y` :  
        Vector for the second variable  
    * `delta` :  
        ratio of error variances (s_y^2 / s_x^2)  

    Returns
    -------
    Vector of coefficients for the equation  

    Returns
    -------
    y = beta[0] + beta[1] * x  

    remark: Both input vectors are assumed to contain valid values  

    remark: From: https://en.wikipedia.org/wiki/Deming_regression  

    """
    return _gstlearn.regressionDeming(x, y, delta)
class Rule(AStringable, ASerializable):
    r"""


    C++ includes: Rule.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        Rule::Rule
        """
        _gstlearn.Rule_swiginit(self, _gstlearn.new_Rule(*args))
    __swig_destroy__ = _gstlearn.delete_Rule

    def toString(self, strfmt=None):
        r"""

        Rule::toString
        """
        return _gstlearn.Rule_toString(self, strfmt)

    def resetFromNames(self, nodnames, rho=0.):
        r"""

        Rule::resetFromNames
        """
        return _gstlearn.Rule_resetFromNames(self, nodnames, rho)

    def resetFromCodes(self, nodes, rho=0.):
        r"""

        Rule::resetFromCodes
        """
        return _gstlearn.Rule_resetFromCodes(self, nodes, rho)

    def resetFromNumericalCoding(self, n_type, n_facs, rho=0.):
        r"""

        Rule::resetFromNumericalCoding
        This entry is specific for the Rule inference procedure  

        Parameters
        ----------
        * `n_type` :  
            Vector of items: 0 for Facies, 1 for G1 threshold; 2 for G2 threshold  
        * `n_facs` :  
            Vector of facies: XXX for Facies, 0 for thresholds  
        * `rho` :  
            GRFs correlation coefficient  

        Returns
        -------  

        """
        return _gstlearn.Rule_resetFromNumericalCoding(self, n_type, n_facs, rho)

    def resetFromFaciesCount(self, nfacies, rho=0.):
        r"""

        Rule::resetFromFaciesCount
        """
        return _gstlearn.Rule_resetFromFaciesCount(self, nfacies, rho)

    @staticmethod
    def create(rho=0.):
        r"""

        Rule::create
        """
        return _gstlearn.Rule_create(rho)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        Rule::createFromNF
        """
        return _gstlearn.Rule_createFromNF(NFFilename, verbose)

    @staticmethod
    def createFromNames(nodnames, rho=0.):
        r"""

        Rule::createFromNames
        """
        return _gstlearn.Rule_createFromNames(nodnames, rho)

    @staticmethod
    def createFromCodes(nodes, rho=0.):
        r"""

        Rule::createFromCodes
        """
        return _gstlearn.Rule_createFromCodes(nodes, rho)

    @staticmethod
    def createFromNumericalCoding(n_type, n_facs, rho=0.):
        r"""

        Rule::createFromNumericalCoding
        """
        return _gstlearn.Rule_createFromNumericalCoding(n_type, n_facs, rho)

    @staticmethod
    def createFromFaciesCount(nfacies, rho=0.):
        r"""

        Rule::createFromFaciesCount
        """
        return _gstlearn.Rule_createFromFaciesCount(nfacies, rho)

    def displaySpecific(self):
        r"""

        Rule::displaySpecific
        """
        return _gstlearn.Rule_displaySpecific(self)

    def particularities(self, db, dbprop, model, flag_grid_check, flag_stat):
        r"""

        Rule::particularities
        Define the particularities of the PGS model  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `dbprop` :  
            Db structure used for proportions  
        * `model` :  
            Model structure (only used for shift option)  
        * `flag_grid_check` :  
            1 if grid is compulsory; 0 otherwise (only for SHIFT)  
        * `flag_stat` :  
            1 for stationary; 0 otherwise  

        """
        return _gstlearn.Rule_particularities(self, db, dbprop, model, flag_grid_check, flag_stat)

    def checkModel(self, model, nvar=0):
        r"""

        Rule::checkModel
        """
        return _gstlearn.Rule_checkModel(self, model, nvar)

    def gaus2facData(self, propdef, dbin, dbout, flag_used, ipgs, isimu, nbsimu):
        r"""

        Rule::gaus2facData
        Combine the underlying GRF into a facies value at data points  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `propdef` :  
            Props structure  
        * `dbin` :  
            Db input structure  
        * `dbout` :  
            Db output structure  
        * `flag_used` :  
            1 if the gaussian is used; 0 otherwise  
        * `ipgs` :  
            Rank of the PGS  
        * `isimu` :  
            Rank of the simulation  
        * `nbsimu` :  
            Number of simulations  

        remark: Attributes ELoc::GAUSFAC are mandatory  

        remark: Attributes ELoc::FACIES are mandatory  

        """
        return _gstlearn.Rule_gaus2facData(self, propdef, dbin, dbout, flag_used, ipgs, isimu, nbsimu)

    def gaus2facResult(self, propdef, dbout, flag_used, ipgs, isimu, nbsimu):
        r"""

        Rule::gaus2facResult
        Combine the underlying GRF into a facies value  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `propdef` :  
            Props structure  
        * `dbout` :  
            Db output structure  
        * `flag_used` :  
            1 if the gaussian is used; 0 otherwise  
        * `ipgs` :  
            Rank of the PGS  
        * `isimu` :  
            Rank of the simulation  
        * `nbsimu` :  
            Number of simulations  

        remark: Attributes ELoc::FACIES and ELoc::SIMU are mandatory  

        """
        return _gstlearn.Rule_gaus2facResult(self, propdef, dbout, flag_used, ipgs, isimu, nbsimu)

    def evaluateBounds(self, propdef, dbin, dbout, isimu, igrf, ipgs, nbsimu):
        r"""

        Rule::evaluateBounds
        Set the bounds and possibly add replicates  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `propdef` :  
            PropDef structure  
        * `dbin` :  
            Db structure  
        * `dbout` :  
            Db grid structure  
        * `isimu` :  
            Rank of the simulation (if EProcessOper::CONDITIONAL)  
        * `igrf` :  
            Rank of the GRF  
        * `ipgs` :  
            Rank of the GS  
        * `nbsimu` :  
            Number of simulations (if EProcessOper::CONDITIONAL)  

        """
        return _gstlearn.Rule_evaluateBounds(self, propdef, dbin, dbout, isimu, igrf, ipgs, nbsimu)

    def getFlagProp(self):
        r"""

        Rule::getFlagProp
        """
        return _gstlearn.Rule_getFlagProp(self)

    def getModeRule(self):
        r"""

        Rule::getModeRule
        """
        return _gstlearn.Rule_getModeRule(self)

    def getRho(self):
        r"""

        Rule::getRho
        """
        return _gstlearn.Rule_getRho(self)

    def getMainNode(self):
        r"""

        Rule::getMainNode
        """
        return _gstlearn.Rule_getMainNode(self)

    def setFlagProp(self, flagProp):
        r"""

        Rule::setFlagProp
        """
        return _gstlearn.Rule_setFlagProp(self, flagProp)

    def setRho(self, rho):
        r"""

        Rule::setRho
        """
        return _gstlearn.Rule_setRho(self, rho)

    def setModeRule(self, modeRule):
        r"""

        Rule::setModeRule
        TODO : Check if mutable is really necessary.  

        """
        return _gstlearn.Rule_setModeRule(self, modeRule)

    def setProportions(self, *args, **kwargs):
        r"""

        Rule::setProportions
        Define constant proportions  

        Parameters
        ----------
        * `proportions` :  
            The vector of constant proportions. It should be dimensioned to the number
            of facies. If absent, all proportions are considered equal.  

        Returns
        -------  

        """
        return _gstlearn.Rule_setProportions(self, *args, **kwargs)

    def statistics(self, verbose, node_tot, nfac_tot, nmax_tot, ny1_tot, ny2_tot, prop_tot):
        r"""

        Rule::statistics
        Calculates the statistics from the Lithotype Rule  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `verbose` :  
            1 for a verbose output; 0 otherwise  
        * `node_tot` :  
            Number of nodes  
        * `nfac_tot` :  
            Number of facies  
        * `nmax_tot` :  
            Number of (different) facies  
        * `ny1_tot` :  
            Number of thresholds for Y1  
        * `ny2_tot` :  
            Number of thresholds for Y2  
        * `prop_tot` :  
            Total proportion  

        remark: The tolerance on the sum of the proportions can be defined  

        remark: using set_keypair("TolSumProportions",newtol)  

        """
        return _gstlearn.Rule_statistics(self, verbose, node_tot, nfac_tot, nmax_tot, ny1_tot, ny2_tot, prop_tot)

    def getNFacies(self):
        r"""

        Rule::getNFacies
        """
        return _gstlearn.Rule_getNFacies(self)

    def getNGRF(self):
        r"""

        Rule::getNGRF
        """
        return _gstlearn.Rule_getNGRF(self)

    def getNY1(self):
        r"""

        Rule::getNY1
        """
        return _gstlearn.Rule_getNY1(self)

    def getNY2(self):
        r"""

        Rule::getNY2
        """
        return _gstlearn.Rule_getNY2(self)

    def isYUsed(self, igrf):
        r"""

        Rule::isYUsed
        """
        return _gstlearn.Rule_isYUsed(self, igrf)

    def whichGRFUsed(self):
        r"""

        Rule::whichGRFUsed
        """
        return _gstlearn.Rule_whichGRFUsed(self)

    def getProportion(self, facies):
        r"""

        Rule::getProportion
        Returns the proportion of a given facies  

        Parameters
        ----------
        * `facies` :  
            Facies rank (starting from 1)  

        Returns
        -------
        Proportion of the given Facies  

        """
        return _gstlearn.Rule_getProportion(self, facies)

    def getThreshFromRectangle(self, rect, facies):
        r"""

        Rule::getThreshFromRectangle
        """
        return _gstlearn.Rule_getThreshFromRectangle(self, rect, facies)

    def getFaciesFromGaussian(self, y1, y2):
        r"""

        Rule::getFaciesFromGaussian
        Convert the two underlying GRFs into facies  

        Returns
        -------
        The facies rank or 0 (facies not found)  

        Parameters
        ----------
        * `y1` :  
            Value of the first underlying GRF  
        * `y2` :  
            Value of the second underlying GRF  

        remark: If one of the two GRF is undefined, the resulting facies is 0  

        """
        return _gstlearn.Rule_getFaciesFromGaussian(self, y1, y2)

    def getNodes(self):
        r"""

        Rule::getNodes
        """
        return _gstlearn.Rule_getNodes(self)

    def updateShift(self):
        r"""

        Rule::updateShift
        """
        return _gstlearn.Rule_updateShift(self)

    def getThresh(self, facies):
        r"""

        Rule::getThresh
        Return the vector of bounds for a given facies  

        Parameters
        ----------
        * `facies` :  
            Rank of the target facies (starting from 1)  

        Returns
        -------
        The vector of bounds organized as [t1min, t1max, t2min, t2max]  

        """
        return _gstlearn.Rule_getThresh(self, facies)

    def __repr__(self):
        return _gstlearn.Rule___repr__(self)

# Register Rule in _gstlearn:
_gstlearn.Rule_swigregister(Rule)

def set_rule_mode(rule_mode):
    r"""


    Set the Rule Mode  

    Parameters
    ----------
    * `rule_mode` :  
        1 for Gaussian; 0 for absence of conversion  

    remark: The absence of conversion is used in order to evaluate the  

    remark: real thresholds along the rule for representing the rule  

    remark: by proportions rather than in gaussian scale  

    """
    return _gstlearn.set_rule_mode(rule_mode)

def get_rule_mode():
    r"""


    Get the current Rule Mode  

    Returns
    -------
    Returns the current mode (1 for Gaussian; 0 for Raw)  

    """
    return _gstlearn.get_rule_mode()

def get_rule_extreme(mode):
    r"""


    Get the lower or upper bound  

    Returns
    -------
    Lower of Upper Bound  

    Parameters
    ----------
    * `mode` :  
        <0 for lower bound; >0 for upper bound  

    """
    return _gstlearn.get_rule_extreme(mode)

def rule_free(rule):
    r"""


    Free a Rule structure  

    Returns
    -------
    Pointer to the newly freed Rule structure  

    Parameters
    ----------
    * `rule` :  
        Rule structure to be freed  

    """
    return _gstlearn.rule_free(rule)

def model_rule_combine(model1, model2, rule):
    r"""


    Combine two basic models into a bivariate model (residuals model)  

    Returns
    -------
    The newly Model structure  

    Parameters
    ----------
    * `model1` :  
        First input Model  
    * `model2` :  
        Second input Model  
    * `rule` :  
        Rule  

    remark: : The drift is not copied into the new model  

    """
    return _gstlearn.model_rule_combine(model1, model2, rule)

def db_rule_shadow(db, dbprop, rule, model1, props, flag_stat, nfacies):
    r"""


    Apply the Rule transformation to the GRFs of a Db (Shadow case)  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Output Db structure  
    * `dbprop` :  
        Db structure used for proportions (non-stationary case)  
    * `rule` :  
        Lithotype Rule definition  
    * `model` :  
        First Model structure (only for SHIFT)  
    * `props` :  
        Array of proportions for the facies  
    * `flag_stat` :  
        1 for stationary; 0 otherwise  
    * `nfacies` :  
        Number of facies  

    remark: The input variable must be locatorized as Z or ELoc::SIMU  

    remark: It will be changed in this function to locator ELoc::SIMU  

    """
    return _gstlearn.db_rule_shadow(db, dbprop, rule, model1, props, flag_stat, nfacies)
class RuleStringFormat(AStringFormat):
    r"""


    C++ includes: RuleStringFormat.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        RuleStringFormat::RuleStringFormat
        """
        _gstlearn.RuleStringFormat_swiginit(self, _gstlearn.new_RuleStringFormat(*args))
    __swig_destroy__ = _gstlearn.delete_RuleStringFormat

    def getFlagProp(self):
        r"""

        RuleStringFormat::getFlagProp
        """
        return _gstlearn.RuleStringFormat_getFlagProp(self)

    def getFlagThresh(self):
        r"""

        RuleStringFormat::getFlagThresh
        """
        return _gstlearn.RuleStringFormat_getFlagThresh(self)

    def setFlagProp(self, flagProp):
        r"""

        RuleStringFormat::setFlagProp
        """
        return _gstlearn.RuleStringFormat_setFlagProp(self, flagProp)

    def setFlagThresh(self, flagThresh):
        r"""

        RuleStringFormat::setFlagThresh
        """
        return _gstlearn.RuleStringFormat_setFlagThresh(self, flagThresh)

# Register RuleStringFormat in _gstlearn:
_gstlearn.RuleStringFormat_swigregister(RuleStringFormat)
class RuleProp(AStringable):
    r"""


    C++ includes: RuleProp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        RuleProp::RuleProp
        """
        _gstlearn.RuleProp_swiginit(self, _gstlearn.new_RuleProp(*args))
    __swig_destroy__ = _gstlearn.delete_RuleProp

    def toString(self, strfmt=None):
        r"""

        RuleProp::toString
        Interface to AStringable.  

        """
        return _gstlearn.RuleProp_toString(self, strfmt)

    def resetFromDb(self, *args, **kwargs):
        r"""

        RuleProp::resetFromDb
        This constructor is used in the exceptional case where the Rule is not yet
        defined (typically when inferring the Rule)  

        Parameters
        ----------
        * `dbprop` :  
            Db containing the Proportion information (ELoc::P fields)  
        * `propcst` :  
            Vector of constant proportions  

        """
        return _gstlearn.RuleProp_resetFromDb(self, *args, **kwargs)

    def resetFromRule(self, *args, **kwargs):
        r"""

        RuleProp::resetFromRule
        """
        return _gstlearn.RuleProp_resetFromRule(self, *args, **kwargs)

    def resetFromRuleAndDb(self, rule, dbprop):
        r"""

        RuleProp::resetFromRuleAndDb
        """
        return _gstlearn.RuleProp_resetFromRuleAndDb(self, rule, dbprop)

    def resetFromRules(self, *args, **kwargs):
        r"""

        RuleProp::resetFromRules
        """
        return _gstlearn.RuleProp_resetFromRules(self, *args, **kwargs)

    def resetFromRulesAndDb(self, rule1, rule2, dbprop):
        r"""

        RuleProp::resetFromRulesAndDb
        """
        return _gstlearn.RuleProp_resetFromRulesAndDb(self, rule1, rule2, dbprop)

    @staticmethod
    def createFromDb(*args, **kwargs):
        r"""

        RuleProp::createFromDb
        """
        return _gstlearn.RuleProp_createFromDb(*args, **kwargs)

    @staticmethod
    def createFromRule(*args, **kwargs):
        r"""

        RuleProp::createFromRule
        """
        return _gstlearn.RuleProp_createFromRule(*args, **kwargs)

    @staticmethod
    def createFromRuleAndDb(rule, dbprop):
        r"""

        RuleProp::createFromRuleAndDb
        """
        return _gstlearn.RuleProp_createFromRuleAndDb(rule, dbprop)

    @staticmethod
    def createFromRules(*args, **kwargs):
        r"""

        RuleProp::createFromRules
        """
        return _gstlearn.RuleProp_createFromRules(*args, **kwargs)

    @staticmethod
    def createFromRulesAndDb(rule1, rule2, dbprop):
        r"""

        RuleProp::createFromRulesAndDb
        """
        return _gstlearn.RuleProp_createFromRulesAndDb(rule1, rule2, dbprop)

    def getDbprop(self):
        r"""

        RuleProp::getDbprop
        """
        return _gstlearn.RuleProp_getDbprop(self)

    def setDbprop(self, dbprop):
        r"""

        RuleProp::setDbprop
        """
        return _gstlearn.RuleProp_setDbprop(self, dbprop)

    def isFlagStat(self):
        r"""

        RuleProp::isFlagStat
        """
        return _gstlearn.RuleProp_isFlagStat(self)

    def setFlagStat(self, flagStat):
        r"""

        RuleProp::setFlagStat
        """
        return _gstlearn.RuleProp_setFlagStat(self, flagStat)

    def getPropCst(self):
        r"""

        RuleProp::getPropCst
        """
        return _gstlearn.RuleProp_getPropCst(self)

    def setPropCst(self, propcst):
        r"""

        RuleProp::setPropCst
        """
        return _gstlearn.RuleProp_setPropCst(self, propcst)

    def getRule(self, rank=0):
        r"""

        RuleProp::getRule
        """
        return _gstlearn.RuleProp_getRule(self, rank)

    def addRule(self, rule):
        r"""

        RuleProp::addRule
        """
        return _gstlearn.RuleProp_addRule(self, rule)

    def clearRule(self):
        r"""

        RuleProp::clearRule
        """
        return _gstlearn.RuleProp_clearRule(self)

    def getNRule(self):
        r"""

        RuleProp::getNRule
        """
        return _gstlearn.RuleProp_getNRule(self)

    def fit(self, db, varioparam, ngrfmax=1, verbose=False):
        r"""

        RuleProp::fit
        """
        return _gstlearn.RuleProp_fit(self, db, varioparam, ngrfmax, verbose)

    def gaussToCategory(self, *args, **kwargs):
        r"""

        RuleProp::gaussToCategory
        Convert a set of Gaussian vectors into the corresponding Facies in a Db  

        Parameters
        ----------
        * `db` :  
            Pointer to the Db structure (in/out)  
        * `namconv` :  
            Naming convention  

        Returns
        -------
        Error return code  

        remark: The input variables must be locatorized Z or SIMU  

        """
        return _gstlearn.RuleProp_gaussToCategory(self, *args, **kwargs)

    def categoryToThresh(self, *args, **kwargs):
        r"""

        RuleProp::categoryToThresh
        Derive the bounds variables for a Db (depending on the Category information of
        each sample)  

        Parameters
        ----------
        * `db` :  
            Pointer to the Db structure (in/out)  
        * `namconv` :  
            Naming convention  

        Returns
        -------
        Error return code  

        """
        return _gstlearn.RuleProp_categoryToThresh(self, *args, **kwargs)

    def computeAllThreshes(self, *args, **kwargs):
        r"""

        RuleProp::computeAllThreshes
        Calculate all the thresholds at each sample of a Db  

        Parameters
        ----------
        * `db` :  
            Pointer to the Db structure (in/out)  
        * `namconv` :  
            Naming convention  

        Returns
        -------
        Error return code  

        """
        return _gstlearn.RuleProp_computeAllThreshes(self, *args, **kwargs)

    def __repr__(self):
        return _gstlearn.RuleProp___repr__(self)

# Register RuleProp in _gstlearn:
_gstlearn.RuleProp_swigregister(RuleProp)
class KrigingSystem(object):
    r"""


    C++ includes: KrigingSystem.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""

        KrigingSystem::KrigingSystem
        """
        _gstlearn.KrigingSystem_swiginit(self, _gstlearn.new_KrigingSystem(*args, **kwargs))
    __swig_destroy__ = _gstlearn.delete_KrigingSystem

    def resetData(self):
        r"""

        KrigingSystem::resetData
        """
        return _gstlearn.KrigingSystem_resetData(self)

    def setKrigOpt(self, krigopt):
        r"""

        KrigingSystem::setKrigOpt
        """
        return _gstlearn.KrigingSystem_setKrigOpt(self, krigopt)

    def setKrigOptCalcul(self, *args, **kwargs):
        r"""

        KrigingSystem::setKrigOptCalcul
        """
        return _gstlearn.KrigingSystem_setKrigOptCalcul(self, *args, **kwargs)

    def setKrigOptXValid(self, flag_xvalid, flag_kfold, optionXValidEstim=False, optionXValidStdev=False, optionXValidVarZ=False):
        r"""

        KrigingSystem::setKrigOptXValid
        Set the flag for performing Cross-Validation  

        Parameters
        ----------
        * `flag_xvalid` :  
            True if the Cross-Validation option is switched ON  
        * `flag_kfold` :  
            True if the KFold option is switch ON  
        * `optionXValidEstim` :  
            True for Z*-Z; False for Z*  
        * `optionXValidStdev` :  
            True for (Z*-Z)/S; False for S  
        * `optionXValidVarZ` :  
            True for Var(Z*)  

        Returns
        -------  

        remark: The KFold option requires a Code to be assigned to each Datum  

        remark: In the Neighborhood search for a Target sample, some other data points  

        remark: are discarded:  

        remark: - either the Target sample itself (Leave-One-Point-Out) if KFold is
            False  

        remark: - all samples with same code as Target if KFold is True  

        """
        return _gstlearn.KrigingSystem_setKrigOptXValid(self, flag_xvalid, flag_kfold, optionXValidEstim, optionXValidStdev, optionXValidVarZ)

    def setKrigOptBayes(self, flag_bayes, prior_mean, prior_cov):
        r"""

        KrigingSystem::setKrigOptBayes
        """
        return _gstlearn.KrigingSystem_setKrigOptBayes(self, flag_bayes, prior_mean, prior_cov)

    def setKrigOptDataWeights(self, iptrWeights, flagSet=True):
        r"""

        KrigingSystem::setKrigOptDataWeights
        """
        return _gstlearn.KrigingSystem_setKrigOptDataWeights(self, iptrWeights, flagSet)

    def setKrigOptFlagSimu(self, flagSimu, nbsimu=0, rankPGS=-1):
        r"""

        KrigingSystem::setKrigOptFlagSimu
        """
        return _gstlearn.KrigingSystem_setKrigOptFlagSimu(self, flagSimu, nbsimu, rankPGS)

    def setKrigOptFlagGlobal(self, flag_global):
        r"""

        KrigingSystem::setKrigOptFlagGlobal
        """
        return _gstlearn.KrigingSystem_setKrigOptFlagGlobal(self, flag_global)

    def setKrigOptFlagLTerm(self, flag_lterm):
        r"""

        KrigingSystem::setKrigOptFlagLTerm
        Ask for the specific calculation of Z * A-1 * Z  

        Parameters
        ----------
        * `flag_lterm` :  
            Flag for asking this specific calculation  

        Returns
        -------  

        remark: The calculated value can be retrieved using _getLTerm() method  

        """
        return _gstlearn.KrigingSystem_setKrigOptFlagLTerm(self, flag_lterm)

    def setKrigOptAnamophosis(self, anam):
        r"""

        KrigingSystem::setKrigOptAnamophosis
        Perform Gaussian Anamoprhosis kriging  

        Parameters
        ----------
        * `anam` :  
            Pointer to the AAnam structure  

        Returns
        -------  

        """
        return _gstlearn.KrigingSystem_setKrigOptAnamophosis(self, anam)

    def setKrigOptFactorKriging(self, flag_factor_kriging):
        r"""

        KrigingSystem::setKrigOptFactorKriging
        """
        return _gstlearn.KrigingSystem_setKrigOptFactorKriging(self, flag_factor_kriging)

    def updKrigOptEstim(self, iptrEst, iptrStd, iptrVarZ, forceNoDual=False):
        r"""

        KrigingSystem::updKrigOptEstim
        Set the calculation options  

        Parameters
        ----------
        * `iptrEst` :  
            UID for storing the estimation(s)  
        * `iptrStd` :  
            UID for storing the Standard deviations(s)  
        * `iptrVarZ` :  
            UID for storing the Variance(s) of estimator  
        * `forceNoDual` :  
            Force that the algebra is not using the Dual option  

        Returns
        -------
        Error returned code  

        remark: If a term must not be calculated, its UID must be negative  

        """
        return _gstlearn.KrigingSystem_updKrigOptEstim(self, iptrEst, iptrStd, iptrVarZ, forceNoDual)

    def updKrigOptIclass(self, index_class, nclasses):
        r"""

        KrigingSystem::updKrigOptIclass
        """
        return _gstlearn.KrigingSystem_updKrigOptIclass(self, index_class, nclasses)

    def updKrigOptNeighOnly(self, iptrNeigh):
        r"""

        KrigingSystem::updKrigOptNeighOnly
        """
        return _gstlearn.KrigingSystem_updKrigOptNeighOnly(self, iptrNeigh)

    def isReady(self):
        r"""

        KrigingSystem::isReady
        Performs the last operations before launching the loop on Estimations  

        Returns
        -------  

        """
        return _gstlearn.KrigingSystem_isReady(self)

    def estimate(self, iech_out):
        r"""

        KrigingSystem::estimate
        Perform the Kriging of target  

        Parameters
        ----------
        * `iech_out` :  
            Rank of the target  

        Returns
        -------  

        """
        return _gstlearn.KrigingSystem_estimate(self, iech_out)

    def conclusion(self):
        r"""

        KrigingSystem::conclusion
        This method closes the use of a KrigingSystem sequence  

        """
        return _gstlearn.KrigingSystem_conclusion(self)

    def getNDim(self):
        r"""

        KrigingSystem::getNDim
        """
        return _gstlearn.KrigingSystem_getNDim(self)

    def getNVar(self):
        r"""

        KrigingSystem::getNVar
        """
        return _gstlearn.KrigingSystem_getNVar(self)

    def getNech(self):
        r"""

        KrigingSystem::getNech
        """
        return _gstlearn.KrigingSystem_getNech(self)

    def getCovSize(self):
        r"""

        KrigingSystem::getCovSize
        """
        return _gstlearn.KrigingSystem_getCovSize(self)

    def getDriftSize(self):
        r"""

        KrigingSystem::getDriftSize
        """
        return _gstlearn.KrigingSystem_getDriftSize(self)

    def getNrhs(self):
        r"""

        KrigingSystem::getNrhs
        """
        return _gstlearn.KrigingSystem_getNrhs(self)

    def getSampleNbgh(self):
        r"""

        KrigingSystem::getSampleNbgh
        """
        return _gstlearn.KrigingSystem_getSampleNbgh(self)

    def getSampleCoordinates(self):
        r"""

        KrigingSystem::getSampleCoordinates
        Returns the coordinates of the neighboring samples  

        Returns
        -------
        Array organized by Coordinate (minor) then by Sample (major)  

        """
        return _gstlearn.KrigingSystem_getSampleCoordinates(self)

    def getSampleData(self):
        r"""

        KrigingSystem::getSampleData
        """
        return _gstlearn.KrigingSystem_getSampleData(self)

    def getLHS(self):
        r"""

        KrigingSystem::getLHS
        """
        return _gstlearn.KrigingSystem_getLHS(self)

    def getLHSF(self):
        r"""

        KrigingSystem::getLHSF
        """
        return _gstlearn.KrigingSystem_getLHSF(self)

    def getRHS(self):
        r"""

        KrigingSystem::getRHS
        """
        return _gstlearn.KrigingSystem_getRHS(self)

    def getRHSF(self):
        r"""

        KrigingSystem::getRHSF
        """
        return _gstlearn.KrigingSystem_getRHSF(self)

    def getVariance(self):
        r"""

        KrigingSystem::getVariance
        """
        return _gstlearn.KrigingSystem_getVariance(self)

    def getWeights(self):
        r"""

        KrigingSystem::getWeights
        """
        return _gstlearn.KrigingSystem_getWeights(self)

    def getMu(self):
        r"""

        KrigingSystem::getMu
        """
        return _gstlearn.KrigingSystem_getMu(self)

    def getLTerm(self):
        r"""

        KrigingSystem::getLTerm
        """
        return _gstlearn.KrigingSystem_getLTerm(self)

# Register KrigingSystem in _gstlearn:
_gstlearn.KrigingSystem_swigregister(KrigingSystem)
class KrigingAlgebra(object):
    r"""


    Perform the Algebra for Kriging and CoKriging.  

    It requires the definition of:  

    *   the vector of Data values *Z* (possibly multivariate and heterotopic)  
    *   the Covariance matrix at data points *Sigma*  
    *   the Drift matrix at data points *X* (UK if defined, SK otherwise)  
    *   the Covariance matrix at target *Sigma00* (only for calculating variance)  
    *   the Drift coefficients *Beta* (for SK)  

    Note: When using SK:  

    *   the vector *Z* must be centered by the drift beforehand  
    *   the vector *beta* corresponds to the vector of Means.  

    C++ includes: KrigingAlgebra.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, flagDual=False, sampleRanks=None, Z=None, Sigma=None, X=None, Sigma00=None, Means=None):
        r"""

        KrigingAlgebra::KrigingAlgebra
        """
        _gstlearn.KrigingAlgebra_swiginit(self, _gstlearn.new_KrigingAlgebra(flagDual, sampleRanks, Z, Sigma, X, Sigma00, Means))

    def setDual(self, status):
        r"""

        KrigingAlgebra::setDual
        """
        return _gstlearn.KrigingAlgebra_setDual(self, status)

    def resetNewData(self):
        r"""

        KrigingAlgebra::resetNewData
        Method to be used when the data has changed (e.g. Moving Neighborhood)  

        """
        return _gstlearn.KrigingAlgebra_resetNewData(self)

    def setData(self, Z=None, indices=None, Means=None):
        r"""

        KrigingAlgebra::setData
        Modify the Data Values (and Means)  

        Parameters
        ----------
        * `Z` :  
            Data flattened vector (possibly multivariate)  
        * `indices` :  
            Vector Of Vector of sample ranks  
        * `Means` :  
            Vector of known Drift coefficients (optional)  

        Returns
        -------
        int  

        note: If one element is not provided, its address (if already defined) is  

        note: kept unchanged (even if its contents may have been updated)  

        """
        return _gstlearn.KrigingAlgebra_setData(self, Z, indices, Means)

    def setLHS(self, Sigma=None, X=None):
        r"""

        KrigingAlgebra::setLHS
        Modify the elements linked to the LHS.  

        Parameters
        ----------
        * `Sigma` :  
            Data-Data Covariance matrix  
        * `X` :  
            Data Drift Matrix  

        Returns
        -------
        int  

        note: If one element is not provided, its address (if already defined) is  

        note: kept unchanged (even if its contents may have been updated)  

        """
        return _gstlearn.KrigingAlgebra_setLHS(self, Sigma, X)

    def setRHS(self, Sigma0=None, X0=None):
        r"""

        KrigingAlgebra::setRHS
        """
        return _gstlearn.KrigingAlgebra_setRHS(self, Sigma0, X0)

    def setVariance(self, Sigma00=None):
        r"""

        KrigingAlgebra::setVariance
        """
        return _gstlearn.KrigingAlgebra_setVariance(self, Sigma00)

    def setBayes(self, PriorMean=None, PriorCov=None):
        r"""

        KrigingAlgebra::setBayes
        """
        return _gstlearn.KrigingAlgebra_setBayes(self, PriorMean, PriorCov)

    def setXvalidUnique(self, rankXvalidEqs=None, rankXvalidVars=None):
        r"""

        KrigingAlgebra::setXvalidUnique
        Define the elements of the input Db to be cross-validated.  

        Parameters
        ----------
        * `rankXvalidEqs` :  
            Vector of equation ranks to be cross-validated  
        * `rankXvalidVars` :  
            Vector of variable ranks to be cross-validated  

        Returns
        -------
        int Error return code  

        remark: The argument 'rankXvalidVars' only serves in assigning the mean of the
            correct cross-validated variable (SK only). It is optional in OK  

        """
        return _gstlearn.KrigingAlgebra_setXvalidUnique(self, rankXvalidEqs, rankXvalidVars)

    def setColCokUnique(self, Zp=None, rankColCok=None):
        r"""

        KrigingAlgebra::setColCokUnique
        Define the inforlation for Collocated Option.  

        Parameters
        ----------
        * `Zp` :  
            Vector of the Collocated variables (see note)  
        * `rankColCok` :  
            Vector of ranks of Collocated variables (dim: _nvar)  

        Returns
        -------
        int Error return code  

        note: Argument 'rankColCok' gives the variable rank in Target File or -1  

        note: The argument 'Zp' must be corrected by the mean of the variables for the
            use of Collocated Option in Simple Kriging  

        """
        return _gstlearn.KrigingAlgebra_setColCokUnique(self, Zp, rankColCok)

    def printStatus(self):
        r"""

        KrigingAlgebra::printStatus
        """
        return _gstlearn.KrigingAlgebra_printStatus(self)

    def dumpLHS(self, nbypas=5):
        r"""

        KrigingAlgebra::dumpLHS
        """
        return _gstlearn.KrigingAlgebra_dumpLHS(self, nbypas)

    def dumpRHS(self):
        r"""

        KrigingAlgebra::dumpRHS
        """
        return _gstlearn.KrigingAlgebra_dumpRHS(self)

    def dumpWGT(self):
        r"""

        KrigingAlgebra::dumpWGT
        """
        return _gstlearn.KrigingAlgebra_dumpWGT(self)

    def dumpAux(self):
        r"""

        KrigingAlgebra::dumpAux
        """
        return _gstlearn.KrigingAlgebra_dumpAux(self)

    def getEstimation(self):
        r"""

        KrigingAlgebra::getEstimation
        """
        return _gstlearn.KrigingAlgebra_getEstimation(self)

    def getStdv(self):
        r"""

        KrigingAlgebra::getStdv
        """
        return _gstlearn.KrigingAlgebra_getStdv(self)

    def getVarianceZstar(self):
        r"""

        KrigingAlgebra::getVarianceZstar
        """
        return _gstlearn.KrigingAlgebra_getVarianceZstar(self)

    def getPostMean(self):
        r"""

        KrigingAlgebra::getPostMean
        """
        return _gstlearn.KrigingAlgebra_getPostMean(self)

    def getStdvMat(self):
        r"""

        KrigingAlgebra::getStdvMat
        """
        return _gstlearn.KrigingAlgebra_getStdvMat(self)

    def getVarianceZstarMat(self):
        r"""

        KrigingAlgebra::getVarianceZstarMat
        """
        return _gstlearn.KrigingAlgebra_getVarianceZstarMat(self)

    def getPostCov(self):
        r"""

        KrigingAlgebra::getPostCov
        """
        return _gstlearn.KrigingAlgebra_getPostCov(self)

    def getLambda(self):
        r"""

        KrigingAlgebra::getLambda
        """
        return _gstlearn.KrigingAlgebra_getLambda(self)

    def getLambda0(self):
        r"""

        KrigingAlgebra::getLambda0
        """
        return _gstlearn.KrigingAlgebra_getLambda0(self)

    def getMu(self):
        r"""

        KrigingAlgebra::getMu
        """
        return _gstlearn.KrigingAlgebra_getMu(self)

    def getLTerm(self):
        r"""

        KrigingAlgebra::getLTerm
        """
        return _gstlearn.KrigingAlgebra_getLTerm(self)

    def isDual(self):
        r"""

        KrigingAlgebra::isDual
        """
        return _gstlearn.KrigingAlgebra_isDual(self)
    __swig_destroy__ = _gstlearn.delete_KrigingAlgebra

# Register KrigingAlgebra in _gstlearn:
_gstlearn.KrigingAlgebra_swigregister(KrigingAlgebra)
class Krigtest_Res(object):
    r"""


    C++ includes: CalcKriging.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ndim = property(_gstlearn.Krigtest_Res_ndim_get, _gstlearn.Krigtest_Res_ndim_set)
    nvar = property(_gstlearn.Krigtest_Res_nvar_get, _gstlearn.Krigtest_Res_nvar_set)
    nech = property(_gstlearn.Krigtest_Res_nech_get, _gstlearn.Krigtest_Res_nech_set)
    CSize = property(_gstlearn.Krigtest_Res_CSize_get, _gstlearn.Krigtest_Res_CSize_set)
    DSize = property(_gstlearn.Krigtest_Res_DSize_get, _gstlearn.Krigtest_Res_DSize_set)
    nrhs = property(_gstlearn.Krigtest_Res_nrhs_get, _gstlearn.Krigtest_Res_nrhs_set)
    nbgh = property(_gstlearn.Krigtest_Res_nbgh_get, _gstlearn.Krigtest_Res_nbgh_set)
    xyz = property(_gstlearn.Krigtest_Res_xyz_get, _gstlearn.Krigtest_Res_xyz_set)
    data = property(_gstlearn.Krigtest_Res_data_get, _gstlearn.Krigtest_Res_data_set)
    lhs = property(_gstlearn.Krigtest_Res_lhs_get, _gstlearn.Krigtest_Res_lhs_set)
    lhsF = property(_gstlearn.Krigtest_Res_lhsF_get, _gstlearn.Krigtest_Res_lhsF_set)
    rhs = property(_gstlearn.Krigtest_Res_rhs_get, _gstlearn.Krigtest_Res_rhs_set)
    rhsF = property(_gstlearn.Krigtest_Res_rhsF_get, _gstlearn.Krigtest_Res_rhsF_set)
    wgt = property(_gstlearn.Krigtest_Res_wgt_get, _gstlearn.Krigtest_Res_wgt_set)
    mu = property(_gstlearn.Krigtest_Res_mu_get, _gstlearn.Krigtest_Res_mu_set)
    var = property(_gstlearn.Krigtest_Res_var_get, _gstlearn.Krigtest_Res_var_set)

    def toTL(self):
        return _gstlearn.Krigtest_Res_toTL(self)

    def __init__(self):
        r"""


        C++ includes: CalcKriging.hpp

        """
        _gstlearn.Krigtest_Res_swiginit(self, _gstlearn.new_Krigtest_Res())
    __swig_destroy__ = _gstlearn.delete_Krigtest_Res

# Register Krigtest_Res in _gstlearn:
_gstlearn.Krigtest_Res_swigregister(Krigtest_Res)
class CalcKriging(ACalcInterpolator):
    r"""


    C++ includes: CalcKriging.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, flag_est=True, flag_std=True, flag_varZ=False):
        r"""

        CalcKriging::CalcKriging
        """
        _gstlearn.CalcKriging_swiginit(self, _gstlearn.new_CalcKriging(flag_est, flag_std, flag_varZ))
    __swig_destroy__ = _gstlearn.delete_CalcKriging

    def setPriorCov(self, priorCov):
        r"""

        CalcKriging::setPriorCov
        """
        return _gstlearn.CalcKriging_setPriorCov(self, priorCov)

    def setPriorMean(self, priorMean):
        r"""

        CalcKriging::setPriorMean
        """
        return _gstlearn.CalcKriging_setPriorMean(self, priorMean)

    def setFlagBayes(self, flagBayes):
        r"""

        CalcKriging::setFlagBayes
        """
        return _gstlearn.CalcKriging_setFlagBayes(self, flagBayes)

    def setIechSingleTarget(self, iechSingleTarget):
        r"""

        CalcKriging::setIechSingleTarget
        """
        return _gstlearn.CalcKriging_setIechSingleTarget(self, iechSingleTarget)

    def setVerboseSingleTarget(self, verbose):
        r"""

        CalcKriging::setVerboseSingleTarget
        """
        return _gstlearn.CalcKriging_setVerboseSingleTarget(self, verbose)

    def setAnam(self, anam):
        r"""

        CalcKriging::setAnam
        """
        return _gstlearn.CalcKriging_setAnam(self, anam)

    def setFlagGam(self, flagGam):
        r"""

        CalcKriging::setFlagGam
        """
        return _gstlearn.CalcKriging_setFlagGam(self, flagGam)

    def setFlagXvalidEst(self, flagXvalidEst):
        r"""

        CalcKriging::setFlagXvalidEst
        """
        return _gstlearn.CalcKriging_setFlagXvalidEst(self, flagXvalidEst)

    def setFlagXvalidStd(self, flagXvalidStd):
        r"""

        CalcKriging::setFlagXvalidStd
        """
        return _gstlearn.CalcKriging_setFlagXvalidStd(self, flagXvalidStd)

    def setFlagXvalidVarZ(self, flagXvalidVarZ):
        r"""

        CalcKriging::setFlagXvalidVarZ
        """
        return _gstlearn.CalcKriging_setFlagXvalidVarZ(self, flagXvalidVarZ)

    def setFlagXvalid(self, flagXvalid):
        r"""

        CalcKriging::setFlagXvalid
        """
        return _gstlearn.CalcKriging_setFlagXvalid(self, flagXvalid)

    def setFlagKfold(self, flag_kfold):
        r"""

        CalcKriging::setFlagKfold
        """
        return _gstlearn.CalcKriging_setFlagKfold(self, flag_kfold)

    def setFlagNeighOnly(self, flagNeighOnly):
        r"""

        CalcKriging::setFlagNeighOnly
        """
        return _gstlearn.CalcKriging_setFlagNeighOnly(self, flagNeighOnly)

    def getKtest(self):
        r"""

        CalcKriging::getKtest
        """
        return _gstlearn.CalcKriging_getKtest(self)

# Register CalcKriging in _gstlearn:
_gstlearn.CalcKriging_swigregister(CalcKriging)

def kriging(*args, **kwargs):
    r"""


    Standard Kriging  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        ModelGeneric structure  
    * `neigh` :  
        ANeigh structure  
    * `flag_est` :  
        Option for storing the estimation  
    * `flag_std` :  
        Option for storing the standard deviation  
    * `flag_varz` :  
        Option for storing the variance of the estimator (only available for
        stationary model)  
    * `krigopt` :  
        KrigOpt structure  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.kriging(*args, **kwargs)

def krigcell(*args, **kwargs):
    r"""


    Standard Block Kriging with variable cell dimension  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        ModelGeneric structure  
    * `neigh` :  
        ANeigh structure  
    * `flag_est` :  
        Option for the storing the estimation  
    * `flag_std` :  
        Option for the storing the standard deviation  
    * `krigopt` :  
        KrigOpt structure  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.krigcell(*args, **kwargs)

def kribayes(*args, **kwargs):
    r"""


    Estimation with Bayesian Drift  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        input Db structure  
    * `dbout` :  
        output Db structure  
    * `model` :  
        ModelGeneric structure  
    * `neigh` :  
        ANeigh structure  
    * `prior_mean` :  
        Array giving the prior means for the drift terms  
    * `prior_cov` :  
        Array containing the prior covariance matrix for the drift terms  
    * `flag_est` :  
        Pointer for the storing the estimation  
    * `flag_std` :  
        Pointer for the storing the standard deviation  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.kribayes(*args, **kwargs)

def kriggam(*args, **kwargs):
    r"""


    Punctual Kriging in the Anamorphosed Gaussian Model  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        input Db structure  
    * `dbout` :  
        output Db structure  
    * `model` :  
        ModelGeneric structure  
    * `neigh` :  
        ANeigh structure  
    * `anam` :  
        AAnam structure  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.kriggam(*args, **kwargs)

def krigtest(*args, **kwargs):
    r"""


    Perform kriging and return the calculation elements  

    Returns
    -------
    A Krigtest_Res structure  

    Parameters
    ----------
    * `dbin` :  
        input Db structure  
    * `dbout` :  
        output Db structure  
    * `model` :  
        ModelGeneric structure  
    * `neigh` :  
        ANeigh structure  
    * `iech0` :  
        Rank of the target sample  
    * `krigopt` :  
        KrigOpt structure  
    * `verbose` :  
        When TRUE, the full debugging flag is switched ON (the current status is
        reset after the run)  

    """
    return _gstlearn.krigtest(*args, **kwargs)

def xvalid(*args, **kwargs):
    r"""


    Standard Cross-Validation  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `model` :  
        ModelGeneric structure  
    * `neigh` :  
        ANeigh structure  
    * `flag_kfold` :  
        True if a code (K-FOLD) is used  
    * `flag_xvalid_est` :  
        Option for storing the estimation: 1 for Z*-Z; -1 for Z*; 0 not stored  
    * `flag_xvalid_std` :  
        Option for storing the standard deviation: 1:for (Z*-Z)/S; -1 for S; 0 not
        stored  
    * `flag_xvalid_varz` :  
        Option for storing the variance of the estimator: 1 to store and 0 not
        stored  
    * `krigopt` :  
        KrigOpt structure  
    * `namconv` :  
        Naming Convention  

    Returns
    -------
    Error return code  

    """
    return _gstlearn.xvalid(*args, **kwargs)

def test_neigh(*args, **kwargs):
    r"""


    Check the Neighborhood  

    Returns
    -------
    Error return code (0: success, 1: error)  

    Parameters
    ----------
    * `dbin` :  
        input Db structure  
    * `dbout` :  
        output Db structure  
    * `model` :  
        ModelGeneric structure (optional)  
    * `neigh` :  
        ANeigh structure  
    * `namconv` :  
        Naming Convention  

    remark: This procedure creates the following arrays:  

    remark: 1 - The number of selected samples  

    remark: 2 - The maximum neighborhood distance  

    remark: 3 - The minimum neighborhood distance  

    remark: 4 - The number of non-empty sectors  

    remark: 5 - The number of consecutive empty sectors  

    """
    return _gstlearn.test_neigh(*args, **kwargs)
class CalcKrigingFactors(ACalcInterpolator):
    r"""


    C++ includes: CalcKrigingFactors.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, flag_est=True, flag_std=True):
        r"""

        CalcKrigingFactors::CalcKrigingFactors
        """
        _gstlearn.CalcKrigingFactors_swiginit(self, _gstlearn.new_CalcKrigingFactors(flag_est, flag_std))
    __swig_destroy__ = _gstlearn.delete_CalcKrigingFactors

    def setIuidFactors(self, iuidFactors):
        r"""

        CalcKrigingFactors::setIuidFactors
        """
        return _gstlearn.CalcKrigingFactors_setIuidFactors(self, iuidFactors)

# Register CalcKrigingFactors in _gstlearn:
_gstlearn.CalcKrigingFactors_swigregister(CalcKrigingFactors)

def krigingFactors(*args, **kwargs):
    r"""


    Disjunctive Kriging  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        input Db structure (containing the factors)  
    * `dbout` :  
        output Grid Db structure  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure  
    * `flag_est` :  
        Option for the storing the estimation  
    * `flag_std` :  
        Option for the storing the standard deviation  
    * `krigopt` :  
        Krigopt structure  
    * `namconv` :  
        Naming convention  

    remark: When the change of support is defined through the Anamorphosis  

    remark: the 'calcul' option must be set to POINT and 'ndisc' does not  

    remark: have to be defined  

    """
    return _gstlearn.krigingFactors(*args, **kwargs)
class CalcSimpleInterpolation(ACalcInterpolator):
    r"""


    C++ includes: CalcSimpleInterpolation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcSimpleInterpolation::CalcSimpleInterpolation
        """
        _gstlearn.CalcSimpleInterpolation_swiginit(self, _gstlearn.new_CalcSimpleInterpolation())
    __swig_destroy__ = _gstlearn.delete_CalcSimpleInterpolation

    def setFlagMovAve(self, flagMovAve):
        r"""

        CalcSimpleInterpolation::setFlagMovAve
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagMovAve(self, flagMovAve)

    def setFlagMovMed(self, flagMovMed):
        r"""

        CalcSimpleInterpolation::setFlagMovMed
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagMovMed(self, flagMovMed)

    def setFlagInvDist(self, flagInvDist):
        r"""

        CalcSimpleInterpolation::setFlagInvDist
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagInvDist(self, flagInvDist)

    def setFlagLstSqr(self, flagLstSqr):
        r"""

        CalcSimpleInterpolation::setFlagLstSqr
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagLstSqr(self, flagLstSqr)

    def setFlagNearest(self, flagNearest):
        r"""

        CalcSimpleInterpolation::setFlagNearest
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagNearest(self, flagNearest)

    def setDmax(self, dmax):
        r"""

        CalcSimpleInterpolation::setDmax
        """
        return _gstlearn.CalcSimpleInterpolation_setDmax(self, dmax)

    def setExponent(self, exponent):
        r"""

        CalcSimpleInterpolation::setExponent
        """
        return _gstlearn.CalcSimpleInterpolation_setExponent(self, exponent)

    def setFlagExpand(self, flagExpand):
        r"""

        CalcSimpleInterpolation::setFlagExpand
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagExpand(self, flagExpand)

    def setOrder(self, order):
        r"""

        CalcSimpleInterpolation::setOrder
        """
        return _gstlearn.CalcSimpleInterpolation_setOrder(self, order)

    def setFlagEst(self, flagEst):
        r"""

        CalcSimpleInterpolation::setFlagEst
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagEst(self, flagEst)

    def setFlagStd(self, flagStd):
        r"""

        CalcSimpleInterpolation::setFlagStd
        """
        return _gstlearn.CalcSimpleInterpolation_setFlagStd(self, flagStd)

# Register CalcSimpleInterpolation in _gstlearn:
_gstlearn.CalcSimpleInterpolation_swigregister(CalcSimpleInterpolation)

def inverseDistance(*args, **kwargs):
    r"""


    Inverse distance estimation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `exponent` :  
        exponent of the inverse distance  
    * `flag_expand` :  
        True for expansion option (if dbin is Grid)  
    * `dmax` :  
        Maximum search radius (if dbin is Points)  
    * `flag_est` :  
        True if the estimation must be calculated  
    * `flag_std` :  
        True if the St. Dev. must be calculated  
    * `model` :  
        Model structure (used for St. Dev.)  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.inverseDistance(*args, **kwargs)

def nearestNeighbor(*args, **kwargs):
    r"""


    Nearest Neighbor estimation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `flag_est` :  
        True if the estimation must be calculated  
    * `flag_std` :  
        True if the St. Dev. must be calculated  
    * `model` :  
        Model structure (used for St. Dev.)  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.nearestNeighbor(*args, **kwargs)

def movingAverage(*args, **kwargs):
    r"""


    Moving Average estimation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `neigh` :  
        ANeigh structure  
    * `flag_est` :  
        True if the estimation must be calculated  
    * `flag_std` :  
        True if the St. Dev. must be calculated  
    * `model` :  
        Model structure (used for St. Dev.)  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.movingAverage(*args, **kwargs)

def movingMedian(*args, **kwargs):
    r"""


    Moving Median estimation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `neigh` :  
        ANeigh structure  
    * `flag_est` :  
        True if the estimation must be calculated  
    * `flag_std` :  
        True if the St. Dev. must be calculated  
    * `model` :  
        Model structure (used for St. Dev.)  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.movingMedian(*args, **kwargs)

def leastSquares(*args, **kwargs):
    r"""


    Polynomial estimation using Least Squares  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure  
    * `dbout` :  
        Output Db structure  
    * `neigh` :  
        ANeigh structure  
    * `order` :  
        Order of the polynomial  
    * `namconv` :  
        Naming Convention  

    """
    return _gstlearn.leastSquares(*args, **kwargs)
class CalcImage(ACalcInterpolator):
    r"""


    C++ includes: CalcImage.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        CalcImage::CalcImage
        """
        _gstlearn.CalcImage_swiginit(self, _gstlearn.new_CalcImage())
    __swig_destroy__ = _gstlearn.delete_CalcImage

    def setFlagFilter(self, flagFilter):
        r"""

        CalcImage::setFlagFilter
        """
        return _gstlearn.CalcImage_setFlagFilter(self, flagFilter)

    def setFlagFFT(self, flagFFT):
        r"""

        CalcImage::setFlagFFT
        """
        return _gstlearn.CalcImage_setFlagFFT(self, flagFFT)

    def setSeed(self, seed):
        r"""

        CalcImage::setSeed
        """
        return _gstlearn.CalcImage_setSeed(self, seed)

    def setFlagMorpho(self, flagMorpho):
        r"""

        CalcImage::setFlagMorpho
        """
        return _gstlearn.CalcImage_setFlagMorpho(self, flagMorpho)

    def setOper(self, oper):
        r"""

        CalcImage::setOper
        """
        return _gstlearn.CalcImage_setOper(self, oper)

    def setOption(self, option):
        r"""

        CalcImage::setOption
        """
        return _gstlearn.CalcImage_setOption(self, option)

    def setRadius(self, radius):
        r"""

        CalcImage::setRadius
        """
        return _gstlearn.CalcImage_setRadius(self, radius)

    def setVmin(self, vmin):
        r"""

        CalcImage::setVmin
        """
        return _gstlearn.CalcImage_setVmin(self, vmin)

    def setVmax(self, vmax):
        r"""

        CalcImage::setVmax
        """
        return _gstlearn.CalcImage_setVmax(self, vmax)

    def setVerbose(self, verbose):
        r"""

        CalcImage::setVerbose
        """
        return _gstlearn.CalcImage_setVerbose(self, verbose)

    def setDistErode(self, distErode):
        r"""

        CalcImage::setDistErode
        """
        return _gstlearn.CalcImage_setDistErode(self, distErode)

    def setNvarMorpho(self, nvarMorpho):
        r"""

        CalcImage::setNvarMorpho
        """
        return _gstlearn.CalcImage_setNvarMorpho(self, nvarMorpho)

    def setFlagSmooth(self, flagSmooth):
        r"""

        CalcImage::setFlagSmooth
        """
        return _gstlearn.CalcImage_setFlagSmooth(self, flagSmooth)

    def setSmoothRange(self, smoothRange):
        r"""

        CalcImage::setSmoothRange
        """
        return _gstlearn.CalcImage_setSmoothRange(self, smoothRange)

    def setSmoothType(self, smoothType):
        r"""

        CalcImage::setSmoothType
        """
        return _gstlearn.CalcImage_setSmoothType(self, smoothType)

# Register CalcImage in _gstlearn:
_gstlearn.CalcImage_swigregister(CalcImage)

def krimage(*args, **kwargs):
    r"""


    Kriging (Factorial) a regular grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbgrid` :  
        input and output Db grid structure  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure  
    * `flagFFT` :  
        True if the FFT version is to be used  
    * `verbose` :  
        Verbose flag  
    * `seed` :  
        Seed used for random number generation  
    * `namconv` :  
        Naming Convention  

    """
    return _gstlearn.krimage(*args, **kwargs)

def dbMorpho(*args, **kwargs):
    r"""


    Perform a Morphological operation on an image stored in Db  

    Parameters
    ----------
    * `dbgrid` :  
        Target IN/OUT Db (must be a Grid)  
    * `oper` :  
        Type of morphological operation  
    * `vmin` :  
        Minimum threshold value  
    * `vmax` :  
        Maximum threshold value  
    * `option` :  
        Option  
    * `radius` :  
        Radius  
    * `verbose` :  
        Verbose option  
    * `flagDistErode` :  
        True: Inflate the grain; False: Reduce the grain  
    * `namconv` :  
        Naming convention  

    Returns
    -------  

    """
    return _gstlearn.dbMorpho(*args, **kwargs)

def dbSmoother(*args, **kwargs):
    r"""


    Smooth a regular grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbgrid` :  
        input and output Db grid structure  
    * `neigh` :  
        ANeigh structure  
    * `type` :  
        1 for Uniform; 2 for Gaussian  
    * `range` :  
        Range (used for Gaussian only)  
    * `namconv` :  
        Naming Convention  

    """
    return _gstlearn.dbSmoother(*args, **kwargs)
class Global_Result(object):
    r"""


    C++ includes: CalcGlobal.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ntot = property(_gstlearn.Global_Result_ntot_get, _gstlearn.Global_Result_ntot_set)
    np = property(_gstlearn.Global_Result_np_get, _gstlearn.Global_Result_np_set)
    ng = property(_gstlearn.Global_Result_ng_get, _gstlearn.Global_Result_ng_set)
    surface = property(_gstlearn.Global_Result_surface_get, _gstlearn.Global_Result_surface_set, doc=r"""


    Calculate the (discretized) surface of influence  

    Returns
    -------
    Error returned code  

    Parameters
    ----------
    * `db_point` :  
        Db containing the data points  
    * `db_grid` :  
        Db containing the discretization grid  
    * `dlim` :  
        Maximum distance (TEST if not defined)  
    * `dtab` :  
        Array containing the surface of influence (Dimension = Number of samples in
        db_point)  
    * `gtab` :  
        Array containing the surface of influence of the polygon to which it belongs
        (or TEST) (Dimension = Number of samples in db_grid)  

    """)
    zest = property(_gstlearn.Global_Result_zest_get, _gstlearn.Global_Result_zest_set)
    sse = property(_gstlearn.Global_Result_sse_get, _gstlearn.Global_Result_sse_set)
    cvgeo = property(_gstlearn.Global_Result_cvgeo_get, _gstlearn.Global_Result_cvgeo_set)
    cvv = property(_gstlearn.Global_Result_cvv_get, _gstlearn.Global_Result_cvv_set)
    weights = property(_gstlearn.Global_Result_weights_get, _gstlearn.Global_Result_weights_set)

    def toTL(self):
        return _gstlearn.Global_Result_toTL(self)

    def __init__(self):
        r"""


        C++ includes: CalcGlobal.hpp

        """
        _gstlearn.Global_Result_swiginit(self, _gstlearn.new_Global_Result())
    __swig_destroy__ = _gstlearn.delete_Global_Result

# Register Global_Result in _gstlearn:
_gstlearn.Global_Result_swigregister(Global_Result)
class CalcGlobal(ACalcInterpolator):
    r"""


    C++ includes: CalcGlobal.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ivar0=0, verbose=False):
        r"""

        CalcGlobal::CalcGlobal
        """
        _gstlearn.CalcGlobal_swiginit(self, _gstlearn.new_CalcGlobal(ivar0, verbose))
    __swig_destroy__ = _gstlearn.delete_CalcGlobal

    def setFlagArithmetic(self, flagArithmetic):
        r"""

        CalcGlobal::setFlagArithmetic
        """
        return _gstlearn.CalcGlobal_setFlagArithmetic(self, flagArithmetic)

    def setFlagKriging(self, flagKriging):
        r"""

        CalcGlobal::setFlagKriging
        """
        return _gstlearn.CalcGlobal_setFlagKriging(self, flagKriging)

    def getGRes(self):
        r"""

        CalcGlobal::getGRes
        """
        return _gstlearn.CalcGlobal_getGRes(self)

# Register CalcGlobal in _gstlearn:
_gstlearn.CalcGlobal_swigregister(CalcGlobal)

def global_arithmetic(dbin, dbgrid, model, ivar0, verbose):
    r"""


    """
    return _gstlearn.global_arithmetic(dbin, dbgrid, model, ivar0, verbose)

def global_kriging(dbin, dbout, model, ivar0, verbose):
    r"""


    """
    return _gstlearn.global_kriging(dbin, dbout, model, ivar0, verbose)
class KrigOpt(object):
    r"""


    C++ includes: KrigOpt.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        KrigOpt::KrigOpt
        """
        _gstlearn.KrigOpt_swiginit(self, _gstlearn.new_KrigOpt(*args))
    __swig_destroy__ = _gstlearn.delete_KrigOpt

    def setOptionCalcul(self, *args, **kwargs):
        r"""

        KrigOpt::setOptionCalcul
        """
        return _gstlearn.KrigOpt_setOptionCalcul(self, *args, **kwargs)

    def setColCok(self, rank_colcok):
        r"""

        KrigOpt::setColCok
        """
        return _gstlearn.KrigOpt_setColCok(self, rank_colcok)

    def setMatLC(self, matLC):
        r"""

        KrigOpt::setMatLC
        Define the output as Linear Combinations of the Input Variables  

        Parameters
        ----------
        * `matLC` :  
            Vector of Vectors of weights (see remarks)  

        Returns
        -------  

        remark: The number of Rows of 'matLC' is the number of Output variables  

        remark: The number of Columns of 'matLC' is the number of input Variables.  

        """
        return _gstlearn.KrigOpt_setMatLC(self, matLC)

    def setMode(self, mode):
        r"""

        KrigOpt::setMode
        """
        return _gstlearn.KrigOpt_setMode(self, mode)

    def setOptionDGM(self, flag_dgm):
        r"""

        KrigOpt::setOptionDGM
        """
        return _gstlearn.KrigOpt_setOptionDGM(self, flag_dgm)

    def getMode(self):
        r"""

        KrigOpt::getMode
        """
        return _gstlearn.KrigOpt_getMode(self)

    def getCalcul(self):
        r"""

        KrigOpt::getCalcul
        """
        return _gstlearn.KrigOpt_getCalcul(self)

    def getNDisc(self):
        r"""

        KrigOpt::getNDisc
        """
        return _gstlearn.KrigOpt_getNDisc(self)

    def hasDiscs(self):
        r"""

        KrigOpt::hasDiscs
        """
        return _gstlearn.KrigOpt_hasDiscs(self)

    def getDiscs(self):
        r"""

        KrigOpt::getDiscs
        """
        return _gstlearn.KrigOpt_getDiscs(self)

    def getDisc(self, idim):
        r"""

        KrigOpt::getDisc
        """
        return _gstlearn.KrigOpt_getDisc(self, idim)

    def hasFlagPerCell(self):
        r"""

        KrigOpt::hasFlagPerCell
        """
        return _gstlearn.KrigOpt_hasFlagPerCell(self)

    def blockDiscretize(self, iechout, flagRandom=False, seed=1234546):
        r"""

        KrigOpt::blockDiscretize
        """
        return _gstlearn.KrigOpt_blockDiscretize(self, iechout, flagRandom, seed)

    def getDisc1VD(self, idisc):
        r"""

        KrigOpt::getDisc1VD
        """
        return _gstlearn.KrigOpt_getDisc1VD(self, idisc)

    def getDisc2VD(self, idisc):
        r"""

        KrigOpt::getDisc2VD
        """
        return _gstlearn.KrigOpt_getDisc2VD(self, idisc)

    def getDisc1VVD(self):
        r"""

        KrigOpt::getDisc1VVD
        """
        return _gstlearn.KrigOpt_getDisc1VVD(self)

    def getDisc2VVD(self):
        r"""

        KrigOpt::getDisc2VVD
        """
        return _gstlearn.KrigOpt_getDisc2VVD(self)

    def getMatLC(self):
        r"""

        KrigOpt::getMatLC
        """
        return _gstlearn.KrigOpt_getMatLC(self)

    def getMatLCValue(self, ivarcl, ivar):
        r"""

        KrigOpt::getMatLCValue
        """
        return _gstlearn.KrigOpt_getMatLCValue(self, ivarcl, ivar)

    def hasMatLC(self):
        r"""

        KrigOpt::hasMatLC
        """
        return _gstlearn.KrigOpt_hasMatLC(self)

    def getMatLCNRows(self):
        r"""

        KrigOpt::getMatLCNRows
        """
        return _gstlearn.KrigOpt_getMatLCNRows(self)

    def getNvarLC(self):
        r"""

        KrigOpt::getNvarLC
        """
        return _gstlearn.KrigOpt_getNvarLC(self)

    def getRankColcok(self, *args):
        r"""

        KrigOpt::getRankColcok
        """
        return _gstlearn.KrigOpt_getRankColcok(self, *args)

    def hasColcok(self):
        r"""

        KrigOpt::hasColcok
        """
        return _gstlearn.KrigOpt_hasColcok(self)

    def hasFlagDGM(self):
        r"""

        KrigOpt::hasFlagDGM
        """
        return _gstlearn.KrigOpt_hasFlagDGM(self)

    def isCorrect(self, dbout, neigh, model):
        r"""

        KrigOpt::isCorrect
        """
        return _gstlearn.KrigOpt_isCorrect(self, dbout, neigh, model)

    def dumpOptions(self):
        r"""

        KrigOpt::dumpOptions
        """
        return _gstlearn.KrigOpt_dumpOptions(self)

# Register KrigOpt in _gstlearn:
_gstlearn.KrigOpt_swigregister(KrigOpt)
class AModelOptim(object):
    r"""


    C++ includes: AModelOptim.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setEnvironment(self, vars, href):
        r"""

        AModelOptim::setEnvironment
        """
        return _gstlearn.AModelOptim_setEnvironment(self, vars, href)

    def setAuthorizedAnalyticalGradients(self, authorized):
        r"""

        AModelOptim::setAuthorizedAnalyticalGradients
        """
        return _gstlearn.AModelOptim_setAuthorizedAnalyticalGradients(self, authorized)

    def getAuthorizedAnalyticalGradients(self):
        r"""

        AModelOptim::getAuthorizedAnalyticalGradients
        """
        return _gstlearn.AModelOptim_getAuthorizedAnalyticalGradients(self)
    __swig_destroy__ = _gstlearn.delete_AModelOptim

    def setGradients(self, gradients):
        r"""

        AModelOptim::setGradients
        """
        return _gstlearn.AModelOptim_setGradients(self, gradients)

    def setVerbose(self, verbose=False, trace=False):
        r"""

        AModelOptim::setVerbose
        """
        return _gstlearn.AModelOptim_setVerbose(self, verbose, trace)

    def eval(self, x):
        r"""

        AModelOptim::eval
        """
        return _gstlearn.AModelOptim_eval(self, x)

    def evalGrad(self, res):
        r"""

        AModelOptim::evalGrad
        """
        return _gstlearn.AModelOptim_evalGrad(self, res)

    def run(self):
        r"""

        AModelOptim::run
        """
        return _gstlearn.AModelOptim_run(self)

    def resetIter(self):
        r"""

        AModelOptim::resetIter
        """
        return _gstlearn.AModelOptim_resetIter(self)

    def computeCost(self, verbose=False):
        r"""

        AModelOptim::computeCost
        """
        return _gstlearn.AModelOptim_computeCost(self, verbose)

# Register AModelOptim in _gstlearn:
_gstlearn.AModelOptim_swigregister(AModelOptim)
class ALikelihood(AModelOptim):
    r"""


    C++ includes: ALikelihood.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ALikelihood

    def init(self, verbose=False):
        r"""

        ALikelihood::init
        """
        return _gstlearn.ALikelihood_init(self, verbose)

    def computeCost(self, verbose=False):
        r"""

        ALikelihood::computeCost
        """
        return _gstlearn.ALikelihood_computeCost(self, verbose)

    def computeLogLikelihood(self, verbose=False):
        r"""

        ALikelihood::computeLogLikelihood
        """
        return _gstlearn.ALikelihood_computeLogLikelihood(self, verbose)

# Register ALikelihood in _gstlearn:
_gstlearn.ALikelihood_swigregister(ALikelihood)
class Vecchia(ALikelihood):
    r"""


    C++ includes: Vecchia.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Vecchia::Vecchia
        """
        _gstlearn.Vecchia_swiginit(self, _gstlearn.new_Vecchia(*args))
    __swig_destroy__ = _gstlearn.delete_Vecchia

    @staticmethod
    def createForOptim(model, db1, nb_neigh=30):
        r"""

        Vecchia::createForOptim
        """
        return _gstlearn.Vecchia_createForOptim(model, db1, nb_neigh)

    def computeLower(self, Ranks, verbose=False):
        r"""

        Vecchia::computeLower
        Construct the Vecchia approximation starting from 'Ranks'.  

        Parameters
        ----------
        * `Ranks` :  
            MatrixT<int> which the ranks of the sample indices for each target  
        * `verbose` :  
            Verbose flag  

        Returns
        -------
        int Error returned code  

        note: The dimension of 'Rank' is:  

            *   ncols = Dimension of the Neighborhood + 1  
            *   nrows = Number of samples (dbin and dbout [optional])  

        note: For each row, the first element of 'Ranks' is the sample number  

            *   if smaller than N_dbin, it refers to the sample absolute rank in 'dbin'  
            *   if larger, its value (after subtracting N_dbin) gives the sample
                absolute rank in 'dbout'  

        """
        return _gstlearn.Vecchia_computeLower(self, Ranks, verbose)

    def getDFull(self):
        r"""

        Vecchia::getDFull
        """
        return _gstlearn.Vecchia_getDFull(self)

    def getDMat(self):
        r"""

        Vecchia::getDMat
        """
        return _gstlearn.Vecchia_getDMat(self)

    def getLFull(self, *args):
        r"""

        Vecchia::getLFull
        """
        return _gstlearn.Vecchia_getLFull(self, *args)

    def getND(self):
        r"""

        Vecchia::getND
        """
        return _gstlearn.Vecchia_getND(self)

    def getNT(self):
        r"""

        Vecchia::getNT
        """
        return _gstlearn.Vecchia_getNT(self)

    def productMatVecchia(self, X, resmat):
        r"""

        Vecchia::productMatVecchia
        """
        return _gstlearn.Vecchia_productMatVecchia(self, X, resmat)

    def productVecchia(self, Y, res):
        r"""

        Vecchia::productVecchia
        """
        return _gstlearn.Vecchia_productVecchia(self, Y, res)

    def calculateLdY(self, Y):
        r"""

        Vecchia::calculateLdY
        """
        return _gstlearn.Vecchia_calculateLdY(self, Y)

    def calculateFtLdY(self, LdY):
        r"""

        Vecchia::calculateFtLdY
        """
        return _gstlearn.Vecchia_calculateFtLdY(self, LdY)

    def calculateW(self, D_dd):
        r"""

        Vecchia::calculateW
        Product 't(A)' %*% 'M' %*% 'A' or 'A' %*% 'M' %*% 't(A)'  

        """
        return _gstlearn.Vecchia_calculateW(self, D_dd)

# Register Vecchia in _gstlearn:
_gstlearn.Vecchia_swigregister(Vecchia)

def krigingVecchia(*args, **kwargs):
    r"""


    """
    return _gstlearn.krigingVecchia(*args, **kwargs)

def logLikelihoodVecchia(db, model, nb_neigh=5, verbose=False):
    r"""


    Compute the log-likelihood (based on Vecchia approximation for covMat)  

    Parameters
    ----------
    * `db` :  
        Db structure where variable are loaded from  
    * `model` :  
        ModelGeneric structure used for the calculation  
    * `nb_neigh` :  
        Number of neighbors to consider in the Vecchia approximation  
    * `verbose` :  
        Verbose flag  

    remark: The calculation considers all the active samples.  

    remark: It can work in multivariate case with or without drift conditions
        (linked or not)  

    remark: The algorithm is stopped (with a message) in the heterotopic case  

    """
    return _gstlearn.logLikelihoodVecchia(db, model, nb_neigh, verbose)
class Likelihood(ALikelihood):
    r"""


    C++ includes: Likelihood.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Likelihood::Likelihood
        """
        _gstlearn.Likelihood_swiginit(self, _gstlearn.new_Likelihood(*args))
    __swig_destroy__ = _gstlearn.delete_Likelihood

    @staticmethod
    def createForOptim(model, db):
        r"""

        Likelihood::createForOptim
        """
        return _gstlearn.Likelihood_createForOptim(model, db)

    def evalGrad(self, res):
        r"""

        Likelihood::evalGrad
        """
        return _gstlearn.Likelihood_evalGrad(self, res)

# Register Likelihood in _gstlearn:
_gstlearn.Likelihood_swigregister(Likelihood)
class AOF(object):
    r"""


    C++ includes: AOF.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        AOF::AOF
        """
        _gstlearn.AOF_swiginit(self, _gstlearn.new_AOF(*args))
    __swig_destroy__ = _gstlearn.delete_AOF

    def mustBeGrid(self):
        r"""

        AOF::mustBeGrid
        """
        return _gstlearn.AOF_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        AOF::mustBeOneVariable
        """
        return _gstlearn.AOF_mustBeOneVariable(self)

    def mustBeForNDim(self, arg2):
        r"""

        AOF::mustBeForNDim
        """
        return _gstlearn.AOF_mustBeForNDim(self, arg2)

    def mustBeForRotation(self, arg2):
        r"""

        AOF::mustBeForRotation
        """
        return _gstlearn.AOF_mustBeForRotation(self, arg2)

    def isAuthorized(self):
        r"""

        AOF::isAuthorized
        """
        return _gstlearn.AOF_isAuthorized(self)

    def writeInFile(self):
        r"""

        AOF::writeInFile
        """
        return _gstlearn.AOF_writeInFile(self)

    def readFromFile(self):
        r"""

        AOF::readFromFile
        """
        return _gstlearn.AOF_readFromFile(self)

    def readGridFromFile(self):
        r"""

        AOF::readGridFromFile
        """
        return _gstlearn.AOF_readGridFromFile(self)

    def isValidForGrid(self):
        r"""

        AOF::isValidForGrid
        """
        return _gstlearn.AOF_isValidForGrid(self)

    def isValidForVariable(self):
        r"""

        AOF::isValidForVariable
        """
        return _gstlearn.AOF_isValidForVariable(self)

    def isValidForNDim(self):
        r"""

        AOF::isValidForNDim
        """
        return _gstlearn.AOF_isValidForNDim(self)

    def isValidForRotation(self):
        r"""

        AOF::isValidForRotation
        """
        return _gstlearn.AOF_isValidForRotation(self)

    def setCols(self, *args):
        r"""

        AOF::setCols
        """
        return _gstlearn.AOF_setCols(self, *args)

    def setCol(self, icol):
        r"""

        AOF::setCol
        """
        return _gstlearn.AOF_setCol(self, icol)

    def getFilename(self):
        r"""

        AOF::getFilename
        """
        return _gstlearn.AOF_getFilename(self)

# Register AOF in _gstlearn:
_gstlearn.AOF_swigregister(AOF)

def db_grid_read_f2g(filename, verbose=0):
    r"""


    """
    return _gstlearn.db_grid_read_f2g(filename, verbose)

def db_grid_write_zycor(filename, db, icol):
    r"""


    """
    return _gstlearn.db_grid_write_zycor(filename, db, icol)

def db_grid_read_zycor(filename, verbose=0):
    r"""


    """
    return _gstlearn.db_grid_read_zycor(filename, verbose)

def db_grid_write_arcgis(filename, db, icol):
    r"""


    """
    return _gstlearn.db_grid_write_arcgis(filename, db, icol)

def db_grid_write_XYZ(filename, db, icol):
    r"""


    Read / Write a File (Grid or Not) according to different format  

    Returns
    -------
    Error return code  

    """
    return _gstlearn.db_grid_write_XYZ(filename, db, icol)

def db_write_vtk(filename, db, cols):
    r"""


    """
    return _gstlearn.db_write_vtk(filename, db, cols)

def db_grid_write_bmp(filename, db, icol, nsamplex=1, nsampley=1, nmult=1, ncolor=1, flag_low=1, flag_high=1, valmin=1.234e30, valmax=1.234e30, red=None, green=None, blue=None, mask_red=0, mask_green=0, mask_blue=0, ffff_red=232, ffff_green=232, ffff_blue=0, low_red=255, low_green=255, low_blue=255, high_red=255, high_green=0, high_blue=0):
    r"""


    """
    return _gstlearn.db_grid_write_bmp(filename, db, icol, nsamplex, nsampley, nmult, ncolor, flag_low, flag_high, valmin, valmax, red, green, blue, mask_red, mask_green, mask_blue, ffff_red, ffff_green, ffff_blue, low_red, low_green, low_blue, high_red, high_green, high_blue)

def db_grid_read_bmp(filename, verbose=0):
    r"""


    """
    return _gstlearn.db_grid_read_bmp(filename, verbose)

def db_grid_write_irap(filename, db, icol, nsamplex=1, nsampley=1):
    r"""


    """
    return _gstlearn.db_grid_write_irap(filename, db, icol, nsamplex, nsampley)

def db_grid_write_ifpen(filename, db, ncol, icols):
    r"""


    """
    return _gstlearn.db_grid_write_ifpen(filename, db, ncol, icols)

def db_grid_read_ifpen(filename, verbose=0):
    r"""


    """
    return _gstlearn.db_grid_read_ifpen(filename, verbose)

def db_grid_write_eclipse(filename, db, icol):
    r"""


    """
    return _gstlearn.db_grid_write_eclipse(filename, db, icol)

def db_well_read_las(filename, xwell, ywell, cwell, verbose=0):
    r"""


    """
    return _gstlearn.db_well_read_las(filename, xwell, ywell, cwell, verbose)
class FileLAS(AOF):
    r"""


    C++ includes: FileLAS.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        FileLAS::FileLAS
        """
        _gstlearn.FileLAS_swiginit(self, _gstlearn.new_FileLAS(*args))
    __swig_destroy__ = _gstlearn.delete_FileLAS

    def mustBeGrid(self):
        r"""

        FileLAS::mustBeGrid
        """
        return _gstlearn.FileLAS_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        FileLAS::mustBeOneVariable
        """
        return _gstlearn.FileLAS_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        FileLAS::mustBeForNDim
        """
        return _gstlearn.FileLAS_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        FileLAS::mustBeForRotation
        """
        return _gstlearn.FileLAS_mustBeForRotation(self, mode)

    def readFromFile(self):
        r"""

        FileLAS::readFromFile
        """
        return _gstlearn.FileLAS_readFromFile(self)

    def setCwell(self, cwell):
        r"""

        FileLAS::setCwell
        """
        return _gstlearn.FileLAS_setCwell(self, cwell)

    def setXwell(self, xwell):
        r"""

        FileLAS::setXwell
        """
        return _gstlearn.FileLAS_setXwell(self, xwell)

    def setYwell(self, ywell):
        r"""

        FileLAS::setYwell
        """
        return _gstlearn.FileLAS_setYwell(self, ywell)

# Register FileLAS in _gstlearn:
_gstlearn.FileLAS_swigregister(FileLAS)
class FileVTK(AOF):
    r"""


    C++ includes: FileVTK.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        FileVTK::FileVTK
        """
        _gstlearn.FileVTK_swiginit(self, _gstlearn.new_FileVTK(*args))
    __swig_destroy__ = _gstlearn.delete_FileVTK

    def mustBeGrid(self):
        r"""

        FileVTK::mustBeGrid
        """
        return _gstlearn.FileVTK_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        FileVTK::mustBeOneVariable
        """
        return _gstlearn.FileVTK_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        FileVTK::mustBeForNDim
        """
        return _gstlearn.FileVTK_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        FileVTK::mustBeForRotation
        """
        return _gstlearn.FileVTK_mustBeForRotation(self, mode)

    def writeInFile(self):
        r"""

        FileVTK::writeInFile
        """
        return _gstlearn.FileVTK_writeInFile(self)

    def setFactvar(self, factvar):
        r"""

        FileVTK::setFactvar
        """
        return _gstlearn.FileVTK_setFactvar(self, factvar)

    def setFactx(self, factx):
        r"""

        FileVTK::setFactx
        """
        return _gstlearn.FileVTK_setFactx(self, factx)

    def setFacty(self, facty):
        r"""

        FileVTK::setFacty
        """
        return _gstlearn.FileVTK_setFacty(self, facty)

    def setFactz(self, factz):
        r"""

        FileVTK::setFactz
        """
        return _gstlearn.FileVTK_setFactz(self, factz)

    def setFlagBinary(self, flagBinary):
        r"""

        FileVTK::setFlagBinary
        """
        return _gstlearn.FileVTK_setFlagBinary(self, flagBinary)

# Register FileVTK in _gstlearn:
_gstlearn.FileVTK_swigregister(FileVTK)
class GridArcGis(AOF):
    r"""


    C++ includes: GridArcGis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridArcGis::GridArcGis
        """
        _gstlearn.GridArcGis_swiginit(self, _gstlearn.new_GridArcGis(*args))
    __swig_destroy__ = _gstlearn.delete_GridArcGis

    def mustBeGrid(self):
        r"""

        GridArcGis::mustBeGrid
        """
        return _gstlearn.GridArcGis_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridArcGis::mustBeOneVariable
        """
        return _gstlearn.GridArcGis_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        GridArcGis::mustBeForNDim
        """
        return _gstlearn.GridArcGis_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        GridArcGis::mustBeForRotation
        """
        return _gstlearn.GridArcGis_mustBeForRotation(self, mode)

    def isAuthorized(self):
        r"""

        GridArcGis::isAuthorized
        """
        return _gstlearn.GridArcGis_isAuthorized(self)

    def writeInFile(self):
        r"""

        GridArcGis::writeInFile
        """
        return _gstlearn.GridArcGis_writeInFile(self)

# Register GridArcGis in _gstlearn:
_gstlearn.GridArcGis_swigregister(GridArcGis)
class GridBmp(AOF):
    r"""


    C++ includes: GridBmp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridBmp::GridBmp
        """
        _gstlearn.GridBmp_swiginit(self, _gstlearn.new_GridBmp(*args))
    __swig_destroy__ = _gstlearn.delete_GridBmp

    def mustBeGrid(self):
        r"""

        GridBmp::mustBeGrid
        """
        return _gstlearn.GridBmp_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridBmp::mustBeOneVariable
        """
        return _gstlearn.GridBmp_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        GridBmp::mustBeForNDim
        """
        return _gstlearn.GridBmp_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        GridBmp::mustBeForRotation
        """
        return _gstlearn.GridBmp_mustBeForRotation(self, mode)

    def writeInFile(self):
        r"""

        GridBmp::writeInFile
        """
        return _gstlearn.GridBmp_writeInFile(self)

    def readGridFromFile(self):
        r"""

        GridBmp::readGridFromFile
        """
        return _gstlearn.GridBmp_readGridFromFile(self)

    def setColors(self, reds, greens, blues):
        r"""

        GridBmp::setColors
        """
        return _gstlearn.GridBmp_setColors(self, reds, greens, blues)

    def setFFFF(self, red, green, blue):
        r"""

        GridBmp::setFFFF
        """
        return _gstlearn.GridBmp_setFFFF(self, red, green, blue)

    def setHigh(self, red, green, blue):
        r"""

        GridBmp::setHigh
        """
        return _gstlearn.GridBmp_setHigh(self, red, green, blue)

    def setLow(self, red, green, blue):
        r"""

        GridBmp::setLow
        """
        return _gstlearn.GridBmp_setLow(self, red, green, blue)

    def setMask(self, red, green, blue):
        r"""

        GridBmp::setMask
        """
        return _gstlearn.GridBmp_setMask(self, red, green, blue)

    def setFlagHigh(self, flagHigh):
        r"""

        GridBmp::setFlagHigh
        """
        return _gstlearn.GridBmp_setFlagHigh(self, flagHigh)

    def setFlagLow(self, flagLow):
        r"""

        GridBmp::setFlagLow
        """
        return _gstlearn.GridBmp_setFlagLow(self, flagLow)

    def setNcolor(self, ncolor):
        r"""

        GridBmp::setNcolor
        """
        return _gstlearn.GridBmp_setNcolor(self, ncolor)

    def setNmult(self, nmult):
        r"""

        GridBmp::setNmult
        """
        return _gstlearn.GridBmp_setNmult(self, nmult)

    def setNsamplex(self, nsamplex):
        r"""

        GridBmp::setNsamplex
        """
        return _gstlearn.GridBmp_setNsamplex(self, nsamplex)

    def setNsampley(self, nsampley):
        r"""

        GridBmp::setNsampley
        """
        return _gstlearn.GridBmp_setNsampley(self, nsampley)

    def setValmax(self, valmax):
        r"""

        GridBmp::setValmax
        """
        return _gstlearn.GridBmp_setValmax(self, valmax)

    def setValmin(self, valmin):
        r"""

        GridBmp::setValmin
        """
        return _gstlearn.GridBmp_setValmin(self, valmin)

# Register GridBmp in _gstlearn:
_gstlearn.GridBmp_swigregister(GridBmp)
class GridEclipse(AOF):
    r"""


    C++ includes: GridEclipse.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridEclipse::GridEclipse
        """
        _gstlearn.GridEclipse_swiginit(self, _gstlearn.new_GridEclipse(*args))
    __swig_destroy__ = _gstlearn.delete_GridEclipse

    def mustBeGrid(self):
        r"""

        GridEclipse::mustBeGrid
        """
        return _gstlearn.GridEclipse_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridEclipse::mustBeOneVariable
        """
        return _gstlearn.GridEclipse_mustBeOneVariable(self)

    def mustBeForNDim(self, arg2):
        r"""

        GridEclipse::mustBeForNDim
        """
        return _gstlearn.GridEclipse_mustBeForNDim(self, arg2)

    def mustBeForRotation(self, mode):
        r"""

        GridEclipse::mustBeForRotation
        """
        return _gstlearn.GridEclipse_mustBeForRotation(self, mode)

    def writeInFile(self):
        r"""

        GridEclipse::writeInFile
        """
        return _gstlearn.GridEclipse_writeInFile(self)

# Register GridEclipse in _gstlearn:
_gstlearn.GridEclipse_swigregister(GridEclipse)
class GridF2G(AOF):
    r"""


    C++ includes: GridF2G.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridF2G::GridF2G
        """
        _gstlearn.GridF2G_swiginit(self, _gstlearn.new_GridF2G(*args))
    __swig_destroy__ = _gstlearn.delete_GridF2G

    def mustBeGrid(self):
        r"""

        GridF2G::mustBeGrid
        """
        return _gstlearn.GridF2G_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridF2G::mustBeOneVariable
        """
        return _gstlearn.GridF2G_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        GridF2G::mustBeForNDim
        """
        return _gstlearn.GridF2G_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        GridF2G::mustBeForRotation
        """
        return _gstlearn.GridF2G_mustBeForRotation(self, mode)

    def readGridFromFile(self):
        r"""

        GridF2G::readGridFromFile
        """
        return _gstlearn.GridF2G_readGridFromFile(self)

# Register GridF2G in _gstlearn:
_gstlearn.GridF2G_swigregister(GridF2G)
class GridIfpEn(AOF):
    r"""


    C++ includes: GridIfpEn.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridIfpEn::GridIfpEn
        """
        _gstlearn.GridIfpEn_swiginit(self, _gstlearn.new_GridIfpEn(*args))
    __swig_destroy__ = _gstlearn.delete_GridIfpEn

    def mustBeGrid(self):
        r"""

        GridIfpEn::mustBeGrid
        """
        return _gstlearn.GridIfpEn_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridIfpEn::mustBeOneVariable
        """
        return _gstlearn.GridIfpEn_mustBeOneVariable(self)

    def mustBeForNDim(self, arg2):
        r"""

        GridIfpEn::mustBeForNDim
        """
        return _gstlearn.GridIfpEn_mustBeForNDim(self, arg2)

    def mustBeForRotation(self, mode):
        r"""

        GridIfpEn::mustBeForRotation
        """
        return _gstlearn.GridIfpEn_mustBeForRotation(self, mode)

    def writeInFile(self):
        r"""

        GridIfpEn::writeInFile
        """
        return _gstlearn.GridIfpEn_writeInFile(self)

    def readGridFromFile(self):
        r"""

        GridIfpEn::readGridFromFile
        """
        return _gstlearn.GridIfpEn_readGridFromFile(self)

# Register GridIfpEn in _gstlearn:
_gstlearn.GridIfpEn_swigregister(GridIfpEn)
class GridIrap(AOF):
    r"""


    C++ includes: GridIrap.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridIrap::GridIrap
        """
        _gstlearn.GridIrap_swiginit(self, _gstlearn.new_GridIrap(*args))
    __swig_destroy__ = _gstlearn.delete_GridIrap

    def mustBeGrid(self):
        r"""

        GridIrap::mustBeGrid
        """
        return _gstlearn.GridIrap_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridIrap::mustBeOneVariable
        """
        return _gstlearn.GridIrap_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        GridIrap::mustBeForNDim
        """
        return _gstlearn.GridIrap_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        GridIrap::mustBeForRotation
        """
        return _gstlearn.GridIrap_mustBeForRotation(self, mode)

    def writeInFile(self):
        r"""

        GridIrap::writeInFile
        """
        return _gstlearn.GridIrap_writeInFile(self)

    def getNsamplex(self):
        r"""

        GridIrap::getNsamplex
        """
        return _gstlearn.GridIrap_getNsamplex(self)

    def setNsamplex(self, nsamplex):
        r"""

        GridIrap::setNsamplex
        """
        return _gstlearn.GridIrap_setNsamplex(self, nsamplex)

    def getNsampley(self):
        r"""

        GridIrap::getNsampley
        """
        return _gstlearn.GridIrap_getNsampley(self)

    def setNsampley(self, nsampley):
        r"""

        GridIrap::setNsampley
        """
        return _gstlearn.GridIrap_setNsampley(self, nsampley)

# Register GridIrap in _gstlearn:
_gstlearn.GridIrap_swigregister(GridIrap)
class GridXYZ(AOF):
    r"""


    C++ includes: GridXYZ.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridXYZ::GridXYZ
        """
        _gstlearn.GridXYZ_swiginit(self, _gstlearn.new_GridXYZ(*args))
    __swig_destroy__ = _gstlearn.delete_GridXYZ

    def mustBeGrid(self):
        r"""

        GridXYZ::mustBeGrid
        """
        return _gstlearn.GridXYZ_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridXYZ::mustBeOneVariable
        """
        return _gstlearn.GridXYZ_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        GridXYZ::mustBeForNDim
        """
        return _gstlearn.GridXYZ_mustBeForNDim(self, ndim)

    def writeInFile(self):
        r"""

        GridXYZ::writeInFile
        """
        return _gstlearn.GridXYZ_writeInFile(self)

# Register GridXYZ in _gstlearn:
_gstlearn.GridXYZ_swigregister(GridXYZ)
class GridZycor(AOF):
    r"""


    C++ includes: GridZycor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GridZycor::GridZycor
        """
        _gstlearn.GridZycor_swiginit(self, _gstlearn.new_GridZycor(*args))
    __swig_destroy__ = _gstlearn.delete_GridZycor

    def mustBeGrid(self):
        r"""

        GridZycor::mustBeGrid
        """
        return _gstlearn.GridZycor_mustBeGrid(self)

    def mustBeOneVariable(self):
        r"""

        GridZycor::mustBeOneVariable
        """
        return _gstlearn.GridZycor_mustBeOneVariable(self)

    def mustBeForNDim(self, ndim):
        r"""

        GridZycor::mustBeForNDim
        """
        return _gstlearn.GridZycor_mustBeForNDim(self, ndim)

    def mustBeForRotation(self, mode):
        r"""

        GridZycor::mustBeForRotation
        """
        return _gstlearn.GridZycor_mustBeForRotation(self, mode)

    def writeInFile(self):
        r"""

        GridZycor::writeInFile
        """
        return _gstlearn.GridZycor_writeInFile(self)

    def readGridFromFile(self):
        r"""

        GridZycor::readGridFromFile
        """
        return _gstlearn.GridZycor_readGridFromFile(self)

# Register GridZycor in _gstlearn:
_gstlearn.GridZycor_swigregister(GridZycor)
class SegYArg(object):
    r"""


    C++ includes: segy.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    error = property(_gstlearn.SegYArg_error_get, _gstlearn.SegYArg_error_set, doc=r"""


    """)
    ndescr = property(_gstlearn.SegYArg_ndescr_get, _gstlearn.SegYArg_ndescr_set)
    npertrace = property(_gstlearn.SegYArg_npertrace_get, _gstlearn.SegYArg_npertrace_set)
    ntraces = property(_gstlearn.SegYArg_ntraces_get, _gstlearn.SegYArg_ntraces_set)
    tab = property(_gstlearn.SegYArg_tab_get, _gstlearn.SegYArg_tab_set)
    descr = property(_gstlearn.SegYArg_descr_get, _gstlearn.SegYArg_descr_set)
    cotes = property(_gstlearn.SegYArg_cotes_get, _gstlearn.SegYArg_cotes_set)

    def __init__(self):
        r"""


        C++ includes: segy.h

        """
        _gstlearn.SegYArg_swiginit(self, _gstlearn.new_SegYArg())
    __swig_destroy__ = _gstlearn.delete_SegYArg

# Register SegYArg in _gstlearn:
_gstlearn.SegYArg_swigregister(SegYArg)

def segy_summary(*args, **kwargs):
    r"""


    Read the contents of a SEGY file and returns the structure SegyRead which
    captures the main characteristics of the SEGY grid  

    Parameters
    ----------
    * `filesegy` :  
        Name of the SEGY file  
    * `surf2D` :  
        Db containing the top, Bottom and Reference surfaces This file is optional  
    * `name_top` :  
        Rank of variable containing the Top Surface (or 0)  
    * `name_bot` :  
        Rank of variable containing the Bottom Surface (or 0)  
    * `thickmin` :  
        Minimum thickness (or 0)  
    * `option` :  
        Flattening option: 0 no flattening; 1 flattening from top; -1 flattening
        from bottom -2 squeeze and stretch option 2 averaging from 3-D to 2-D  
    * `nz_ss` :  
        Number of layers for different options (see details)  
    * `verbOption` :  
        Verbose option  
    * `iline_min` :  
        Minimum Inline number included (if defined)  
    * `iline_max` :  
        Maximum Inline number included (if defined)  
    * `xline_min` :  
        Minimum Xline number included (if defined)  
    * `xline_max` :  
        Maximum Xline number included (if defined)  
    * `modif_high` :  
        Upper truncation (when defined)  
    * `modif_low` :  
        Lower truncation (when defined)  
    * `modif_scale` :  
        Scaling value (when defined)  
    * `codefmt` :  
        Reading format  

    : In the case of Squeeze and Stretch (S&S), the number of layers  

    : is meaningless. It is fixed by the user, unless defined  

    : by the output grid (if flag_store == 1)  

    """
    return _gstlearn.segy_summary(*args, **kwargs)

def segy_array(*args, **kwargs):
    r"""


    Read the contents of a SEGY file  

    Returns
    -------
    A SegYArg structure which contains:  

    Returns
    -------
    - a vector of trace vectors  

    Returns
    -------
    - a vector of trace descriptors  

    Returns
    -------  

    Returns
    -------
    The Descriptor for each trace contains:  

    Returns
    -------
    0: Absolute rank for the trace number  

    Returns
    -------
    1: Cross-Line number  

    Returns
    -------
    2: In-Line number  

    Returns
    -------
    3: Coordinate along X  

    Returns
    -------
    4: Coordinate along Y  

    Returns
    -------
    5: Minimum Elevation  

    Returns
    -------
    6: Maximum Elevation  

    Returns
    -------
    7: Minimum Value  

    Returns
    -------
    8: Maximum value  

    Returns
    -------
    9: Thickness  

    Returns
    -------
    10: Number of values  

    Returns
    -------
    11: Minimum Elevation of Auxiliary surface  

    Returns
    -------
    12: Maximum Elevation of Auxiliary surface  

    Parameters
    ----------
    * `filesegy` :  
        Name of the SEGY file  
    * `surf2D` :  
        Db containing the top, Bottom and Reference surfaces This file is optional  
    * `top_name` :  
        Name of variable containing the Top Surface (or "")  
    * `bot_name` :  
        Name of variable containing the Bottom Surface (or "")  
    * `top_aux` :  
        Name of auxiliary variable containing a Top (or "")  
    * `bot_aux` :  
        Name of auxiliary variable containing a Top (or "")  
    * `thickmin` :  
        Minimum thickness (or 0)  
    * `option` :  
        Flattening option: 0 no flattening; 1 flattening from top; -1 flattening
        from bottom -2 squeeze and stretch option 2 averaging from 3-D to 2-D  
    * `nz_ss` :  
        Number of layers for different options (see details)  
    * `verbOption` :  
        Verbose option  
    * `iline_min` :  
        Minimum Inline number included (if defined)  
    * `iline_max` :  
        Maximum Inline number included (if defined)  
    * `xline_min` :  
        Minimum Xline number included (if defined)  
    * `xline_max` :  
        Maximum Xline number included (if defined)  
    * `modif_high` :  
        Upper truncation (when defined)  
    * `modif_low` :  
        Lower truncation (when defined)  
    * `modif_scale` :  
        Scaling value (when defined)  
    * `codefmt` :  
        Reading format  

    In the case of Squeeze and Stretch (S&S), the number of layers  

    is meaningless. It is fixed by the user.  

    """
    return _gstlearn.segy_array(*args, **kwargs)

def db_segy(*args, **kwargs):
    r"""


    Read the contents of a SEGY file  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `filesegy` :  
        Name of the SEGY file  
    * `grid3D` :  
        Db containing the resulting 3-D grid  
    * `surf2D` :  
        Db containing the top, Bottom and Reference surfaces This file is optional  
    * `name_top` :  
        Rank of variable containing the Top Surface (or 0)  
    * `name_bot` :  
        Rank of variable containing the Bottom Surface (or 0)  
    * `thickmin` :  
        Minimum thickness (or 0)  
    * `option` :  
        Flattening option: 0 no flattening; 1 flattening from top; -1 flattening
        from bottom -2 squeeze and stretch option 2 averaging from 3-D to 2-D  
    * `nz_ss` :  
        Deprecated argument  
    * `verbOption` :  
        Verbose option  
    * `iline_min` :  
        Minimum Inline number included (if defined)  
    * `iline_max` :  
        Maximum Inline number included (if defined)  
    * `xline_min` :  
        Minimum Xline number included (if defined)  
    * `xline_max` :  
        Maximum Xline number included (if defined)  
    * `modif_high` :  
        Upper truncation (when defined)  
    * `modif_low` :  
        Lower truncation (when defined)  
    * `modif_scale` :  
        Scaling value (when defined)  
    * `codefmt` :  
        Reading format  
    * `namconv` :  
        Naming convention  

    : In the case of Squeeze and Stretch (S&S), the number of layers  

    : is meaningless. It is fixed by the user, unless defined  

    : by the output grid (if flag_store == 1)  

    remark: For filling the 3-D grid  

    remark: - 2-D characteristics of the grid are taken into account  

    remark: - no attention is paid to the vertical mesh value.  

    """
    return _gstlearn.db_segy(*args, **kwargs)
class ACalcSimulation(ACalcInterpolator):
    r"""


    C++ includes: ACalcSimulation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gstlearn.delete_ACalcSimulation

    def getSeed(self):
        r"""

        ACalcSimulation::getSeed
        """
        return _gstlearn.ACalcSimulation_getSeed(self)

    def getNbSimu(self):
        r"""

        ACalcSimulation::getNbSimu
        """
        return _gstlearn.ACalcSimulation_getNbSimu(self)

    def setSeed(self, seed):
        r"""

        ACalcSimulation::setSeed
        """
        return _gstlearn.ACalcSimulation_setSeed(self, seed)

    def setNbSimu(self, nbsimu):
        r"""

        ACalcSimulation::setNbSimu
        """
        return _gstlearn.ACalcSimulation_setNbSimu(self, nbsimu)

# Register ACalcSimulation in _gstlearn:
_gstlearn.ACalcSimulation_swigregister(ACalcSimulation)
class CalcSimuTurningBands(ACalcSimulation):
    r"""


    C++ includes: CalcSimuTurningBands.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nbsimu=0, nbtuba=0, flag_check=False, seed=4324324):
        r"""

        CalcSimuTurningBands::CalcSimuTurningBands
        """
        _gstlearn.CalcSimuTurningBands_swiginit(self, _gstlearn.new_CalcSimuTurningBands(nbsimu, nbtuba, flag_check, seed))
    __swig_destroy__ = _gstlearn.delete_CalcSimuTurningBands

    def getNBtuba(self):
        r"""

        CalcSimuTurningBands::getNBtuba
        """
        return _gstlearn.CalcSimuTurningBands_getNBtuba(self)

    def setNBtuba(self, nbtuba):
        r"""

        CalcSimuTurningBands::setNBtuba
        """
        return _gstlearn.CalcSimuTurningBands_setNBtuba(self, nbtuba)

    def getNDirs(self):
        r"""

        CalcSimuTurningBands::getNDirs
        """
        return _gstlearn.CalcSimuTurningBands_getNDirs(self)

    def simulate(self, *args, **kwargs):
        r"""

        CalcSimuTurningBands::simulate
        Perform the Simulation Process using the Turning Bands Method  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `dbin` :  
            Input Db structure  
        * `dbout` :  
            Output Db structure  
        * `model` :  
            Model structure  
        * `neigh` :  
            ANeigh structure  
        * `icase` :  
            Case for PGS or -1  
        * `flag_bayes` :  
            1 if the Bayes option is switched ON  
        * `dmean` :  
            Array giving the prior means for the drift terms  
        * `dcov` :  
            Array containing the prior covariance matrix for the drift terms  
        * `flag_pgs` :  
            1 if called from PGS  
        * `flag_gibbs` :  
            1 if called from Gibbs  
        * `flag_dgm` :  
            1 if the Discrete Gaussian Model is used  

        """
        return _gstlearn.CalcSimuTurningBands_simulate(self, *args, **kwargs)

    def simulatePotential(self, dbiso, dbgrd, dbtgt, dbout, model, delta):
        r"""

        CalcSimuTurningBands::simulatePotential
        Perform the (non-conditional) Simulation(s) using the Turning Bands Method  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `dbiso` :  
            Isovalues Db structure  
        * `dbgrd` :  
            Gradient Db structure  
        * `dbtgt` :  
            Tangent Db structure  
        * `dbout` :  
            Output Db structure  
        * `model` :  
            Model structure  
        * `delta` :  
            Value of the increment  

        """
        return _gstlearn.CalcSimuTurningBands_simulatePotential(self, dbiso, dbgrd, dbtgt, dbout, model, delta)

    @staticmethod
    def isValidForTurningBands(model):
        r"""

        CalcSimuTurningBands::isValidForTurningBands
        Check if the Model can be simulated using Turning Bands  

        Returns
        -------
        True if the Model is valid; 0 otherwise  

        Parameters
        ----------
        * `model` :  
            Model structure  

        """
        return _gstlearn.CalcSimuTurningBands_isValidForTurningBands(model)

    def getBayesCov(self):
        r"""

        CalcSimuTurningBands::getBayesCov
        """
        return _gstlearn.CalcSimuTurningBands_getBayesCov(self)

    def setBayesCov(self, bayes_cov):
        r"""

        CalcSimuTurningBands::setBayesCov
        """
        return _gstlearn.CalcSimuTurningBands_setBayesCov(self, bayes_cov)

    def getBayesMean(self):
        r"""

        CalcSimuTurningBands::getBayesMean
        """
        return _gstlearn.CalcSimuTurningBands_getBayesMean(self)

    def setBayesMean(self, dmean):
        r"""

        CalcSimuTurningBands::setBayesMean
        """
        return _gstlearn.CalcSimuTurningBands_setBayesMean(self, dmean)

    def isFlagCheck(self):
        r"""

        CalcSimuTurningBands::isFlagCheck
        """
        return _gstlearn.CalcSimuTurningBands_isFlagCheck(self)

    def setFlagCheck(self, flag_check):
        r"""

        CalcSimuTurningBands::setFlagCheck
        """
        return _gstlearn.CalcSimuTurningBands_setFlagCheck(self, flag_check)

    def isFlagBayes(self):
        r"""

        CalcSimuTurningBands::isFlagBayes
        """
        return _gstlearn.CalcSimuTurningBands_isFlagBayes(self)

    def setFlagBayes(self, flag_bayes):
        r"""

        CalcSimuTurningBands::setFlagBayes
        """
        return _gstlearn.CalcSimuTurningBands_setFlagBayes(self, flag_bayes)

    def setFlagDgm(self, flag_dgm):
        r"""

        CalcSimuTurningBands::setFlagDgm
        """
        return _gstlearn.CalcSimuTurningBands_setFlagDgm(self, flag_dgm)

    def isFlagGibbs(self):
        r"""

        CalcSimuTurningBands::isFlagGibbs
        """
        return _gstlearn.CalcSimuTurningBands_isFlagGibbs(self)

    def setFlagGibbs(self, flag_gibbs):
        r"""

        CalcSimuTurningBands::setFlagGibbs
        """
        return _gstlearn.CalcSimuTurningBands_setFlagGibbs(self, flag_gibbs)

    def isFlagPgs(self):
        r"""

        CalcSimuTurningBands::isFlagPgs
        """
        return _gstlearn.CalcSimuTurningBands_isFlagPgs(self)

    def setFlagPgs(self, flag_pgs):
        r"""

        CalcSimuTurningBands::setFlagPgs
        """
        return _gstlearn.CalcSimuTurningBands_setFlagPgs(self, flag_pgs)

    def getIcase(self):
        r"""

        CalcSimuTurningBands::getIcase
        """
        return _gstlearn.CalcSimuTurningBands_getIcase(self)

    def setIcase(self, icase):
        r"""

        CalcSimuTurningBands::setIcase
        """
        return _gstlearn.CalcSimuTurningBands_setIcase(self, icase)

    def getNbtuba(self):
        r"""

        CalcSimuTurningBands::getNbtuba
        """
        return _gstlearn.CalcSimuTurningBands_getNbtuba(self)

    def setNbtuba(self, nbtuba):
        r"""

        CalcSimuTurningBands::setNbtuba
        """
        return _gstlearn.CalcSimuTurningBands_setNbtuba(self, nbtuba)

    def setFlagAllocationAlreadyDone(self, flag):
        r"""

        CalcSimuTurningBands::setFlagAllocationAlreadyDone
        """
        return _gstlearn.CalcSimuTurningBands_setFlagAllocationAlreadyDone(self, flag)

# Register CalcSimuTurningBands in _gstlearn:
_gstlearn.CalcSimuTurningBands_swigregister(CalcSimuTurningBands)

def simtub(*args, **kwargs):
    r"""


    Perform the conditional or non-conditional simulation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure (optional)  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Seed for random number generator  
    * `nbtuba` :  
        Number of turning bands  
    * `flag_dgm` :  
        1 for Direct Block Simulation  
    * `flag_check` :  
        1 to check the proximity in Gaussian scale  
    * `namconv` :  
        Naming convention  

    remark: The arguments 'dbin' and 'neigh' are optional: they must  

    remark: be defined only for conditional simulations  

    """
    return _gstlearn.simtub(*args, **kwargs)

def simbayes(*args, **kwargs):
    r"""


    Perform the conditional or non-conditional simulation with Bayesian Drift  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Input Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure (optional)  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Seed for random number generator  
    * `dmean` :  
        Array giving the prior means for the drift terms  
    * `dcov` :  
        Array containing the prior covariance matrix for the drift terms  
    * `nbtuba` :  
        Number of turning bands  
    * `flag_check` :  
        1 to check the proximity in Gaussian scale  
    * `namconv` :  
        Naming convention  

    remark: The arguments 'dbin' and 'neigh' are optional: they must  

    remark: be defined only for conditional simulations  

    """
    return _gstlearn.simbayes(*args, **kwargs)
class TurningBandDirection(object):
    r"""


    Class for management of Directions used in Turning Band algorithm Remark: The
    3-D definition is compulsory (even in 2-D)  

    C++ includes: TurningBandDirection.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        TurningBandDirection::TurningBandDirection
        """
        _gstlearn.TurningBandDirection_swiginit(self, _gstlearn.new_TurningBandDirection(*args))
    __swig_destroy__ = _gstlearn.delete_TurningBandDirection

    def getAng(self, *args):
        r"""

        TurningBandDirection::getAng
        """
        return _gstlearn.TurningBandDirection_getAng(self, *args)

    def getDXP(self):
        r"""

        TurningBandDirection::getDXP
        """
        return _gstlearn.TurningBandDirection_getDXP(self)

    def getDYP(self):
        r"""

        TurningBandDirection::getDYP
        """
        return _gstlearn.TurningBandDirection_getDYP(self)

    def getDZP(self):
        r"""

        TurningBandDirection::getDZP
        """
        return _gstlearn.TurningBandDirection_getDZP(self)

    def getT00(self):
        r"""

        TurningBandDirection::getT00
        """
        return _gstlearn.TurningBandDirection_getT00(self)

    def getTmax(self):
        r"""

        TurningBandDirection::getTmax
        """
        return _gstlearn.TurningBandDirection_getTmax(self)

    def getTmin(self):
        r"""

        TurningBandDirection::getTmin
        """
        return _gstlearn.TurningBandDirection_getTmin(self)

    def getScale(self):
        r"""

        TurningBandDirection::getScale
        """
        return _gstlearn.TurningBandDirection_getScale(self)

    def setAng(self, *args):
        r"""

        TurningBandDirection::setAng
        """
        return _gstlearn.TurningBandDirection_setAng(self, *args)

    def setDXP(self, dxp):
        r"""

        TurningBandDirection::setDXP
        """
        return _gstlearn.TurningBandDirection_setDXP(self, dxp)

    def setDYP(self, dyp):
        r"""

        TurningBandDirection::setDYP
        """
        return _gstlearn.TurningBandDirection_setDYP(self, dyp)

    def setDZP(self, dzp):
        r"""

        TurningBandDirection::setDZP
        """
        return _gstlearn.TurningBandDirection_setDZP(self, dzp)

    def setT00(self, t00):
        r"""

        TurningBandDirection::setT00
        """
        return _gstlearn.TurningBandDirection_setT00(self, t00)

    def setTmax(self, tmax):
        r"""

        TurningBandDirection::setTmax
        """
        return _gstlearn.TurningBandDirection_setTmax(self, tmax)

    def setTmin(self, tmin):
        r"""

        TurningBandDirection::setTmin
        """
        return _gstlearn.TurningBandDirection_setTmin(self, tmin)

    def setScale(self, scale):
        r"""

        TurningBandDirection::setScale
        """
        return _gstlearn.TurningBandDirection_setScale(self, scale)

    def projectPoint(self, db, iech):
        r"""

        TurningBandDirection::projectPoint
        Calculates the projection of a point on a turning band  

        Returns
        -------
        Projection value  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `iech` :  
            rank of the sample  

        """
        return _gstlearn.TurningBandDirection_projectPoint(self, db, iech)

    def projectGrid(self, db, ix, iy, iz):
        r"""

        TurningBandDirection::projectGrid
        Calculates the projection of a grid node on a turning band  

        Returns
        -------
        Projection value  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `ix` :  
            grid index along X  
        * `iy` :  
            grid index along Y  
        * `iz` :  
            grid index along Z  

        """
        return _gstlearn.TurningBandDirection_projectGrid(self, db, ix, iy, iz)

    def dump(self, flagGrid=True):
        r"""

        TurningBandDirection::dump
        """
        return _gstlearn.TurningBandDirection_dump(self, flagGrid)

# Register TurningBandDirection in _gstlearn:
_gstlearn.TurningBandDirection_swigregister(TurningBandDirection)
class TurningBandOperate(object):
    r"""


    Class for management of Directions used in Turning Band algorithm Remark: The
    3-D definition is compulsory (even in 2-D)  

    C++ includes: TurningBandOperate.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        TurningBandOperate::TurningBandOperate
        """
        _gstlearn.TurningBandOperate_swiginit(self, _gstlearn.new_TurningBandOperate(*args))
    __swig_destroy__ = _gstlearn.delete_TurningBandOperate

    def getT(self):
        r"""

        TurningBandOperate::getT
        """
        return _gstlearn.TurningBandOperate_getT(self)

    def getV0(self):
        r"""

        TurningBandOperate::getV0
        """
        return _gstlearn.TurningBandOperate_getV0(self)

    def getV1(self):
        r"""

        TurningBandOperate::getV1
        """
        return _gstlearn.TurningBandOperate_getV1(self)

    def getV2(self):
        r"""

        TurningBandOperate::getV2
        """
        return _gstlearn.TurningBandOperate_getV2(self)

    def getNt0(self):
        r"""

        TurningBandOperate::getNt0
        """
        return _gstlearn.TurningBandOperate_getNt0(self)

    def isFlagScaled(self):
        r"""

        TurningBandOperate::isFlagScaled
        """
        return _gstlearn.TurningBandOperate_isFlagScaled(self)

    def getVexp(self):
        r"""

        TurningBandOperate::getVexp
        """
        return _gstlearn.TurningBandOperate_getVexp(self)

    def getTdeb(self):
        r"""

        TurningBandOperate::getTdeb
        """
        return _gstlearn.TurningBandOperate_getTdeb(self)

    def getOmega(self):
        r"""

        TurningBandOperate::getOmega
        """
        return _gstlearn.TurningBandOperate_getOmega(self)

    def getPhi(self):
        r"""

        TurningBandOperate::getPhi
        """
        return _gstlearn.TurningBandOperate_getPhi(self)

    def getOffset(self):
        r"""

        TurningBandOperate::getOffset
        """
        return _gstlearn.TurningBandOperate_getOffset(self)

    def getScale(self):
        r"""

        TurningBandOperate::getScale
        """
        return _gstlearn.TurningBandOperate_getScale(self)

    def setT(self, t):
        r"""

        TurningBandOperate::setT
        """
        return _gstlearn.TurningBandOperate_setT(self, t)

    def setV0(self, v0):
        r"""

        TurningBandOperate::setV0
        """
        return _gstlearn.TurningBandOperate_setV0(self, v0)

    def setV1(self, v1):
        r"""

        TurningBandOperate::setV1
        """
        return _gstlearn.TurningBandOperate_setV1(self, v1)

    def setV2(self, v2):
        r"""

        TurningBandOperate::setV2
        """
        return _gstlearn.TurningBandOperate_setV2(self, v2)

    def setNt0(self, nt0):
        r"""

        TurningBandOperate::setNt0
        """
        return _gstlearn.TurningBandOperate_setNt0(self, nt0)

    def setFlagScaled(self, flagScaled):
        r"""

        TurningBandOperate::setFlagScaled
        """
        return _gstlearn.TurningBandOperate_setFlagScaled(self, flagScaled)

    def setVexp(self, vexp):
        r"""

        TurningBandOperate::setVexp
        """
        return _gstlearn.TurningBandOperate_setVexp(self, vexp)

    def setTdeb(self, tdeb):
        r"""

        TurningBandOperate::setTdeb
        """
        return _gstlearn.TurningBandOperate_setTdeb(self, tdeb)

    def setOmega(self, omega):
        r"""

        TurningBandOperate::setOmega
        """
        return _gstlearn.TurningBandOperate_setOmega(self, omega)

    def setPhi(self, phi):
        r"""

        TurningBandOperate::setPhi
        """
        return _gstlearn.TurningBandOperate_setPhi(self, phi)

    def setOffset(self, offset):
        r"""

        TurningBandOperate::setOffset
        """
        return _gstlearn.TurningBandOperate_setOffset(self, offset)

    def setScale(self, scale):
        r"""

        TurningBandOperate::setScale
        """
        return _gstlearn.TurningBandOperate_setScale(self, scale)

    def getTsize(self):
        r"""

        TurningBandOperate::getTsize
        """
        return _gstlearn.TurningBandOperate_getTsize(self)

    def pushT(self, value):
        r"""

        TurningBandOperate::pushT
        """
        return _gstlearn.TurningBandOperate_pushT(self, value)

    def pushV0(self, value):
        r"""

        TurningBandOperate::pushV0
        """
        return _gstlearn.TurningBandOperate_pushV0(self, value)

    def pushV1(self, value):
        r"""

        TurningBandOperate::pushV1
        """
        return _gstlearn.TurningBandOperate_pushV1(self, value)

    def pushV2(self, value):
        r"""

        TurningBandOperate::pushV2
        """
        return _gstlearn.TurningBandOperate_pushV2(self, value)

    def reset(self):
        r"""

        TurningBandOperate::reset
        """
        return _gstlearn.TurningBandOperate_reset(self)

    def shotNoiseAffineOne(self, t0):
        r"""

        TurningBandOperate::shotNoiseAffineOne
        """
        return _gstlearn.TurningBandOperate_shotNoiseAffineOne(self, t0)

    def shotNoiseCubicOne(self, t0):
        r"""

        TurningBandOperate::shotNoiseCubicOne
        """
        return _gstlearn.TurningBandOperate_shotNoiseCubicOne(self, t0)

    def spectralOne(self, t0):
        r"""

        TurningBandOperate::spectralOne
        """
        return _gstlearn.TurningBandOperate_spectralOne(self, t0)

    def IRFProcessOne(self, t0):
        r"""

        TurningBandOperate::IRFProcessOne
        """
        return _gstlearn.TurningBandOperate_IRFProcessOne(self, t0)

    def cosineOne(self, t0):
        r"""

        TurningBandOperate::cosineOne
        """
        return _gstlearn.TurningBandOperate_cosineOne(self, t0)

# Register TurningBandOperate in _gstlearn:
_gstlearn.TurningBandOperate_swigregister(TurningBandOperate)
class spSim(object):
    r"""


    C++ includes: SimuSpectral.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _k = property(_gstlearn.spSim__k_get, _gstlearn.spSim__k_set)
    _countP = property(_gstlearn.spSim__countP_get, _gstlearn.spSim__countP_set)
    _countM = property(_gstlearn.spSim__countM_get, _gstlearn.spSim__countM_set)
    _tab = property(_gstlearn.spSim__tab_get, _gstlearn.spSim__tab_set)

    def __init__(self):
        r"""


        C++ includes: SimuSpectral.hpp

        """
        _gstlearn.spSim_swiginit(self, _gstlearn.new_spSim())
    __swig_destroy__ = _gstlearn.delete_spSim

# Register spSim in _gstlearn:
_gstlearn.spSim_swigregister(spSim)
class SimuSpectral(object):
    r"""


    Class for operating the Spectral simulations  

    C++ includes: SimuSpectral.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        SimuSpectral::SimuSpectral
        """
        _gstlearn.SimuSpectral_swiginit(self, _gstlearn.new_SimuSpectral(*args))
    __swig_destroy__ = _gstlearn.delete_SimuSpectral

    def simulate(self, ns, seed=4273, verbose=False, nd=100):
        r"""

        SimuSpectral::simulate
        Perpare the simulation context (This method works for Rn and Sphere)  

        Parameters
        ----------
        * `ns` :  
            Number of components  
        * `seed` :  
            Seed for random number generation 5: avoid setting the seed)  
        * `verbose` :  
            Verbose flag  
        * `nd` :  
            Number of discretization of the spectrum  

        """
        return _gstlearn.SimuSpectral_simulate(self, ns, seed, verbose, nd)

    def compute(self, *args, **kwargs):
        r"""

        SimuSpectral::compute
        Compute the simulation on Dbout using Spectral Method  

        Parameters
        ----------
        * `dbout` :  
            Db containing the results  
        * `iuid` :  
            Address for storage (or 0 if the variable must be created locally)  
        * `verbose` :  
            Verbose flag  
        * `namconv` :  
            Naming convention (only used when 'iuid' == 0)  

        """
        return _gstlearn.SimuSpectral_compute(self, *args, **kwargs)

    @staticmethod
    def isValidForSpectral(model):
        r"""

        SimuSpectral::isValidForSpectral
        Check if the Model can be simulated using Spectral Method  

        Returns
        -------
        True if the Model is valid; 0 otherwise  

        Parameters
        ----------
        * `model` :  
            Model structure  

        """
        return _gstlearn.SimuSpectral_isValidForSpectral(model)

    def setModel(self, model):
        r"""

        SimuSpectral::setModel
        """
        return _gstlearn.SimuSpectral_setModel(self, model)

    def setNdim(self, ndim):
        r"""

        SimuSpectral::setNdim
        """
        return _gstlearn.SimuSpectral_setNdim(self, ndim)

    def setNs(self, ns):
        r"""

        SimuSpectral::setNs
        """
        return _gstlearn.SimuSpectral_setNs(self, ns)

# Register SimuSpectral in _gstlearn:
_gstlearn.SimuSpectral_swigregister(SimuSpectral)

def simuSpectral(*args, **kwargs):
    r"""


    Perform a series of simulations (on Rn or on the Spehere) using Spectral Method  

    Parameters
    ----------
    * `dbin` :  
        Input Db where the conditioning data are read  
    * `dbout` :  
        Output Db where the results are stored  
    * `model` :  
        Model (should only contain covariances that can cope with spectral method)  
    * `ns` :  
        Number of spectral components  
    * `nbsimu` :  
        Number of simulations processed simultaneously  
    * `seed` :  
        Seed used for the Random number generator  
    * `verbose` :  
        Verbose flag  
    * `nd` :  
        Number of discretization steps (used for the Spectrum on Sphere)  
    * `namconv` :  
        Naming Convention  

    note: The conditional version is not yet available  

    """
    return _gstlearn.simuSpectral(*args, **kwargs)
class BooleanObject(AStringable):
    r"""


    C++ includes: BooleanObject.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        BooleanObject::BooleanObject
        """
        _gstlearn.BooleanObject_swiginit(self, _gstlearn.new_BooleanObject(*args))
    __swig_destroy__ = _gstlearn.delete_BooleanObject

    def toString(self, strfmt=None):
        r"""

        BooleanObject::toString
        Interface to AStringable.  

        """
        return _gstlearn.BooleanObject_toString(self, strfmt)

    def setMode(self, mode):
        r"""

        BooleanObject::setMode
        """
        return _gstlearn.BooleanObject_setMode(self, mode)

    def setOrientation(self, orientation):
        r"""

        BooleanObject::setOrientation
        """
        return _gstlearn.BooleanObject_setOrientation(self, orientation)

    def setCenter(self, *args):
        r"""

        BooleanObject::setCenter
        """
        return _gstlearn.BooleanObject_setCenter(self, *args)

    def setExtension(self, idim, value):
        r"""

        BooleanObject::setExtension
        """
        return _gstlearn.BooleanObject_setExtension(self, idim, value)

    def setValue(self, rank, value):
        r"""

        BooleanObject::setValue
        """
        return _gstlearn.BooleanObject_setValue(self, rank, value)

    def getMode(self):
        r"""

        BooleanObject::getMode
        """
        return _gstlearn.BooleanObject_getMode(self)

    def getCenter(self, idim):
        r"""

        BooleanObject::getCenter
        """
        return _gstlearn.BooleanObject_getCenter(self, idim)

    def getExtension(self, idim):
        r"""

        BooleanObject::getExtension
        """
        return _gstlearn.BooleanObject_getExtension(self, idim)

    def getOrientation(self):
        r"""

        BooleanObject::getOrientation
        """
        return _gstlearn.BooleanObject_getOrientation(self)

    def getValue(self, rank):
        r"""

        BooleanObject::getValue
        """
        return _gstlearn.BooleanObject_getValue(self, rank)

    def getToken(self):
        r"""

        BooleanObject::getToken
        """
        return _gstlearn.BooleanObject_getToken(self)

    @staticmethod
    def generate(dbout, cdgrain, tokens, boolparam, eps=1.e-3):
        r"""

        BooleanObject::generate
        Function used to generate the geometry of an object  

        """
        return _gstlearn.BooleanObject_generate(dbout, cdgrain, tokens, boolparam, eps)

    def isCompatiblePore(self, db):
        r"""

        BooleanObject::isCompatiblePore
        Check if the current object is compatible with the constraining pores  

        Returns
        -------
        True if it is compatible; False otherwise  

        Parameters
        ----------
        * `db` :  
            Constraining data set  

        """
        return _gstlearn.BooleanObject_isCompatiblePore(self, db)

    def isCompatibleGrainAdd(self, db):
        r"""

        BooleanObject::isCompatibleGrainAdd
        Check if an object can be added with regards to the constraining grains  

        Parameters
        ----------
        * `db` :  
            Constraining data set  

        """
        return _gstlearn.BooleanObject_isCompatibleGrainAdd(self, db)

    def isCompatibleGrainDelete(self, db, iptr_cover):
        r"""

        BooleanObject::isCompatibleGrainDelete
        Check if an object can be deleted with regards to the constraining grains  

        Parameters
        ----------
        * `db` :  
            Constraining data set  
        * `iptr_cover` :  
            UIUD for coverage variable  

        """
        return _gstlearn.BooleanObject_isCompatibleGrainDelete(self, db, iptr_cover)

    def projectToGrid(self, dbout, iptr_simu, iptr_rank, facies, rank):
        r"""

        BooleanObject::projectToGrid
        """
        return _gstlearn.BooleanObject_projectToGrid(self, dbout, iptr_simu, iptr_rank, facies, rank)

    def coverageUpdate(self, db, iptr_cover, val):
        r"""

        BooleanObject::coverageUpdate
        Update the covering value of each constraining grain after a deletion or an
        addition operation  

        Returns
        -------
        Count of grains not covered after the operation  

        Parameters
        ----------
        * `db` :  
            Db structure  
        * `iptr_cover` :  
            UID for the covering variable  
        * `val` :  
            type of the operation to be tested 1 for addition; -1 for deletion  

        """
        return _gstlearn.BooleanObject_coverageUpdate(self, db, iptr_cover, val)

    def getValues(self):
        r"""

        BooleanObject::getValues
        """
        return _gstlearn.BooleanObject_getValues(self)

    def __repr__(self):
        return _gstlearn.BooleanObject___repr__(self)

# Register BooleanObject in _gstlearn:
_gstlearn.BooleanObject_swigregister(BooleanObject)
class SimuBoolean(ACalcSimulation, AStringable):
    r"""


    Class for performing Boolean simulation.  

    A Boolean simulation results in drawing random object into a Field conditionally
    to existing samples or not These objects are called tokens and are generated
    according to:  

    *   their type (extension, orientation, ...)  
    *   their proportion: fix or variable  

    The samples (used for conditional simulations) are defined in input Db (as Z
    Locator variable) and are set to 0 (pore) or 1 (grain) If the proportion is
    variable, it uses Proportion locator in output DbGrid  

    C++ includes: SimuBoolean.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbsimu=0, seed=4324324):
        r"""

        SimuBoolean::SimuBoolean
        """
        _gstlearn.SimuBoolean_swiginit(self, _gstlearn.new_SimuBoolean(nbsimu, seed))
    __swig_destroy__ = _gstlearn.delete_SimuBoolean

    def toString(self, strfmt=None):
        r"""

        SimuBoolean::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuBoolean_toString(self, strfmt)

    def simulate(self, dbin, dbout, tokens, boolparam, iptr_simu, iptr_rank, iptr_cover, verbose=False):
        r"""

        SimuBoolean::simulate
        """
        return _gstlearn.SimuBoolean_simulate(self, dbin, dbout, tokens, boolparam, iptr_simu, iptr_rank, iptr_cover, verbose)

    def extractObjects(self):
        r"""

        SimuBoolean::extractObjects
        """
        return _gstlearn.SimuBoolean_extractObjects(self)

    def __repr__(self):
        return _gstlearn.SimuBoolean___repr__(self)

# Register SimuBoolean in _gstlearn:
_gstlearn.SimuBoolean_swigregister(SimuBoolean)

def simbool(*args, **kwargs):
    r"""


    Performs the boolean simulation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbin` :  
        Db structure containing the data (optional)  
    * `dbout` :  
        DbGrid structure containing the simulated grid  
    * `tokens` :  
        Tokens structure  
    * `boolparam` :  
        SimuBooleanParam structure  
    * `seed` :  
        Seed for the random number generator  
    * `flag_simu` :  
        Store the boolean simulation  
    * `flag_rank` :  
        Store the object rank  
    * `verbose` :  
        1 for a verbose output  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.simbool(*args, **kwargs)
class SimuBooleanParam(AStringable):
    r"""


    C++ includes: SimuBooleanParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SimuBooleanParam::SimuBooleanParam
        """
        _gstlearn.SimuBooleanParam_swiginit(self, _gstlearn.new_SimuBooleanParam(*args))
    __swig_destroy__ = _gstlearn.delete_SimuBooleanParam

    def toString(self, strfmt=None):
        r"""

        SimuBooleanParam::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuBooleanParam_toString(self, strfmt)

    def getBackground(self):
        r"""

        SimuBooleanParam::getBackground
        """
        return _gstlearn.SimuBooleanParam_getBackground(self)

    def setBackground(self, background):
        r"""

        SimuBooleanParam::setBackground
        """
        return _gstlearn.SimuBooleanParam_setBackground(self, background)

    def getFacies(self):
        r"""

        SimuBooleanParam::getFacies
        """
        return _gstlearn.SimuBooleanParam_getFacies(self)

    def setFacies(self, facies):
        r"""

        SimuBooleanParam::setFacies
        """
        return _gstlearn.SimuBooleanParam_setFacies(self, facies)

    def getMaxiter(self):
        r"""

        SimuBooleanParam::getMaxiter
        """
        return _gstlearn.SimuBooleanParam_getMaxiter(self)

    def setMaxiter(self, maxiter):
        r"""

        SimuBooleanParam::setMaxiter
        """
        return _gstlearn.SimuBooleanParam_setMaxiter(self, maxiter)

    def getTmax(self):
        r"""

        SimuBooleanParam::getTmax
        """
        return _gstlearn.SimuBooleanParam_getTmax(self)

    def setTmax(self, tmax):
        r"""

        SimuBooleanParam::setTmax
        """
        return _gstlearn.SimuBooleanParam_setTmax(self, tmax)

    def setDilate(self, dilate):
        r"""

        SimuBooleanParam::setDilate
        """
        return _gstlearn.SimuBooleanParam_setDilate(self, dilate)

    def getDilate(self, *args):
        r"""

        SimuBooleanParam::getDilate
        """
        return _gstlearn.SimuBooleanParam_getDilate(self, *args)

    def isDilate(self):
        r"""

        SimuBooleanParam::isDilate
        """
        return _gstlearn.SimuBooleanParam_isDilate(self)

    def __repr__(self):
        return _gstlearn.SimuBooleanParam___repr__(self)

# Register SimuBooleanParam in _gstlearn:
_gstlearn.SimuBooleanParam_swigregister(SimuBooleanParam)
class SimuSpherical(ACalcSimulation):
    r"""


    C++ includes: SimuSpherical.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nbsimu=1, seed=4324324):
        r"""

        SimuSpherical::SimuSpherical
        """
        _gstlearn.SimuSpherical_swiginit(self, _gstlearn.new_SimuSpherical(nbsimu, seed))
    __swig_destroy__ = _gstlearn.delete_SimuSpherical

    def simulate(self, db, model, sphepar, iptr, verbose=False):
        r"""

        SimuSpherical::simulate
        """
        return _gstlearn.SimuSpherical_simulate(self, db, model, sphepar, iptr, verbose)

    def simulate_mesh(self, mesh, model, sphepar, verbose=False):
        r"""

        SimuSpherical::simulate_mesh
        """
        return _gstlearn.SimuSpherical_simulate_mesh(self, mesh, model, sphepar, verbose)

# Register SimuSpherical in _gstlearn:
_gstlearn.SimuSpherical_swigregister(SimuSpherical)

def simsph(*args, **kwargs):
    r"""


    Simulates the random function on the sphere  

    Parameters
    ----------
    * `db` :  
        Data base containing the coordinates of target points These coordinates must
        be expressed in long/lat  
    * `model` :  
        Model (defined in Euclidean space) to be used  
    * `sphepar` :  
        SimuSphericalParam structure  
    * `seed` :  
        Seed for random number generation  
    * `verbose` :  
        Verbose flag  
    * `namconv` :  
        Naming convention  

    """
    return _gstlearn.simsph(*args, **kwargs)
class SimuSphericalParam(AStringable):
    r"""


    C++ includes: SimuSphericalParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SimuSphericalParam::SimuSphericalParam
        """
        _gstlearn.SimuSphericalParam_swiginit(self, _gstlearn.new_SimuSphericalParam(*args))
    __swig_destroy__ = _gstlearn.delete_SimuSphericalParam

    def toString(self, strfmt=None):
        r"""

        SimuSphericalParam::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuSphericalParam_toString(self, strfmt)

    def getNbf(self):
        r"""

        SimuSphericalParam::getNbf
        """
        return _gstlearn.SimuSphericalParam_getNbf(self)

    def setNbf(self, nbf):
        r"""

        SimuSphericalParam::setNbf
        """
        return _gstlearn.SimuSphericalParam_setNbf(self, nbf)

    def getNdisc(self):
        r"""

        SimuSphericalParam::getNdisc
        """
        return _gstlearn.SimuSphericalParam_getNdisc(self)

    def setNdisc(self, ndisc):
        r"""

        SimuSphericalParam::setNdisc
        """
        return _gstlearn.SimuSphericalParam_setNdisc(self, ndisc)

    def getNfmax(self):
        r"""

        SimuSphericalParam::getNfmax
        """
        return _gstlearn.SimuSphericalParam_getNfmax(self)

    def setNfmax(self, nfmax):
        r"""

        SimuSphericalParam::setNfmax
        """
        return _gstlearn.SimuSphericalParam_setNfmax(self, nfmax)

    def getSpecial(self):
        r"""

        SimuSphericalParam::getSpecial
        """
        return _gstlearn.SimuSphericalParam_getSpecial(self)

    def setSpecial(self, special):
        r"""

        SimuSphericalParam::setSpecial
        """
        return _gstlearn.SimuSphericalParam_setSpecial(self, special)

    def getTol(self):
        r"""

        SimuSphericalParam::getTol
        """
        return _gstlearn.SimuSphericalParam_getTol(self)

    def setTol(self, tol):
        r"""

        SimuSphericalParam::setTol
        """
        return _gstlearn.SimuSphericalParam_setTol(self, tol)

    def getDegmax(self):
        r"""

        SimuSphericalParam::getDegmax
        """
        return _gstlearn.SimuSphericalParam_getDegmax(self)

    def setDegmax(self, degmax):
        r"""

        SimuSphericalParam::setDegmax
        """
        return _gstlearn.SimuSphericalParam_setDegmax(self, degmax)

    def __repr__(self):
        return _gstlearn.SimuSphericalParam___repr__(self)

# Register SimuSphericalParam in _gstlearn:
_gstlearn.SimuSphericalParam_swigregister(SimuSphericalParam)
class CalcSimuSubstitution(ACalcSimulation):
    r"""


    C++ includes: CalcSimuSubstitution.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nbsimu=0, seed=4324324, verbose=False):
        r"""

        CalcSimuSubstitution::CalcSimuSubstitution
        """
        _gstlearn.CalcSimuSubstitution_swiginit(self, _gstlearn.new_CalcSimuSubstitution(nbsimu, seed, verbose))
    __swig_destroy__ = _gstlearn.delete_CalcSimuSubstitution

    def getSubparam(self):
        r"""

        CalcSimuSubstitution::getSubparam
        """
        return _gstlearn.CalcSimuSubstitution_getSubparam(self)

    def setSubparam(self, subparam):
        r"""

        CalcSimuSubstitution::setSubparam
        """
        return _gstlearn.CalcSimuSubstitution_setSubparam(self, subparam)

# Register CalcSimuSubstitution in _gstlearn:
_gstlearn.CalcSimuSubstitution_swigregister(CalcSimuSubstitution)

def substitution(*args, **kwargs):
    r"""


    """
    return _gstlearn.substitution(*args, **kwargs)
class SimuSubstitutionParam(AStringable):
    r"""


    C++ includes: SimuSubstitutionParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SimuSubstitutionParam::SimuSubstitutionParam
        """
        _gstlearn.SimuSubstitutionParam_swiginit(self, _gstlearn.new_SimuSubstitutionParam(*args))
    __swig_destroy__ = _gstlearn.delete_SimuSubstitutionParam

    def toString(self, strfmt=None):
        r"""

        SimuSubstitutionParam::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuSubstitutionParam_toString(self, strfmt)

    def setColang(self, colang):
        r"""

        SimuSubstitutionParam::setColang
        """
        return _gstlearn.SimuSubstitutionParam_setColang(self, colang)

    def getColfac(self):
        r"""

        SimuSubstitutionParam::getColfac
        """
        return _gstlearn.SimuSubstitutionParam_getColfac(self)

    def setColfac(self, colfac):
        r"""

        SimuSubstitutionParam::setColfac
        """
        return _gstlearn.SimuSubstitutionParam_setColfac(self, colfac)

    def getFactor(self):
        r"""

        SimuSubstitutionParam::getFactor
        """
        return _gstlearn.SimuSubstitutionParam_getFactor(self)

    def setFactor(self, factor):
        r"""

        SimuSubstitutionParam::setFactor
        """
        return _gstlearn.SimuSubstitutionParam_setFactor(self, factor)

    def isFlagAuto(self):
        r"""

        SimuSubstitutionParam::isFlagAuto
        """
        return _gstlearn.SimuSubstitutionParam_isFlagAuto(self)

    def setFlagAuto(self, flagAuto):
        r"""

        SimuSubstitutionParam::setFlagAuto
        """
        return _gstlearn.SimuSubstitutionParam_setFlagAuto(self, flagAuto)

    def isFlagCoding(self):
        r"""

        SimuSubstitutionParam::isFlagCoding
        """
        return _gstlearn.SimuSubstitutionParam_isFlagCoding(self)

    def setFlagCoding(self, flagCoding):
        r"""

        SimuSubstitutionParam::setFlagCoding
        """
        return _gstlearn.SimuSubstitutionParam_setFlagCoding(self, flagCoding)

    def isFlagDirect(self):
        r"""

        SimuSubstitutionParam::isFlagDirect
        """
        return _gstlearn.SimuSubstitutionParam_isFlagDirect(self)

    def setFlagDirect(self, flagDirect):
        r"""

        SimuSubstitutionParam::setFlagDirect
        """
        return _gstlearn.SimuSubstitutionParam_setFlagDirect(self, flagDirect)

    def isFlagOrient(self):
        r"""

        SimuSubstitutionParam::isFlagOrient
        """
        return _gstlearn.SimuSubstitutionParam_isFlagOrient(self)

    def setFlagOrient(self, flagOrient):
        r"""

        SimuSubstitutionParam::setFlagOrient
        """
        return _gstlearn.SimuSubstitutionParam_setFlagOrient(self, flagOrient)

    def getIntensity(self):
        r"""

        SimuSubstitutionParam::getIntensity
        """
        return _gstlearn.SimuSubstitutionParam_getIntensity(self)

    def setIntensity(self, intensity):
        r"""

        SimuSubstitutionParam::setIntensity
        """
        return _gstlearn.SimuSubstitutionParam_setIntensity(self, intensity)

    def getNfacies(self):
        r"""

        SimuSubstitutionParam::getNfacies
        """
        return _gstlearn.SimuSubstitutionParam_getNfacies(self)

    def setNfacies(self, nfacies):
        r"""

        SimuSubstitutionParam::setNfacies
        """
        return _gstlearn.SimuSubstitutionParam_setNfacies(self, nfacies)

    def getNstates(self):
        r"""

        SimuSubstitutionParam::getNstates
        """
        return _gstlearn.SimuSubstitutionParam_getNstates(self)

    def setNstates(self, nstates):
        r"""

        SimuSubstitutionParam::setNstates
        """
        return _gstlearn.SimuSubstitutionParam_setNstates(self, nstates)

    def getTrans(self):
        r"""

        SimuSubstitutionParam::getTrans
        """
        return _gstlearn.SimuSubstitutionParam_getTrans(self)

    def setTrans(self, trans):
        r"""

        SimuSubstitutionParam::setTrans
        """
        return _gstlearn.SimuSubstitutionParam_setTrans(self, trans)

    def setVector(self, vector):
        r"""

        SimuSubstitutionParam::setVector
        """
        return _gstlearn.SimuSubstitutionParam_setVector(self, vector)

    def getColang(self, *args):
        r"""

        SimuSubstitutionParam::getColang
        """
        return _gstlearn.SimuSubstitutionParam_getColang(self, *args)

    def getVector(self, *args):
        r"""

        SimuSubstitutionParam::getVector
        """
        return _gstlearn.SimuSubstitutionParam_getVector(self, *args)

    def isValid(self, verbose=False):
        r"""

        SimuSubstitutionParam::isValid
        """
        return _gstlearn.SimuSubstitutionParam_isValid(self, verbose)

    def isValidOrientation(self, vector, verbose=False):
        r"""

        SimuSubstitutionParam::isValidOrientation
        """
        return _gstlearn.SimuSubstitutionParam_isValidOrientation(self, vector, verbose)

    def isValidFactor(self, factor, verbose=False):
        r"""

        SimuSubstitutionParam::isValidFactor
        """
        return _gstlearn.SimuSubstitutionParam_isValidFactor(self, factor, verbose)

    def isAngleLocal(self):
        r"""

        SimuSubstitutionParam::isAngleLocal
        """
        return _gstlearn.SimuSubstitutionParam_isAngleLocal(self)

    def isLocal(self):
        r"""

        SimuSubstitutionParam::isLocal
        """
        return _gstlearn.SimuSubstitutionParam_isLocal(self)

    def __repr__(self):
        return _gstlearn.SimuSubstitutionParam___repr__(self)

# Register SimuSubstitutionParam in _gstlearn:
_gstlearn.SimuSubstitutionParam_swigregister(SimuSubstitutionParam)
class Stack(object):
    r"""


    C++ includes: CalcSimuPartition.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    valref = property(_gstlearn.Stack_valref_get, _gstlearn.Stack_valref_set)
    valsim = property(_gstlearn.Stack_valsim_get, _gstlearn.Stack_valsim_set)

    def __init__(self):
        r"""


        C++ includes: CalcSimuPartition.hpp

        """
        _gstlearn.Stack_swiginit(self, _gstlearn.new_Stack())
    __swig_destroy__ = _gstlearn.delete_Stack

# Register Stack in _gstlearn:
_gstlearn.Stack_swigregister(Stack)
class CalcSimuPartition(ACalcSimulation):
    r"""


    C++ includes: CalcSimuPartition.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mode, nbsimu=0, seed=4324324, verbose=False):
        r"""

        CalcSimuPartition::CalcSimuPartition
        """
        _gstlearn.CalcSimuPartition_swiginit(self, _gstlearn.new_CalcSimuPartition(mode, nbsimu, seed, verbose))
    __swig_destroy__ = _gstlearn.delete_CalcSimuPartition

    def getParparam(self):
        r"""

        CalcSimuPartition::getParparam
        """
        return _gstlearn.CalcSimuPartition_getParparam(self)

    def setParparam(self, parparam):
        r"""

        CalcSimuPartition::setParparam
        """
        return _gstlearn.CalcSimuPartition_setParparam(self, parparam)

    def setMode(self, mode):
        r"""

        CalcSimuPartition::setMode
        """
        return _gstlearn.CalcSimuPartition_setMode(self, mode)

    def setVerbose(self, verbose):
        r"""

        CalcSimuPartition::setVerbose
        """
        return _gstlearn.CalcSimuPartition_setVerbose(self, verbose)

# Register CalcSimuPartition in _gstlearn:
_gstlearn.CalcSimuPartition_swigregister(CalcSimuPartition)

def tessellation_voronoi(*args, **kwargs):
    r"""


    """
    return _gstlearn.tessellation_voronoi(*args, **kwargs)

def tessellation_poisson(*args, **kwargs):
    r"""


    """
    return _gstlearn.tessellation_poisson(*args, **kwargs)
class SimuPartitionParam(AStringable):
    r"""


    C++ includes: SimuPartitionParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SimuPartitionParam::SimuPartitionParam
        """
        _gstlearn.SimuPartitionParam_swiginit(self, _gstlearn.new_SimuPartitionParam(*args))
    __swig_destroy__ = _gstlearn.delete_SimuPartitionParam

    def toString(self, strfmt=None):
        r"""

        SimuPartitionParam::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuPartitionParam_toString(self, strfmt)

    def setDilate(self, dilate):
        r"""

        SimuPartitionParam::setDilate
        """
        return _gstlearn.SimuPartitionParam_setDilate(self, dilate)

    def getIntensity(self):
        r"""

        SimuPartitionParam::getIntensity
        """
        return _gstlearn.SimuPartitionParam_getIntensity(self)

    def setIntensity(self, intensity):
        r"""

        SimuPartitionParam::setIntensity
        """
        return _gstlearn.SimuPartitionParam_setIntensity(self, intensity)

    def getNbtuba(self):
        r"""

        SimuPartitionParam::getNbtuba
        """
        return _gstlearn.SimuPartitionParam_getNbtuba(self)

    def setNbtuba(self, nbtuba):
        r"""

        SimuPartitionParam::setNbtuba
        """
        return _gstlearn.SimuPartitionParam_setNbtuba(self, nbtuba)

    def getDilate(self, *args):
        r"""

        SimuPartitionParam::getDilate
        """
        return _gstlearn.SimuPartitionParam_getDilate(self, *args)

    def __repr__(self):
        return _gstlearn.SimuPartitionParam___repr__(self)

# Register SimuPartitionParam in _gstlearn:
_gstlearn.SimuPartitionParam_swigregister(SimuPartitionParam)
class SimuFFTParam(AStringable):
    r"""


    C++ includes: SimuFFTParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SimuFFTParam::SimuFFTParam
        """
        _gstlearn.SimuFFTParam_swiginit(self, _gstlearn.new_SimuFFTParam(*args))
    __swig_destroy__ = _gstlearn.delete_SimuFFTParam

    def toString(self, strfmt=None):
        r"""

        SimuFFTParam::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuFFTParam_toString(self, strfmt)

    def isFlagAliasing(self):
        r"""

        SimuFFTParam::isFlagAliasing
        """
        return _gstlearn.SimuFFTParam_isFlagAliasing(self)

    def setFlagAliasing(self, flagAliasing):
        r"""

        SimuFFTParam::setFlagAliasing
        """
        return _gstlearn.SimuFFTParam_setFlagAliasing(self, flagAliasing)

    def getPercent(self):
        r"""

        SimuFFTParam::getPercent
        """
        return _gstlearn.SimuFFTParam_getPercent(self)

    def setPercent(self, percent):
        r"""

        SimuFFTParam::setPercent
        """
        return _gstlearn.SimuFFTParam_setPercent(self, percent)

    def __repr__(self):
        return _gstlearn.SimuFFTParam___repr__(self)

# Register SimuFFTParam in _gstlearn:
_gstlearn.SimuFFTParam_swigregister(SimuFFTParam)
class CalcSimuFFT(ACalcSimulation):
    r"""


    C++ includes: CalcSimuFFT.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nbsimu=0, verbose=False, seed=4324324):
        r"""

        CalcSimuFFT::CalcSimuFFT
        """
        _gstlearn.CalcSimuFFT_swiginit(self, _gstlearn.new_CalcSimuFFT(nbsimu, verbose, seed))
    __swig_destroy__ = _gstlearn.delete_CalcSimuFFT

    def setParam(self, param):
        r"""

        CalcSimuFFT::setParam
        """
        return _gstlearn.CalcSimuFFT_setParam(self, param)

    def setVerbose(self, verbose):
        r"""

        CalcSimuFFT::setVerbose
        """
        return _gstlearn.CalcSimuFFT_setVerbose(self, verbose)

    def changeSupport(self, sigma):
        r"""

        CalcSimuFFT::changeSupport
        """
        return _gstlearn.CalcSimuFFT_changeSupport(self, sigma)

# Register CalcSimuFFT in _gstlearn:
_gstlearn.CalcSimuFFT_swigregister(CalcSimuFFT)

def simfft(*args, **kwargs):
    r"""


    Perform the non-conditional simulation by FFT method on a grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `model` :  
        ModelGeneric structure  
    * `param` :  
        SimuFFTParam structure  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Value of the seed  
    * `verbose` :  
        Verbose flag  
    * `namconv` :  
        Naming Convention  

    """
    return _gstlearn.simfft(*args, **kwargs)

def getChangeSupport(*args, **kwargs):
    r"""


    Calculate the change of support coefficients by FFT method in the lognormal case
    on a grid  

    Returns
    -------
    r^2 coefficients for the different logarithmic variances  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `model` :  
        ModelGeneric structure  
    * `param` :  
        SimuFFTParam structure  
    * `sigma` :  
        Array of logarithmic variances  
    * `seed` :  
        Seed for random number generator  
    * `verbose` :  
        Verbose flag  

    """
    return _gstlearn.getChangeSupport(*args, **kwargs)
class SimuRefineParam(AStringable):
    r"""


    C++ includes: SimuRefineParam.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SimuRefineParam::SimuRefineParam
        """
        _gstlearn.SimuRefineParam_swiginit(self, _gstlearn.new_SimuRefineParam(*args))
    __swig_destroy__ = _gstlearn.delete_SimuRefineParam

    def toString(self, strfmt=None):
        r"""

        SimuRefineParam::toString
        Interface to AStringable.  

        """
        return _gstlearn.SimuRefineParam_toString(self, strfmt)

    def isFlagSK(self):
        r"""

        SimuRefineParam::isFlagSK
        """
        return _gstlearn.SimuRefineParam_isFlagSK(self)

    def setFlagKs(self, flagKS):
        r"""

        SimuRefineParam::setFlagKs
        """
        return _gstlearn.SimuRefineParam_setFlagKs(self, flagKS)

    def getNmult(self):
        r"""

        SimuRefineParam::getNmult
        """
        return _gstlearn.SimuRefineParam_getNmult(self)

    def setNmult(self, nmult):
        r"""

        SimuRefineParam::setNmult
        """
        return _gstlearn.SimuRefineParam_setNmult(self, nmult)

    def __repr__(self):
        return _gstlearn.SimuRefineParam___repr__(self)

# Register SimuRefineParam in _gstlearn:
_gstlearn.SimuRefineParam_swigregister(SimuRefineParam)
class CalcSimuRefine(ACalcSimulation):
    r"""


    C++ includes: CalcSimuRefine.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nbsimu=0, seed=4324324):
        r"""

        CalcSimuRefine::CalcSimuRefine
        """
        _gstlearn.CalcSimuRefine_swiginit(self, _gstlearn.new_CalcSimuRefine(nbsimu, seed))
    __swig_destroy__ = _gstlearn.delete_CalcSimuRefine

    def getParam(self):
        r"""

        CalcSimuRefine::getParam
        """
        return _gstlearn.CalcSimuRefine_getParam(self)

    def setParam(self, param):
        r"""

        CalcSimuRefine::setParam
        """
        return _gstlearn.CalcSimuRefine_setParam(self, param)

    def getResultingGrid(self):
        r"""

        CalcSimuRefine::getResultingGrid
        """
        return _gstlearn.CalcSimuRefine_getResultingGrid(self)

# Register CalcSimuRefine in _gstlearn:
_gstlearn.CalcSimuRefine_swigregister(CalcSimuRefine)

def simulation_refine(*args, **kwargs):
    r"""


    Refine the simulation  

    Returns
    -------
    Newly refined Grid.  

    Parameters
    ----------
    * `dbin` :  
        Input grid Db structure  
    * `model` :  
        Model structure  
    * `param` :  
        SimuRefineParam structure  
    * `seed` :  
        Seed for the random number generator  
    * `namconv` :  
        Naming convention  

    remark: For each dimension of the space, if N stands for the number of  

    remark: nodes in the input grid, the number of nodes of the output grid  

    remark: will be (N-1) * 2^p + 1 where p is the param.getNmult()  

    """
    return _gstlearn.simulation_refine(*args, **kwargs)
class CalcSimuEden(ACalcSimulation, AStringable, ISkinFunctions):
    r"""


    Multivariate multiphase propagation into a set of components constrained by
    initial conditions and fluid densities  

    remark: Directions are ordered as follows :  

    remark: 0: +X; 1: -X; 2: +Y; 3: -Y; 4: +Z(up); 5: -Z(down)  

    remark: The coding of the matrix is:  

    remark: facies + nfacies * fluid  

    remark: Facies: 0 (Shale), 1 to nfacies, -1 (Cork)  

    remark: Fluids: 0 (undefined), 1 to nfluids, -1 (No Fluid)  

    remark: Fluids should be ordered by increasing weight  

    remark: A Permeability variable is a value (>=1) which divides  

    remark: the velocities. This variable is optional.  

    remark: A Porosity variable is a value (in [0,1]) which multiplies  

    remark: the volumes. This variable is optional.  

    remark: Volume_max represents the volumic part of the invaded area:  

    remark: it is always <= number of cells invaded.  

    C++ includes: CalcSimuEden.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nfacies=0, nfluids=0, niter=1, nbsimu=0, seed=4324324, verbose=False):
        r"""

        CalcSimuEden::CalcSimuEden
        """
        _gstlearn.CalcSimuEden_swiginit(self, _gstlearn.new_CalcSimuEden(nfacies, nfluids, niter, nbsimu, seed, verbose))
    __swig_destroy__ = _gstlearn.delete_CalcSimuEden

    def toString(self, strfmt=None):
        r"""

        CalcSimuEden::toString
        Interface to AStringable.  

        """
        return _gstlearn.CalcSimuEden_toString(self, strfmt)

    def isAlreadyFilled(self, ipos):
        r"""

        CalcSimuEden::isAlreadyFilled
        Interface to ISkinFunctions.  

        Check if the cell is already filled with fluid  

        Returns
        -------
        1 if the cell (filled with facies) is already filled with Fluid  

        Parameters
        ----------
        * `ipos` :  
            Absolute grid index of the input grid node  

        """
        return _gstlearn.CalcSimuEden_isAlreadyFilled(self, ipos)

    def isToBeFilled(self, ipos):
        r"""

        CalcSimuEden::isToBeFilled
        Check if the cell can be filled with fluid  

        Returns
        -------
        1 if the cell (filled with facies) can be filled with Fluid  

        Parameters
        ----------
        * `ipos` :  
            Absolute grid index of the input grid node  

        """
        return _gstlearn.CalcSimuEden_isToBeFilled(self, ipos)

    def getWeight(self, ipos, idir):
        r"""

        CalcSimuEden::getWeight
        Returns the weight of a cell in a given direction  

        Returns
        -------
        The weight  

        Parameters
        ----------
        * `ipos` :  
            Cell location  
        * `idir` :  
            Direction value  

        """
        return _gstlearn.CalcSimuEden_getWeight(self, ipos, idir)

    def setIndFacies(self, indFacies):
        r"""

        CalcSimuEden::setIndFacies
        """
        return _gstlearn.CalcSimuEden_setIndFacies(self, indFacies)

    def setIndFluid(self, indFluid):
        r"""

        CalcSimuEden::setIndFluid
        """
        return _gstlearn.CalcSimuEden_setIndFluid(self, indFluid)

    def setIndPerm(self, indPerm):
        r"""

        CalcSimuEden::setIndPerm
        """
        return _gstlearn.CalcSimuEden_setIndPerm(self, indPerm)

    def setIndPoro(self, indPoro):
        r"""

        CalcSimuEden::setIndPoro
        """
        return _gstlearn.CalcSimuEden_setIndPoro(self, indPoro)

    def setSpeeds(self, speeds):
        r"""

        CalcSimuEden::setSpeeds
        """
        return _gstlearn.CalcSimuEden_setSpeeds(self, speeds)

    def setNMax(self, numberMax):
        r"""

        CalcSimuEden::setNMax
        """
        return _gstlearn.CalcSimuEden_setNMax(self, numberMax)

    def setShowFluid(self, showFluid):
        r"""

        CalcSimuEden::setShowFluid
        """
        return _gstlearn.CalcSimuEden_setShowFluid(self, showFluid)

    def setVolumeMax(self, volumeMax):
        r"""

        CalcSimuEden::setVolumeMax
        """
        return _gstlearn.CalcSimuEden_setVolumeMax(self, volumeMax)

    def __repr__(self):
        return _gstlearn.CalcSimuEden___repr__(self)

# Register CalcSimuEden in _gstlearn:
_gstlearn.CalcSimuEden_swigregister(CalcSimuEden)

def fluid_propagation(*args, **kwargs):
    r"""


    Multivariate multiphase propagation into a set of components constrained by
    initial conditions and fluid densities  

    Returns
    -------
    Error return code : 1 no fluid to propagate  

    Parameters
    ----------
    * `dbgrid` :  
        Db grid structure  
    * `name_facies` :  
        Name of the variable containing the Facies  
    * `name_fluid` :  
        Name of the variable containing the Fluid  
    * `name_perm` :  
        Name of the variable containing the Permeability  
    * `name_poro` :  
        Name of the variable containing the Porosity  
    * `nfacies` :  
        number of facies (facies 0 excluded)  
    * `nfluids` :  
        number of fluids  
    * `niter` :  
        Number of iterations  
    * `speeds` :  
        Array containing the travel speeds  
    * `show_fluid` :  
        1 for modifying the value of the cells to show  

        *   the initial valid fluid information  
        *   the cork (different from shale)  
    * `number_max` :  
        Maximum count of cells invaded (or TEST)  
    * `volume_max` :  
        Maximum volume invaded (or TEST)  
    * `seed` :  
        Seed for random number generator (or 0)  
    * `verbose` :  
        1 for a verbose option  
    * `namconv` :  
        Naming convention  

    remark: Directions are ordered as follows :  

    remark: 0: +X; 1: -X; 2: +Y; 3: -Y; 4: +Z(up); 5: -Z(down)  

    remark: The coding of the matrix is:  

    remark: facies + nfacies * fluid  

    remark: Facies: 0 (Shale), 1 to nfacies, -1 (Cork)  

    remark: Fluids: 0 (undefined), 1 to nfluids, -1 (No Fluid)  

    remark: Fluids should be ordered by increasing weight  

    remark: A Permeability variable is a value (>=1) which divides  

    remark: the velocities. This variable is optional.  

    remark: A Porosity variable is a value (in [0,1]) which multiplies  

    remark: the velocities. This variable is optional.  

    remark: the volumes. This variable is optional.  

    remark: Volume_max represents the volumic part of the invaded area:  

    remark: it is always <= number of cells invaded.  

    """
    return _gstlearn.fluid_propagation(*args, **kwargs)
class FracEnviron(AStringable, ASerializable):
    r"""


    C++ includes: FracEnviron.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        FracEnviron::FracEnviron
        """
        _gstlearn.FracEnviron_swiginit(self, _gstlearn.new_FracEnviron(*args))
    __swig_destroy__ = _gstlearn.delete_FracEnviron

    def toString(self, strfmt=None):
        r"""

        FracEnviron::toString
        Interface to AStringable.  

        """
        return _gstlearn.FracEnviron_toString(self, strfmt)

    @staticmethod
    def createFromNF(NFFilename, verbose=True):
        r"""

        FracEnviron::createFromNF
        Create a Environ by loading the contents of a Neutral File  

        Parameters
        ----------
        * `NFFilename` :  
            Name of the Neutral File  
        * `verbose` :  
            Verbose  

        """
        return _gstlearn.FracEnviron_createFromNF(NFFilename, verbose)

    @staticmethod
    def create(xmax=0., ymax=0., deltax=0., deltay=0, mean=0., stdev=0.):
        r"""

        FracEnviron::create
        """
        return _gstlearn.FracEnviron_create(xmax, ymax, deltax, deltay, mean, stdev)

    def getNFamilies(self):
        r"""

        FracEnviron::getNFamilies
        """
        return _gstlearn.FracEnviron_getNFamilies(self)

    def getNFaults(self):
        r"""

        FracEnviron::getNFaults
        """
        return _gstlearn.FracEnviron_getNFaults(self)

    def getDeltax(self):
        r"""

        FracEnviron::getDeltax
        """
        return _gstlearn.FracEnviron_getDeltax(self)

    def getDeltay(self):
        r"""

        FracEnviron::getDeltay
        """
        return _gstlearn.FracEnviron_getDeltay(self)

    def getMean(self):
        r"""

        FracEnviron::getMean
        """
        return _gstlearn.FracEnviron_getMean(self)

    def getStdev(self):
        r"""

        FracEnviron::getStdev
        """
        return _gstlearn.FracEnviron_getStdev(self)

    def getXmax(self):
        r"""

        FracEnviron::getXmax
        """
        return _gstlearn.FracEnviron_getXmax(self)

    def getYmax(self):
        r"""

        FracEnviron::getYmax
        """
        return _gstlearn.FracEnviron_getYmax(self)

    def getXextend(self):
        r"""

        FracEnviron::getXextend
        """
        return _gstlearn.FracEnviron_getXextend(self)

    def getFault(self, i):
        r"""

        FracEnviron::getFault
        """
        return _gstlearn.FracEnviron_getFault(self, i)

    def getFamily(self, i):
        r"""

        FracEnviron::getFamily
        """
        return _gstlearn.FracEnviron_getFamily(self, i)

    def addFamily(self, family):
        r"""

        FracEnviron::addFamily
        """
        return _gstlearn.FracEnviron_addFamily(self, family)

    def addFault(self, fault):
        r"""

        FracEnviron::addFault
        """
        return _gstlearn.FracEnviron_addFault(self, fault)

    def __repr__(self):
        return _gstlearn.FracEnviron___repr__(self)

# Register FracEnviron in _gstlearn:
_gstlearn.FracEnviron_swigregister(FracEnviron)
class FracFamily(AStringable, ASerializable):
    r"""


    C++ includes: FracFamily.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        FracFamily::FracFamily
        """
        _gstlearn.FracFamily_swiginit(self, _gstlearn.new_FracFamily(*args))
    __swig_destroy__ = _gstlearn.delete_FracFamily

    def toString(self, strfmt=None):
        r"""

        FracFamily::toString
        Interface for AStringable.  

        """
        return _gstlearn.FracFamily_toString(self, strfmt)

    def getAlpha(self):
        r"""

        FracFamily::getAlpha
        """
        return _gstlearn.FracFamily_getAlpha(self)

    def setAlpha(self, alpha):
        r"""

        FracFamily::setAlpha
        """
        return _gstlearn.FracFamily_setAlpha(self, alpha)

    def getAterm(self):
        r"""

        FracFamily::getAterm
        """
        return _gstlearn.FracFamily_getAterm(self)

    def setAterm(self, aterm):
        r"""

        FracFamily::setAterm
        """
        return _gstlearn.FracFamily_setAterm(self, aterm)

    def getBterm(self):
        r"""

        FracFamily::getBterm
        """
        return _gstlearn.FracFamily_getBterm(self)

    def setBterm(self, bterm):
        r"""

        FracFamily::setBterm
        """
        return _gstlearn.FracFamily_setBterm(self, bterm)

    def getDorient(self):
        r"""

        FracFamily::getDorient
        """
        return _gstlearn.FracFamily_getDorient(self)

    def setDorient(self, dorient):
        r"""

        FracFamily::setDorient
        """
        return _gstlearn.FracFamily_setDorient(self, dorient)

    def getOrient(self):
        r"""

        FracFamily::getOrient
        """
        return _gstlearn.FracFamily_getOrient(self)

    def setOrient(self, orient):
        r"""

        FracFamily::setOrient
        """
        return _gstlearn.FracFamily_setOrient(self, orient)

    def getProp1(self):
        r"""

        FracFamily::getProp1
        """
        return _gstlearn.FracFamily_getProp1(self)

    def setProp1(self, prop1):
        r"""

        FracFamily::setProp1
        """
        return _gstlearn.FracFamily_setProp1(self, prop1)

    def getProp2(self):
        r"""

        FracFamily::getProp2
        """
        return _gstlearn.FracFamily_getProp2(self)

    def setProp2(self, prop2):
        r"""

        FracFamily::setProp2
        """
        return _gstlearn.FracFamily_setProp2(self, prop2)

    def getRange(self):
        r"""

        FracFamily::getRange
        """
        return _gstlearn.FracFamily_getRange(self)

    def setRange(self, range):
        r"""

        FracFamily::setRange
        """
        return _gstlearn.FracFamily_setRange(self, range)

    def getRatcst(self):
        r"""

        FracFamily::getRatcst
        """
        return _gstlearn.FracFamily_getRatcst(self)

    def setRatcst(self, ratcst):
        r"""

        FracFamily::setRatcst
        """
        return _gstlearn.FracFamily_setRatcst(self, ratcst)

    def getTheta0(self):
        r"""

        FracFamily::getTheta0
        """
        return _gstlearn.FracFamily_getTheta0(self)

    def setTheta0(self, theta0):
        r"""

        FracFamily::setTheta0
        """
        return _gstlearn.FracFamily_setTheta0(self, theta0)

    def _deserializeAscii(self, _is, verbose=False):
        r"""

        FracFamily::_deserializeAscii
        """
        return _gstlearn.FracFamily__deserializeAscii(self, _is, verbose)

    def _serializeAscii(self, os, verbose=False):
        r"""

        FracFamily::_serializeAscii
        """
        return _gstlearn.FracFamily__serializeAscii(self, os, verbose)

    def _deserializeH5(self, grp, verbose=False):
        return _gstlearn.FracFamily__deserializeH5(self, grp, verbose)

    def _serializeH5(self, grp, verbose=False):
        return _gstlearn.FracFamily__serializeH5(self, grp, verbose)

    def __repr__(self):
        return _gstlearn.FracFamily___repr__(self)

# Register FracFamily in _gstlearn:
_gstlearn.FracFamily_swigregister(FracFamily)
class FracFault(AStringable, ASerializable):
    r"""


    C++ includes: FracFault.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        FracFault::FracFault
        """
        _gstlearn.FracFault_swiginit(self, _gstlearn.new_FracFault(*args))
    __swig_destroy__ = _gstlearn.delete_FracFault

    def toString(self, strfmt=None):
        r"""

        FracFault::toString
        Interface for AStringable.  

        """
        return _gstlearn.FracFault_toString(self, strfmt)

    def getCoord(self):
        r"""

        FracFault::getCoord
        """
        return _gstlearn.FracFault_getCoord(self)

    def getOrient(self):
        r"""

        FracFault::getOrient
        """
        return _gstlearn.FracFault_getOrient(self)

    def getRangel(self, *args):
        r"""

        FracFault::getRangel
        """
        return _gstlearn.FracFault_getRangel(self, *args)

    def getRanger(self, *args):
        r"""

        FracFault::getRanger
        """
        return _gstlearn.FracFault_getRanger(self, *args)

    def getThetal(self, *args):
        r"""

        FracFault::getThetal
        """
        return _gstlearn.FracFault_getThetal(self, *args)

    def getThetar(self, *args):
        r"""

        FracFault::getThetar
        """
        return _gstlearn.FracFault_getThetar(self, *args)

    def getNFamilies(self):
        r"""

        FracFault::getNFamilies
        """
        return _gstlearn.FracFault_getNFamilies(self)

    def faultAbscissae(self, cote):
        r"""

        FracFault::faultAbscissae
        Calculate the abscissae of a fault at a given elevation  

        Returns
        -------
        The fault abscissae  

        Parameters
        ----------
        * `cote` :  
            Ordinate of the fracture starting point  

        """
        return _gstlearn.FracFault_faultAbscissae(self, cote)

    def addFaultPerFamily(self, thetal, thetar, rangel, ranger):
        r"""

        FracFault::addFaultPerFamily
        """
        return _gstlearn.FracFault_addFaultPerFamily(self, thetal, thetar, rangel, ranger)

    def setRangel(self, rangel):
        r"""

        FracFault::setRangel
        """
        return _gstlearn.FracFault_setRangel(self, rangel)

    def setRanger(self, ranger):
        r"""

        FracFault::setRanger
        """
        return _gstlearn.FracFault_setRanger(self, ranger)

    def setThetal(self, thetal):
        r"""

        FracFault::setThetal
        """
        return _gstlearn.FracFault_setThetal(self, thetal)

    def setThetar(self, thetar):
        r"""

        FracFault::setThetar
        """
        return _gstlearn.FracFault_setThetar(self, thetar)

    def __repr__(self):
        return _gstlearn.FracFault___repr__(self)

# Register FracFault in _gstlearn:
_gstlearn.FracFault_swigregister(FracFault)
class FracDesc(AStringable):
    r"""


    C++ includes: FracDesc.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        FracDesc::FracDesc
        """
        _gstlearn.FracDesc_swiginit(self, _gstlearn.new_FracDesc(*args))
    __swig_destroy__ = _gstlearn.delete_FracDesc

    def toString(self, strfmt=None):
        r"""

        FracDesc::toString
        Interface for AStringable.  

        """
        return _gstlearn.FracDesc_toString(self, strfmt)

    def getNPoint(self):
        r"""

        FracDesc::getNPoint
        """
        return _gstlearn.FracDesc_getNPoint(self)

    def getFamily(self):
        r"""

        FracDesc::getFamily
        """
        return _gstlearn.FracDesc_getFamily(self)

    def setFamily(self, family):
        r"""

        FracDesc::setFamily
        """
        return _gstlearn.FracDesc_setFamily(self, family)

    def getOrient(self):
        r"""

        FracDesc::getOrient
        """
        return _gstlearn.FracDesc_getOrient(self)

    def setOrient(self, orient):
        r"""

        FracDesc::setOrient
        """
        return _gstlearn.FracDesc_setOrient(self, orient)

    def getXXF(self, i):
        r"""

        FracDesc::getXXF
        """
        return _gstlearn.FracDesc_getXXF(self, i)

    def getYYF(self, i):
        r"""

        FracDesc::getYYF
        """
        return _gstlearn.FracDesc_getYYF(self, i)

    def setXXF(self, i, value):
        r"""

        FracDesc::setXXF
        """
        return _gstlearn.FracDesc_setXXF(self, i, value)

    def setYYF(self, i, value):
        r"""

        FracDesc::setYYF
        """
        return _gstlearn.FracDesc_setYYF(self, i, value)

    def addPoint(self, x, y):
        r"""

        FracDesc::addPoint
        """
        return _gstlearn.FracDesc_addPoint(self, x, y)

    def fractureExtension(self, cote, dcote):
        r"""

        FracDesc::fractureExtension
        Calculate the fracture extension  

        Returns
        -------
        The fracture extension  

        Parameters
        ----------
        * `cote` :  
            Selected layer or TEST for all layers  
        * `dcote` :  
            Tolerance on the layer elevation  

        """
        return _gstlearn.FracDesc_fractureExtension(self, cote, dcote)

    def __repr__(self):
        return _gstlearn.FracDesc___repr__(self)

# Register FracDesc in _gstlearn:
_gstlearn.FracDesc_swigregister(FracDesc)
NPART = _gstlearn.NPART
NBYFRAC = _gstlearn.NBYFRAC
NBYWOUT = _gstlearn.NBYWOUT
class FracList(AStringable):
    r"""


    C++ includes: FracList.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        FracList::FracList
        """
        _gstlearn.FracList_swiginit(self, _gstlearn.new_FracList(*args))
    __swig_destroy__ = _gstlearn.delete_FracList

    def toString(self, strfmt=None):
        r"""

        FracList::toString
        Interface for AStringable.  

        """
        return _gstlearn.FracList_toString(self, strfmt)

    def getNFracs(self):
        r"""

        FracList::getNFracs
        """
        return _gstlearn.FracList_getNFracs(self)

    def simulate(self, *args, **kwargs):
        r"""

        FracList::simulate
        Simulate a set of fractures  

        Parameters
        ----------
        * `envir` :  
            Environ structure  
        * `flag_sim_layer` :  
            TRUE for simulating layers FALSE if they are read  
        * `flag_sim_fract` :  
            TRUE for simulating the fractures FALSE establish the layers and the main
            faults  
        * `elevations` :  
            Array of elevations (used if flag_sim_layer=F)  
        * `seed` :  
            Seed for the random number generator  
        * `verbose` :  
            Verbose option  

        """
        return _gstlearn.FracList_simulate(self, *args, **kwargs)

    def addDescription(self, *args, **kwargs):
        r"""

        FracList::addDescription
        """
        return _gstlearn.FracList_addDescription(self, *args, **kwargs)

    def fractureExport(self):
        r"""

        FracList::fractureExport
        Export the Fractures  

        """
        return _gstlearn.FracList_fractureExport(self)

    def layinfoExport(self):
        r"""

        FracList::layinfoExport
        """
        return _gstlearn.FracList_layinfoExport(self)

    @staticmethod
    def fractureImport(*args, **kwargs):
        r"""

        FracList::fractureImport
        Import the Fractures  

        Returns
        -------
        Pointer to the FracList structure  

        Parameters
        ----------
        * `frac_segs` :  
            Array of fracture segments  
        * `layinfo` :  
            Array of layer information  
        * `nfamilies` :  
            Number of families  

        """
        return _gstlearn.FracList_fractureImport(*args, **kwargs)

    def fractureToBlock(self, *args, **kwargs):
        r"""

        FracList::fractureToBlock
        Plunge a subset of the simulated fractures into a block  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `dbgrid` :  
            Db structure  
        * `xmax` :  
            Maximum extension along horizontal axis  
        * `permtab` :  
            Permabilities per family (starting from 0)  
        * `perm_mat` :  
            Permability for the matrix  
        * `perm_bench` :  
            Permability along the bench edge  
        * `ndisc` :  
            Number of discretization steps  
        * `verbose` :  
            Verbose flag  
        * `namconv` :  
            Naming convention  

        """
        return _gstlearn.FracList_fractureToBlock(self, *args, **kwargs)

    def fractureToWell(self, nval, well, xmax, permtab, nint, ncol):
        r"""

        FracList::fractureToWell
        Plunge a well line in a set of fractures  

        Returns
        -------
        Array of the intersections (should be checked against NULL)  

        Parameters
        ----------
        * `nval` :  
            Number of well information  
        * `well` :  
            Array giving the well trajectory  
        * `xmax` :  
            Maximum extension along horizontal axis  
        * `permtab` :  
            Permabilities per family (starting from 0) Optional  
        * `nint` :  
            Number of intersections  
        * `ncol` :  
            Number of attributes per intersection  

        remark: Output array must be freed by the calling function  

        """
        return _gstlearn.FracList_fractureToWell(self, nval, well, xmax, permtab, nint, ncol)

    def fractureWellToBlock(self, dbgrid, col_perm, col_fluid, flag_fluid, val_fluid, wellout, nval, ndisc=1000., verbose=False):
        r"""

        FracList::fractureWellToBlock
        Plunge a line trajectory and the modified permeabilities within an existing
        block  

        Returns
        -------
        Error return code  

        Parameters
        ----------
        * `dbgrid` :  
            Db structure  
        * `col_perm` :  
            Existing attribute for permeability (or ITEST)  
        * `col_fluid` :  
            Existing attribute for fluid (or ITEST)  
        * `flag_fluid` :  
            1 for performing the Fluid filling  
        * `val_fluid` :  
            Value assigned to the fluid  
        * `wellout` :  
            Pointer to the new wellout information  
        * `nval` :  
            Number of values for wellout informations  
        * `ndisc` :  
            Number of discretization steps  
        * `verbose` :  
            Verbose flag  

        """
        return _gstlearn.FracList_fractureWellToBlock(self, dbgrid, col_perm, col_fluid, flag_fluid, val_fluid, wellout, nval, ndisc, verbose)

    def fractureExtractLength(self, ifam, cote, dcote):
        r"""

        FracList::fractureExtractLength
        Extract the array of fracture lengths  

        Returns
        -------
        The returned array  

        Parameters
        ----------
        * `ifam` :  
            Rank of the family or ITEST for all  
        * `cote` :  
            Selected layer or TEST for all layers  
        * `dcote` :  
            Tolerance on the layer elevation  

        """
        return _gstlearn.FracList_fractureExtractLength(self, ifam, cote, dcote)

    def fractureExtractDist(self, ifam, cote, dcote):
        r"""

        FracList::fractureExtractDist
        Extract the fracture interdistances  

        Returns
        -------
        The returned array  

        Parameters
        ----------
        * `ifam` :  
            Rank of the family or ITEST for all  
        * `cote` :  
            Selected layer or TEST for all layers  
        * `dcote` :  
            Tolerance on the layer elevation  

        """
        return _gstlearn.FracList_fractureExtractDist(self, ifam, cote, dcote)

    def setFamily(self, i, ifam):
        r"""

        FracList::setFamily
        """
        return _gstlearn.FracList_setFamily(self, i, ifam)

    def setOrient(self, i, orient):
        r"""

        FracList::setOrient
        """
        return _gstlearn.FracList_setOrient(self, i, orient)

    def addPoint(self, i, xx, yy):
        r"""

        FracList::addPoint
        """
        return _gstlearn.FracList_addPoint(self, i, xx, yy)

    def __repr__(self):
        return _gstlearn.FracList___repr__(self)

# Register FracList in _gstlearn:
_gstlearn.FracList_swigregister(FracList)
class Ball(object):
    r"""


    C++ includes: Ball.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Ball::Ball
        """
        _gstlearn.Ball_swiginit(self, _gstlearn.new_Ball(*args))
    __swig_destroy__ = _gstlearn.delete_Ball

    def init(self, db, dist_function=None, leaf_size=10, default_distance_function=1, useSel=False):
        r"""

        Ball::init
        """
        return _gstlearn.Ball_init(self, db, dist_function, leaf_size, default_distance_function, useSel)

    def query(self, test, n_samples, n_features, n_neighbors=1):
        r"""

        Ball::query
        """
        return _gstlearn.Ball_query(self, test, n_samples, n_features, n_neighbors)

    def queryAsVVD(self, test, n_neighbors=1):
        r"""

        Ball::queryAsVVD
        """
        return _gstlearn.Ball_queryAsVVD(self, test, n_neighbors)

    def queryOne(self, test, n_features, n_neighbors=1):
        r"""

        Ball::queryOne
        """
        return _gstlearn.Ball_queryOne(self, test, n_features, n_neighbors)

    def queryOneAsVD(self, test, n_neighbors=1):
        r"""

        Ball::queryOneAsVD
        """
        return _gstlearn.Ball_queryOneAsVD(self, test, n_neighbors)

    def queryOneAsVDFromSP(self, Pt, n_neighbors=1):
        r"""

        Ball::queryOneAsVDFromSP
        """
        return _gstlearn.Ball_queryOneAsVDFromSP(self, Pt, n_neighbors)

    def getIndices(self, Pt, n_neighbors=1):
        r"""

        Ball::getIndices
        """
        return _gstlearn.Ball_getIndices(self, Pt, n_neighbors)

    def queryClosest(self, test):
        r"""

        Ball::queryClosest
        """
        return _gstlearn.Ball_queryClosest(self, test)

    def queryOneInPlace(self, test, n_neighbors, indices, distances, rank=0):
        r"""

        Ball::queryOneInPlace
        """
        return _gstlearn.Ball_queryOneInPlace(self, test, n_neighbors, indices, distances, rank)

    def display(self, level=-1):
        r"""

        Ball::display
        Ask for information regarding the Ball Tree organization.  

        Parameters
        ----------
        * `level` :  
            Level of details -1 Just the general volumetry information 0 List of the
            different nodes 1 List of Leaves and attached list of samples  

        """
        return _gstlearn.Ball_display(self, level)

    def setConstraint(self, rank, status):
        r"""

        Ball::setConstraint
        """
        return _gstlearn.Ball_setConstraint(self, rank, status)

    def resetConstraints(self, status):
        r"""

        Ball::resetConstraints
        """
        return _gstlearn.Ball_resetConstraints(self, status)

    def empty(self):
        r"""

        Ball::empty
        """
        return _gstlearn.Ball_empty(self)

# Register Ball in _gstlearn:
_gstlearn.Ball_swigregister(Ball)

def findNN(dbin, dbout=None, nb_neigh=3, flagShuffle=False, verbose=False, dist_function=None, leaf_size=10, default_distance_function=1):
    r"""


    """
    return _gstlearn.findNN(dbin, dbout, nb_neigh, flagShuffle, verbose, dist_function, leaf_size, default_distance_function)
class KNN(object):
    r"""


    C++ includes: KNN.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        KNN::KNN
        """
        _gstlearn.KNN_swiginit(self, _gstlearn.new_KNN(*args))
    __swig_destroy__ = _gstlearn.delete_KNN

    def setDistances(self, distances):
        r"""

        KNN::setDistances
        """
        return _gstlearn.KNN_setDistances(self, distances)

    def setIndices(self, indices):
        r"""

        KNN::setIndices
        """
        return _gstlearn.KNN_setIndices(self, indices)

    def setNNeighbors(self, n_neighbors):
        r"""

        KNN::setNNeighbors
        """
        return _gstlearn.KNN_setNNeighbors(self, n_neighbors)

    def setNSamples(self, n_samples):
        r"""

        KNN::setNSamples
        """
        return _gstlearn.KNN_setNSamples(self, n_samples)

    def btree_query(self, tree, x, n_samples, n_features, n_neigh):
        r"""

        KNN::btree_query
        """
        return _gstlearn.KNN_btree_query(self, tree, x, n_samples, n_features, n_neigh)

    def btree_query_inPlace(self, tree, x, n_samples, n_features, n_neigh, rank, indices, distances):
        r"""

        KNN::btree_query_inPlace
        """
        return _gstlearn.KNN_btree_query_inPlace(self, tree, x, n_samples, n_features, n_neigh, rank, indices, distances)

    def getIndices(self, rank=0):
        r"""

        KNN::getIndices
        """
        return _gstlearn.KNN_getIndices(self, rank)

    def getIndex(self, rank=0, ineigh=0):
        r"""

        KNN::getIndex
        """
        return _gstlearn.KNN_getIndex(self, rank, ineigh)

    def getDistances(self, rank=0):
        r"""

        KNN::getDistances
        """
        return _gstlearn.KNN_getDistances(self, rank)

    def getDistance(self, rank=0, ineigh=0):
        r"""

        KNN::getDistance
        """
        return _gstlearn.KNN_getDistance(self, rank, ineigh)

# Register KNN in _gstlearn:
_gstlearn.KNN_swigregister(KNN)
class Projection(object):
    r"""


    C++ includes: Projection.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Projection::Projection
        """
        _gstlearn.Projection_swiginit(self, _gstlearn.new_Projection(*args))
    __swig_destroy__ = _gstlearn.delete_Projection

    def operateInPlace(self, coor):
        r"""

        Projection::operateInPlace
        """
        return _gstlearn.Projection_operateInPlace(self, coor)

    def operateInvert(self, coor):
        r"""

        Projection::operateInvert
        """
        return _gstlearn.Projection_operateInvert(self, coor)

    def operateVecInPlace(self, x, y):
        r"""

        Projection::operateVecInPlace
        """
        return _gstlearn.Projection_operateVecInPlace(self, x, y)

    def operateOnDb(self, db):
        r"""

        Projection::operateOnDb
        """
        return _gstlearn.Projection_operateOnDb(self, db)

    def operateOnPolygons(self, poly):
        r"""

        Projection::operateOnPolygons
        """
        return _gstlearn.Projection_operateOnPolygons(self, poly)

    def isFlagMean(self):
        r"""

        Projection::isFlagMean
        """
        return _gstlearn.Projection_isFlagMean(self)

    def getXcenter(self):
        r"""

        Projection::getXcenter
        """
        return _gstlearn.Projection_getXcenter(self)

    def getYcenter(self):
        r"""

        Projection::getYcenter
        """
        return _gstlearn.Projection_getYcenter(self)

# Register Projection in _gstlearn:
_gstlearn.Projection_swigregister(Projection)
class SpatialIndices(AStringable):
    r"""


    C++ includes: SpatialIndices.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""

        SpatialIndices::SpatialIndices
        """
        _gstlearn.SpatialIndices_swiginit(self, _gstlearn.new_SpatialIndices(*args))
    __swig_destroy__ = _gstlearn.delete_SpatialIndices

    def toString(self, strfmt=None):
        r"""

        SpatialIndices::toString
        Interface to AStringable.  

        """
        return _gstlearn.SpatialIndices_toString(self, strfmt)

    def computeCGI(self, name):
        r"""

        SpatialIndices::computeCGI
        Calculate the Center of Gravity  

        Returns
        -------
        Error returned code  

        Parameters
        ----------
        * `name` :  
            Name of the optional attribute  

        """
        return _gstlearn.SpatialIndices_computeCGI(self, name)

    def spatial(self, name):
        r"""

        SpatialIndices::spatial
        Calculate several Spatial indices.  

        Parameters
        ----------
        * `name` :  
            Name of the Target variable  

        remark: This functions have been developped in the scope of the UE  

        remark: program Fisboat, DG-Fish, STREP #502572  

        """
        return _gstlearn.SpatialIndices_spatial(self, name)

    def getLIC(self, name1, name2):
        r"""

        SpatialIndices::getLIC
        """
        return _gstlearn.SpatialIndices_getLIC(self, name1, name2)

    def getGIC(self, name1, name2):
        r"""

        SpatialIndices::getGIC
        """
        return _gstlearn.SpatialIndices_getGIC(self, name1, name2)

    def getMatrixEllipse(self):
        r"""

        SpatialIndices::getMatrixEllipse
        """
        return _gstlearn.SpatialIndices_getMatrixEllipse(self)

    def getMatrixInertia(self):
        r"""

        SpatialIndices::getMatrixInertia
        """
        return _gstlearn.SpatialIndices_getMatrixInertia(self)

    def getAxes(self):
        r"""

        SpatialIndices::getAxes
        """
        return _gstlearn.SpatialIndices_getAxes(self)

    def getAxe(self, rank):
        r"""

        SpatialIndices::getAxe
        """
        return _gstlearn.SpatialIndices_getAxe(self, rank)

    def getCenter(self):
        r"""

        SpatialIndices::getCenter
        """
        return _gstlearn.SpatialIndices_getCenter(self)

    def getInertia(self):
        r"""

        SpatialIndices::getInertia
        """
        return _gstlearn.SpatialIndices_getInertia(self)

    def getIso(self):
        r"""

        SpatialIndices::getIso
        """
        return _gstlearn.SpatialIndices_getIso(self)

    def getQT(self, name):
        r"""

        SpatialIndices::getQT
        """
        return _gstlearn.SpatialIndices_getQT(self, name)

    def getMicroStructure(self, name, h0, polygon=None, dlim=0., ndisc=100):
        r"""

        SpatialIndices::getMicroStructure
        """
        return _gstlearn.SpatialIndices_getMicroStructure(self, name, h0, polygon, dlim, ndisc)

    def getPatches(self, name, Dmin, Amin=0):
        r"""

        SpatialIndices::getPatches
        Returns the list of center of gravity of the different patches The last center
        of gravity is the global one  

        Parameters
        ----------
        * `name` :  
            Name of the target variable  
        * `Dmin` :  
            Minimum rejection distance between patches  
        * `Amin` :  
            Abundance percentage above which patches are displayed  

        """
        return _gstlearn.SpatialIndices_getPatches(self, name, Dmin, Amin)

    def __repr__(self):
        return _gstlearn.SpatialIndices___repr__(self)

# Register SpatialIndices in _gstlearn:
_gstlearn.SpatialIndices_swigregister(SpatialIndices)

def acknowledge_gstlearn():
    r"""


    Acknowledgment of the authors for gstlearn Library  

    """
    return _gstlearn.acknowledge_gstlearn()

def potential_kriging(db, dbgrd, dbtgt, dbout, model, neigh, nugget_grd=0., nugget_tgt=0., flag_pot=True, flag_grad=False, flag_trans=False, flag_save_data=False, opt_part=0, verbose=False):
    r"""


    Potential estimation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbiso` :  
        Iso-potential Db structure  
    * `dbgrd` :  
        Gradient Db structure  
    * `dbtgt` :  
        Tangent Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure  
    * `nugget_grd` :  
        Nugget effect for Gradients  
    * `nugget_tgt` :  
        Nugget effect for Tangents  
    * `flag_pot` :  
        True if the Potential must be estimated  
    * `flag_grad` :  
        True if the gradient must also be estimated  
    * `flag_trans` :  
        True if the estimation result must be translated into layer number  
    * `flag_save_data` :  
        True if the Potential / Gradient must be saved on any Information file  
    * `opt_part` :  
        Option to exhibit only a part of estimation:  

        *   0 : the whole estimation  
        *   1 : the gradient contribution only  
        *   2 : the tangent contribution only  
        *   3 : the isovalues contribution only  
        *   4 : the drift contribution only  
        *   5 : the external drift contribution only  
    * `verbose` :  
        Verbose option  

    remark: The results will be stored in the dbout file  

    remark: - the estimation in the variable ELoc::Z  

    remark: - the gradient components in the variables ELoc::GRD  

    """
    return _gstlearn.potential_kriging(db, dbgrd, dbtgt, dbout, model, neigh, nugget_grd, nugget_tgt, flag_pot, flag_grad, flag_trans, flag_save_data, opt_part, verbose)

def potential_cov(model, verbose, type1, x10, x1p, tx1, type2, x20, x2p, tx2, covtab):
    r"""


    Potential covariance  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `model` :  
        Model structure  
    * `verbose` :  
        Verbose flag  
    * `type1` :  
        Type of the first point 1 for gradient; 2 for tangent; 3 for isopotential  
    * `x10` :  
        Coordinates of the centering for first point  
    * `x1p` :  
        Coordinates of the first point  
    * `tx1` :  
        Tangent values at the first point  
    * `type2` :  
        Type of the second point 1 for gradient; 2 for tangent; 3 for isopotential
        (Sign is negative for target point)  
    * `x20` :  
        Coordinates of the centering for second point  
    * `x2p` :  
        Coordinates of the second point  
    * `tx2` :  
        Tangent values at the second point  
    * `covtab` :  
        Array of returned values (dimensionned to ndim*ndim)  

    """
    return _gstlearn.potential_cov(model, verbose, type1, x10, x1p, tx1, type2, x20, x2p, tx2, covtab)

def potential_simulate(dbiso, dbgrd, dbtgt, dbout, model, neigh, nugget_grd=0., nugget_tgt=0., dist_tempere=1.234e30, flag_trans=False, seed=135674, nbsimu=1, nbtuba=100, verbose=False):
    r"""


    Potential simulations  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbiso` :  
        Iso-potential Db structure  
    * `dbgrd` :  
        Gradient Db structure  
    * `dbtgt` :  
        Tangent Db structure (optional)  
    * `dbout` :  
        Output Db structure  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure  
    * `nugget_grd` :  
        Nugget effect for Gradients  
    * `nugget_tgt` :  
        Nugget effect for Tangents  
    * `dist_tempere` :  
        Distance for tempering simulations (or TEST)  
    * `flag_trans` :  
        True if the estimation result must be translated into layer number  
    * `seed` :  
        Seed for the random number generator  
    * `nbsimu` :  
        Number of simulations  
    * `nbtuba` :  
        Number of turning bands  
    * `verbose` :  
        Verbose option  

    remark: The simulations will be stored in the dbout file (ELoc::SIMU)  

    """
    return _gstlearn.potential_simulate(dbiso, dbgrd, dbtgt, dbout, model, neigh, nugget_grd, nugget_tgt, dist_tempere, flag_trans, seed, nbsimu, nbtuba, verbose)

def potential_xvalid(dbiso, dbgrd, dbtgt, model, neigh, nugget_grd=0., nugget_tgt=0., flag_dist_conv=False, verbose=False):
    r"""


    Potential cross-validation  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `dbiso` :  
        Iso-potential Db structure  
    * `dbgrd` :  
        Gradient Db structure  
    * `dbtgt` :  
        Tangent Db structure (optional)  
    * `model` :  
        Model structure  
    * `neigh` :  
        ANeigh structure  
    * `nugget_grd` :  
        Nugget effect for Gradients  
    * `nugget_tgt` :  
        Nugget effect for Tangents  
    * `flag_dist_conv` :  
        Flag for converting into distance  
    * `verbose` :  
        Verbose option  

    """
    return _gstlearn.potential_xvalid(dbiso, dbgrd, dbtgt, model, neigh, nugget_grd, nugget_tgt, flag_dist_conv, verbose)

def seismic_estimate_XZ(db, model, nbench, nv2max, flag_ks, flag_std, flag_sort, flag_stat):
    r"""


    Perform a bivariate estimation on a grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Grid Db structure  
    * `model` :  
        Model structure  
    * `nbench` :  
        Vertical Radius of the neighborhood (center excluded)  
    * `nv2max` :  
        Maximum number of traces of second variable on each side of the target trace  
    * `flag_ks` :  
        1 for a Simple Kriging; otherwise Ordinary Kriging  
    * `flag_std` :  
        1 for the calculation of the St. Dev.  
    * `flag_sort` :  
        1 if the traces to be treated are sorted by increasing distance to trace
        where first variable is defined  
    * `flag_stat` :  
        1 for producing final statistics  

    """
    return _gstlearn.seismic_estimate_XZ(db, model, nbench, nv2max, flag_ks, flag_std, flag_sort, flag_stat)

def seismic_simulate_XZ(db, model, nbench, nv2max, nbsimu, seed, flag_ks, flag_sort, flag_stat):
    r"""


    Perform a bivariate cosimulation on a grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Grid Db structure  
    * `model` :  
        Model structure  
    * `nbench` :  
        Vertical Radius of the neighborhood (center excluded)  
    * `nv2max` :  
        Maximum number of traces of second variable on each side of the target trace  
    * `nbsimu` :  
        Number of simulations  
    * `seed` :  
        Seed for the random number generator  
    * `flag_ks` :  
        1 for a Simple Kriging; otherwise Ordinary Kriging  
    * `flag_sort` :  
        1 if the traces to be treated are sorted by increasing distance to trace
        where first variable is defined  
    * `flag_stat` :  
        1 for producing final statistics  

    """
    return _gstlearn.seismic_simulate_XZ(db, model, nbench, nv2max, nbsimu, seed, flag_ks, flag_sort, flag_stat)

def seismic_z2t_grid(verbose, db_z, iatt_v, nx, x0, dx):
    r"""


    Define the Time Grid characteristics from the Depth Grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `verbose` :  
        Verbose flag  
    * `db_z` :  
        Depth Grid structure  
    * `iatt_v` :  
        Attribute address of the Velocity (int Depth Grid)  
    * `nx` :  
        Number of grid nodes along each direction  
    * `x0` :  
        Origin of the grid along each direction  
    * `dx` :  
        Mesh of the grid along each direction  

    """
    return _gstlearn.seismic_z2t_grid(verbose, db_z, iatt_v, nx, x0, dx)

def seismic_t2z_grid(verbose, db_t, iatt_v, nx, x0, dx):
    r"""


    Define the Depth Grid characteristics from the Time Grid  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `verbose` :  
        Verbose flag  
    * `db_t` :  
        Time Grid structure  
    * `iatt_v` :  
        Attribute address of the Velocity (in Time grid)  
    * `nx` :  
        Number of grid nodes along each direction  
    * `x0` :  
        Origin of the grid along each direction  
    * `dx` :  
        Mesh of the grid along each direction  

    """
    return _gstlearn.seismic_t2z_grid(verbose, db_t, iatt_v, nx, x0, dx)

def seismic_z2t_convert(db_z, iatt_v, db_t):
    r"""


    Resample from depth to time  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db_z` :  
        Depth Grid structure  
    * `iatt_v` :  
        Address of the Velocity variable (in Depth grid)  
    * `db_t` :  
        Time Grid structure  

    remark: Linear interpolation and constant extrapolation is used to  

    remark: determine interval velocities at times not specified.  

    """
    return _gstlearn.seismic_z2t_convert(db_z, iatt_v, db_t)

def seismic_t2z_convert(db_t, iatt_v, db_z):
    r"""


    Resample from time to depth  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db_t` :  
        Time Grid structure  
    * `iatt_v` :  
        Address of the Velocity variable (in Time grid)  
    * `db_z` :  
        Depth Grid structure  

    remark: Linear interpolation and constant extrapolation is used to  

    remark: determine interval velocities at times not specified.  

    """
    return _gstlearn.seismic_t2z_convert(db_t, iatt_v, db_z)

def seismic_operate(db, oper):
    r"""


    Do unary arithmetic operation on traces  

    Returns
    -------
    Error return code  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `oper` :  
        Operator flag (::ENUM_SEISMICS)  

    remark: Operations inv, slog and slog10 are "punctuated", meaning that if,  

    remark: the input contains 0 values, 0 values are returned.  

    """
    return _gstlearn.seismic_operate(db, oper)

def seismic_convolve(db, flag_operate, flag_contrast, type, ntw, option, tindex, fpeak, period, amplitude, distort, val_before, val_middle, val_after, wavelet):
    r"""


    Convolve with a given wavelet  

    Returns
    -------
    Array containing the discretized wavelet, allocated here  

    Parameters
    ----------
    * `db` :  
        Db structure  
    * `flag_operate` :  
        1 to perform the convolution; 0 otherwise  
    * `flag_contrast` :  
        1 to perform contrast; 0 otherwise  
    * `type` :  
        Type of the wavelet (::ENUM_WAVELETS)  
    * `ntw` :  
        half-length of the wavelet excluding center (samples)  
    * `option` :  
        option used to perform the convolution  

        *   -1 : erode the edge (on ntw pixels)  
        *   0 : truncate the wavelet on the edge  
        *   +1 : extend the trace with padding before convolution  
        *   +2 : extend the trace with the last informed values  
    * `tindex` :  
        time index to locate the spike (Spike)  
    * `fpeak` :  
        peak frequency of the Ricker wavelet  
    * `period` :  
        wavelet period (s) (Ricker)  
    * `amplitude` :  
        wavelet amplitude (Ricker)  
    * `distort` :  
        wavelet distortion factor (Ricker)  
    * `val_before` :  
        Replacement value for undefined element before first defined sample  
    * `val_middle` :  
        Replacement value for undefined element between defined samples  
    * `val_after` :  
        Replacement value for undefined element after last defined sample  
    * `wavelet` :  
        Wavelet defined as input (Dimension: 2*ntw+1)  

    """
    return _gstlearn.seismic_convolve(db, flag_operate, flag_contrast, type, ntw, option, tindex, fpeak, period, amplitude, distort, val_before, val_middle, val_after, wavelet)
class LinearOpCGSolver(ALinearOpCGSolver):
    r"""


    C++ includes: LinearOpCGSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, linop):
        r"""

        LinearOpCGSolver::LinearOpCGSolver
        """
        _gstlearn.LinearOpCGSolver_swiginit(self, _gstlearn.new_LinearOpCGSolver(linop))
    __swig_destroy__ = _gstlearn.delete_LinearOpCGSolver

    def solve(self, rhs, out):
        r"""

        LinearOpCGSolver::solve
        """
        return _gstlearn.LinearOpCGSolver_solve(self, rhs, out)

    def setMaxIterations(self, n):
        r"""

        LinearOpCGSolver::setMaxIterations
        """
        return _gstlearn.LinearOpCGSolver_setMaxIterations(self, n)

    def setTolerance(self, tol):
        r"""

        LinearOpCGSolver::setTolerance
        """
        return _gstlearn.LinearOpCGSolver_setTolerance(self, tol)

    def getIterations(self):
        r"""

        LinearOpCGSolver::getIterations
        """
        return _gstlearn.LinearOpCGSolver_getIterations(self)

    def getError(self):
        r"""

        LinearOpCGSolver::getError
        """
        return _gstlearn.LinearOpCGSolver_getError(self)

# Register LinearOpCGSolver in _gstlearn:
_gstlearn.LinearOpCGSolver_swigregister(LinearOpCGSolver)
class LinearSPDEOpCGSolver(ALinearOpCGSolver):
    r"""


    C++ includes: LinearOpCGSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, linop):
        r"""

        LinearOpCGSolver::LinearOpCGSolver
        """
        _gstlearn.LinearSPDEOpCGSolver_swiginit(self, _gstlearn.new_LinearSPDEOpCGSolver(linop))
    __swig_destroy__ = _gstlearn.delete_LinearSPDEOpCGSolver

    def solve(self, rhs, out):
        r"""

        LinearOpCGSolver::solve
        """
        return _gstlearn.LinearSPDEOpCGSolver_solve(self, rhs, out)

    def setMaxIterations(self, n):
        r"""

        LinearOpCGSolver::setMaxIterations
        """
        return _gstlearn.LinearSPDEOpCGSolver_setMaxIterations(self, n)

    def setTolerance(self, tol):
        r"""

        LinearOpCGSolver::setTolerance
        """
        return _gstlearn.LinearSPDEOpCGSolver_setTolerance(self, tol)

    def getIterations(self):
        r"""

        LinearOpCGSolver::getIterations
        """
        return _gstlearn.LinearSPDEOpCGSolver_getIterations(self)

    def getError(self):
        r"""

        LinearOpCGSolver::getError
        """
        return _gstlearn.LinearSPDEOpCGSolver_getError(self)

# Register LinearSPDEOpCGSolver in _gstlearn:
_gstlearn.LinearSPDEOpCGSolver_swigregister(LinearSPDEOpCGSolver)

import gstlearn as gl

def evalCovMat(self, *args, **kwargs):
    return self.getCov().evalCovMat(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMat', evalCovMat)

def evalCovMatInPlace(self, *args, **kwargs):
    return self.getCov().evalCovMatInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatInPlace', evalCovMatInPlace)

def evalCovMatInPlaceFromIdx(self, *args, **kwargs):
    return self.getCov().evalCovMatInPlaceFromIdx(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatInPlaceFromIdx', evalCovMatInPlaceFromIdx)

def evalCovMatSym(self, *args, **kwargs):
    return self.getCov().evalCovMatSym(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatSym', evalCovMatSym)

def evalCovMatSymInPlace(self, *args, **kwargs):
    return self.getCov().evalCovMatSymInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatSymInPlace', evalCovMatSymInPlace)

def evalCovMatSymInPlaceFromIdx(self, *args, **kwargs):
    return self.getCov().evalCovMatSymInPlaceFromIdx(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatSymInPlaceFromIdx', evalCovMatSymInPlaceFromIdx)

def eval0Mat(self, *args, **kwargs):
    return self.getCov().eval0Mat(*args, **kwargs)

setattr(gl.ModelGeneric, 'eval0Mat', eval0Mat)

def evalCovMat0(self, *args, **kwargs):
    return self.getCov().evalCovMat0(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMat0', evalCovMat0)

def evalCovMat0InPlace(self, *args, **kwargs):
    return self.getCov().evalCovMat0InPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMat0InPlace', evalCovMat0InPlace)

def evalCovVecRHSInPlace(self, *args, **kwargs):
    return self.getCov().evalCovVecRHSInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovVecRHSInPlace', evalCovVecRHSInPlace)

def evalCovMatOptimInPlace(self, *args, **kwargs):
    return self.getCov().evalCovMatOptimInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatOptimInPlace', evalCovMatOptimInPlace)

def evalCovMatRHSInPlaceFromIdx(self, *args, **kwargs):
    return self.getCov().evalCovMatRHSInPlaceFromIdx(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatRHSInPlaceFromIdx', evalCovMatRHSInPlaceFromIdx)

def evalCovMatSparse(self, *args, **kwargs):
    return self.getCov().evalCovMatSparse(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovMatSparse', evalCovMatSparse)

def eval0(self, *args, **kwargs):
    return self.getCov().eval0(*args, **kwargs)

setattr(gl.ModelGeneric, 'eval0', eval0)

def evalCov(self, *args, **kwargs):
    return self.getCov().evalCov(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCov', evalCov)

def evalNvarIpas(self, *args, **kwargs):
    return self.getCov().evalNvarIpas(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalNvarIpas', evalNvarIpas)

def evalNvarIpasIncr(self, *args, **kwargs):
    return self.getCov().evalNvarIpasIncr(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalNvarIpasIncr', evalNvarIpasIncr)

def evalIvarNlag(self, *args, **kwargs):
    return self.getCov().evalIvarNlag(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalIvarNlag', evalIvarNlag)

def evalIvarIpas(self, *args, **kwargs):
    return self.getCov().evalIvarIpas(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalIvarIpas', evalIvarIpas)

def evalCvv(self, *args, **kwargs):
    return self.getCov().evalCvv(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCvv', evalCvv)

def evalCvvShift(self, *args, **kwargs):
    return self.getCov().evalCvvShift(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCvvShift', evalCvvShift)

def evalCvvM(self, *args, **kwargs):
    return self.getCov().evalCvvM(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCvvM', evalCvvM)

def evalCxv(self, *args, **kwargs):
    return self.getCov().evalCxv(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCxv', evalCxv)

def evalCxvM(self, *args, **kwargs):
    return self.getCov().evalCxvM(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCxvM', evalCxvM)

def evalPointToDb(self, *args, **kwargs):
    return self.getCov().evalPointToDb(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalPointToDb', evalPointToDb)

def evalPointToDbAsSP(self, *args, **kwargs):
    return self.getCov().evalPointToDbAsSP(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalPointToDbAsSP', evalPointToDbAsSP)

def evalAverageDbToDb(self, *args, **kwargs):
    return self.getCov().evalAverageDbToDb(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalAverageDbToDb', evalAverageDbToDb)

def evalAverageIncrToIncr(self, *args, **kwargs):
    return self.getCov().evalAverageIncrToIncr(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalAverageIncrToIncr', evalAverageIncrToIncr)

def evalAveragePointToDb(self, *args, **kwargs):
    return self.getCov().evalAveragePointToDb(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalAveragePointToDb', evalAveragePointToDb)

def samplingDensityVariance(self, *args, **kwargs):
    return self.getCov().samplingDensityVariance(*args, **kwargs)

setattr(gl.ModelGeneric, 'samplingDensityVariance', samplingDensityVariance)

def specificVolume(self, *args, **kwargs):
    return self.getCov().specificVolume(*args, **kwargs)

setattr(gl.ModelGeneric, 'specificVolume', specificVolume)

def coefficientOfVariation(self, *args, **kwargs):
    return self.getCov().coefficientOfVariation(*args, **kwargs)

setattr(gl.ModelGeneric, 'coefficientOfVariation', coefficientOfVariation)

def specificVolumeFromCoV(self, *args, **kwargs):
    return self.getCov().specificVolumeFromCoV(*args, **kwargs)

setattr(gl.ModelGeneric, 'specificVolumeFromCoV', specificVolumeFromCoV)

def extensionVariance(self, *args, **kwargs):
    return self.getCov().extensionVariance(*args, **kwargs)

setattr(gl.ModelGeneric, 'extensionVariance', extensionVariance)

def calculateStDev(self, *args, **kwargs):
    return self.getCov().calculateStDev(*args, **kwargs)

setattr(gl.ModelGeneric, 'calculateStDev', calculateStDev)

def evaluateMatInPlace(self, *args, **kwargs):
    return self.getCov().evaluateMatInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evaluateMatInPlace', evaluateMatInPlace)

def evaluateOneGeneric(self, *args, **kwargs):
    return self.getCov().evaluateOneGeneric(*args, **kwargs)

setattr(gl.ModelGeneric, 'evaluateOneGeneric', evaluateOneGeneric)

def evaluateOneIncr(self, *args, **kwargs):
    return self.getCov().evaluateOneIncr(*args, **kwargs)

setattr(gl.ModelGeneric, 'evaluateOneIncr', evaluateOneIncr)

def buildVmapOnDbGrid(self, *args, **kwargs):
    return self.getCov().buildVmapOnDbGrid(*args, **kwargs)

setattr(gl.ModelGeneric, 'buildVmapOnDbGrid', buildVmapOnDbGrid)

def sample(self, *args, **kwargs):
    return self.getCov().sample(*args, **kwargs)

setattr(gl.ModelGeneric, 'sample', sample)

def sampleUnitary(self, *args, **kwargs):
    return self.getCov().sampleUnitary(*args, **kwargs)

setattr(gl.ModelGeneric, 'sampleUnitary', sampleUnitary)

def envelop(self, *args, **kwargs):
    return self.getCov().envelop(*args, **kwargs)

setattr(gl.ModelGeneric, 'envelop', envelop)

def gofToVario(self, *args, **kwargs):
    return self.getCov().gofToVario(*args, **kwargs)

setattr(gl.ModelGeneric, 'gofToVario', gofToVario)

def isNoStat(self, *args, **kwargs):
    return self.getCov().isNoStat(*args, **kwargs)

setattr(gl.ModelGeneric, 'isNoStat', isNoStat)

def manage(self, *args, **kwargs):
    return self.getCov().manage(*args, **kwargs)

setattr(gl.ModelGeneric, 'manage', manage)

def optimizationPreProcessForData(self, *args, **kwargs):
    return self.getCov().optimizationPreProcessForData(*args, **kwargs)

setattr(gl.ModelGeneric, 'optimizationPreProcessForData', optimizationPreProcessForData)

def optimizationPostProcess(self, *args, **kwargs):
    return self.getCov().optimizationPostProcess(*args, **kwargs)

setattr(gl.ModelGeneric, 'optimizationPostProcess', optimizationPostProcess)

def getDrift(self, *args, **kwargs):
    return self.getDriftList().getDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'getDrift', getDrift)

def computeDrift(self, *args, **kwargs):
    return self.getDriftList().computeDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'computeDrift', computeDrift)

def evalDriftValue(self, *args, **kwargs):
    return self.getDriftList().evalDriftValue(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftValue', evalDriftValue)

def evalDriftMat(self, *args, **kwargs):
    return self.getDriftList().evalDriftMat(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftMat', evalDriftMat)

def evalDriftMatInPlace(self, *args, **kwargs):
    return self.getDriftList().evalDriftMatInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftMatInPlace', evalDriftMatInPlace)

def evalDriftMatByRanks(self, *args, **kwargs):
    return self.getDriftList().evalDriftMatByRanks(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftMatByRanks', evalDriftMatByRanks)

def evalMeanVecByRanks(self, *args, **kwargs):
    return self.getDriftList().evalMeanVecByRanks(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalMeanVecByRanks', evalMeanVecByRanks)

def evalDriftMatByRanksInPlace(self, *args, **kwargs):
    return self.getDriftList().evalDriftMatByRanksInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftMatByRanksInPlace', evalDriftMatByRanksInPlace)

def evalDriftMatByTargetInPlace(self, *args, **kwargs):
    return self.getDriftList().evalDriftMatByTargetInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftMatByTargetInPlace', evalDriftMatByTargetInPlace)

def getNDrift(self, *args, **kwargs):
    return self.getDriftList().getNDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'getNDrift', getNDrift)

def getNDriftEquation(self, *args, **kwargs):
    return self.getDriftList().getNDriftEquation(*args, **kwargs)

setattr(gl.ModelGeneric, 'getNDriftEquation', getNDriftEquation)

def getNExtDrift(self, *args, **kwargs):
    return self.getDriftList().getNExtDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'getNExtDrift', getNExtDrift)

def isFlagLinked(self, *args, **kwargs):
    return self.getDriftList().isFlagLinked(*args, **kwargs)

setattr(gl.ModelGeneric, 'isFlagLinked', isFlagLinked)

def getDriftMaxIRFOrder(self, *args, **kwargs):
    return self.getDriftList().getDriftMaxIRFOrder(*args, **kwargs)

setattr(gl.ModelGeneric, 'getDriftMaxIRFOrder', getDriftMaxIRFOrder)

def getRankFex(self, *args, **kwargs):
    return self.getDriftList().getRankFex(*args, **kwargs)

setattr(gl.ModelGeneric, 'getRankFex', getRankFex)

def isDriftSampleDefined(self, *args, **kwargs):
    return self.getDriftList().isDriftSampleDefined(*args, **kwargs)

setattr(gl.ModelGeneric, 'isDriftSampleDefined', isDriftSampleDefined)

def isDriftFiltered(self, *args, **kwargs):
    return self.getDriftList().isDriftFiltered(*args, **kwargs)

setattr(gl.ModelGeneric, 'isDriftFiltered', isDriftFiltered)

def isDriftDefined(self, *args, **kwargs):
    return self.getDriftList().isDriftDefined(*args, **kwargs)

setattr(gl.ModelGeneric, 'isDriftDefined', isDriftDefined)

def isDriftDifferentDefined(self, *args, **kwargs):
    return self.getDriftList().isDriftDifferentDefined(*args, **kwargs)

setattr(gl.ModelGeneric, 'isDriftDifferentDefined', isDriftDifferentDefined)

def getDrifts(self, *args, **kwargs):
    return self.getDriftList().getDrifts(*args, **kwargs)

setattr(gl.ModelGeneric, 'getDrifts', getDrifts)

def evalDrift(self, *args, **kwargs):
    return self.getDriftList().evalDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDrift', evalDrift)

def evalDriftBySample(self, *args, **kwargs):
    return self.getDriftList().evalDriftBySample(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftBySample', evalDriftBySample)

def evalDriftBySampleInPlace(self, *args, **kwargs):
    return self.getDriftList().evalDriftBySampleInPlace(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftBySampleInPlace', evalDriftBySampleInPlace)

def evalDriftCoef(self, *args, **kwargs):
    return self.getDriftList().evalDriftCoef(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftCoef', evalDriftCoef)

def hasDrift(self, *args, **kwargs):
    return self.getDriftList().hasDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'hasDrift', hasDrift)

def getMean(self, *args, **kwargs):
    return self.getDriftList().getMean(*args, **kwargs)

setattr(gl.ModelGeneric, 'getMean', getMean)

def getMeans(self, *args, **kwargs):
    return self.getDriftList().getMeans(*args, **kwargs)

setattr(gl.ModelGeneric, 'getMeans', getMeans)

def evalDriftVarCoef(self, *args, **kwargs):
    return self.getDriftList().evalDriftVarCoef(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftVarCoef', evalDriftVarCoef)

def evalDriftVarCoefs(self, *args, **kwargs):
    return self.getDriftList().evalDriftVarCoefs(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalDriftVarCoefs', evalDriftVarCoefs)

def getNVar(self, *args, **kwargs):
    return self.getContext().getNVar(*args, **kwargs)

setattr(gl.ModelGeneric, 'getNVar', getNVar)

def getNDim(self, *args, **kwargs):
    return self.getContext().getNDim(*args, **kwargs)

setattr(gl.ModelGeneric, 'getNDim', getNDim)

def getSpace(self, *args, **kwargs):
    return self.getContext().getSpace(*args, **kwargs)

setattr(gl.ModelGeneric, 'getSpace', getSpace)

def getCovar0(self, *args, **kwargs):
    return self.getContext().getCovar0(*args, **kwargs)

setattr(gl.ModelGeneric, 'getCovar0', getCovar0)

def getField(self, *args, **kwargs):
    return self.getContext().getField(*args, **kwargs)

setattr(gl.ModelGeneric, 'getField', getField)


import gstlearn as gl

def setFitSills(self, *args, **kwargs):
    return self.getCovList().setFitSills(*args, **kwargs)

setattr(gl.ModelCovList, 'setFitSills', setFitSills)

def deleteFitSills(self, *args, **kwargs):
    return self.getCovList().deleteFitSills(*args, **kwargs)

setattr(gl.ModelCovList, 'deleteFitSills', deleteFitSills)

def getNCov(self, *args, **kwargs):
    return self.getCovList().getNCov(*args, **kwargs)

setattr(gl.ModelCovList, 'getNCov', getNCov)

def getSills(self, *args, **kwargs):
    return self.getCovList().getSills(*args, **kwargs)

setattr(gl.ModelCovList, 'getSills', getSills)

def getSill(self, *args, **kwargs):
    return self.getCovList().getSill(*args, **kwargs)

setattr(gl.ModelCovList, 'getSill', getSill)

def getTotalSill(self, *args, **kwargs):
    return self.getCovList().getTotalSill(*args, **kwargs)

setattr(gl.ModelCovList, 'getTotalSill', getTotalSill)

def getTotalSills(self, *args, **kwargs):
    return self.getCovList().getTotalSills(*args, **kwargs)

setattr(gl.ModelCovList, 'getTotalSills', getTotalSills)

def isAllActiveCovList(self, *args, **kwargs):
    return self.getCovList().isAllActiveCovList(*args, **kwargs)

setattr(gl.ModelCovList, 'isAllActiveCovList', isAllActiveCovList)

def getFitSills(self, *args, **kwargs):
    return self.getCovList().getFitSills(*args, **kwargs)

setattr(gl.ModelCovList, 'getFitSills', getFitSills)


import gstlearn as gl

def getActiveFactor(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getActiveFactor(*args, **kwargs)

setattr(gl.Model, 'getActiveFactor', getActiveFactor)

def getCovAniso(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getCovAniso(*args, **kwargs)

setattr(gl.Model, 'getCovAniso', getCovAniso)

def getNCov(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getNCov(*args, **kwargs)

setattr(gl.Model, 'getNCov', getNCov)

def getCovType(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getCovType(*args, **kwargs)

setattr(gl.Model, 'getCovType', getCovType)

def getRange(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getRange(*args, **kwargs)

setattr(gl.Model, 'getRange', getRange)

def getRanges(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getRanges(*args, **kwargs)

setattr(gl.Model, 'getRanges', getRanges)

def getAngles(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getAngles(*args, **kwargs)

setattr(gl.Model, 'getAngles', getAngles)

def getAnam(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getAnam(*args, **kwargs)

setattr(gl.Model, 'getAnam', getAnam)

def getParam(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getParam(*args, **kwargs)

setattr(gl.Model, 'getParam', getParam)

def getCovName(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getCovName(*args, **kwargs)

setattr(gl.Model, 'getCovName', getCovName)

def extractCova(self, *args, **kwargs):
    return self.castInCovAnisoListConst().extractCova(*args, **kwargs)

setattr(gl.Model, 'extractCova', extractCova)

def getNGradParam(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getNGradParam(*args, **kwargs)

setattr(gl.Model, 'getNGradParam', getNGradParam)

def getMaximumDistance(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getMaximumDistance(*args, **kwargs)

setattr(gl.Model, 'getMaximumDistance', getMaximumDistance)

def getCovMinIRFOrder(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getCovMinIRFOrder(*args, **kwargs)

setattr(gl.Model, 'getCovMinIRFOrder', getCovMinIRFOrder)

def getAnamNClass(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getAnamNClass(*args, **kwargs)

setattr(gl.Model, 'getAnamNClass', getAnamNClass)

def hasAnam(self, *args, **kwargs):
    return self.castInCovAnisoListConst().hasAnam(*args, **kwargs)

setattr(gl.Model, 'hasAnam', hasAnam)

def hasNugget(self, *args, **kwargs):
    return self.castInCovAnisoListConst().hasNugget(*args, **kwargs)

setattr(gl.Model, 'hasNugget', hasNugget)

def getRankNugget(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getRankNugget(*args, **kwargs)

setattr(gl.Model, 'getRankNugget', getRankNugget)

def getBallRadius(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getBallRadius(*args, **kwargs)

setattr(gl.Model, 'getBallRadius', getBallRadius)

def hasExternalCov(self, *args, **kwargs):
    return self.castInCovAnisoListConst().hasExternalCov(*args, **kwargs)

setattr(gl.Model, 'hasExternalCov', hasExternalCov)

def isChangeSupportDefined(self, *args, **kwargs):
    return self.castInCovAnisoListConst().isChangeSupportDefined(*args, **kwargs)

setattr(gl.Model, 'isChangeSupportDefined', isChangeSupportDefined)

def getAnamHermite(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getAnamHermite(*args, **kwargs)

setattr(gl.Model, 'getAnamHermite', getAnamHermite)

def getCovMode(self, *args, **kwargs):
    return self.castInCovAnisoListConst().getCovMode(*args, **kwargs)

setattr(gl.Model, 'getCovMode', getCovMode)

def evalZAndGradients(self, *args, **kwargs):
    return self.castInCovLMGradientConst().evalZAndGradients(*args, **kwargs)

setattr(gl.Model, 'evalZAndGradients', evalZAndGradients)


import gstlearn as gl

def getScaleIso(self, *args, **kwargs):
    return self.getCorAniso().getScaleIso(*args, **kwargs)

setattr(gl.CovAniso, 'getScaleIso', getScaleIso)

def getScale(self, *args, **kwargs):
    return self.getCorAniso().getScale(*args, **kwargs)

setattr(gl.CovAniso, 'getScale', getScale)

def isValidForTurningBand(self, *args, **kwargs):
    return self.getCorAniso().isValidForTurningBand(*args, **kwargs)

setattr(gl.CovAniso, 'isValidForTurningBand', isValidForTurningBand)

def simulateTurningBand(self, *args, **kwargs):
    return self.getCorAniso().simulateTurningBand(*args, **kwargs)

setattr(gl.CovAniso, 'simulateTurningBand', simulateTurningBand)

def isValidForSpectral(self, *args, **kwargs):
    return self.getCorAniso().isValidForSpectral(*args, **kwargs)

setattr(gl.CovAniso, 'isValidForSpectral', isValidForSpectral)

def simulateSpectralOmega(self, *args, **kwargs):
    return self.getCorAniso().simulateSpectralOmega(*args, **kwargs)

setattr(gl.CovAniso, 'simulateSpectralOmega', simulateSpectralOmega)

def getRanges(self, *args, **kwargs):
    return self.getCorAniso().getRanges(*args, **kwargs)

setattr(gl.CovAniso, 'getRanges', getRanges)

def getScales(self, *args, **kwargs):
    return self.getCorAniso().getScales(*args, **kwargs)

setattr(gl.CovAniso, 'getScales', getScales)

def getRangeIso(self, *args, **kwargs):
    return self.getCorAniso().getRangeIso(*args, **kwargs)

setattr(gl.CovAniso, 'getRangeIso', getRangeIso)

def getRange(self, *args, **kwargs):
    return self.getCorAniso().getRange(*args, **kwargs)

setattr(gl.CovAniso, 'getRange', getRange)

def getAnisoCoeffs(self, *args, **kwargs):
    return self.getCorAniso().getAnisoCoeffs(*args, **kwargs)

setattr(gl.CovAniso, 'getAnisoCoeffs', getAnisoCoeffs)

def getType(self, *args, **kwargs):
    return self.getCorAniso().getType(*args, **kwargs)

setattr(gl.CovAniso, 'getType', getType)

def getParam(self, *args, **kwargs):
    return self.getCorAniso().getParam(*args, **kwargs)

setattr(gl.CovAniso, 'getParam', getParam)

def getScadef(self, *args, **kwargs):
    return self.getCorAniso().getScadef(*args, **kwargs)

setattr(gl.CovAniso, 'getScadef', getScadef)

def getParMax(self, *args, **kwargs):
    return self.getCorAniso().getParMax(*args, **kwargs)

setattr(gl.CovAniso, 'getParMax', getParMax)

def getMaxNDim(self, *args, **kwargs):
    return self.getCorAniso().getMaxNDim(*args, **kwargs)

setattr(gl.CovAniso, 'getMaxNDim', getMaxNDim)

def getMinOrder(self, *args, **kwargs):
    return self.getCorAniso().getMinOrder(*args, **kwargs)

setattr(gl.CovAniso, 'getMinOrder', getMinOrder)

def hasInt1D(self, *args, **kwargs):
    return self.getCorAniso().hasInt1D(*args, **kwargs)

setattr(gl.CovAniso, 'hasInt1D', hasInt1D)

def hasInt2D(self, *args, **kwargs):
    return self.getCorAniso().hasInt2D(*args, **kwargs)

setattr(gl.CovAniso, 'hasInt2D', hasInt2D)

def hasRange(self, *args, **kwargs):
    return self.getCorAniso().hasRange(*args, **kwargs)

setattr(gl.CovAniso, 'hasRange', hasRange)

def hasParam(self, *args, **kwargs):
    return self.getCorAniso().hasParam(*args, **kwargs)

setattr(gl.CovAniso, 'hasParam', hasParam)

def getNGradParam(self, *args, **kwargs):
    return self.getCorAniso().getNGradParam(*args, **kwargs)

setattr(gl.CovAniso, 'getNGradParam', getNGradParam)

def hasCovDerivative(self, *args, **kwargs):
    return self.getCorAniso().hasCovDerivative(*args, **kwargs)

setattr(gl.CovAniso, 'hasCovDerivative', hasCovDerivative)

def hasCovOnSphere(self, *args, **kwargs):
    return self.getCorAniso().hasCovOnSphere(*args, **kwargs)

setattr(gl.CovAniso, 'hasCovOnSphere', hasCovOnSphere)

def hasSpectrumOnSphere(self, *args, **kwargs):
    return self.getCorAniso().hasSpectrumOnSphere(*args, **kwargs)

setattr(gl.CovAniso, 'hasSpectrumOnSphere', hasSpectrumOnSphere)

def hasMarkovCoeffs(self, *args, **kwargs):
    return self.getCorAniso().hasMarkovCoeffs(*args, **kwargs)

setattr(gl.CovAniso, 'hasMarkovCoeffs', hasMarkovCoeffs)

def hasSpectrumOnRn(self, *args, **kwargs):
    return self.getCorAniso().hasSpectrumOnRn(*args, **kwargs)

setattr(gl.CovAniso, 'hasSpectrumOnRn', hasSpectrumOnRn)

def normalizeOnSphere(self, *args, **kwargs):
    return self.getCorAniso().normalizeOnSphere(*args, **kwargs)

setattr(gl.CovAniso, 'normalizeOnSphere', normalizeOnSphere)

def getMarkovCoeffs(self, *args, **kwargs):
    return self.getCorAniso().getMarkovCoeffs(*args, **kwargs)

setattr(gl.CovAniso, 'getMarkovCoeffs', getMarkovCoeffs)

def getCorrec(self, *args, **kwargs):
    return self.getCorAniso().getCorrec(*args, **kwargs)

setattr(gl.CovAniso, 'getCorrec', getCorrec)

def getFullCorrec(self, *args, **kwargs):
    return self.getCorAniso().getFullCorrec(*args, **kwargs)

setattr(gl.CovAniso, 'getFullCorrec', getFullCorrec)

def isNoStatForParam(self, *args, **kwargs):
    return self.getCorAniso().isNoStatForParam(*args, **kwargs)

setattr(gl.CovAniso, 'isNoStatForParam', isNoStatForParam)

def isNoStatForTensor(self, *args, **kwargs):
    return self.getCorAniso().isNoStatForTensor(*args, **kwargs)

setattr(gl.CovAniso, 'isNoStatForTensor', isNoStatForTensor)

def isNoStatForAnisotropy(self, *args, **kwargs):
    return self.getCorAniso().isNoStatForAnisotropy(*args, **kwargs)

setattr(gl.CovAniso, 'isNoStatForAnisotropy', isNoStatForAnisotropy)

def isNoStatForRotation(self, *args, **kwargs):
    return self.getCorAniso().isNoStatForRotation(*args, **kwargs)

setattr(gl.CovAniso, 'isNoStatForRotation', isNoStatForRotation)

def getNAngles(self, *args, **kwargs):
    return self.getCorAniso().getNAngles(*args, **kwargs)

setattr(gl.CovAniso, 'getNAngles', getNAngles)

def getNRanges(self, *args, **kwargs):
    return self.getCorAniso().getNRanges(*args, **kwargs)

setattr(gl.CovAniso, 'getNRanges', getNRanges)

def getNScales(self, *args, **kwargs):
    return self.getCorAniso().getNScales(*args, **kwargs)

setattr(gl.CovAniso, 'getNScales', getNScales)

def getDetTensor(self, *args, **kwargs):
    return self.getCorAniso().getDetTensor(*args, **kwargs)

setattr(gl.CovAniso, 'getDetTensor', getDetTensor)


import gstlearn as gl

def setOptimEnabled(self, *args, **kwargs):
    return self.getCov().setOptimEnabled(*args, **kwargs)

setattr(gl.ModelGeneric, 'setOptimEnabled', setOptimEnabled)

def attachNoStatDb(self, *args, **kwargs):
    return self.getCov().attachNoStatDb(*args, **kwargs)

setattr(gl.ModelGeneric, 'attachNoStatDb', attachNoStatDb)

def makeStationary(self, *args, **kwargs):
    return self.getCov().makeStationary(*args, **kwargs)

setattr(gl.ModelGeneric, 'makeStationary', makeStationary)

def setContext(self, *args, **kwargs):
    return self._getCovModify().setContext(*args, **kwargs)

setattr(gl.ModelGeneric, 'setContext', setContext)

def evalCovGrad(self, *args, **kwargs):
    return self._getCovModify().evalCovGrad(*args, **kwargs)

setattr(gl.ModelGeneric, 'evalCovGrad', evalCovGrad)

def setFlagLinked(self, *args, **kwargs):
    return self._getDriftListModify().setFlagLinked(*args, **kwargs)

setattr(gl.ModelGeneric, 'setFlagLinked', setFlagLinked)

def setBetaHat(self, *args, **kwargs):
    return self._getDriftListModify().setBetaHat(*args, **kwargs)

setattr(gl.ModelGeneric, 'setBetaHat', setBetaHat)

def setFiltered(self, *args, **kwargs):
    return self._getDriftListModify().setFiltered(*args, **kwargs)

setattr(gl.ModelGeneric, 'setFiltered', setFiltered)

def delDrift(self, *args, **kwargs):
    return self._getDriftListModify().delDrift(*args, **kwargs)

setattr(gl.ModelGeneric, 'delDrift', delDrift)

def delAllDrifts(self, *args, **kwargs):
    return self._getDriftListModify().delAllDrifts(*args, **kwargs)

setattr(gl.ModelGeneric, 'delAllDrifts', delAllDrifts)

def copyCovContext(self, *args, **kwargs):
    return self._getDriftListModify().copyCovContext(*args, **kwargs)

setattr(gl.ModelGeneric, 'copyCovContext', copyCovContext)

def setMeans(self, *args, **kwargs):
    return self._getDriftListModify().setMeans(*args, **kwargs)

setattr(gl.ModelGeneric, 'setMeans', setMeans)

def setMean(self, *args, **kwargs):
    return self._getDriftListModify().setMean(*args, **kwargs)

setattr(gl.ModelGeneric, 'setMean', setMean)

def setField(self, *args, **kwargs):
    return self._getContextModify().setField(*args, **kwargs)

setattr(gl.ModelGeneric, 'setField', setField)

def setCovar0s(self, *args, **kwargs):
    return self._getContextModify().setCovar0s(*args, **kwargs)

setattr(gl.ModelGeneric, 'setCovar0s', setCovar0s)

def setCovar0(self, *args, **kwargs):
    return self._getContextModify().setCovar0(*args, **kwargs)

setattr(gl.ModelGeneric, 'setCovar0', setCovar0)


import gstlearn as gl

def delCov(self, *args, **kwargs):
    return self.getCovListModify().delCov(*args, **kwargs)

setattr(gl.ModelCovList, 'delCov', delCov)

def delAllCov(self, *args, **kwargs):
    return self.getCovListModify().delAllCov(*args, **kwargs)

setattr(gl.ModelCovList, 'delAllCov', delAllCov)

def setCovFiltered(self, *args, **kwargs):
    return self.getCovListModify().setCovFiltered(*args, **kwargs)

setattr(gl.ModelCovList, 'setCovFiltered', setCovFiltered)

def makeSillNoStatDb(self, *args, **kwargs):
    return self.getCovListModify().makeSillNoStatDb(*args, **kwargs)

setattr(gl.ModelCovList, 'makeSillNoStatDb', makeSillNoStatDb)

def makeSillStationary(self, *args, **kwargs):
    return self.getCovListModify().makeSillStationary(*args, **kwargs)

setattr(gl.ModelCovList, 'makeSillStationary', makeSillStationary)

def makeSillsStationary(self, *args, **kwargs):
    return self.getCovListModify().makeSillsStationary(*args, **kwargs)

setattr(gl.ModelCovList, 'makeSillsStationary', makeSillsStationary)

def makeSillNoStatFunctional(self, *args, **kwargs):
    return self.getCovListModify().makeSillNoStatFunctional(*args, **kwargs)

setattr(gl.ModelCovList, 'makeSillNoStatFunctional', makeSillNoStatFunctional)

def setSill(self, *args, **kwargs):
    return self.getCovListModify().setSill(*args, **kwargs)

setattr(gl.ModelCovList, 'setSill', setSill)

def setSills(self, *args, **kwargs):
    return self.getCovListModify().setSills(*args, **kwargs)

setattr(gl.ModelCovList, 'setSills', setSills)

def normalize(self, *args, **kwargs):
    return self.getCovListModify().normalize(*args, **kwargs)

setattr(gl.ModelCovList, 'normalize', normalize)


import gstlearn as gl

def setActiveFactor(self, *args, **kwargs):
    return self._castInCovAnisoList().setActiveFactor(*args, **kwargs)

setattr(gl.Model, 'setActiveFactor', setActiveFactor)

def getCovAniso(self, *args, **kwargs):
    return self._castInCovAnisoList().getCovAniso(*args, **kwargs)

setattr(gl.Model, 'getCovAniso', getCovAniso)

def setRangeIsotropic(self, *args, **kwargs):
    return self._castInCovAnisoList().setRangeIsotropic(*args, **kwargs)

setattr(gl.Model, 'setRangeIsotropic', setRangeIsotropic)

def setMarkovCoeffs(self, *args, **kwargs):
    return self._castInCovAnisoList().setMarkovCoeffs(*args, **kwargs)

setattr(gl.Model, 'setMarkovCoeffs', setMarkovCoeffs)

def makeRangeNoStatDb(self, *args, **kwargs):
    return self._castInCovAnisoList().makeRangeNoStatDb(*args, **kwargs)

setattr(gl.Model, 'makeRangeNoStatDb', makeRangeNoStatDb)

def makeScaleNoStatDb(self, *args, **kwargs):
    return self._castInCovAnisoList().makeScaleNoStatDb(*args, **kwargs)

setattr(gl.Model, 'makeScaleNoStatDb', makeScaleNoStatDb)

def makeAngleNoStatDb(self, *args, **kwargs):
    return self._castInCovAnisoList().makeAngleNoStatDb(*args, **kwargs)

setattr(gl.Model, 'makeAngleNoStatDb', makeAngleNoStatDb)

def makeTensorNoStatDb(self, *args, **kwargs):
    return self._castInCovAnisoList().makeTensorNoStatDb(*args, **kwargs)

setattr(gl.Model, 'makeTensorNoStatDb', makeTensorNoStatDb)

def makeParamNoStatDb(self, *args, **kwargs):
    return self._castInCovAnisoList().makeParamNoStatDb(*args, **kwargs)

setattr(gl.Model, 'makeParamNoStatDb', makeParamNoStatDb)

def makeRangeNoStatFunctional(self, *args, **kwargs):
    return self._castInCovAnisoList().makeRangeNoStatFunctional(*args, **kwargs)

setattr(gl.Model, 'makeRangeNoStatFunctional', makeRangeNoStatFunctional)

def makeScaleNoStatFunctional(self, *args, **kwargs):
    return self._castInCovAnisoList().makeScaleNoStatFunctional(*args, **kwargs)

setattr(gl.Model, 'makeScaleNoStatFunctional', makeScaleNoStatFunctional)

def makeAngleNoStatFunctional(self, *args, **kwargs):
    return self._castInCovAnisoList().makeAngleNoStatFunctional(*args, **kwargs)

setattr(gl.Model, 'makeAngleNoStatFunctional', makeAngleNoStatFunctional)

def makeTensorNoStatFunctional(self, *args, **kwargs):
    return self._castInCovAnisoList().makeTensorNoStatFunctional(*args, **kwargs)

setattr(gl.Model, 'makeTensorNoStatFunctional', makeTensorNoStatFunctional)

def makeParamNoStatFunctional(self, *args, **kwargs):
    return self._castInCovAnisoList().makeParamNoStatFunctional(*args, **kwargs)

setattr(gl.Model, 'makeParamNoStatFunctional', makeParamNoStatFunctional)

def makeRangeStationary(self, *args, **kwargs):
    return self._castInCovAnisoList().makeRangeStationary(*args, **kwargs)

setattr(gl.Model, 'makeRangeStationary', makeRangeStationary)

def makeScaleStationary(self, *args, **kwargs):
    return self._castInCovAnisoList().makeScaleStationary(*args, **kwargs)

setattr(gl.Model, 'makeScaleStationary', makeScaleStationary)

def makeAngleStationary(self, *args, **kwargs):
    return self._castInCovAnisoList().makeAngleStationary(*args, **kwargs)

setattr(gl.Model, 'makeAngleStationary', makeAngleStationary)

def makeTensorStationary(self, *args, **kwargs):
    return self._castInCovAnisoList().makeTensorStationary(*args, **kwargs)

setattr(gl.Model, 'makeTensorStationary', makeTensorStationary)

def makeParamStationary(self, *args, **kwargs):
    return self._castInCovAnisoList().makeParamStationary(*args, **kwargs)

setattr(gl.Model, 'makeParamStationary', makeParamStationary)

def setTapeRange(self, *args, **kwargs):
    return self._castInCovLMCTapering().setTapeRange(*args, **kwargs)

setattr(gl.Model, 'setTapeRange', setTapeRange)


import gstlearn as gl

def setParam(self, *args, **kwargs):
    return self.getCorAniso().setParam(*args, **kwargs)

setattr(gl.CovAniso, 'setParam', setParam)

def computeMarkovCoeffs(self, *args, **kwargs):
    return self.getCorAniso().computeMarkovCoeffs(*args, **kwargs)

setattr(gl.CovAniso, 'computeMarkovCoeffs', computeMarkovCoeffs)

def setRangeIsotropic(self, *args, **kwargs):
    return self.getCorAniso().setRangeIsotropic(*args, **kwargs)

setattr(gl.CovAniso, 'setRangeIsotropic', setRangeIsotropic)

def setRange(self, *args, **kwargs):
    return self.getCorAniso().setRange(*args, **kwargs)

setattr(gl.CovAniso, 'setRange', setRange)

def setRanges(self, *args, **kwargs):
    return self.getCorAniso().setRanges(*args, **kwargs)

setattr(gl.CovAniso, 'setRanges', setRanges)

def setScale(self, *args, **kwargs):
    return self.getCorAniso().setScale(*args, **kwargs)

setattr(gl.CovAniso, 'setScale', setScale)

def setScaleDim(self, *args, **kwargs):
    return self.getCorAniso().setScaleDim(*args, **kwargs)

setattr(gl.CovAniso, 'setScaleDim', setScaleDim)

def setScales(self, *args, **kwargs):
    return self.getCorAniso().setScales(*args, **kwargs)

setattr(gl.CovAniso, 'setScales', setScales)

def setAnisoRotationMat(self, *args, **kwargs):
    return self.getCorAniso().setAnisoRotationMat(*args, **kwargs)

setattr(gl.CovAniso, 'setAnisoRotationMat', setAnisoRotationMat)

def setAnisoRotation(self, *args, **kwargs):
    return self.getCorAniso().setAnisoRotation(*args, **kwargs)

setattr(gl.CovAniso, 'setAnisoRotation', setAnisoRotation)

def setAnisoAngles(self, *args, **kwargs):
    return self.getCorAniso().setAnisoAngles(*args, **kwargs)

setattr(gl.CovAniso, 'setAnisoAngles', setAnisoAngles)

def setAnisoAngle(self, *args, **kwargs):
    return self.getCorAniso().setAnisoAngle(*args, **kwargs)

setattr(gl.CovAniso, 'setAnisoAngle', setAnisoAngle)

def setRotationAnglesAndRadius(self, *args, **kwargs):
    return self.getCorAniso().setRotationAnglesAndRadius(*args, **kwargs)

setattr(gl.CovAniso, 'setRotationAnglesAndRadius', setRotationAnglesAndRadius)

def setType(self, *args, **kwargs):
    return self.getCorAniso().setType(*args, **kwargs)

setattr(gl.CovAniso, 'setType', setType)

def makeRangeNoStatDb(self, *args, **kwargs):
    return self.getCorAniso().makeRangeNoStatDb(*args, **kwargs)

setattr(gl.CovAniso, 'makeRangeNoStatDb', makeRangeNoStatDb)

def makeScaleNoStatDb(self, *args, **kwargs):
    return self.getCorAniso().makeScaleNoStatDb(*args, **kwargs)

setattr(gl.CovAniso, 'makeScaleNoStatDb', makeScaleNoStatDb)

def makeAngleNoStatDb(self, *args, **kwargs):
    return self.getCorAniso().makeAngleNoStatDb(*args, **kwargs)

setattr(gl.CovAniso, 'makeAngleNoStatDb', makeAngleNoStatDb)

def makeTensorNoStatDb(self, *args, **kwargs):
    return self.getCorAniso().makeTensorNoStatDb(*args, **kwargs)

setattr(gl.CovAniso, 'makeTensorNoStatDb', makeTensorNoStatDb)

def makeParamNoStatDb(self, *args, **kwargs):
    return self.getCorAniso().makeParamNoStatDb(*args, **kwargs)

setattr(gl.CovAniso, 'makeParamNoStatDb', makeParamNoStatDb)

def makeRangeNoStatFunctional(self, *args, **kwargs):
    return self.getCorAniso().makeRangeNoStatFunctional(*args, **kwargs)

setattr(gl.CovAniso, 'makeRangeNoStatFunctional', makeRangeNoStatFunctional)

def makeScaleNoStatFunctional(self, *args, **kwargs):
    return self.getCorAniso().makeScaleNoStatFunctional(*args, **kwargs)

setattr(gl.CovAniso, 'makeScaleNoStatFunctional', makeScaleNoStatFunctional)

def makeAngleNoStatFunctional(self, *args, **kwargs):
    return self.getCorAniso().makeAngleNoStatFunctional(*args, **kwargs)

setattr(gl.CovAniso, 'makeAngleNoStatFunctional', makeAngleNoStatFunctional)

def makeTensorNoStatFunctional(self, *args, **kwargs):
    return self.getCorAniso().makeTensorNoStatFunctional(*args, **kwargs)

setattr(gl.CovAniso, 'makeTensorNoStatFunctional', makeTensorNoStatFunctional)

def makeParamNoStatFunctional(self, *args, **kwargs):
    return self.getCorAniso().makeParamNoStatFunctional(*args, **kwargs)

setattr(gl.CovAniso, 'makeParamNoStatFunctional', makeParamNoStatFunctional)

def makeRangeStationary(self, *args, **kwargs):
    return self.getCorAniso().makeRangeStationary(*args, **kwargs)

setattr(gl.CovAniso, 'makeRangeStationary', makeRangeStationary)

def makeScaleStationary(self, *args, **kwargs):
    return self.getCorAniso().makeScaleStationary(*args, **kwargs)

setattr(gl.CovAniso, 'makeScaleStationary', makeScaleStationary)

def makeAngleStationary(self, *args, **kwargs):
    return self.getCorAniso().makeAngleStationary(*args, **kwargs)

setattr(gl.CovAniso, 'makeAngleStationary', makeAngleStationary)

def makeTensorStationary(self, *args, **kwargs):
    return self.getCorAniso().makeTensorStationary(*args, **kwargs)

setattr(gl.CovAniso, 'makeTensorStationary', makeTensorStationary)

def makeParamStationary(self, *args, **kwargs):
    return self.getCorAniso().makeParamStationary(*args, **kwargs)

setattr(gl.CovAniso, 'makeParamStationary', makeParamStationary)

def setMarkovCoeffs(self, *args, **kwargs):
    return self.getCorAniso().setMarkovCoeffs(*args, **kwargs)

setattr(gl.CovAniso, 'setMarkovCoeffs', setMarkovCoeffs)

def setMarkovCoeffsBySquaredPolynomials(self, *args, **kwargs):
    return self.getCorAniso().setMarkovCoeffsBySquaredPolynomials(*args, **kwargs)

setattr(gl.CovAniso, 'setMarkovCoeffsBySquaredPolynomials', setMarkovCoeffsBySquaredPolynomials)

def informDbInForAnisotropy(self, *args, **kwargs):
    return self.getCorAniso().informDbInForAnisotropy(*args, **kwargs)

setattr(gl.CovAniso, 'informDbInForAnisotropy', informDbInForAnisotropy)

def informDbOutForAnisotropy(self, *args, **kwargs):
    return self.getCorAniso().informDbOutForAnisotropy(*args, **kwargs)

setattr(gl.CovAniso, 'informDbOutForAnisotropy', informDbOutForAnisotropy)

def informMeshByMeshForAnisotropy(self, *args, **kwargs):
    return self.getCorAniso().informMeshByMeshForAnisotropy(*args, **kwargs)

setattr(gl.CovAniso, 'informMeshByMeshForAnisotropy', informMeshByMeshForAnisotropy)

def informMeshByApexForAnisotropy(self, *args, **kwargs):
    return self.getCorAniso().informMeshByApexForAnisotropy(*args, **kwargs)

setattr(gl.CovAniso, 'informMeshByApexForAnisotropy', informMeshByApexForAnisotropy)

def computeCorrec(self, *args, **kwargs):
    return self.getCorAniso().computeCorrec(*args, **kwargs)

setattr(gl.CovAniso, 'computeCorrec', computeCorrec)



import gstlearn as gl
import numpy as np
import os
import sys

## Version and authors
from gstlearn.version import __version__
from gstlearn.version import __author__

## Numpy default integer type could be different according the OS (int64 or int32)
## https://stackoverflow.com/questions/36278590/numpy-array-dtype-is-coming-as-int32-by-default-in-a-windows-10-64-bit-machine
## Remind that there is no standard NaN for integers in Python
## We cannot use std::numeric_limits<int>::quiet_NaN() in C++
## But we can use the minimum signed integer value as follow

import os
## Integer NaN custom value
if os.name == 'nt':         # Windows
  inan = -2147483648
else:                       # Others
  inan = -sys.maxsize - 1

## isNaN custom function
def isNaN(value):
  if (type(value).__module__ == np.__name__): # Numpy type
    if (np.dtype(value) == 'intc' or np.dtype(value) == 'int64' or np.dtype(value) == 'int32'):
      return value == gl.inan
  else:
    if (type(value).__name__ == 'int'):
      return value == gl.inan
  return np.isnan(value)


## Add operator [] to VectorXXX R class [1-based index] ##
## ---------------------------------------------------- ##

def setitem(self, idx, item):
  if idx < 0 or idx >= self.length():
    raise IndexError("Index out or range")
  self.setAt(idx,item)

def getitem(self, idx):
  if idx < 0 or idx >= self.length():
    raise IndexError("Index out or range")
  return self.getAt(idx)

setattr(gl.VectorDouble,       "__getitem__", getitem)
setattr(gl.VectorDouble,       "__setitem__", setitem)
setattr(gl.VectorInt,          "__getitem__", getitem)
setattr(gl.VectorInt,          "__setitem__", setitem)
setattr(gl.VectorString,       "__getitem__", getitem)
setattr(gl.VectorString,       "__setitem__", setitem)
setattr(gl.VectorFloat,        "__getitem__", getitem)
setattr(gl.VectorFloat,        "__setitem__", setitem)
setattr(gl.VectorUChar,        "__getitem__", getitem)
setattr(gl.VectorUChar,        "__setitem__", setitem)
setattr(gl.VectorBool,         "__getitem__", getitem)
setattr(gl.VectorBool,         "__setitem__", setitem)
setattr(gl.VectorVectorDouble, "__getitem__", getitem)
setattr(gl.VectorVectorDouble, "__setitem__", setitem)
setattr(gl.VectorVectorInt,    "__getitem__", getitem)
setattr(gl.VectorVectorInt,    "__setitem__", setitem)
setattr(gl.VectorVectorFloat,  "__getitem__", getitem)
setattr(gl.VectorVectorFloat,  "__setitem__", setitem)

## Override operator [] for the Db class ##
## ------------------------------------- ##
# Thanks to Nicolas Desassis:

def is_list_type(mylist, types):
    """Check if an input is an iterable (tuple, list or numpy array) containing
       elements of only a given type"""
    all_type = True
    if not(isinstance(mylist,(tuple, list, np.ndarray))):
        all_type = False
    i = 0
    while all_type and i<len(mylist):
        if not(isinstance(mylist[i], types)):
               all_type = False
        i += 1
    return all_type

def check_nrows(db, nrows):
    """Check if a number of rows matches with the number of samples of a Db, 
    and returns the flag for useSel (whether it matches the number of active 
    samples or the total number of samples)"""
    if nrows == db.getNSampleActive() :
        useSel = True
    elif nrows == db.getNSample() or db.getNSample()==0:
        useSel = False
    else:
        if db.getNSampleActive() != db.getNSample():
            raise ValueError("Error of dimension. Your number of lines ("+str(nrows)+") has to be equal to " +
                str(db.getNSampleActive()) + " or " + str(db.getNSample()))
        else :
            raise ValueError("Error of dimension. Your number of lines ("+str(nrows)+") has to be equal to " +
                  str(db.getNSampleActive()))
    return useSel

def findColumnNames(self, columns):
    """Extract names of columns from Db, given different possible types of arguments: 
        names, indices, or locator"""
    if isinstance(columns, str) or is_list_type(columns, (str, np.str_)): #get variable(s) by name
        names = self.identifyNames(np.atleast_1d(columns))

    elif isinstance(columns, (int, np.int_)):
        names = self.getNameByColIdx(columns)

    elif isinstance(columns, slice):
        Nmax = self.getNColumn()
        names = []
        for i in range(Nmax)[columns]:
            names.append(self.getNameByColIdx(i))

    elif is_list_type(columns, (int, np.int_)):
        names = []
        Nfields = self.getNColumn()
        for i in columns:
            if i >= Nfields:
                print("Warning: the index {} is out of bounds with {}, this index is ignored".format(i,Nfields))
            else:
                names.append(self.getNameByColIdx(int(i)))

    else:
        raise ValueError("Argument for columns of wrong type: {}".format(type(columns)))

    return np.atleast_1d(names)

def has_row_selection(self, arg):
    """Check if the argument given contains a rows selection [rows,columns], 
    or only column selection [columns].
    If the argument is a tuple of length 2 and its first element is a valid argument
    for indexing rows, then the function returns True."""
    valid_row_indexing = False
    if isinstance(arg, tuple) and len(arg)==2:
        array_test = np.zeros(getNrows(self))
        try: # test if first element of tuple is a valid argument for indexing rows. If yes, then we assume it is the argument for rows.
            array_test[arg[0],]
            valid_row_indexing = True
        except IndexError:
            valid_row_indexing = False
    return valid_row_indexing

def getNrows(self, useSel=None):
    """ get number of rows of the Db when using or not a selection"""
    if useSel is None:
        useSel = self.useSel
    nrows = self.getNSample(useSel)
    return nrows

def getdbitem(self,arg):
    """
    Extract data from a Db. Use Db[arg]

    Parameters
    ----------
    arg is (rows, columns) or columns
    rows : (optional) int, list of int, or slice. Which rows (samples) to extract.
    columns: str or list of str. Names of the variables to extract.
             int, list of int, or slice. Indices of the variables to extract.
             gstlearn.ELoc. Locator of the variables to extract.

    Returns
    -------
    numpy.ndarray
        2D array of shape (nrows, nvars) of the extracted data.
    Examples
    --------
    db["var"] or db[:,"var"] extracts the variable named "var"
    db[5:10,(2,3)] extracts the rows 5 to 9 of the variables of index 2 and 3 (array of shape (5,2))
    db[gl.ELoc.Z] extracts all the variables located with Z.
    """
    nrows = getNrows(self)

    selec_rows = has_row_selection(self, arg)
    if selec_rows:
        rows = arg[0]
        columns = arg[1]
    else:
        rows = slice(None,None,None) # extract all rows
        columns = arg

# extract columns
    ColNames = findColumnNames(self, columns)
    nbvar = len(ColNames)
    temp = np.array(self.getColumns(ColNames, self.useSel))
    temp = temp.reshape([nbvar,nrows]).T

# extract rows
    temp = temp[rows,]
    if len(temp.shape) == 2:
      if temp.shape[1] == 1:
        return temp[:,0]

    return temp

# This function will add a set of vectors (as a numpy array) to a db. 
# If some of the names exist, the corresponding variables will be replaced 
# and not added.

def setdbitem(self,name,tab):

# analyze input arguments
    selec_rows = has_row_selection(self, name)   
    if selec_rows:
        rows = name[0]
        columns = name[1]
    else:
        columns = name

# find existing column names
    arr_columns = np.atleast_1d(columns)
    ColNames = findColumnNames(self, columns) #existing names

# analyze input table
    if isinstance(tab, (float, np.floating, int, np.integer, bool, np.bool_)):
        nrows = getNrows(self)
        nvars = len(ColNames) # this means we will only modify existing columns, not create ones
        tab = np.ones((nrows, nvars))*tab
        if selec_rows:
            tab = np.atleast_2d(tab[rows,:])
    else:
        tab = np.copy(np.float64(tab))
        if len(tab.shape) == 1:
            tab = np.atleast_2d(tab).T
        nrows, nvars = tab.shape

# create list of column names to modify and/or create
    if len(ColNames) == nvars: # modify existing variables only
        new_names = ColNames

    elif len(arr_columns) == nvars and is_list_type(arr_columns, (str,np.str_)):
        new_names = arr_columns

    elif isinstance(columns, (str,np.str_)) and nvars > 1 and len(ColNames)==0: # create new variables from a unique name
        new_names = gl.generateMultipleNames(columns, nvars)

    else:
        raise ValueError("Wrong type or length of input ({0}): the input should correspond"
                         " either to a number of existing variables ({1}) equal to the"
                         " number of columns of the table (nvar={2}), or should be a name or "
                         "list of names of length nvar={2} in order to create new variables.".format(columns, len(ColNames), nvars))

# loop on the column names to modify/create each column
    for i,name in enumerate(new_names):
# check if existing name
        ExistingNames = findColumnNames(self, name)
        if len(ExistingNames) > 1:
            raise ValueError("There is more than one variable name corresponding to '{}' "
                             "in the Db: {}".format(name, ExistingNames))

        if selec_rows:
            useSel = self.useSel
            if len(ExistingNames) == 0: # create new variable
                nrows_tot = getNrows(self, useSel)
                tab_i = np.empty(nrows_tot)
                tab_i.fill(np.nan) # NaNs outside of target rows
            elif len(ExistingNames) == 1: # modify existing variable
                tab_i = self[name]

            tab_i = np.squeeze(tab_i)
            tab_i[rows,] = tab[:,i]

        else:
            useSel = check_nrows(self,nrows)
            tab_i = np.empty(nrows)
            tab_i[:] = tab[:,i]

        tab_i[np.isnan(tab_i)] = np.nan
        VectD = np.double(tab_i)
        self.setColumn(VectD.tolist(), name, gl.ELoc.UNKNOWN, 0, useSel)

    return

setattr(gl.Db,"useSel",False)    

setattr(gl.Db,"__getitem__",getdbitem)
setattr(gl.Db,"__setitem__",setdbitem)

def Vector_toTL(self):
  return np.array(self)

setattr(gl.VectorDouble, "toTL", Vector_toTL)
setattr(gl.VectorInt, "toTL", Vector_toTL)

def VectorVector_toTL(self):
  retvec = []
  for vec in self:
    retvec.append(np.array(vec))
  return (retvec)

setattr(gl.VectorVectorDouble, "toTL", VectorVector_toTL)

try:
    from .conv import *
except ModuleNotFoundError:
    pass



