# coding: utf-8

"""
    Companies

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: v3
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import io
import json
import time
import logging
import re
import ssl
import asyncio
from functools import wraps
from typing import Callable, Awaitable, ParamSpec, TypeVar

# python 2 and python 3 compatibility library
import six
from six.moves.urllib.parse import urlencode
import urllib3


logger = logging.getLogger(__name__)

P = ParamSpec("P")
T = TypeVar("T")

rpm_limit_config = {
    "last_request_time": time.time() - 0.1,
    "rpm_limit": 600,
}

def configure(rpm_limit: int):
    rpm_limit_config["rpm_limit"] = rpm_limit

def rpm_limit_cls_async(class_method: Callable[P, Awaitable[T]]) -> Callable[P, Awaitable[T]]:
    """
    Decorator that limits the number of requests per minute to the decorated class methods
    Decorated method must have 'self' as it's first arg.
    :param rpm_limit: maximum number of requests per minute. If <= 0, then no limit is imposed
    """
    @wraps(class_method)
    async def wrapper(self, *args, **kwargs):
        if rpm_limit_config["rpm_limit"] <= 0:
            return await class_method(self, *args, **kwargs)
        
        while True:
            if time.time() - rpm_limit_config["last_request_time"] < 60 / rpm_limit_config["rpm_limit"]:
                diff = 60 / rpm_limit_config["rpm_limit"] - (time.time() - rpm_limit_config["last_request_time"])
                await asyncio.sleep(diff)
                continue
            
            rpm_limit_config["last_request_time"] = time.time()
            return await class_method(self, *args, **kwargs)
    return wrapper


def get_rest_response():
    class RESTResponse(io.IOBase):
        def __init__(self, resp: urllib3.AsyncHTTPResponse):
            self.urllib3_response = resp
            self.status = resp.status
            self.reason = resp.reason
            self.data = resp.data

        def getheaders(self):
            """Returns a dictionary of the response headers."""
            return self.urllib3_response.getheaders()

        def getheader(self, name, default=None):
            """Returns a given response header."""
            return self.urllib3_response.getheader(name, default)

    return RESTResponse

def get_rest_client(ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError, RESTResponse):
    class RESTClientObject(object):
        def __init__(self, configuration, pools_size=4, maxsize=None):
            # urllib3.PoolManager will pass all kw parameters to connectionpool
            # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
            # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
            # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
            # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

            # cert_reqs
            if configuration.verify_ssl:
                cert_reqs = ssl.CERT_REQUIRED
            else:
                cert_reqs = ssl.CERT_NONE

            addition_pool_args = {}
            if configuration.assert_hostname is not None:
                addition_pool_args["assert_hostname"] = configuration.assert_hostname  # noqa: E501

            if configuration.retries is not None:
                addition_pool_args["retries"] = configuration.retries

            if configuration.socket_options is not None:
                addition_pool_args["socket_options"] = configuration.socket_options

            if maxsize is None:
                if configuration.connection_pool_maxsize is not None:
                    maxsize = configuration.connection_pool_maxsize
                else:
                    maxsize = 4

            # https pool manager
            if configuration.proxy:
                self.pool_manager = urllib3.AsyncProxyManager(
                    num_pools=pools_size,
                    maxsize=maxsize,
                    cert_reqs=cert_reqs,
                    ca_certs=configuration.ssl_ca_cert,
                    cert_file=configuration.cert_file,
                    key_file=configuration.key_file,
                    proxy_url=configuration.proxy,
                    proxy_headers=configuration.proxy_headers,
                    **addition_pool_args
                )
            else:
                self.pool_manager = urllib3.AsyncPoolManager(
                    num_pools=pools_size, maxsize=maxsize, cert_reqs=cert_reqs, ca_certs=configuration.ssl_ca_cert, cert_file=configuration.cert_file, key_file=configuration.key_file, **addition_pool_args
                )

        @rpm_limit_cls_async
        async def request(self, method, url, query_params=None, headers=None, body=None, post_params=None, _preload_content=True, _request_timeout=None) -> urllib3.AsyncHTTPResponse:
            """Perform requests.

            :param method: http request method
            :param url: http request url
            :param query_params: query parameters in the url
            :param headers: http request headers
            :param body: request json body, for `application/json`
            :param post_params: request post parameters,
                                `application/x-www-form-urlencoded`
                                and `multipart/form-data`
            :param _preload_content: if False, the urllib3.HTTPResponse object will
                                    be returned without reading/decoding response
                                    data. Default is True.
            :param _request_timeout: timeout setting for this request. If one
                                    number provided, it will be total request
                                    timeout. It can also be a pair (tuple) of
                                    (connection, read) timeouts.
            """
            method = method.upper()
            assert method in ["GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"]

            if post_params and body:
                raise ApiValueError("body parameter cannot be used with post_params parameter.")

            post_params = post_params or {}
            headers = headers or {}

            timeout = None
            if _request_timeout:
                if isinstance(_request_timeout, six.integer_types + (float,)):  # noqa: E501,F821
                    timeout = urllib3.Timeout(total=_request_timeout)
                elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:
                    timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])

            if "Content-Type" not in headers:
                headers["Content-Type"] = "application/json"

            try:
                # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
                if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
                    if query_params:
                        url += "?" + urlencode(query_params)
                    if re.search("json", headers["Content-Type"], re.IGNORECASE):
                        request_body = None
                        if body is not None:
                            request_body = json.dumps(body)
                        r = await self.pool_manager.request(method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)
                    elif headers["Content-Type"] == "application/x-www-form-urlencoded":  # noqa: E501
                        r = await self.pool_manager.request(method, url, fields=post_params, encode_multipart=False, preload_content=_preload_content, timeout=timeout, headers=headers)
                    elif headers["Content-Type"] == "multipart/form-data":
                        # must del headers['Content-Type'], or the correct
                        # Content-Type which generated by urllib3 will be
                        # overwritten.
                        del headers["Content-Type"]
                        r = await self.pool_manager.request(method, url, fields=post_params, encode_multipart=True, preload_content=_preload_content, timeout=timeout, headers=headers)
                    # Pass a `string` parameter directly in the body to support
                    # other content types than Json when `body` argument is
                    # provided in serialized form
                    elif isinstance(body, str) or isinstance(body, bytes):
                        request_body = body
                        r = await self.pool_manager.request(method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)
                    else:
                        # Cannot generate the request from given parameters
                        msg = """Cannot prepare a request message for provided
                                arguments. Please check that your arguments match
                                declared content type."""
                        raise ApiException(status=0, reason=msg)
                # For `GET`, `HEAD`
                else:
                    r = await self.pool_manager.request(method, url, fields=query_params, preload_content=_preload_content, timeout=timeout, headers=headers)
            except urllib3.exceptions.SSLError as e:
                msg = "{0}\n{1}".format(type(e).__name__, str(e))
                raise ApiException(status=0, reason=msg)
            
            r = RESTResponse(r)
            r.data = await r.data

            if not 200 <= r.status <= 299:
                if r.status == 401:
                    raise UnauthorizedException(http_resp=r)

                if r.status == 403:
                    raise ForbiddenException(http_resp=r)

                if r.status == 404:
                    raise NotFoundException(http_resp=r)

                if 500 <= r.status <= 599:
                    raise ServiceException(http_resp=r)

                raise ApiException(http_resp=r)

            return r

        async def GET(self, url, headers=None, query_params=None, _preload_content=True, _request_timeout=None):
            return await self.request("GET", url, headers=headers, _preload_content=_preload_content, _request_timeout=_request_timeout, query_params=query_params)

        async def HEAD(self, url, headers=None, query_params=None, _preload_content=True, _request_timeout=None):
            return await self.request("HEAD", url, headers=headers, _preload_content=_preload_content, _request_timeout=_request_timeout, query_params=query_params)

        async def OPTIONS(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
            return await self.request("OPTIONS", url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

        async def DELETE(self, url, headers=None, query_params=None, body=None, _preload_content=True, _request_timeout=None):
            return await self.request("DELETE", url, headers=headers, query_params=query_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

        async def POST(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
            return await self.request("POST", url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

        async def PUT(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
            return await self.request("PUT", url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

        async def PATCH(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
            return await self.request("PATCH", url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

    return RESTClientObject
