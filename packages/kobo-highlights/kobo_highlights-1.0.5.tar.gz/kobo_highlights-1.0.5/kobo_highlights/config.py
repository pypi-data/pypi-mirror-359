"""This module contains the definition of the `Config` object used to store the
program configuration and the `ConfigError` exception raised when the configuration
can not be read.

* Config: Class that holds the configuration of the program. It is based on pydantic
to ensure a correct structure and facilitate parsing. It used as a singleton in the
program but this behavior is not enforced.


* ConfigError: Simple exception that is raised when a `Config` constructor is called
but a valid `Config` object can't be created.
"""

# Imports:
from __future__ import annotations
from pathlib import Path

from pydantic import BaseModel, ValidationError
from rich.prompt import Prompt
from rich.table import Table
import toml

from kobo_highlights.console import console


# Definitions
class Config(BaseModel, extra="forbid"):
    """
    Config: Class that holds the configuration of the program. It is based on pydantic
    to ensure a correct structure and facilitate parsing. It used as a singleton in the
    program but this behavior is not enforced.

    Class Methods:

        from_file(): Constructor that builds a `Config` object from a config file.

        create_interactively(): Constructor that builds a `Config` object by asking
        the user interactively.

    Methods:

        save_file(): Save the configuration in a config file.

        __rich__(): Method that defines how rich would print `Config` objects.

    Attributes:

        target_dir (pathlib.Path): Directory where the markdown documents will be created.

        ereader_dir (pathlib.Path): Path where the ereader is mounted.
    """

    target_dir: Path
    ereader_dir: Path

    @classmethod
    def from_file(cls, config_path: Path) -> Config:
        """Constructor that builds a `Config` object from a config file. The config
        file must be a toml file with the keys `target_dir` and `ereader_dir` and values
        corresponding to absolute paths.

        A valid config file is generated by the method `save_file()`.

        Args:
            config_path (Path): Path to the config file that will be used to build
            the `Config` object.

        Raises:
            ConfigError: If the `Config` object can't be created because either the
            config file was not found, or it could not be parsed, a `ConfigError`
            exception will be raised.

        Returns:
            Config: `Config` object representing the config file.
        """
        try:
            return cls.model_validate(toml.load(config_path))

        except FileNotFoundError:
            raise ConfigError(f"No config file was found in: {config_path}")

        except (toml.TomlDecodeError, TypeError):
            raise ConfigError(f"The config file {config_path} is not a valid toml file")

        except ValidationError:
            raise ConfigError(
                f"The config file {config_path} is not a valid configuration file"
            )

    @classmethod
    def create_interactively(cls) -> Config:
        """Constructor that builds a `Config` object by asking the user interactively.
        It will ask for values for `target_dir` and `ereader_dir` and check that they
        are absolute paths before creating the `Config` object.

        Returns:
            Config: `Config` object representing the config file.
        """
        while True:
            ereader_input: str = Prompt.ask(
                "Please enter the absolute path where your [bold]ereader[/] is"
                " mounted",
                console=console,
            )

            target_input: str = Prompt.ask(
                "Please enter the absolute path to the [bold]target directory[/]"
                " where the highlights will be exported",
                console=console,
            )

            try:
                ereader_dir, target_dir = Path(ereader_input), Path(target_input)

            except TypeError:  # User input cannot be converted into path
                console.print("[prompt.invalid]The inputs entered are not paths")

            else:
                if ereader_dir.is_absolute() and target_dir.is_absolute():
                    config = cls(
                        target_dir=Path(target_input),
                        ereader_dir=Path(ereader_dir),
                    )

                    return config

                else:
                    console.print("[prompt.invalid]The paths entered are not absolute")

    def save_file(self, config_filepath: Path) -> Config:
        """Saves the configuration represented by a `Config` object in a toml config
        file. The config file is a toml file with the keys `target_dir` and
        `ereader_dir` and values corresponding to absolute paths.

        This config files can be used to create a config object with the class method
        `from_file()`.

        Args:
            config_filepath (Path): Path of the toml config file. If the file doesn't
            exist it will be created, if a file exists, its contents will be erased

        Returns:
            Config: `Config` object from which the method was called, to allow method
            cascading.
        """
        # Convert the path attributes to strings:
        toml_representation: dict[str, str] = {
            field: str(path) for field, path in self.model_dump().items()
        }

        config_filepath.parent.mkdir(parents=True, exist_ok=True)
        config_filepath.write_text(toml.dumps(toml_representation), encoding="utf-8")
        return self

    def __rich__(self) -> Table:
        """Required for rendering the config objects using Rich:
        https://rich.readthedocs.io/en/stable/protocol.html#console-customization
        """
        config_table = Table(box=None, show_header=False)

        config_table.add_row(
            "target_dir:",
            f"[cyan]{str(self.target_dir)}",
            "[bright_black]# Directory where your highlights will be exported ",
        )

        config_table.add_row(
            "ereader_dir:",
            f"[cyan]{str(self.ereader_dir)}",
            "[bright_black]# Directory where your ereader is mounted ",
        )
        return config_table


class ConfigError(Exception):
    """Simple exception that is raised when a `Config` constructor is called but a
    valid `Config` object can't be created.
    """

    def __init__(self, message: str):
        super().__init__(message)
