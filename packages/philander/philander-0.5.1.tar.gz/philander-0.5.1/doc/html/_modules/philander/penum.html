<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>philander.penum &#8212; philander 0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script src="../../_static/documentation_options.js?v=b489f392"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for philander.penum</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A light-weight replication of the Python 3.4 built-in Enum and Flag classes.</span>

<span class="sd">For portability, this is to support the MicroPython environments. While</span>
<span class="sd">functionality is drastically reduced, this implementation strives for</span>
<span class="sd">providing the most basic features of enums, flags and dataclasses.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Oliver Maye&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;dataclass&quot;</span><span class="p">,</span> <span class="s2">&quot;Enum&quot;</span><span class="p">,</span> <span class="s2">&quot;Flag&quot;</span><span class="p">,</span> <span class="s2">&quot;idiotypic&quot;</span><span class="p">,</span> <span class="s2">&quot;unique&quot;</span><span class="p">]</span>

<span class="n">_hasBuiltinEnums</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Flag</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">auto</span>
    <span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
    <span class="p">(</span><span class="n">Enum</span><span class="p">,</span> <span class="n">Flag</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">auto</span><span class="p">,</span> <span class="n">dataclass</span><span class="p">)</span>   <span class="c1"># suppress &quot;unused&quot; warning</span>
    <span class="n">_hasBuiltinEnums</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="n">_hasBuiltinEnums</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">if</span> <span class="ow">not</span> <span class="n">_hasBuiltinEnums</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">auto</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically assign the *next* value to an enum or flag.</span>

<span class="sd">        Note that there is no guarantee on the attribute order,</span>
<span class="sd">        meaning that the attributes are not necessarily assigned an</span>
<span class="sd">        auto value  in the order of their appearance.</span>
<span class="sd">        Thus, mixing explicit and auto assignments may lead to unexpected</span>
<span class="sd">        results violating the uniqueness of attribute values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="n">_hasBuiltinEnums</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">idiotypic</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span>

<span class="k">else</span><span class="p">:</span>
<div class="viewcode-block" id="idiotypic">
<a class="viewcode-back" href="../../philander.html#philander.penum.idiotypic">[docs]</a>
    <span class="k">def</span> <span class="nf">idiotypic</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Class decorator for idiotypic classes.</span>
<span class="sd">        </span>
<span class="sd">        Modifies each class attribute to be an instance of that class and to</span>
<span class="sd">        have an attribute ``key`` set to the name of that attribute as a</span>
<span class="sd">        string value as well as another attribute ``value`` set to the value</span>
<span class="sd">        originally given at the class definition. This feature is meant to</span>
<span class="sd">        be used with enums and flags.</span>
<span class="sd">        </span>
<span class="sd">        The technique of a decorator is used, because Micropython does not</span>
<span class="sd">        support metaclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enumerations</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                         <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">or</span> \
                                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">)</span> <span class="ow">or</span> \
                                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">)</span> <span class="p">)}</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_idiotypicDone</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># handle auto() and auto</span>
        <span class="n">next_value</span> <span class="o">=</span> <span class="mh">0x01</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">enumerations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="n">auto</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">auto</span><span class="p">:</span>
                <span class="n">enumerations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">next_value</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">Flag</span> <span class="p">):</span>
                <span class="n">next_value</span> <span class="o">=</span> <span class="n">next_value</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_value</span> <span class="o">=</span> <span class="n">next_value</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_enumerations</span> <span class="o">=</span> <span class="n">enumerations</span>
        <span class="c1"># make &quot;static&quot; instances of each enumeration object</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_instances</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">cls</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">enumerations</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># initialize static instances</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instances</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">instance</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">k</span> <span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">instance</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">enumerations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">instance</span> <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_idiotypicDone</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">cls</span></div>



<span class="k">if</span> <span class="ow">not</span> <span class="n">_hasBuiltinEnums</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Class decorator for unique enums.</span>
<span class="sd">        </span>
<span class="sd">        Checks the attributes of the decorated class to be assigned to</span>
<span class="sd">        unique values. If any two attributes are of equal value,</span>
<span class="sd">        raises an exception.</span>
<span class="sd">        </span>
<span class="sd">        :raise ValueError: If the class has two equal attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enumerations</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">))}</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">enumerations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">seen</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Uniqueness violated in class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> by duplicate attributes: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">seen</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="si">}</span><span class="s2"> are the same!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>    
        <span class="k">return</span> <span class="bp">cls</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">_hasBuiltinEnums</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dataclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dataclass decorator.</span>
<span class="sd">        </span>
<span class="sd">        Scan a class for data attributes, i.e. variables, not methods.</span>
<span class="sd">        Add a constructor to the class to create and initialize same-named</span>
<span class="sd">        instance attributes.</span>
<span class="sd">        Note that this constructor does not support positional arguments,</span>
<span class="sd">        but just keyword arguments. This is because the order of attributes</span>
<span class="sd">        retrieved cannot be guaranteed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attribs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">currcls</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">):</span>
            <span class="n">currclsattr</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">currcls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">))}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">currclsattr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1">#if not type(val) in (int, float, complex, bool, str, tuple, range, frozenset, bytes):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mutual defaults are not allowed. </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="n">attribs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">currclsattr</span> <span class="p">)</span>
    
        <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Do not allow positional arguments, as the order of attributes</span>
            <span class="c1"># cannot be guaranteed by __dict__</span>
            <span class="n">numArgs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numArgs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Positional arguments are not supported. </span><span class="si">{</span><span class="n">numArgs</span><span class="si">}</span><span class="s2"> were given!&quot;</span><span class="p">)</span>
            <span class="c1"># Overwrite key word arguments</span>
            <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pname</span> <span class="ow">in</span> <span class="n">attribs</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected keyword argument </span><span class="si">{</span><span class="n">pname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
        <span class="k">def</span> <span class="nf">_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Generates a string representation of this instance.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span>
            <span class="k">for</span> <span class="n">aname</span> <span class="ow">in</span> <span class="n">attribs</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">, &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aname</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">_constructor</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__str__</span>  <span class="o">=</span> <span class="n">_str</span>
        <span class="k">return</span> <span class="bp">cls</span>


<span class="k">if</span> <span class="ow">not</span> <span class="n">_hasBuiltinEnums</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Enum</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An enumeration base type.</span>
<span class="sd">        </span>
<span class="sd">        Provide the most basic properties of an enumeration type. So, enums</span>
<span class="sd">        have attributes with speaking names and - in principle - arbitrary</span>
<span class="sd">        values. However, most commonly the attributes have integer values.</span>
<span class="sd">        A class should be derived from this class to define such attributes.</span>
<span class="sd">        </span>
<span class="sd">        To make the attributes be of the same type as the class defining them,</span>
<span class="sd">        that class should be decorated as `idiotypic`.</span>
<span class="sd">        </span>
<span class="sd">        In order to ensure the enum attributes are unique, use the `unique`</span>
<span class="sd">        decorator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Constructor to create an enum instance.</span>
<span class="sd">            </span>
<span class="sd">            For idiotypic classes, a singleton implementation is imitated as</span>
<span class="sd">            follows: The ``value`` attribute of the created instance will be</span>
<span class="sd">            the same as the matching attribute&#39;s value.</span>
<span class="sd">            An exception is raised if the given value is different from the</span>
<span class="sd">            values defined by the attributes.</span>
<span class="sd">            </span>
<span class="sd">            :param int value: The value of this enum item. Should be unique.</span>
<span class="sd">            :raise ValueError: If the given value does not match any of the enum values.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;_idiotypicDone&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_idiotypicDone</span><span class="p">:</span>
                <span class="c1"># make sure the passed in value is a valid enumeration value</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_enumerations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> is not a valid </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># save the actual enumeration value</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_enumerations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;item_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;item_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
    
        <span class="c1"># @classmethod</span>
        <span class="c1"># def __str__(cls):</span>
        <span class="c1">#     return f&#39;&lt;enum \&#39;{cls.__name__}\&#39;&gt;&#39;</span>
        
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_enumerations</span><span class="p">)</span>
    
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_instances</span><span class="p">)</span>
    
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instances</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> 
            <span class="k">return</span> <span class="n">item</span>
    
    <span class="c1">#     def __getattribute__(cls, key):</span>
    <span class="c1">#         if key.startswith(&#39;_&#39;):</span>
    <span class="c1">#             return object.__getattribute__(cls, key)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             return cls(object.__getattribute__(cls, &#39;_enumerations&#39;)[key])</span>
    <span class="c1">#</span>
    <span class="c1">#     def __contains__(cls, other):</span>
    <span class="c1">#         if type(other) == cls:</span>
    <span class="c1">#             return True</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             return False</span>
    
    
        <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The less-than operator. Called for the &#39;&lt;&#39; comparison.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The less-or-equal operator. Called for the &#39;&lt;=&#39; comparison.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The equals operator. Called for the &#39;==&#39; comparison.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
            
        <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The not-equal operator. Called for the &#39;!=&#39; comparison.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The greater-than operator. Called for the &#39;&gt;&#39; comparison.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The greater-or-equal operator. Called for the &#39;&gt;=&#39; comparison.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span> <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">issubclass</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Hash function to support ``hash()`` and operations with sets, dictionaries etc.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Generates a string representation of this instance.</span>
<span class="sd">            </span>
<span class="sd">            Called e.g. for printing.</span>
<span class="sd">    </span>
<span class="sd">            :return: A string describing the content of this instance.</span>
<span class="sd">            :rtype: str</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise AND operator. Called for the &#39;&amp;&#39; operation.</span>
<span class="sd">            </span>
<span class="sd">            Note that the result of a binary operation of two Enums is a plain</span>
<span class="sd">            integer and not an Enum! Typically, this result is beyond the range</span>
<span class="sd">            of the attributes defined.</span>
<span class="sd">            This kind of logic is provided just for convenience.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise OR operator. Called for the &#39;|&#39; operation.</span>
<span class="sd">            </span>
<span class="sd">            Note that the result of a binary operation of two Enums is a plain</span>
<span class="sd">            integer and not an Enum! Typically, this result is beyond the range</span>
<span class="sd">            of the attributes defined.</span>
<span class="sd">            This kind of logic is provided just for convenience.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">|</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise XOR operator. Called for the &#39;^&#39; operation.</span>
<span class="sd">            </span>
<span class="sd">            Note that the result of a binary operation of two Enums is a plain</span>
<span class="sd">            integer and not an Enum! Typically, this result is beyond the range</span>
<span class="sd">            of the attributes defined.</span>
<span class="sd">            This kind of logic is provided just for convenience.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">^</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">^</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise NOT operator. Called for the &#39;~&#39; operation.</span>
<span class="sd">            </span>
<span class="sd">            Note that the result of a binary operation of two Enums is a plain</span>
<span class="sd">            integer and not an Enum! Typically, this result is beyond the range</span>
<span class="sd">            of the attributes defined.</span>
<span class="sd">            This kind of logic is provided just for convenience.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">if</span> <span class="ow">not</span> <span class="n">_hasBuiltinEnums</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Flag</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A base class for flag types.</span>
<span class="sd">    </span>
<span class="sd">        As with enums, flag attributes have speaking names while their values</span>
<span class="sd">        are assumed to be integer bit masks.</span>
<span class="sd">        A class should be derived from this class to define such attributes.</span>
<span class="sd">        </span>
<span class="sd">        To make the attributes be of the same type as the class defining them,</span>
<span class="sd">        that class should be decorated as `idiotypic`.</span>
<span class="sd">        </span>
<span class="sd">        In order to ensure the attributes are unique, use the `unique`</span>
<span class="sd">        decorator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Construct a flag instance.</span>
<span class="sd">            </span>
<span class="sd">            For idiotypic classes, a singleton implementation is imitated as</span>
<span class="sd">            follows: The ``value`` attribute of the created instance will be</span>
<span class="sd">            the same as the matching attribute&#39;s value. The ``key`` attribute</span>
<span class="sd">            is copied from that attribute.</span>
<span class="sd">            </span>
<span class="sd">            :param int value: The value of this flag item, interpreted as a bit mask.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;_idiotypicDone&quot;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_idiotypicDone</span> <span class="ow">and</span> \
                <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_enumerations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_enumerations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;item_</span><span class="si">%04x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;item_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
    
        <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise AND operator. Called for the &#39;&amp;&#39; operation.</span>
<span class="sd">    </span>
<span class="sd">            :returns: A same-type object representing the conjunction of this and the given object.</span>
<span class="sd">            :rtype: Subclass of Flag</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Flag</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise OR operator. Called for the &#39;|&#39; operation.</span>
<span class="sd">    </span>
<span class="sd">            :returns: A same-type object representing the disjunction of this and the given object.</span>
<span class="sd">            :rtype: Subclass of Flag</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Flag</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">|</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise XOR operator. Called for the &#39;^&#39; operation.</span>
<span class="sd">    </span>
<span class="sd">            :returns: A same-type object representing the exclusive-or of this and the given object.</span>
<span class="sd">            :rtype: Subclass of Flag</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Flag</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">^</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">^</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
        <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; The bitwise NOT operator. Called for the &#39;~&#39; operation.</span>
<span class="sd">    </span>
<span class="sd">            :returns: A same-type object representing the negation this object&#39;s value.</span>
<span class="sd">            :rtype: Subclass of Flag</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Determine the truth value of this instance.</span>
<span class="sd">    </span>
<span class="sd">            :returns: True, if the value field has no bit flag set, False otherwise.</span>
<span class="sd">            :rtype: bool</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">philander</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">philander</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023-2024, Oliver Maye.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>