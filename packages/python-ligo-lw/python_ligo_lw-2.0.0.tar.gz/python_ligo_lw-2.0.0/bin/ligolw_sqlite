#!/usr/bin/python3
#
# Copyright (C) 2007--2014,2016,2017  Kipp Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Transfer table data between LIGO Light Weight XML files and SQLite
databases.
"""


from optparse import OptionParser
import os
import sqlite3
import sys


from lal.utils.cache import CacheEntry
import ligolw
from ligolw import __author__, __date__, __version__
import ligolw.dbtables
from ligolw.utils import ligolw_sqlite


__author__ = "Kipp Cannon <kipp@g.ecc.u-tokyo.ac.jp>"


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	"""
	Parse the command line, return an options object and a list of file
	names.
	"""
	parser = OptionParser(
		version = "Name: %%prog\n%s" % __version__,
		usage = "%prog -d|--database filename [options] [url ...]",
		description = "Transfers data between LIGO Light Weight XML files and SQLite database files.  The contents of the XML documents listed on the command line will be inserted, in order, into the SQLite database file identified by the --database argument.  If the database exists the contents of the XML documents will be added to it, otherwise a new database file is created.  If --extract is given on the command line, then the database contents will be converted to XML and written to the file named by this argument.  The input XML documents can be regular files or many common URLs such as ftp:// and http://.  If no input documents are named then input is read from stdin unless --extract is given in which case the datase contents are extracted to XML without reading any input documents.  Input XML documents ending in .gz will be gzip-decompressed while being read, and if the file named by --extract ends in .gz then it will be gzip-compressed when written."
	)
	parser.add_option("-d", "--database", metavar = "filename", help = "Set the name of the SQLite3 database file (required).")
	parser.add_option("-i", "--input-cache", metavar = "filename", action = "append", default = [], help = "Get the names of XML documents to insert into the database from this LAL cache.  This option can be given multiple times, and all files from all caches will be loaded.")
	parser.add_option("-p", "--preserve-ids", action = "store_true", help = "Preserve row IDs from the XML in the database.  The default is to assign new IDs to prevent collisisions.  Inserts will fail if collisions occur.")
	parser.add_option("-r", "--replace", action = "store_true", help = "If the database file already exists, over-write it instead of inserting into it.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	parser.add_option("-x", "--extract", metavar = "filename", default = None, help = "Extract database contents to the given XML file, \"-\" == stdout (use \"./-\" if you want to write to a file named \"-\").  Extraction is done after any inserts.")
	options, urls = parser.parse_args()

	urls += [CacheEntry(line).url for cache in options.input_cache for line in open(cache)]

	if not options.database:
		raise ValueError("missing required argument --database")

	return options, (urls or [None])


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Command line
#


options, urls = parse_command_line()

will_read_from_file = options.extract is not None
will_write_to_file = urls and not (will_read_from_file and urls == [None])
will_replace_file = will_write_to_file and options.replace
will_use_tmp_space = will_write_to_file and (options.tmp_space is not None)

if options.verbose:
	ligolw.set_verbose(True, application = "ligolw_sqlite")


#
# Open database
#


if will_read_from_file and not will_write_to_file and not os.path.exists(options.database):
	ligolw.logger.error("'%s': no such file" % options.database)
	sys.exit(1)

with ligolw.dbtables.workingcopy(options.database, tmp_path = options.tmp_space if will_use_tmp_space else None, replace_file = will_replace_file) as target:
	ligolw.dbtables.ContentHandler.connection = sqlite3.connect(str(target))
	target.set_temp_store_directory(ligolw.dbtables.ContentHandler.connection)


	#
	# Insert files
	#


	if will_write_to_file:
		for n, url in enumerate(urls, 1):
			ligolw.logger.info("%d/%d inserting '%s' ..." % (n, len(urls), url))
			if url.endswith(".sqlite"):
				# input is a database file
				with ligolw.dbtables.workingcopy(ligolw.utils.local_path_from_url(url), tmp_path = options.tmp_space, discard = True) as source_filename:
					ligolw.logger.info("connecting to '%s' ..." % str(source_filename))
					xmldoc = ligolw.dbtables.get_xml(sqlite3.connect(str(source_filename)))
					ligolw.logger.info("inserting into '%s' ..." % str(target))
					ligolw_sqlite.insert_from_xmldoc(ligolw.dbtables.ContentHandler.connection, xmldoc, preserve_ids = options.preserve_ids)
					xmldoc.unlink()
			else:
				# assume input is an xml file
				ligolw_sqlite.insert_from_url(url, contenthandler = ligolw.dbtables.ContentHandler, preserve_ids = options.preserve_ids)
			ligolw.logger.info("... inserting '%s' done." % url)
		ligolw.dbtables.build_indexes(ligolw.dbtables.ContentHandler.connection)


	#
	# Extract database contents
	#


	if will_read_from_file:
		ligolw.logger.info("extracting from '%s' ..." % str(target))
		if options.extract == "-":
			# stdout
			ligolw_sqlite.extract(ligolw.dbtables.ContentHandler.connection, None)
		else:
			ligolw_sqlite.extract(ligolw.dbtables.ContentHandler.connection, options.extract)
		ligolw.logger.info("... extracting from '%s' done." % str(target))


	#
	# Close database
	#


	ligolw.dbtables.ContentHandler.connection.close()


#
# Done
#


ligolw.logger.info("done.")
