window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "readabs", "modulename": "readabs", "kind": "module", "doc": "<p>Package to download timeseries data from \nthe Australian Bureau of Statistics (ABS) \nand the Reserve Bank of Australia (RBA).</p>\n"}, {"fullname": "readabs.metacol", "modulename": "readabs", "qualname": "metacol", "kind": "variable", "doc": "<p></p>\n", "default_value": "Metacol(did=&#x27;Data Item Description&#x27;, stype=&#x27;Series Type&#x27;, id=&#x27;Series ID&#x27;, start=&#x27;Series Start&#x27;, end=&#x27;Series End&#x27;, num=&#x27;No. Obs.&#x27;, unit=&#x27;Unit&#x27;, dtype=&#x27;Data Type&#x27;, freq=&#x27;Freq.&#x27;, cmonth=&#x27;Collection Month&#x27;, table=&#x27;Table&#x27;, tdesc=&#x27;Table Description&#x27;, cat=&#x27;Catalogue number&#x27;)"}, {"fullname": "readabs.read_abs_cat", "modulename": "readabs", "qualname": "read_abs_cat", "kind": "function", "doc": "<p>This function returns the complete ABS Catalogue information as a\npython dictionary of pandas DataFrames, as well as the associated metadata\nin a separate DataFrame. The function automates the collection of zip and\nexcel files from the ABS website. If necessary, these files are downloaded,\nand saved into a cache directory. The files are then parsed to extract time\nseries data, and the associated metadata.</p>\n\n<p>By default, the cache directory is <code>./.readabs_cache/</code>. You can change the\ndefault directory name by setting the shell environment variable\n<code>READABS_CACHE_DIR</code> with the name of the preferred directory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cat : str\n    The ABS Catalogue Number for the data to be downloaded and made\n    available by this function. This argument must be specified in the\n    function call.</p>\n\n<p>keep_non_ts : bool = False\n    A flag for whether to keep the non-time-series tables\n    that might form part of an ABS catalogue item. Normally, the\n    non-time-series information is ignored, and not made available to\n    the user.</p>\n\n<p>**kwargs : Any\n    The following parameters may be passed as optional keyword arguments.</p>\n\n<p>history : str = \"\"\n    Orovide a month-year string to extract historical ABS data.\n    For example, you can set history=\"dec-2023\" to the get the ABS data\n    for a catalogue identifier that was originally published in respect\n    of Q4 of 2023. Note: not all ABS data sources are structured so that\n    this technique works in every case; but most are.</p>\n\n<p>verbose : bool = False\n    Setting this to true may help diagnose why something\n    might be going wrong with the data retrieval process.</p>\n\n<p>ignore_errors : bool = False\n    Normally, this function will cease downloading when\n    an error in encountered. However, sometimes the ABS website has\n    malformed links, and changing this setting is necessitated. (Note:\n    if you drop a message to the ABS, they will usually fix broken\n    links with a business day).</p>\n\n<p>get_zip : bool = True\n    Download the excel files in .zip files.</p>\n\n<p>get_excel_if_no_zip : bool = True\n    Only try to download .xlsx files if there are no zip\n    files available to be downloaded. Only downloading individual excel\n    files when there are no zip files to download can speed up the\n    download process.</p>\n\n<p>get_excel : bool = False\n    The default value means that excel files are not\n    automatically download. Note: at least one of <code>get_zip</code>,\n    <code>get_excel_if_no_zip</code>, or <code>get_excel</code> must be true. For most ABS\n    catalogue items, it is sufficient to just download the one zip\n    file. But note, some catalogue items do not have a zip file.\n    Others have quite a number of zip files.</p>\n\n<p>single_excel_only : str = \"\"\n    If this argument is set to a table name (without the\n    .xlsx extension), only that excel file will be downloaded. If\n    set, and only a limited subset of available data is needed,\n    this can speed up download times significantly. Note: overrides\n    <code>get_zip</code>, <code>get_excel_if_no_zip</code>, <code>get_excel</code> and <code>single_zip_only</code>.</p>\n\n<p>single_zip_only : str = \"\"\n    If this argument is set to a zip file name (without\n    the .zip extension), only that zip file will be downloaded.\n    If set, and only a limited subset of available data is needed,\n    this can speed up download times significantly. Note: overrides\n    <code>get_zip</code>, <code>get_excel_if_no_zip</code>, and <code>get_excel</code>.</p>\n\n<p>cache_only : bool = False\n    If set to True, this function will only access\n    data that has been previously cached. Normally, the function\n    checks the date of the cache data against the date of the data\n    on the ABS website, before deciding whether the ABS has fresher\n    data that needs to be downloaded to the cache.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[dict[str, DataFrame], DataFrame]\n    The function returns a tuple of two items. The first item is a\n    python dictionary of pandas DataFrames (which is the primary data\n    associated with the ABS catalogue item). The second item is a\n    DataFrame of ABS metadata for the ABS collection.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">DataFrame</span><span class=\"p\">],</span> <span class=\"n\">DataFrame</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat</span><span class=\"o\">=</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">abs_dict</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cat</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">keep_non_ts</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">],</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_abs_series", "modulename": "readabs", "qualname": "read_abs_series", "kind": "function", "doc": "<p>Get specific ABS data series by their ABS catalogue and series identifiers.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cat : str\n    The ABS catalogue ID.</p>\n\n<p>series_id : str | Sequence[str]\n    An ABS series ID or a sequence of ABS series IDs.</p>\n\n<p>**kwargs : Any\n    Keyword arguments for the read_abs_series function,\n    which are the same as the keyword arguments for the\n    read_abs_cat function.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[DataFrame, DataFrame]\n    A tuple of two DataFrames, one for the primary data and one for the metadata.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">unemployment_rate</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;A84423050A&quot;</span>\n<span class=\"n\">seo</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202001&quot;</span>  <span class=\"c1\"># The ABS table name</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_series</span><span class=\"p\">(</span>\n    <span class=\"n\">cat</span><span class=\"o\">=</span><span class=\"n\">cat_num</span><span class=\"p\">,</span> <span class=\"n\">series_id</span><span class=\"o\">=</span><span class=\"n\">unemployment_rate</span><span class=\"p\">,</span> <span class=\"n\">single_excel_only</span><span class=\"o\">=</span><span class=\"n\">seo</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cat</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">series_id</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_abs_by_desc", "modulename": "readabs", "qualname": "read_abs_by_desc", "kind": "function", "doc": "<p>Get specific ABS data series by searching the ABS meta data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>wanted : list of str, dict of str:str, or dict of str:dict - the data\nitem descriptions to search for. If a list, it will be a list of\ndescriptions to search for. If a dictionary, the keys will a name.\nThe dixtionary values can be either a string (the data item\ndescription to search for) or a dictionary of keyword arguments, one of\nwhich would be the data item description to search for.</li>\n<li>kwargs : Any - keyword arguments to control the data retrieval.\nThe keyword arguments can include the following:\n<ul>\n<li>abs_dict : dict - the dictionary of ABS data to search (from\nread_abs_cat()).</li>\n<li>abs_meta : DataFrame - the metadata for the ABS data (from\nread_abs_cat()).</li>\n<li>for the retrieval of data, the \"cat\" argument must be present.\nThe following arguments, if present, will also be used (ie.\npassed to read_abs_cat()): [\"ignore_errors\", \"get_zip\",\n\"get_excel_if_no_zip\", \"get_excel\", \"cache_only\",\n\"single_excel_only\", \"single_zip_only\", \"verbose\"].</li>\n<li>for the selection of data, the following metacol names, if present,\nwill be used to construct the selector: \"cat\", \"did\"\n\"stype\", \"id\", \"start\", \"end\", \"num\", \"unit\", \"dtype\", \"freq\",\n\"cmonth\", \"table\", \"tdesc\".</li>\n<li>finally, the following arguments will be passed to the find_abs_id()\nand search_abs_meta() functions: [\"validate_unique\", \"exact_match\",\n\"regex\", \"verbose\"].</li>\n</ul></li>\n</ul>\n\n<p>Notes:</p>\n\n<ul>\n<li>if \"wanted\" is of type list[str] or dict[str, str], the kwargs should\ninclude sufficient keys from the metacol dataclass to get the data.\nTypically, the \"cat\" key, the \"table\" key, and the \"stype\" key would\nbe required. The did key would taken from the wanted list or\ndictionary.\nif wanted is of type dict[str, dict[str, Any]], the inner dictionary\nmust contain a \"did\" key. The other keys that can be used for the\ndata retrieval are the same as the metacol dataclass fileds, namely:\n\"cat\", \"stype\", \"id\", \"start\", \"end\", \"num\", \"unit\", \"dtype\", \"freq\",\n\"cmonth\", \"table\", \"tdesc\".</li>\n<li>if abs_dict and abs_meta are provided within the kwargs, they will be\nused to locate and extract the selected data.</li>\n<li>if abs_dict and abs_meta are not provided, then, (1) wanted must be of\ntype dict[str, dict[str, Any]] and (2) the inner dictionary must\ncontain a \"cat\" key so the data can be retrieved. Other keys that\ncan be used for the data retrieval are the same as for read_abs_cat(),\nnamely [\"ignore_errors\", \"get_zip\", \"get_excel_if_no_zip\",\n\"get_excel\", \"single_excel_only\", \"single_zip_only\", \"cache_only\"].</li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Returns a tuple of two items:</p>\n\n<ul>\n<li>A dictionary of pandas Series objects, where the keys are the series\ndescriptions. The series.name attribute will be the ABS series-id.</li>\n<li>A pandas DataFrame containing the metadata for the series.</li>\n</ul>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;5206.0&quot;</span>  <span class=\"c1\"># The ABS National Accounts</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat</span><span class=\"o\">=</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">wanted</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Gross domestic product: Chain volume measures ;&quot;</span><span class=\"p\">,]</span>\n<span class=\"n\">selected</span><span class=\"p\">,</span> <span class=\"n\">selected_meta</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_by_desc</span><span class=\"p\">(</span>\n    <span class=\"n\">wanted</span><span class=\"o\">=</span><span class=\"n\">wanted</span><span class=\"p\">,</span> <span class=\"n\">abs_dict</span><span class=\"o\">=</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">abs_meta</span><span class=\"o\">=</span><span class=\"n\">meta</span><span class=\"p\">,</span> <span class=\"n\">table</span><span class=\"o\">=</span><span class=\"s2\">&quot;5206001_Key_Aggregates&quot;</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">wanted</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">],</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.search_abs_meta", "modulename": "readabs", "qualname": "search_abs_meta", "kind": "function", "doc": "<p>Extract from the ABS meta data those rows that match the\nsearch_terms, by iteratively searching the meta data one\nsearch_term at a time.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>meta : DataFrame\n    A pandas DataFrame of metadata from the ABS\n    (via read_abs_cat() or read_abs_series()).\nsearch_terms : dict[str, str]\n    A dictionary {search_phrase: meta_column_name, ...} of search terms.\n    Note: the search terms must be unique, as a dictionary cannot hold the\n    same search term to be applied to different columns.\nexact_match : bool = False\n    Whether to match using == (exact) or .str.contains() (inexact).\nregex : bool = False\n    Whether to use regular expressions in the search.\nvalidate_unique : bool = False\n    Raise a ValueError if the search result is not unique.\n**kwargs : Any\n    Additional keyword arguments. The only keyword argument\n    that is used is verbose.\nverbose : bool = False\n    Print additional information while searching; which can\n    be useful when diagnosing problems with search terms.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    Returns a pandas DataFrame of matching rows (subseted from meta).\n    Note, The index for the returned meta data will always comprise ABS\n    series_ids. Duplicate indexes will be removed from the meta data\n    (ie. where the same ABS series appears in more than one table, this\n    function will only report the first match).</p>\n\n<h2 id=\"metacol\">Metacol</h2>\n\n<p>Because the meta data is a DataFrame, the columns can be referenced by either\ntheir full textual name, or by the short name defined in the metacol object.\nFor example, if metacol is imported as mc, to refer to the\n<code>Data Item Description</code> column, the user can refer to it as mc.did.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">metacol</span> <span class=\"k\">as</span> <span class=\"n\">mc</span>  <span class=\"c1\"># alias for the ABS meta data column names</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">,</span> <span class=\"n\">search_abs_meta</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">search_terms</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&quot;Unemployment rate&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">did</span><span class=\"p\">,</span>  <span class=\"c1\"># the data item description</span>\n    <span class=\"s2\">&quot;Persons&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">did</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;Seasonally Adjusted&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">stype</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;Percent&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">unit</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;6202001&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">table</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"n\">rows</span> <span class=\"o\">=</span> <span class=\"n\">search_abs_meta</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">,</span> <span class=\"n\">search_terms</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">rows</span><span class=\"p\">)</span>  <span class=\"c1\"># should have three rows : FT/PT/All Unemployment rates</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">meta</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">search_terms</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">exact_match</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">validate_unique</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.find_abs_id", "modulename": "readabs", "qualname": "find_abs_id", "kind": "function", "doc": "<p>Find a unique ABS series identifier in the ABS metadata.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>meta : DataFrame\n    A pandas DataFrame of metadata from the ABS\n    (via read_abs_cat() or read_abs_series()).\nsearch_terms : dict[str, str]\n    A dictionary {search_phrase: meta_column_name, ...} of search terms.\n    Note: the search terms must be unique, as a dictionary cannot hold the\n    same search term to be applied to different columns.\n**kwargs : Any\n    Additional keyword arguments. The only additional keyword argument\n    that is used is validate_unique.\nvalidate_unique : bool = True\n    Raise a ValueError if the search result is not a single\n    unique match. Note: the default is True for safety.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[str, str, str]\n    A tuple of the table, series_id and units for the unique\n    series_id that matches the search terms.</p>\n\n<h2 id=\"metacol\">Metacol</h2>\n\n<p>Because the meta data is a DataFrame, the columns can be referenced by either\ntheir full textual name, or by the short name defined in the metacol object.\nFor example, if metacol is imported as mc, to refer to the\n<code>Data Item Description</code> column, the user can refer to it as mc.did.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">metacol</span> <span class=\"k\">as</span> <span class=\"n\">mc</span>  <span class=\"c1\"># alias for the ABS meta data column names</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">,</span> <span class=\"n\">find_abs_id</span><span class=\"p\">,</span> <span class=\"n\">recalibrate</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">search_terms</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&quot;Employed total ;  Persons ;&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">did</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;Seasonally Adjusted&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">stype</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;6202001&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">table</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"n\">table</span><span class=\"p\">,</span> <span class=\"n\">series_id</span><span class=\"p\">,</span> <span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">find_abs_id</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">,</span> <span class=\"n\">search_terms</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Table: </span><span class=\"si\">{</span><span class=\"n\">table</span><span class=\"si\">}</span><span class=\"s2\"> Series ID: </span><span class=\"si\">{</span><span class=\"n\">series_id</span><span class=\"si\">}</span><span class=\"s2\"> Units: </span><span class=\"si\">{</span><span class=\"n\">units</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">recal_series</span><span class=\"p\">,</span> <span class=\"n\">recal_units</span> <span class=\"o\">=</span> <span class=\"n\">recalibrate</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">table</span><span class=\"p\">][</span><span class=\"n\">series_id</span><span class=\"p\">],</span> <span class=\"n\">units</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">meta</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">search_terms</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.grab_abs_url", "modulename": "readabs", "qualname": "grab_abs_url", "kind": "function", "doc": "<p>For a given URL, extract the data from the Excel and ZIP file\nlinks found on that page. The data is returned as a dictionary of\nDataFrames. The Excel files are converted into DataFrames, with\neach sheet in each Excel file becoming a separate DataFrame. ZIP\nfiles are examined for Excel files, which are similarly converted into\nDataFrames. The dictionary of DataFrames is returned.</p>\n\n<p>The preferred mechanism for reading ABS data is to use the <code>read_abs_cat()</code>\nor <code>read_abs_series()</code> functions. This function is provided for those\ncases where the data is not available in the ABS catalogue, where the\ndata is not a timeseries, or where the user wants to extract data from\na specific ABS landingpage.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>url : str = \"\"\n    A URL for an ABS Catalogue landing page. Either a url or\n    a catalogue number must be provided. If both are provided, the\n    URL will be used.</p>\n\n<p>**kwargs : Any\n    Accepts the same keyword arguments as <code>read_abs_cat()</code>. Additionally,\n    a cat argument can be provided, which will be used to get the URL\n    (see below).</p>\n\n<p>cat : str = \"\"\n    An ABS Catalogue number. If provided, and the URL is not\n    provided, then the Catalogue number will be used to get the URL.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict[str, DataFrame]\n    A dictionary of DataFrames.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">url</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.print_abs_catalogue", "modulename": "readabs", "qualname": "print_abs_catalogue", "kind": "function", "doc": "<p>This function prints to standard output a table of the ABS\nCatalogue Numbers that contain time-series data. In addition to the\nCatalogue Numbers, the table includes the theme, parent topic and\ntopic for the collection represented by each Catalogue Number.</p>\n\n<p>It is primarily a convenience function: The first parameter for\nthe read_abs_cat() and read_abs_series() functions is the ABS\nCatalogue Number from which data is sought.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"return-values\">Return values</h2>\n\n<p>The function does not return anything.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">print_abs_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.abs_catalogue", "modulename": "readabs", "qualname": "abs_catalogue", "kind": "function", "doc": "<p>Return a DataFrame of ABS Catalogue numbers. In the first instance,\nthis is downloaded from the ABS website, and cached for future use.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    A DataFrame of ABS Catalogue numbers.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">catalogue</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">abs_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.print_rba_catalogue", "modulename": "readabs", "qualname": "print_rba_catalogue", "kind": "function", "doc": "<p>This function prints to standard output a table of the RBA\nCatalogue Numbers.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"return-values\">Return values</h2>\n\n<p>The function does not return anything.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">print_rba_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.rba_catalogue", "modulename": "readabs", "qualname": "rba_catalogue", "kind": "function", "doc": "<p>Return a DataFrame of RBA Catalogue numbers. In the first instance,\nthis is downloaded from the RBA website, and cached for future use.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    A DataFrame of RBA Catalogue numbers.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">catalogue</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">rba_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_rba_table", "modulename": "readabs", "qualname": "read_rba_table", "kind": "function", "doc": "<p>Read a table from the RBA website and return the actual data\nand the meta data in a tuple of two DataFrames.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>table : str\n    The table to read from the RBA website.\n**kwargs : Any\n    Additional keyword arguments.\n    The only keyword argument that is used is ignore_errors.\nignore_errors : bool = False\n    If True, then any major errors encountered will be printed and the function\n    will return empty DataFrames. If False, then any major errors encountered\n    will raise an exception.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[DataFrame, DataFrame]\n    The primary data and the meta data in a tuple of two DataFrames.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">read_rba_table</span><span class=\"p\">(</span><span class=\"s2\">&quot;C1&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">table</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.rba_metacol", "modulename": "readabs", "qualname": "rba_metacol", "kind": "variable", "doc": "<p></p>\n", "default_value": "_RbaMetacol(title=&#x27;Title&#x27;, desc=&#x27;Description&#x27;, freq=&#x27;Frequency&#x27;, type=&#x27;Type&#x27;, unit=&#x27;Units&#x27;, src=&#x27;Source&#x27;, pub=&#x27;Publication date&#x27;, id=&#x27;Series ID&#x27;, table=&#x27;Table&#x27;, tdesc=&#x27;Table Description&#x27;)"}, {"fullname": "readabs.read_rba_ocr", "modulename": "readabs", "qualname": "read_rba_ocr", "kind": "function", "doc": "<p>Read the Official Cash Rate (OCR) from the RBA website and return it\nin a pandas Series, with either a daily or monthly PeriodIndex,\ndepending on the value of the monthly parameter. The default is monthly.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>monthly : bool = True\n    If True, then the data will be returned with a monthly PeriodIndex.\n    If False, then the data will be returned with a daily PeriodIndex.\n**kwargs : Any\n    Additional keyword arguments. The only keyword argument that is used is ignore_errors.\nignore_errors : bool = False\n    If True, then any major errors encountered will be printed and the function\n    will return an empty Series. If False, then any major errors encountered\n    will raise an exception.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Series\n    The OCR data in a pandas Series, with an index of either daily or monthly Periods.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">ocr</span> <span class=\"o\">=</span> <span class=\"n\">read_rba_ocr</span><span class=\"p\">(</span><span class=\"n\">monthly</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monthly</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.percent_change", "modulename": "readabs", "qualname": "percent_change", "kind": "function", "doc": "<p>Calculate an percentage change in a contiguous, ordered series over n_periods.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : pandas Series or DataFrame\n    The data to calculate the percentage change for.\nn_periods : int\n    The number of periods to calculate the percentage change over.\n    Typically 4 for quarterly data, and 12 for monthly data.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas Series or DataFrame\n    The percentage change in the data over n_periods. For DataFrame input,\n    the percentage change is calculated for each column.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>, </span><span class=\"param\"><span class=\"n\">n_periods</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">Datatype</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.annualise_rates", "modulename": "readabs", "qualname": "annualise_rates", "kind": "function", "doc": "<p>Annualise a growth rate for a period.\nNote: returns a percentage value (and not a rate)!</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : pandas Series or DataFrame\n    The growth rate to annualise. Note a growth rate of 0.05 is 5%.\nperiods_per_year : int or float, default 12\n    The number of periods in a year. For monthly data, this is 12.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas Series or DataFrame\n    The annualised growth expressed as a percentage (not a rate).\n    For DataFrame input, the annualised growth rate is calculated\n    for each column.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>, </span><span class=\"param\"><span class=\"n\">periods_per_year</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">12</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">Datatype</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.annualise_percentages", "modulename": "readabs", "qualname": "annualise_percentages", "kind": "function", "doc": "<p>Annualise a growth rate (expressed as a percentage) for a period.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : pandas Series or DataFrame\n    The growth rate (expresed as a percentage) to annualise. Note a\n    growth percentage of 5% is a growth rate of 0.05.\nperiods_per_year : int or float, default 12\n    The number of periods in a year. For monthly data, this is 12.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas Series or DataFrame\n    The annualised growth expressed as a percentage. For DataFrame input,\n    the annualised growth rate is calculated for each column.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>, </span><span class=\"param\"><span class=\"n\">periods_per_year</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">12</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">Datatype</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.qtly_to_monthly", "modulename": "readabs", "qualname": "qtly_to_monthly", "kind": "function", "doc": "<p>Convert a pandas timeseries with a Quarterly PeriodIndex to an\ntimeseries with a Monthly PeriodIndex.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data - either a pandas Series or DataFrame - assumes the index is unique.\n    The data to convert to monthly frequency.\ninterpolate: bool, default True\n    Whether to interpolate the missing monthly data.\nlimit: int, default 2\n    The maximum number of consecutive missing months to interpolate.\ndropna: bool, default True\n    Whether to drop NA data</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas Series or DataFrame\n    The data with a Monthly PeriodIndex. If interpolate is True, the\n    missing monthly data is interpolated. If dropna is True, any NA\n    data is removed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>,</span><span class=\"param\">\t<span class=\"n\">interpolate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">dropna</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">Datatype</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.monthly_to_qtly", "modulename": "readabs", "qualname": "monthly_to_qtly", "kind": "function", "doc": "<p>Convert monthly data to quarterly data by taking the mean (or sum)\nof the three months in each quarter. Ignore quarters with less than\nor more than three months data. Drop NA items. Change f to \"sum\"\nfor a quarterly sum.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : pandas Series or DataFrame\n    The data to convert to quarterly frequency.\nq_ending : str, default DEC\n    The month in which the quarter ends. For example, \"DEC\" for December.\nf : str, default \"mean\"\n    The function to apply to the three months in each quarter.\n    Change to \"sum\" for a quarterly sum. The default is a\n    quarterly mean.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas Series or DataFrame\n    The data with a quarterly PeriodIndex. If a quarter has less than\n    three months data, the quarter is dropped. If the quarter has more\n    than three months data, the quarter is dropped. Any NA data is removed.\n    For DataFrame input, the function is applied to each column.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>, </span><span class=\"param\"><span class=\"n\">q_ending</span><span class=\"o\">=</span><span class=\"s1\">&#39;DEC&#39;</span>, </span><span class=\"param\"><span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mean&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">Datatype</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.recalibrate", "modulename": "readabs", "qualname": "recalibrate", "kind": "function", "doc": "<p>Recalibrate a Series or DataFrame so the data in in the range -1000 to 1000.\nChange the name of the units to reflect the recalibration.</p>\n\n<p>Note, DataT = TypeVar(\"DataT\", Series, DataFrame). DataT is a constrained typevar.\nIf you provide a Series, you will get a Series back. If you provide a DataFrame,\nyou will get a DataFrame back.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : Series or DataFrame\n    The data to recalibrate.\nunits : str\n    The units of the data. This string should be in the form of\n    \"Number\", \"Thousands\", \"Millions\", \"Billions\", etc. The units\n    should be in title case.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Series or DataFrame\n    The recalibrated data will be a Series if a Series was provided,\n    or a DataFrame if a DataFrame was provided.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Series</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">recalibrate</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">Series</span><span class=\"p\">([</span><span class=\"mi\">1_000</span><span class=\"p\">,</span> <span class=\"mi\">10_000</span><span class=\"p\">,</span> <span class=\"mi\">100_000</span><span class=\"p\">,</span> <span class=\"mi\">1_000_000</span><span class=\"p\">])</span>\n<span class=\"n\">recalibrated</span><span class=\"p\">,</span> <span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">recalibrate</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"s2\">&quot;$&quot;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">recalibrated</span><span class=\"si\">=}</span><span class=\"s2\">, </span><span class=\"si\">{</span><span class=\"n\">units</span><span class=\"si\">=}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>, </span><span class=\"param\"><span class=\"n\">units</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Datatype</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.recalibrate_value", "modulename": "readabs", "qualname": "recalibrate_value", "kind": "function", "doc": "<p>Recalibrate a floating point value. The value will be recalibrated\nso it is in the range -1000 to 1000. The units will be changed to reflect\nthe recalibration.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>value : float\n    The value to recalibrate.\nunits : str\n    The units of the value. This string should be in the form of\n    \"Number\", \"Thousands\", \"Millions\", \"Billions\", etc. The units\n    should be in title case.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[float, str]\n    A tuple containing the recalibrated value and the recalibrated units.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">recalibrate_value</span>\n<span class=\"n\">recalibrated</span><span class=\"p\">,</span> <span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">recalibrate_value</span><span class=\"p\">(</span><span class=\"mi\">10_000_000</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Thousand&quot;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">recalibrated</span><span class=\"p\">,</span> <span class=\"n\">units</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">units</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.abs_catalogue", "modulename": "readabs.abs_catalogue", "kind": "module", "doc": "<p>Catalogue map for ABS data.</p>\n"}, {"fullname": "readabs.abs_catalogue.abs_catalogue", "modulename": "readabs.abs_catalogue", "qualname": "abs_catalogue", "kind": "function", "doc": "<p>Return a DataFrame of ABS Catalogue numbers. In the first instance,\nthis is downloaded from the ABS website, and cached for future use.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    A DataFrame of ABS Catalogue numbers.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">catalogue</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">abs_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.grab_abs_url", "modulename": "readabs.grab_abs_url", "kind": "module", "doc": "<p>Find and extract DataFrames from an ABS webpage.</p>\n"}, {"fullname": "readabs.grab_abs_url.grab_abs_url", "modulename": "readabs.grab_abs_url", "qualname": "grab_abs_url", "kind": "function", "doc": "<p>For a given URL, extract the data from the Excel and ZIP file\nlinks found on that page. The data is returned as a dictionary of\nDataFrames. The Excel files are converted into DataFrames, with\neach sheet in each Excel file becoming a separate DataFrame. ZIP\nfiles are examined for Excel files, which are similarly converted into\nDataFrames. The dictionary of DataFrames is returned.</p>\n\n<p>The preferred mechanism for reading ABS data is to use the <code>read_abs_cat()</code>\nor <code>read_abs_series()</code> functions. This function is provided for those\ncases where the data is not available in the ABS catalogue, where the\ndata is not a timeseries, or where the user wants to extract data from\na specific ABS landingpage.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>url : str = \"\"\n    A URL for an ABS Catalogue landing page. Either a url or\n    a catalogue number must be provided. If both are provided, the\n    URL will be used.</p>\n\n<p>**kwargs : Any\n    Accepts the same keyword arguments as <code>read_abs_cat()</code>. Additionally,\n    a cat argument can be provided, which will be used to get the URL\n    (see below).</p>\n\n<p>cat : str = \"\"\n    An ABS Catalogue number. If provided, and the URL is not\n    provided, then the Catalogue number will be used to get the URL.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict[str, DataFrame]\n    A dictionary of DataFrames.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">url</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.print_abs_catalogue", "modulename": "readabs.print_abs_catalogue", "kind": "module", "doc": "<p>Print the ABS Catalogue of time-series data.</p>\n"}, {"fullname": "readabs.print_abs_catalogue.print_abs_catalogue", "modulename": "readabs.print_abs_catalogue", "qualname": "print_abs_catalogue", "kind": "function", "doc": "<p>This function prints to standard output a table of the ABS\nCatalogue Numbers that contain time-series data. In addition to the\nCatalogue Numbers, the table includes the theme, parent topic and\ntopic for the collection represented by each Catalogue Number.</p>\n\n<p>It is primarily a convenience function: The first parameter for\nthe read_abs_cat() and read_abs_series() functions is the ABS\nCatalogue Number from which data is sought.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"return-values\">Return values</h2>\n\n<p>The function does not return anything.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">print_abs_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.rba_catalogue", "modulename": "readabs.rba_catalogue", "kind": "module", "doc": "<p>Extract links to RBA data files from the RBA website.</p>\n"}, {"fullname": "readabs.rba_catalogue.rba_catalogue", "modulename": "readabs.rba_catalogue", "qualname": "rba_catalogue", "kind": "function", "doc": "<p>Return a DataFrame of RBA Catalogue numbers. In the first instance,\nthis is downloaded from the RBA website, and cached for future use.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    A DataFrame of RBA Catalogue numbers.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">catalogue</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">rba_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.rba_catalogue.print_rba_catalogue", "modulename": "readabs.rba_catalogue", "qualname": "print_rba_catalogue", "kind": "function", "doc": "<p>This function prints to standard output a table of the RBA\nCatalogue Numbers.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cache_only : bool = False\n    If True, only use the cache.\nverbose : bool = False\n    If True, print progress messages.</p>\n\n<h2 id=\"return-values\">Return values</h2>\n\n<p>The function does not return anything.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">print_rba_catalogue</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_abs_by_desc", "modulename": "readabs.read_abs_by_desc", "kind": "module", "doc": "<p>Get specific ABS data series by searching for the ABS \ndata item descriptions.</p>\n"}, {"fullname": "readabs.read_abs_by_desc.read_abs_by_desc", "modulename": "readabs.read_abs_by_desc", "qualname": "read_abs_by_desc", "kind": "function", "doc": "<p>Get specific ABS data series by searching the ABS meta data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>wanted : list of str, dict of str:str, or dict of str:dict - the data\nitem descriptions to search for. If a list, it will be a list of\ndescriptions to search for. If a dictionary, the keys will a name.\nThe dixtionary values can be either a string (the data item\ndescription to search for) or a dictionary of keyword arguments, one of\nwhich would be the data item description to search for.</li>\n<li>kwargs : Any - keyword arguments to control the data retrieval.\nThe keyword arguments can include the following:\n<ul>\n<li>abs_dict : dict - the dictionary of ABS data to search (from\nread_abs_cat()).</li>\n<li>abs_meta : DataFrame - the metadata for the ABS data (from\nread_abs_cat()).</li>\n<li>for the retrieval of data, the \"cat\" argument must be present.\nThe following arguments, if present, will also be used (ie.\npassed to read_abs_cat()): [\"ignore_errors\", \"get_zip\",\n\"get_excel_if_no_zip\", \"get_excel\", \"cache_only\",\n\"single_excel_only\", \"single_zip_only\", \"verbose\"].</li>\n<li>for the selection of data, the following metacol names, if present,\nwill be used to construct the selector: \"cat\", \"did\"\n\"stype\", \"id\", \"start\", \"end\", \"num\", \"unit\", \"dtype\", \"freq\",\n\"cmonth\", \"table\", \"tdesc\".</li>\n<li>finally, the following arguments will be passed to the find_abs_id()\nand search_abs_meta() functions: [\"validate_unique\", \"exact_match\",\n\"regex\", \"verbose\"].</li>\n</ul></li>\n</ul>\n\n<p>Notes:</p>\n\n<ul>\n<li>if \"wanted\" is of type list[str] or dict[str, str], the kwargs should\ninclude sufficient keys from the metacol dataclass to get the data.\nTypically, the \"cat\" key, the \"table\" key, and the \"stype\" key would\nbe required. The did key would taken from the wanted list or\ndictionary.\nif wanted is of type dict[str, dict[str, Any]], the inner dictionary\nmust contain a \"did\" key. The other keys that can be used for the\ndata retrieval are the same as the metacol dataclass fileds, namely:\n\"cat\", \"stype\", \"id\", \"start\", \"end\", \"num\", \"unit\", \"dtype\", \"freq\",\n\"cmonth\", \"table\", \"tdesc\".</li>\n<li>if abs_dict and abs_meta are provided within the kwargs, they will be\nused to locate and extract the selected data.</li>\n<li>if abs_dict and abs_meta are not provided, then, (1) wanted must be of\ntype dict[str, dict[str, Any]] and (2) the inner dictionary must\ncontain a \"cat\" key so the data can be retrieved. Other keys that\ncan be used for the data retrieval are the same as for read_abs_cat(),\nnamely [\"ignore_errors\", \"get_zip\", \"get_excel_if_no_zip\",\n\"get_excel\", \"single_excel_only\", \"single_zip_only\", \"cache_only\"].</li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Returns a tuple of two items:</p>\n\n<ul>\n<li>A dictionary of pandas Series objects, where the keys are the series\ndescriptions. The series.name attribute will be the ABS series-id.</li>\n<li>A pandas DataFrame containing the metadata for the series.</li>\n</ul>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;5206.0&quot;</span>  <span class=\"c1\"># The ABS National Accounts</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat</span><span class=\"o\">=</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">wanted</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Gross domestic product: Chain volume measures ;&quot;</span><span class=\"p\">,]</span>\n<span class=\"n\">selected</span><span class=\"p\">,</span> <span class=\"n\">selected_meta</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_by_desc</span><span class=\"p\">(</span>\n    <span class=\"n\">wanted</span><span class=\"o\">=</span><span class=\"n\">wanted</span><span class=\"p\">,</span> <span class=\"n\">abs_dict</span><span class=\"o\">=</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">abs_meta</span><span class=\"o\">=</span><span class=\"n\">meta</span><span class=\"p\">,</span> <span class=\"n\">table</span><span class=\"o\">=</span><span class=\"s2\">&quot;5206001_Key_Aggregates&quot;</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">wanted</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">],</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_abs_cat", "modulename": "readabs.read_abs_cat", "kind": "module", "doc": "<p>Download <em>timeseries</em> data from the Australian Bureau \nof Statistics (ABS) for a specified ABS catalogue identifier.</p>\n"}, {"fullname": "readabs.read_abs_cat.read_abs_cat", "modulename": "readabs.read_abs_cat", "qualname": "read_abs_cat", "kind": "function", "doc": "<p>This function returns the complete ABS Catalogue information as a\npython dictionary of pandas DataFrames, as well as the associated metadata\nin a separate DataFrame. The function automates the collection of zip and\nexcel files from the ABS website. If necessary, these files are downloaded,\nand saved into a cache directory. The files are then parsed to extract time\nseries data, and the associated metadata.</p>\n\n<p>By default, the cache directory is <code>./.readabs_cache/</code>. You can change the\ndefault directory name by setting the shell environment variable\n<code>READABS_CACHE_DIR</code> with the name of the preferred directory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cat : str\n    The ABS Catalogue Number for the data to be downloaded and made\n    available by this function. This argument must be specified in the\n    function call.</p>\n\n<p>keep_non_ts : bool = False\n    A flag for whether to keep the non-time-series tables\n    that might form part of an ABS catalogue item. Normally, the\n    non-time-series information is ignored, and not made available to\n    the user.</p>\n\n<p>**kwargs : Any\n    The following parameters may be passed as optional keyword arguments.</p>\n\n<p>history : str = \"\"\n    Orovide a month-year string to extract historical ABS data.\n    For example, you can set history=\"dec-2023\" to the get the ABS data\n    for a catalogue identifier that was originally published in respect\n    of Q4 of 2023. Note: not all ABS data sources are structured so that\n    this technique works in every case; but most are.</p>\n\n<p>verbose : bool = False\n    Setting this to true may help diagnose why something\n    might be going wrong with the data retrieval process.</p>\n\n<p>ignore_errors : bool = False\n    Normally, this function will cease downloading when\n    an error in encountered. However, sometimes the ABS website has\n    malformed links, and changing this setting is necessitated. (Note:\n    if you drop a message to the ABS, they will usually fix broken\n    links with a business day).</p>\n\n<p>get_zip : bool = True\n    Download the excel files in .zip files.</p>\n\n<p>get_excel_if_no_zip : bool = True\n    Only try to download .xlsx files if there are no zip\n    files available to be downloaded. Only downloading individual excel\n    files when there are no zip files to download can speed up the\n    download process.</p>\n\n<p>get_excel : bool = False\n    The default value means that excel files are not\n    automatically download. Note: at least one of <code>get_zip</code>,\n    <code>get_excel_if_no_zip</code>, or <code>get_excel</code> must be true. For most ABS\n    catalogue items, it is sufficient to just download the one zip\n    file. But note, some catalogue items do not have a zip file.\n    Others have quite a number of zip files.</p>\n\n<p>single_excel_only : str = \"\"\n    If this argument is set to a table name (without the\n    .xlsx extension), only that excel file will be downloaded. If\n    set, and only a limited subset of available data is needed,\n    this can speed up download times significantly. Note: overrides\n    <code>get_zip</code>, <code>get_excel_if_no_zip</code>, <code>get_excel</code> and <code>single_zip_only</code>.</p>\n\n<p>single_zip_only : str = \"\"\n    If this argument is set to a zip file name (without\n    the .zip extension), only that zip file will be downloaded.\n    If set, and only a limited subset of available data is needed,\n    this can speed up download times significantly. Note: overrides\n    <code>get_zip</code>, <code>get_excel_if_no_zip</code>, and <code>get_excel</code>.</p>\n\n<p>cache_only : bool = False\n    If set to True, this function will only access\n    data that has been previously cached. Normally, the function\n    checks the date of the cache data against the date of the data\n    on the ABS website, before deciding whether the ABS has fresher\n    data that needs to be downloaded to the cache.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[dict[str, DataFrame], DataFrame]\n    The function returns a tuple of two items. The first item is a\n    python dictionary of pandas DataFrames (which is the primary data\n    associated with the ABS catalogue item). The second item is a\n    DataFrame of ABS metadata for the ABS collection.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">DataFrame</span><span class=\"p\">],</span> <span class=\"n\">DataFrame</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat</span><span class=\"o\">=</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">abs_dict</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cat</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">keep_non_ts</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">],</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_abs_series", "modulename": "readabs.read_abs_series", "kind": "module", "doc": "<p>Get specific ABS data series by their ABS series identifiers.</p>\n"}, {"fullname": "readabs.read_abs_series.read_abs_series", "modulename": "readabs.read_abs_series", "qualname": "read_abs_series", "kind": "function", "doc": "<p>Get specific ABS data series by their ABS catalogue and series identifiers.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cat : str\n    The ABS catalogue ID.</p>\n\n<p>series_id : str | Sequence[str]\n    An ABS series ID or a sequence of ABS series IDs.</p>\n\n<p>**kwargs : Any\n    Keyword arguments for the read_abs_series function,\n    which are the same as the keyword arguments for the\n    read_abs_cat function.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[DataFrame, DataFrame]\n    A tuple of two DataFrames, one for the primary data and one for the metadata.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ra</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">unemployment_rate</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;A84423050A&quot;</span>\n<span class=\"n\">seo</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202001&quot;</span>  <span class=\"c1\"># The ABS table name</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">ra</span><span class=\"o\">.</span><span class=\"n\">read_abs_series</span><span class=\"p\">(</span>\n    <span class=\"n\">cat</span><span class=\"o\">=</span><span class=\"n\">cat_num</span><span class=\"p\">,</span> <span class=\"n\">series_id</span><span class=\"o\">=</span><span class=\"n\">unemployment_rate</span><span class=\"p\">,</span> <span class=\"n\">single_excel_only</span><span class=\"o\">=</span><span class=\"n\">seo</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cat</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">series_id</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_rba_table", "modulename": "readabs.read_rba_table", "kind": "module", "doc": "<p>Read a table from the RBA website and store it in a pandas DataFrame.</p>\n"}, {"fullname": "readabs.read_rba_table.read_rba_table", "modulename": "readabs.read_rba_table", "qualname": "read_rba_table", "kind": "function", "doc": "<p>Read a table from the RBA website and return the actual data\nand the meta data in a tuple of two DataFrames.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>table : str\n    The table to read from the RBA website.\n**kwargs : Any\n    Additional keyword arguments.\n    The only keyword argument that is used is ignore_errors.\nignore_errors : bool = False\n    If True, then any major errors encountered will be printed and the function\n    will return empty DataFrames. If False, then any major errors encountered\n    will raise an exception.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[DataFrame, DataFrame]\n    The primary data and the meta data in a tuple of two DataFrames.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">read_rba_table</span><span class=\"p\">(</span><span class=\"s2\">&quot;C1&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">table</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.read_rba_table.read_rba_ocr", "modulename": "readabs.read_rba_table", "qualname": "read_rba_ocr", "kind": "function", "doc": "<p>Read the Official Cash Rate (OCR) from the RBA website and return it\nin a pandas Series, with either a daily or monthly PeriodIndex,\ndepending on the value of the monthly parameter. The default is monthly.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>monthly : bool = True\n    If True, then the data will be returned with a monthly PeriodIndex.\n    If False, then the data will be returned with a daily PeriodIndex.\n**kwargs : Any\n    Additional keyword arguments. The only keyword argument that is used is ignore_errors.\nignore_errors : bool = False\n    If True, then any major errors encountered will be printed and the function\n    will return an empty Series. If False, then any major errors encountered\n    will raise an exception.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Series\n    The OCR data in a pandas Series, with an index of either daily or monthly Periods.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">ocr</span> <span class=\"o\">=</span> <span class=\"n\">read_rba_ocr</span><span class=\"p\">(</span><span class=\"n\">monthly</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monthly</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.recalibrate", "modulename": "readabs.recalibrate", "kind": "module", "doc": "<p>Recalibrate a Series or DataFrame so the data is in the range -1000 to 1000.</p>\n"}, {"fullname": "readabs.recalibrate.recalibrate", "modulename": "readabs.recalibrate", "qualname": "recalibrate", "kind": "function", "doc": "<p>Recalibrate a Series or DataFrame so the data in in the range -1000 to 1000.\nChange the name of the units to reflect the recalibration.</p>\n\n<p>Note, DataT = TypeVar(\"DataT\", Series, DataFrame). DataT is a constrained typevar.\nIf you provide a Series, you will get a Series back. If you provide a DataFrame,\nyou will get a DataFrame back.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : Series or DataFrame\n    The data to recalibrate.\nunits : str\n    The units of the data. This string should be in the form of\n    \"Number\", \"Thousands\", \"Millions\", \"Billions\", etc. The units\n    should be in title case.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Series or DataFrame\n    The recalibrated data will be a Series if a Series was provided,\n    or a DataFrame if a DataFrame was provided.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Series</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">recalibrate</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">Series</span><span class=\"p\">([</span><span class=\"mi\">1_000</span><span class=\"p\">,</span> <span class=\"mi\">10_000</span><span class=\"p\">,</span> <span class=\"mi\">100_000</span><span class=\"p\">,</span> <span class=\"mi\">1_000_000</span><span class=\"p\">])</span>\n<span class=\"n\">recalibrated</span><span class=\"p\">,</span> <span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">recalibrate</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"s2\">&quot;$&quot;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">recalibrated</span><span class=\"si\">=}</span><span class=\"s2\">, </span><span class=\"si\">{</span><span class=\"n\">units</span><span class=\"si\">=}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Datatype</span>, </span><span class=\"param\"><span class=\"n\">units</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Datatype</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.recalibrate.recalibrate_value", "modulename": "readabs.recalibrate", "qualname": "recalibrate_value", "kind": "function", "doc": "<p>Recalibrate a floating point value. The value will be recalibrated\nso it is in the range -1000 to 1000. The units will be changed to reflect\nthe recalibration.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>value : float\n    The value to recalibrate.\nunits : str\n    The units of the value. This string should be in the form of\n    \"Number\", \"Thousands\", \"Millions\", \"Billions\", etc. The units\n    should be in title case.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[float, str]\n    A tuple containing the recalibrated value and the recalibrated units.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">recalibrate_value</span>\n<span class=\"n\">recalibrated</span><span class=\"p\">,</span> <span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">recalibrate_value</span><span class=\"p\">(</span><span class=\"mi\">10_000_000</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Thousand&quot;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">recalibrated</span><span class=\"p\">,</span> <span class=\"n\">units</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">units</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.search_abs_meta", "modulename": "readabs.search_abs_meta", "kind": "module", "doc": "<p>Search a DataFrame of ABS meta data, using a dictionary of search terms,\nto identify the row or rows that match all of the search terms.</p>\n"}, {"fullname": "readabs.search_abs_meta.search_abs_meta", "modulename": "readabs.search_abs_meta", "qualname": "search_abs_meta", "kind": "function", "doc": "<p>Extract from the ABS meta data those rows that match the\nsearch_terms, by iteratively searching the meta data one\nsearch_term at a time.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>meta : DataFrame\n    A pandas DataFrame of metadata from the ABS\n    (via read_abs_cat() or read_abs_series()).\nsearch_terms : dict[str, str]\n    A dictionary {search_phrase: meta_column_name, ...} of search terms.\n    Note: the search terms must be unique, as a dictionary cannot hold the\n    same search term to be applied to different columns.\nexact_match : bool = False\n    Whether to match using == (exact) or .str.contains() (inexact).\nregex : bool = False\n    Whether to use regular expressions in the search.\nvalidate_unique : bool = False\n    Raise a ValueError if the search result is not unique.\n**kwargs : Any\n    Additional keyword arguments. The only keyword argument\n    that is used is verbose.\nverbose : bool = False\n    Print additional information while searching; which can\n    be useful when diagnosing problems with search terms.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    Returns a pandas DataFrame of matching rows (subseted from meta).\n    Note, The index for the returned meta data will always comprise ABS\n    series_ids. Duplicate indexes will be removed from the meta data\n    (ie. where the same ABS series appears in more than one table, this\n    function will only report the first match).</p>\n\n<h2 id=\"metacol\">Metacol</h2>\n\n<p>Because the meta data is a DataFrame, the columns can be referenced by either\ntheir full textual name, or by the short name defined in the metacol object.\nFor example, if metacol is imported as mc, to refer to the\n<code>Data Item Description</code> column, the user can refer to it as mc.did.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">metacol</span> <span class=\"k\">as</span> <span class=\"n\">mc</span>  <span class=\"c1\"># alias for the ABS meta data column names</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">,</span> <span class=\"n\">search_abs_meta</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">search_terms</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&quot;Unemployment rate&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">did</span><span class=\"p\">,</span>  <span class=\"c1\"># the data item description</span>\n    <span class=\"s2\">&quot;Persons&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">did</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;Seasonally Adjusted&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">stype</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;Percent&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">unit</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;6202001&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">table</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"n\">rows</span> <span class=\"o\">=</span> <span class=\"n\">search_abs_meta</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">,</span> <span class=\"n\">search_terms</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">rows</span><span class=\"p\">)</span>  <span class=\"c1\"># should have three rows : FT/PT/All Unemployment rates</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">meta</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">search_terms</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">exact_match</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">validate_unique</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "readabs.search_abs_meta.find_abs_id", "modulename": "readabs.search_abs_meta", "qualname": "find_abs_id", "kind": "function", "doc": "<p>Find a unique ABS series identifier in the ABS metadata.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>meta : DataFrame\n    A pandas DataFrame of metadata from the ABS\n    (via read_abs_cat() or read_abs_series()).\nsearch_terms : dict[str, str]\n    A dictionary {search_phrase: meta_column_name, ...} of search terms.\n    Note: the search terms must be unique, as a dictionary cannot hold the\n    same search term to be applied to different columns.\n**kwargs : Any\n    Additional keyword arguments. The only additional keyword argument\n    that is used is validate_unique.\nvalidate_unique : bool = True\n    Raise a ValueError if the search result is not a single\n    unique match. Note: the default is True for safety.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple[str, str, str]\n    A tuple of the table, series_id and units for the unique\n    series_id that matches the search terms.</p>\n\n<h2 id=\"metacol\">Metacol</h2>\n\n<p>Because the meta data is a DataFrame, the columns can be referenced by either\ntheir full textual name, or by the short name defined in the metacol object.\nFor example, if metacol is imported as mc, to refer to the\n<code>Data Item Description</code> column, the user can refer to it as mc.did.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">metacol</span> <span class=\"k\">as</span> <span class=\"n\">mc</span>  <span class=\"c1\"># alias for the ABS meta data column names</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">readabs</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">,</span> <span class=\"n\">find_abs_id</span><span class=\"p\">,</span> <span class=\"n\">recalibrate</span>\n<span class=\"n\">cat_num</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;6202.0&quot;</span>  <span class=\"c1\"># The ABS labour force survey</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">read_abs_cat</span><span class=\"p\">(</span><span class=\"n\">cat_num</span><span class=\"p\">)</span>\n<span class=\"n\">search_terms</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&quot;Employed total ;  Persons ;&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">did</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;Seasonally Adjusted&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">stype</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;6202001&quot;</span><span class=\"p\">:</span> <span class=\"n\">mc</span><span class=\"o\">.</span><span class=\"n\">table</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"n\">table</span><span class=\"p\">,</span> <span class=\"n\">series_id</span><span class=\"p\">,</span> <span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">find_abs_id</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">,</span> <span class=\"n\">search_terms</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Table: </span><span class=\"si\">{</span><span class=\"n\">table</span><span class=\"si\">}</span><span class=\"s2\"> Series ID: </span><span class=\"si\">{</span><span class=\"n\">series_id</span><span class=\"si\">}</span><span class=\"s2\"> Units: </span><span class=\"si\">{</span><span class=\"n\">units</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">recal_series</span><span class=\"p\">,</span> <span class=\"n\">recal_units</span> <span class=\"o\">=</span> <span class=\"n\">recalibrate</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">table</span><span class=\"p\">][</span><span class=\"n\">series_id</span><span class=\"p\">],</span> <span class=\"n\">units</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">meta</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">search_terms</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();