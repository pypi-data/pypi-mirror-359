#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.1.2
# Product:       scd4x
# Model-Version: 2.0
#
"""
The transfer classes specify the data that is transferred between host and sensor. The generated transfer classes
are used by the driver class and not intended for direct use.
"""

from enum import Enum
from sensirion_driver_adapters.transfer import Transfer
from sensirion_driver_adapters.rx_tx_data import TxData, RxData


class StartPeriodicMeasurement(Transfer):
    """
    Starts the periodic measurement mode.
    The signal update interval is 5 seconds.
    """

    CMD_ID = 0x21b1

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class ReadMeasurementRaw(Transfer):
    """
    Reads the sensor output. The measurement data can only be read out once per signal update interval as the buffer
    is emptied upon read-out. If no data is available in the buffer, the sensor returns a NACK. To avoid a NACK response, the
    get_data_ready_status can be issued to check data status. The I2C master can abort the read transfer with a NACK
    followed by a STOP condition after any data byte if the user is not interested in subsequent data.
    """

    CMD_ID = 0xec05

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>HHH')


class StopPeriodicMeasurement(Transfer):
    """
    Command returns a sensor running in periodic measurement mode or low power periodic measurement mode
    back to the idle state, e.g. to then allow changing the sensor configuration or to save power.
    """

    CMD_ID = 0x3f86

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.5, slave_address=None, ignore_ack=False)


class SetTemperatureOffsetRaw(Transfer):
    """
    Setting the temperature offset of the SCD4x inside the customer device allows the user to optimize the RH and T
    output signal. The temperature offset can depend on several factors such as the SCD4x measurement mode, self-heating of
    close components, the ambient temperature and air flow. Thus, the SCD4x temperature offset should be determined after
    integration into the final device and under its typical operating conditions (including the operation mode to be used in the
    application) in thermal equilibrium. By default, the temperature offset is set to 4 °C. To save the setting to the EEPROM, the
    persist_settings command may be issued. Equation (1) details how the characteristic temperature offset
    can be calculated using the current temperature output of the sensor (TSCD4x), a reference temperature value (TReference),
    and the previous temperature offset (Toffset_pervious) obtained using the get_temperature_offset_raw command:

    Toffset_actual = TSCD4x - TReference + Toffset_pervious.

    Recommended temperature offset values are between 0 °C and 20 °C.
    The temperature offset does not impact the accuracy of the CO2 output.
    """

    CMD_ID = 0x241d

    def __init__(self, offset_temperature):
        self._offset_temperature = offset_temperature

    def pack(self):
        return self.tx_data.pack([self._offset_temperature])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetTemperatureOffsetRaw(Transfer):
    """Get the raw temperature compensation offset used by the sensor."""

    CMD_ID = 0x2318

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetSensorAltitude(Transfer):
    """
    Typically, the sensor altitude is set once after device installation.
    To save the setting to the EEPROM, the persist_settings command must be issued.
    The default sensor altitude value is set to 0 meters above sea level.
    Note that setting a sensor altitude to the sensor overrides any pressure
    compensation based on a previously set ambient pressure.
    """

    CMD_ID = 0x2427

    def __init__(self, sensor_altitude):
        self._sensor_altitude = sensor_altitude

    def pack(self):
        return self.tx_data.pack([self._sensor_altitude])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetSensorAltitude(Transfer):
    """Get the sensor altitude used by the sensor."""

    CMD_ID = 0x2322

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetAmbientPressureRaw(Transfer):
    """
    The set_ambient_pressure command can be sent during periodic measurements to enable continuous pressure
    compensation. Note that setting an ambient pressure overrides any pressure compensation based on a previously set sensor
    altitude. Use of this command is highly recommended for applications experiencing significant ambient pressure changes to
    ensure sensor accuracy. Valid input values are between 70000 - 120000 Pa. The default value is 101300 Pa.
    """

    CMD_ID = 0xe000

    def __init__(self, ambient_pressure):
        self._ambient_pressure = ambient_pressure

    def pack(self):
        return self.tx_data.pack([self._ambient_pressure])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetAmbientPressureRaw(Transfer):
    """Get the ambient pressure around the sensor."""

    CMD_ID = 0xe000

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class PerformForcedRecalibration(Transfer):
    """
    To successfully conduct an accurate FRC, the following steps need to be carried out:

    1. Operate the SCD4x in the operation mode later used for normal sensor operation (e.g. periodic measurement)
    for at least 3 minutes in an environment with a homogenous and constant CO2 concentration.
    The sensor must be operated at the voltage desired for the application when performing the FRC sequence.
    2. Issue the stop_periodic_measurement command.
    3. Issue the perform_forced_recalibration command.

    A return value of 0xffff indicates that the FRC has failed because the sensor was not operated before sending the command.
    """

    CMD_ID = 0x362f

    def __init__(self, target_CO2_concentration):
        self._target_CO2_concentration = target_CO2_concentration

    def pack(self):
        return self.tx_data.pack([self._target_CO2_concentration])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.4, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetAutomaticSelfCalibrationEnabled(Transfer):
    """
    Sets the current state (enabled / disabled) of the ASC. By default, ASC is enabled. To save the setting to the
    EEPROM, the persist_settings command must be issued.
    The ASC enables excellent long-term stability of SCD4x without the need for regular user intervention. The algorithm leverages
    the sensor's measurement history and the assumption of exposure of the sensor to a known minimum background CO₂
    concentration at least once over a period of cumulative operation. By default, the ASC algorithm assumes that the sensor is
    exposed to outdoor fresh air at 400 ppm CO₂ concentration at least once per week of accumulated operation using one of the
    following measurement modes for at least 4 hours without interruption at a time: periodic measurement mode, low
    power periodic measurement mode or single shot mode with a measurement interval of 5 minutes (SCD41 only).
    """

    CMD_ID = 0x2416

    def __init__(self, asc_enabled):
        self._asc_enabled = asc_enabled

    def pack(self):
        return self.tx_data.pack([self._asc_enabled])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetAutomaticSelfCalibrationEnabled(Transfer):
    """Check if automatic self calibration (ASC) is enabled."""

    CMD_ID = 0x2313

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetAutomaticSelfCalibrationTarget(Transfer):
    """
    Sets the value of the ASC baseline target, i.e. the CO₂ concentration in ppm which the ASC algorithm will assume
    as lower-bound background to which the SCD4x is exposed to regularly within one ASC period of operation. To save the setting
    to the EEPROM, the persist_settings command must be issued subsequently. The factory default value is 400 ppm.
    """

    CMD_ID = 0x243a

    def __init__(self, asc_target):
        self._asc_target = asc_target

    def pack(self):
        return self.tx_data.pack([self._asc_target])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetAutomaticSelfCalibrationTarget(Transfer):
    """Reads out the ASC baseline target concentration parameter."""

    CMD_ID = 0x233f

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class StartLowPowerPeriodicMeasurement(Transfer):
    """
    To enable use-cases with a constrained power budget, the SCD4x features a low power periodic measurement mode with a
    signal update interval of approximately 30 seconds. The low power periodic measurement mode is initiated using the
    start_low_power_periodic_measurement command and read-out in a similar manner as the periodic measurement mode using
    the read_measurement command.
    To periodically check whether a new measurement result is available for read out, the get_data_ready_status command
    can be used to synchronize to the sensor's internal measurement interval as an alternative to relying on the ACK/NACK
    status of the read_measurement_command.
    """

    CMD_ID = 0x21ac

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class GetDataReadyStatusRaw(Transfer):
    """Polls the sensor for whether data from a periodic or single shot measurement is ready to be read out."""

    CMD_ID = 0xe4b8

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class PersistSettings(Transfer):
    """
    Configuration settings such as the temperature offset, sensor altitude and the ASC enabled/disabled parameters
    are by default stored in the volatile memory (RAM) only. The persist_settings command stores the current configuration in the
    EEPROM of the SCD4x, ensuring the current settings persist after power-cycling. To avoid unnecessary wear of the EEPROM,
    the persist_settings command should only be sent following configuration changes whose persistence is required. The EEPROM
    is guaranteed to withstand at least 2000 write cycles. Note that field calibration history (i.e. FRC and ASC) is
    automatically stored in a separate EEPROM dimensioned for the specified sensor lifetime when operated continuously in either
    periodic measurement mode, low power periodic measurement mode or single shot mode with 5 minute measurement interval (SCD41 only).
    """

    CMD_ID = 0x3615

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.8, slave_address=None, ignore_ack=False)


class GetSerialNumber(Transfer):
    """
    Reading out the serial number can be used to identify the chip and to verify the presence of the sensor.
    The get_serial_number command returns 3 words, and every word is followed by an 8-bit CRC checksum. Together, the 3 words
    constitute a unique serial number with a length of 48 bits (in big endian format).
    """

    CMD_ID = 0x3682

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>3H', convert_to_int=True)


class PerformSelfTest(Transfer):
    """Can be used as an end-of-line test to check the sensor functionality."""

    CMD_ID = 0x3639

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=10.0, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class PerformFactoryReset(Transfer):
    """
    The perform_factory_reset command resets all configuration settings stored in the EEPROM and erases the
    FRC and ASC algorithm history.
    """

    CMD_ID = 0x3632

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=1.2, slave_address=None, ignore_ack=False)


class Reinit(Transfer):
    """
    The reinit command reinitialize the sensor by reloading user settings from EEPROM. The sensor must be in the
    idle state before sending the reinit command. If the reinit command does not trigger the desired re-initialization,
    a power-cycle should be applied to the SCD4x.
    """

    CMD_ID = 0x3646

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.03, slave_address=None, ignore_ack=False)


class GetSensorVariantRaw(Transfer):
    """Reads out the SCD4x sensor variant."""

    CMD_ID = 0x202f

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class MeasureSingleShot(Transfer):
    """
    The sensor output is read out by using the read_measurement command.
    The fastest possible sampling interval for single shot measurements is 5 seconds.
    The ASC is enabled by default in single shot operation and optimized for single shot measurements performed every 5 minutes.
    For more details about single shot measurements and optimization of power consumption please refer to the datasheet.
    """

    CMD_ID = 0x219d

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=5.0, slave_address=None, ignore_ack=False)


class MeasureSingleShotRhtOnly(Transfer):
    """For more details about single shot measurements and optimization of power consumption please refer to the datasheet."""

    CMD_ID = 0x2196

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.05, slave_address=None, ignore_ack=False)


class PowerDown(Transfer):
    """
    Put the sensor from idle to sleep to reduce power consumption. Can be used to power down when operating the
    sensor in power-cycled single shot mode.
    """

    CMD_ID = 0x36e0

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class WakeUp(Transfer):
    """
    Wake up the sensor from sleep mode into idle mode. Note that the SCD4x does not acknowledge the wake_up
    command. The sensor's idle state after wake up can be verified by reading out the serial number.
    """

    CMD_ID = 0x36f6

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.03, slave_address=None, ignore_ack=True)


class SetAutomaticSelfCalibrationInitialPeriod(Transfer):
    """
    Sets the duration of the initial period for ASC correction (in hours). By default, the initial period for ASC correction
    is 44 hours. Allowed values are integer multiples of 4 hours. A value of 0 results in an immediate correction.
    To save the setting to the EEPROM, the persist_settings command must be issued.

    For single shot operation, this parameter always assumes a measurement interval of 5 minutes, counting the number of
    single shots to calculate elapsed time. If single shot measurements are taken more / less frequently than once every 5 minutes,
    this parameter must be scaled accordingly to achieve the intended period in hours (e.g. for a 10-minute measurement interval,
    the scaled parameter value is obtained by multiplying the intended period in hours by 0.5).
    """

    CMD_ID = 0x2445

    def __init__(self, asc_initial_period):
        self._asc_initial_period = asc_initial_period

    def pack(self):
        return self.tx_data.pack([self._asc_initial_period])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetAutomaticSelfCalibrationInitialPeriod(Transfer):
    """Read out the initial period for ASC correction"""

    CMD_ID = 0x2340

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetAutomaticSelfCalibrationStandardPeriod(Transfer):
    """
    Sets the standard period for ASC correction (in hours). By default, the standard period for ASC correction is 156
    hours. Allowed values are integer multiples of 4 hours. Note: a value of 0 results in an immediate correction. To save the
    setting to the EEPROM, the persist_settings (see Section 3.10.1) command must be issued.

    For single shot operation, this parameter always assumes a measurement interval of 5 minutes, counting the number of
    single shots to calculate elapsed time. If single shot measurements are taken more / less frequently than once every 5 minutes,
    this parameter must be scaled accordingly to achieve the intended period in hours (e.g. for a 10-minute measurement interval,
    the scaled parameter value is obtained by multiplying the intended period in hours by 0.5).
    """

    CMD_ID = 0x244e

    def __init__(self, asc_standard_period):
        self._asc_standard_period = asc_standard_period

    def pack(self):
        return self.tx_data.pack([self._asc_standard_period])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class GetAutomaticSelfCalibrationStandardPeriod(Transfer):
    """Get the standard period for ASC correction."""

    CMD_ID = 0x234b

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SensorVariant(Enum):
    MASK = 61440
    SCD40 = 0
    SCD41 = 4096
    SCD42 = 8192
    SCD43 = 20480

    def __int__(self):
        return self.value
