from typing import overload, Optional, Dict, Union, Mapping, Any, Iterable
from _collections_abc import dict_items, dict_keys, dict_values
import torch
from torch import device, dtype
from torch import nn

def bufferingmethod(funcobj): ...
def hidden(obj): ...
def subclassvisible(obj): ...
class Buffering: ...
class Buffer(torch.Tensor, Buffering):
    @overload
    def __init__(self, tensor: Optional[torch.Tensor], persistent: bool = True): ...
class BufferObject(Buffering):
    _contents: Dict[str, Union[torch.Tensor, Buffering, None]]
    dtype: Optional[dtype]
    device: Optional[device]
    @property
    def persistent(self) -> bool: ...
    @persistent.setter
    def persistent(self, value): ...
    def with_persistent(self, value) -> BufferObject: ...
    def register_to(self, module: nn.Module, name: str): ...
    def copy_(self, src: BufferObject, non_blocking: bool = False) -> BufferObject:  ...
    @overload
    def to(self, device: Optional[Union[int, device]] = ..., dtype: Optional[Union[dtype, str]] = ..., non_blocking: bool = ...) -> BufferObject: ...
    @overload
    def to(self, dtype: Union[dtype, str], non_blocking: bool = ...) -> BufferObject: ...
    @overload
    def to(self, tensor: torch.Tensor, non_blocking: bool = ...) -> BufferObject: ...
    def cuda(self, device: Optional[Union[int, device]] = None) -> BufferObject: ...
    def ipu(self, device: Optional[Union[int, device]] = None) -> BufferObject: ...
    def xpu(self, device: Optional[Union[int, device]] = None) -> BufferObject: ...
    def cpu(self) -> BufferObject: ...
    def type(self, dst_type: Union[dtype, str]) -> BufferObject: ...
    def float(self) -> BufferObject: ...
    def double(self) -> BufferObject: ...
    def half(self) -> BufferObject: ...
    def bfloat16(self) -> BufferObject: ...
    def detach(self, *args, **kwargs) -> BufferObject: ...
    def is_floating_point(self, *args, **kwargs) -> bool: ...
    def is_complex(self, *args, **kwargs) -> bool: ...
    @overload
    def to_(self, device: Optional[Union[int, device]] = ..., dtype: Optional[Union[dtype, str]] = ..., non_blocking: bool = ...) -> BufferObject: ...
    @overload
    def to_(self, dtype: Union[dtype, str], non_blocking: bool = ...) -> BufferObject: ...
    @overload
    def to_(self, tensor: torch.Tensor, non_blocking: bool = ...) -> BufferObject: ...
    def cuda_(self, device: Optional[Union[int, device]] = None) -> BufferObject: ...
    def ipu_(self, device: Optional[Union[int, device]] = None) -> BufferObject: ...
    def xpu_(self, device: Optional[Union[int, device]] = None) -> BufferObject: ...
    def cpu_(self) -> BufferObject: ...
    def type_(self, dst_type: Union[dtype, str]) -> BufferObject: ...
    def float_(self) -> BufferObject: ...
    def double_(self) -> BufferObject: ...
    def half_(self) -> BufferObject: ...
    def bfloat16_(self) -> BufferObject: ...
    def detach_(self, *args, **kwargs) -> BufferObject: ...
class BufferDict(BufferObject):
    _contents: Mapping[str, Any]
    def update(self, buffers: Mapping[str, Any]): ...
    def get(self, key: str) -> Any: ...
    def pop(self, key: str) -> Any: ...
    def popitem(self) -> tuple[str, Any]: ...
    def clear(self): ...
    def copy(self) -> BufferDict: ...
    def setdefault(self, key: str, default: Any = None) -> Any: ...
    def items(self) -> dict_items[str, Any]: ...
    def keys(self) -> dict_keys[str, Any]: ...
    def values(self) -> dict_values[str, Any]: ...
class BufferList(BufferObject):
    _contents: Iterable[Any]
    def count(self, value: Any) -> int: ...
    def pop(self, index: int) -> Any: ...
    def clear(self): ...
    def copy(self) -> BufferList: ...
    def insert(self, index: int, buffer: Any): ...
    def append(self, buffer: Any): ...
    def extend(self, buffers: Iterable[Any]): ...