import ast
import sys
from types import NoneType
from typing import Any

FIELD_MAPS: dict[type[Any], dict[str, Any]] = {
    NoneType: {},
    str: {},
    int: {},
    object: {},
    ast.AST: {},
    ast.mod: {},
    ast.Module: {"body": list[ast.stmt], "type_ignores": list[ast.type_ignore]},
    ast.Interactive: {"body": list[ast.stmt]},
    ast.Expression: {"body": ast.expr},
    ast.FunctionType: {"argtypes": list[ast.expr], "returns": ast.expr},
    ast.stmt: {},
    ast.FunctionDef: {
        "name": str,
        "args": ast.arguments,
        "body": list[ast.stmt],
        "decorator_list": list[ast.expr],
        "returns": ast.expr | NoneType,
        "type_comment": str | NoneType,
        "type_params": list[ast.type_param],
    },
    ast.AsyncFunctionDef: {
        "name": str,
        "args": ast.arguments,
        "body": list[ast.stmt],
        "decorator_list": list[ast.expr],
        "returns": ast.expr | NoneType,
        "type_comment": str | NoneType,
        "type_params": list[ast.type_param],
    },
    ast.ClassDef: {
        "name": str,
        "bases": list[ast.expr],
        "keywords": list[ast.keyword],
        "body": list[ast.stmt],
        "decorator_list": list[ast.expr],
        "type_params": list[ast.type_param],
    },
    ast.Return: {"value": ast.expr | NoneType},
    ast.Delete: {"targets": list[ast.expr]},
    ast.Assign: {"targets": list[ast.expr], "value": ast.expr, "type_comment": str | NoneType},
    ast.TypeAlias: {"name": ast.expr, "type_params": list[ast.type_param], "value": ast.expr},
    ast.AugAssign: {"target": ast.expr, "op": ast.operator, "value": ast.expr},
    ast.AnnAssign: {"target": ast.expr, "annotation": ast.expr, "value": ast.expr | NoneType, "simple": int},
    ast.For: {
        "target": ast.expr,
        "iter": ast.expr,
        "body": list[ast.stmt],
        "orelse": list[ast.stmt],
        "type_comment": str | NoneType,
    },
    ast.AsyncFor: {
        "target": ast.expr,
        "iter": ast.expr,
        "body": list[ast.stmt],
        "orelse": list[ast.stmt],
        "type_comment": str | NoneType,
    },
    ast.While: {"test": ast.expr, "body": list[ast.stmt], "orelse": list[ast.stmt]},
    ast.If: {"test": ast.expr, "body": list[ast.stmt], "orelse": list[ast.stmt]},
    ast.With: {"items": list[ast.withitem], "body": list[ast.stmt], "type_comment": str | NoneType},
    ast.AsyncWith: {"items": list[ast.withitem], "body": list[ast.stmt], "type_comment": str | NoneType},
    ast.Match: {"subject": ast.expr, "cases": list[ast.match_case]},
    ast.Raise: {"exc": ast.expr | NoneType, "cause": ast.expr | NoneType},
    ast.Try: {
        "body": list[ast.stmt],
        "handlers": list[ast.excepthandler],
        "orelse": list[ast.stmt],
        "finalbody": list[ast.stmt],
    },
    ast.TryStar: {
        "body": list[ast.stmt],
        "handlers": list[ast.excepthandler],
        "orelse": list[ast.stmt],
        "finalbody": list[ast.stmt],
    },
    ast.Assert: {"test": ast.expr, "msg": ast.expr | NoneType},
    ast.Import: {"names": list[ast.alias]},
    ast.ImportFrom: {"module": str | NoneType, "names": list[ast.alias], "level": int | NoneType},
    ast.Global: {"names": list[str]},
    ast.Nonlocal: {"names": list[str]},
    ast.Expr: {"value": ast.expr},
    ast.Pass: {},
    ast.Break: {},
    ast.Continue: {},
    ast.expr: {},
    ast.BoolOp: {"op": ast.boolop, "values": list[ast.expr]},
    ast.NamedExpr: {"target": ast.expr, "value": ast.expr},
    ast.BinOp: {"left": ast.expr, "op": ast.operator, "right": ast.expr},
    ast.UnaryOp: {"op": ast.unaryop, "operand": ast.expr},
    ast.Lambda: {"args": ast.arguments, "body": ast.expr},
    ast.IfExp: {"test": ast.expr, "body": ast.expr, "orelse": ast.expr},
    ast.Dict: {"keys": list[ast.expr], "values": list[ast.expr]},
    ast.Set: {"elts": list[ast.expr]},
    ast.ListComp: {"elt": ast.expr, "generators": list[ast.comprehension]},
    ast.SetComp: {"elt": ast.expr, "generators": list[ast.comprehension]},
    ast.DictComp: {"key": ast.expr, "value": ast.expr, "generators": list[ast.comprehension]},
    ast.GeneratorExp: {"elt": ast.expr, "generators": list[ast.comprehension]},
    ast.Await: {"value": ast.expr},
    ast.Yield: {"value": ast.expr | NoneType},
    ast.YieldFrom: {"value": ast.expr},
    ast.Compare: {"left": ast.expr, "ops": list[ast.cmpop], "comparators": list[ast.expr]},
    ast.Call: {"func": ast.expr, "args": list[ast.expr], "keywords": list[ast.keyword]},
    ast.FormattedValue: {"value": ast.expr, "conversion": int, "format_spec": ast.expr | NoneType},
    ast.JoinedStr: {"values": list[ast.expr]},
    ast.Constant: {"value": object, "kind": str | NoneType},
    ast.Attribute: {"value": ast.expr, "attr": str},
    ast.Subscript: {"value": ast.expr, "slice": ast.expr},
    ast.Starred: {"value": ast.expr},
    ast.Name: {"id": str},
    ast.List: {"elts": list[ast.expr]},
    ast.Tuple: {"elts": list[ast.expr]},
    ast.Slice: {"lower": ast.expr | NoneType, "upper": ast.expr | NoneType, "step": ast.expr | NoneType},
    ast.expr_context: {},
    ast.Load: {},
    ast.Store: {},
    ast.Del: {},
    ast.boolop: {},
    ast.And: {},
    ast.Or: {},
    ast.operator: {},
    ast.Add: {},
    ast.Sub: {},
    ast.Mult: {},
    ast.MatMult: {},
    ast.Div: {},
    ast.Mod: {},
    ast.Pow: {},
    ast.LShift: {},
    ast.RShift: {},
    ast.BitOr: {},
    ast.BitXor: {},
    ast.BitAnd: {},
    ast.FloorDiv: {},
    ast.unaryop: {},
    ast.Invert: {},
    ast.Not: {},
    ast.UAdd: {},
    ast.USub: {},
    ast.cmpop: {},
    ast.Eq: {},
    ast.NotEq: {},
    ast.Lt: {},
    ast.LtE: {},
    ast.Gt: {},
    ast.GtE: {},
    ast.Is: {},
    ast.IsNot: {},
    ast.In: {},
    ast.NotIn: {},
    ast.comprehension: {"target": ast.expr, "iter": ast.expr, "ifs": list[ast.expr], "is_async": int},
    ast.excepthandler: {},
    ast.ExceptHandler: {"type": ast.expr | NoneType, "name": str | NoneType, "body": list[ast.stmt]},
    ast.arguments: {
        "posonlyargs": list[ast.arg],
        "args": list[ast.arg],
        "vararg": ast.arg | NoneType,
        "kwonlyargs": list[ast.arg],
        "kw_defaults": list[ast.expr],
        "kwarg": ast.arg | NoneType,
        "defaults": list[ast.expr],
    },
    ast.arg: {"arg": str, "annotation": ast.expr | NoneType, "type_comment": str | NoneType},
    ast.keyword: {"arg": str | NoneType, "value": ast.expr},
    ast.alias: {"name": str, "asname": str | NoneType},
    ast.withitem: {"context_expr": ast.expr, "optional_vars": ast.expr | NoneType},
    ast.match_case: {"pattern": ast.pattern, "guard": ast.expr | NoneType, "body": list[ast.stmt]},
    ast.pattern: {},
    ast.MatchValue: {"value": ast.expr},
    ast.MatchSingleton: {"value": object},
    ast.MatchSequence: {"patterns": list[ast.pattern]},
    ast.MatchMapping: {"keys": list[ast.expr], "patterns": list[ast.pattern], "rest": str | NoneType},
    ast.MatchClass: {
        "cls": ast.expr,
        "patterns": list[ast.pattern],
        "kwd_attrs": list[str],
        "kwd_patterns": list[ast.pattern],
    },
    ast.MatchStar: {"name": str | NoneType},
    ast.MatchAs: {"pattern": ast.pattern | NoneType, "name": str | NoneType},
    ast.MatchOr: {"patterns": list[ast.pattern]},
    ast.type_ignore: {},
    ast.TypeIgnore: {"lineno": int, "tag": str},
    ast.type_param: {},
    ast.TypeVar: {"name": str, "bound": ast.expr | NoneType, "default_value": ast.expr | NoneType},
    ast.ParamSpec: {"name": str, "default_value": ast.expr | NoneType},
    ast.TypeVarTuple: {"name": str, "default_value": ast.expr | NoneType},
    ast.slice: {},
    ast.Index: {},
    ast.ExtSlice: {},
    ast.Suite: {},
    ast.AugLoad: {},
    ast.AugStore: {},
    ast.Param: {},
}
if sys.version_info >= (3, 14):
    FIELD_MAPS |= {
        ast.Interpolation: {"value": ast.expr, "str": object, "conversion": int, "format_spec": ast.expr | NoneType},
        ast.TemplateStr: {"values": list[ast.expr]},
    }
