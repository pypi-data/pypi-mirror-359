# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .create_computer_tool_dto_messages_item import CreateComputerToolDtoMessagesItem
from .open_ai_function import OpenAiFunction
from .server import Server


class CreateComputerToolDto(UncheckedBaseModel):
    messages: typing.Optional[typing.List[CreateComputerToolDtoMessagesItem]] = pydantic.Field(default=None)
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    type: typing.Literal["computer"] = "computer"
    sub_type: typing_extensions.Annotated[typing.Literal["computer_20241022"], FieldMetadata(alias="subType")] = (
        pydantic.Field(default="computer_20241022")
    )
    """
    The sub type of tool.
    """

    server: typing.Optional[Server] = pydantic.Field(default=None)
    """
    
      This is the server where a `tool-calls` webhook will be sent.
    
      Notes:
      - Webhook is sent to this server when a tool call is made.
      - Webhook contains the call, assistant, and phone number objects.
      - Webhook contains the variables set on the assistant.
      - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
      - Webhook expects a response with tool call result.
    """

    name: typing.Literal["computer"] = pydantic.Field(default="computer")
    """
    The name of the tool, fixed to 'computer'
    """

    display_width_px: typing_extensions.Annotated[float, FieldMetadata(alias="displayWidthPx")] = pydantic.Field()
    """
    The display width in pixels
    """

    display_height_px: typing_extensions.Annotated[float, FieldMetadata(alias="displayHeightPx")] = pydantic.Field()
    """
    The display height in pixels
    """

    display_number: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="displayNumber")] = (
        pydantic.Field(default=None)
    )
    """
    Optional display number
    """

    function: typing.Optional[OpenAiFunction] = pydantic.Field(default=None)
    """
    This is the function definition of the tool.
    
    For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
    
    An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
