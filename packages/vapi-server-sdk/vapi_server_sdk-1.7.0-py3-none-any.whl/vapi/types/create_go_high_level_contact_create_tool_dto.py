# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .create_go_high_level_contact_create_tool_dto_messages_item import (
    CreateGoHighLevelContactCreateToolDtoMessagesItem,
)
from .open_ai_function import OpenAiFunction


class CreateGoHighLevelContactCreateToolDto(UncheckedBaseModel):
    messages: typing.Optional[typing.List[CreateGoHighLevelContactCreateToolDtoMessagesItem]] = pydantic.Field(
        default=None
    )
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    type: typing.Literal["gohighlevel.contact.create"] = "gohighlevel.contact.create"
    function: typing.Optional[OpenAiFunction] = pydantic.Field(default=None)
    """
    This is the function definition of the tool.
    
    For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
    
    An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
