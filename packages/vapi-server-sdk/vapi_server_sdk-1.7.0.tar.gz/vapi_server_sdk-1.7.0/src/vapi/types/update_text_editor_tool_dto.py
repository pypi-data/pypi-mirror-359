# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .open_ai_function import OpenAiFunction
from .server import Server
from .update_text_editor_tool_dto_messages_item import UpdateTextEditorToolDtoMessagesItem


class UpdateTextEditorToolDto(UncheckedBaseModel):
    messages: typing.Optional[typing.List[UpdateTextEditorToolDtoMessagesItem]] = pydantic.Field(default=None)
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    sub_type: typing_extensions.Annotated[
        typing.Optional[typing.Literal["text_editor_20241022"]], FieldMetadata(alias="subType")
    ] = pydantic.Field(default=None)
    """
    The sub type of tool.
    """

    server: typing.Optional[Server] = pydantic.Field(default=None)
    """
    
      This is the server where a `tool-calls` webhook will be sent.
    
      Notes:
      - Webhook is sent to this server when a tool call is made.
      - Webhook contains the call, assistant, and phone number objects.
      - Webhook contains the variables set on the assistant.
      - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
      - Webhook expects a response with tool call result.
    """

    function: typing.Optional[OpenAiFunction] = pydantic.Field(default=None)
    """
    This is the function definition of the tool.
    
    For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
    
    An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
    """

    name: typing.Optional[typing.Literal["str_replace_editor"]] = pydantic.Field(default=None)
    """
    The name of the tool, fixed to 'str_replace_editor'
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
